<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>echo</title>
  
  <subtitle>任生命穿梭 时间的角落 </subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://hoo334.github.io/"/>
  <updated>2021-10-25T06:53:46.060Z</updated>
  <id>https://hoo334.github.io/</id>
  
  <author>
    <name>hoo334</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>买卖股票</title>
    <link href="https://hoo334.github.io/2021/10/22/%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8/"/>
    <id>https://hoo334.github.io/2021/10/22/%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8/</id>
    <published>2021-10-22T08:14:35.000Z</published>
    <updated>2021-10-25T06:53:46.060Z</updated>
    
    <content type="html"><![CDATA[<h4 id="121-买卖股票的最佳时机"><a href="#121-买卖股票的最佳时机" class="headerlink" title="121. 买卖股票的最佳时机"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/" target="_blank" rel="noopener">121. 买卖股票的最佳时机</a></h4><p>难度：简单</p><p>给定一个数组 <code>prices</code> ，它的第 <code>i</code> 个元素 <code>prices[i]</code> 表示一支给定股票第 <code>i</code> 天的价格。</p><p>你只能选择 <strong>某一天</strong> 买入这只股票，并选择在 <strong>未来的某一个不同的日子</strong> 卖出该股票。设计一个算法来计算你所能获取的最大利润。</p><p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 <code>0</code> 。</p><a id="more"></a><p> <strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：[7,1,5,3,6,4]</span><br><span class="line">输出：5</span><br><span class="line">解释：在第 2 天（股票价格 &#x3D; 1）的时候买入，在第 5 天（股票价格 &#x3D; 6）的时候卖出，最大利润 &#x3D; 6-1 &#x3D; 5 。</span><br><span class="line">     注意利润不能是 7-1 &#x3D; 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：prices &#x3D; [7,6,4,3,1]</span><br><span class="line">输出：0</span><br><span class="line">解释：在这种情况下, 没有交易完成, 所以最大利润为 0。</span><br></pre></td></tr></table></figure><p> <strong>提示：</strong></p><ul><li><code>1 &lt;= prices.length &lt;= 105</code></li><li><code>0 &lt;= prices[i] &lt;= 104</code></li></ul><p><strong>题解：</strong></p><p>对于只能买卖一次的股票交易，对于 prices 数组中的数对 （<code>prices[i]</code>，<code>prices[j]</code> 且<code>i &lt; j</code>，求 <code>prices[j] - prices[i]</code> 的最大值 。</p><p><strong>方法一：暴力枚举（代码略）</strong></p><p>直接枚举右边界 j，然后向左枚举左边界 i, 维护最大值。</p><ul><li><p>时间：$O(n^2)$</p></li><li><p>空间：$O(1)$ </p></li></ul><p><strong>方法二：一次遍历</strong></p><p>在遍历过程中维护最小值 minStock，省略内层循环。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.length &lt; <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// minStock 为 prices[0 ... i] 中最小值</span></span><br><span class="line">        <span class="keyword">int</span> minStock = prices[<span class="number">0</span>], profit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(prices[i] &gt; minStock)&#123;</span><br><span class="line">                profit = Math.max(profit, prices[i] - minStock);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                minStock = prices[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> profit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>时间：$O(n)$</p></li><li><p>空间：$O(1)$ </p></li></ul><h4 id="122-买卖股票的最佳时机-II"><a href="#122-买卖股票的最佳时机-II" class="headerlink" title="122. 买卖股票的最佳时机 II"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/" target="_blank" rel="noopener">122. 买卖股票的最佳时机 II</a></h4><p>难度：中等</p><p>给定一个数组 <code>prices</code> ，其中 <code>prices[i]</code> 是一支给定股票第 <code>i</code> 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p><p><strong>注意：</strong>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p> <strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: prices &#x3D; [7,1,5,3,6,4]</span><br><span class="line">输出: 7</span><br><span class="line">解释: 在第 2 天（股票价格 &#x3D; 1）的时候买入，在第 3 天（股票价格 &#x3D; 5）的时候卖出, 这笔交易所能获得利润 &#x3D; 5-1 &#x3D; 4 。</span><br><span class="line">     随后，在第 4 天（股票价格 &#x3D; 3）的时候买入，在第 5 天（股票价格 &#x3D; 6）的时候卖出, 这笔交易所能获得利润 &#x3D; 6-3 &#x3D; 3 。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: prices &#x3D; [1,2,3,4,5]</span><br><span class="line">输出: 4</span><br><span class="line">解释: 在第 1 天（股票价格 &#x3D; 1）的时候买入，在第 5 天 （股票价格 &#x3D; 5）的时候卖出, 这笔交易所能获得利润 &#x3D; 5-1 &#x3D; 4 。</span><br><span class="line">     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: prices &#x3D; [7,6,4,3,1]</span><br><span class="line">输出: 0</span><br><span class="line">解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</span><br></pre></td></tr></table></figure><p> <strong>提示：</strong></p><ul><li><code>1 &lt;= prices.length &lt;= 3 * 104</code></li><li><code>0 &lt;= prices[i] &lt;= 104</code></li></ul><p><strong>题解：</strong></p><p><strong>方法一：动态规划</strong></p><p>这次我们可以买卖多次股票，选择第 i - 1天和 第 i 天分析：</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20211022165325957.png" alt="image-20211022165325957"></p><p>第 i 天<strong>有股票</strong>的情况分两种：前一天就有股票；前一天没股票，第 i 天买了股票。</p><p>有股票时的最大利润为两者中的最大值</p><p>类似的，第 i 天<strong>没股票</strong>的情况分两种：前一天没有有股票；前一天有股票，第 i 天买了股票。</p><p>有股票时的最大利润为两者中的最大值</p><p>令 $ f[i][0]$ 为第 i 天<strong>有股票</strong>时的最大利润，令 $ f[i][1]$ 为第 i 天<strong>没股票</strong>时的最大利润，可以得到如下转移方程：<br>$$<br>f[i][0] = max(f[i - 1][0], f[i - 1][1] - prices[i])<br>$$</p><p>$$<br>f[i][1] = max(f[i - 1][1], f[i - 1][0] + prices[i])<br>$$</p><p>初始条件：$ f[i][0] = -prices[0]$，$ f[i][1] = 0$</p><p>第 0 天就持有股票的最大利润为负（利润为 0 时就买了第 0 天的股票），没有持有股票的最大利润为 0 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = prices.length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][<span class="number">2</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">            dp[i][<span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>时间：$O(n)$</p></li><li><p>空间：$O(n)$ </p></li></ul><p>可以看到 第 i 天的状态只与第 i - 1天有关，可以进行空间优化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = prices.length;</span><br><span class="line">        <span class="keyword">int</span> dp0 = <span class="number">0</span>, dp1 = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> newdp0 = Math.max(dp0, dp1 + prices[i]);</span><br><span class="line">            <span class="keyword">int</span> newdp1 = Math.max(dp1, dp0 - prices[i]);</span><br><span class="line">            dp0 = newdp0;</span><br><span class="line">            dp1 = newdp1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>时间：$O(n)$</p></li><li><p>空间：$O(1)$ </p></li></ul><p><strong>方法二：贪心</strong></p><p>由于不限制交易次数，只要今天股价比昨天高，就交易。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> profit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(prices[i] &gt; prices[i - <span class="number">1</span>])&#123;</span><br><span class="line">                profit += prices[i] - prices[i - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> profit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>时间：$O(n)$</p></li><li><p>空间：$O(1)$ </p></li></ul><h4 id="123-买卖股票的最佳时机-III"><a href="#123-买卖股票的最佳时机-III" class="headerlink" title="123. 买卖股票的最佳时机 III"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/" target="_blank" rel="noopener">123. 买卖股票的最佳时机 III</a></h4><p>难度：困难</p><p>给定一个数组，它的第 <code>i</code> 个元素是一支给定的股票在第 <code>i</code> 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 <strong>两笔</strong> 交易。</p><p><strong>注意：</strong>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p> <strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：prices &#x3D; [3,3,5,0,0,3,1,4]</span><br><span class="line">输出：6</span><br><span class="line">解释：在第 4 天（股票价格 &#x3D; 0）的时候买入，在第 6 天（股票价格 &#x3D; 3）的时候卖出，这笔交易所能获得利润 &#x3D; 3-0 &#x3D; 3 。</span><br><span class="line">     随后，在第 7 天（股票价格 &#x3D; 1）的时候买入，在第 8 天 （股票价格 &#x3D; 4）的时候卖出，这笔交易所能获得利润 &#x3D; 4-1 &#x3D; 3 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：prices &#x3D; [1,2,3,4,5]</span><br><span class="line">输出：4</span><br><span class="line">解释：在第 1 天（股票价格 &#x3D; 1）的时候买入，在第 5 天 （股票价格 &#x3D; 5）的时候卖出, 这笔交易所能获得利润 &#x3D; 5-1 &#x3D; 4 。   </span><br><span class="line">     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。   </span><br><span class="line">     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：prices &#x3D; [7,6,4,3,1] </span><br><span class="line">输出：0 </span><br><span class="line">解释：在这个情况下, 没有交易完成, 所以最大利润为 0。</span><br></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：prices &#x3D; [1]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure><p> <strong>提示：</strong></p><ul><li><code>1 &lt;= prices.length &lt;= 105</code></li><li><code>0 &lt;= prices[i] &lt;= 105</code></li></ul><p>此题与 122 不同的是，限制了交易次数，只能交易两次。</p><p>类似的，我们分析一下第 <code>i</code>天有几个状态，第<code>i - 1</code> 天到第<code>i</code> 天的转移关系是什么样的。</p><p>我们可以将每天分为 5 个状态：没有任何买卖操作，第一次持有股票，第一次卖完股票，第二次持有股票，第二次卖完股票。由于没有任何买卖操作，利润总是 0 ，我们需要计算的只有 4 个状态。</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20211022172452534.png" alt="image-20211022172452534"></p><p>令 $ f[i][0]$ 为第 i 天<strong>第一次持有股票</strong>时的最大利润，令 $ f[i][1]$ 为第 i 天<strong>第一次没有股票</strong>时的最大利润，令 $ f[i][2]$ 为第 i 天<strong>第二次持有股票</strong>时的最大利润，令 $ f[i][3]$ 为第 i 天<strong>第二次没有股票</strong>时的最大利润，可以得到如下转移方程：<br>$$<br>f[i][0] = max(f[i - 1][0],  - prices[i])<br>$$</p><p>$$<br>f[i][1] = max(f[i - 1][1], f[i - 1][0] + prices[i])<br>$$</p><p>$$<br>f[i][2] = max(f[i - 1][2], f[i - 1][1] - prices[i])<br>$$</p><p>$$<br>f[i][3] = max(f[i - 1][3], f[i - 1][2] + prices[i])<br>$$</p><p>初始条件：$ f[i][0] = f[i][2] = -prices[0]$，$ f[i][1] = f[i][3] = 0$</p><p>$f[i][2] = -prices[0]$ 可以理解为买了 prices[0]，然后立马卖了 prices[0]，再次买入 prices[0]，这样就是第二次有股票。</p><p>在考虑边界条件时我们注意到以下事实：</p><blockquote><p>==<strong>无论题目中是否允许同一天买入卖出，这一操作都不会对最终结果造成影响，因为这一操作收益为零</strong>==</p></blockquote><p>我们可以进一步优化上述转移方程：<br>$$<br>f[0] = max(f[0],  - prices[i])<br>$$</p><p>$$<br>f[1] = max(f[1], f[0] + prices[i])<br>$$</p><p>$$<br>f[2] = max(f[2], f[1] - prices[i])<br>$$</p><p>$$<br>f[3] = max(f[3], f[2] + prices[i])<br>$$</p><p>对于$f[0] = max(f[0],  - prices[i])$来说，这是滚动数组常用技巧，左边的 $f[0]$代表<strong>今天</strong>第一次持有股票的最大利润，右边的 $f[0]$代表昨天第一次持有股票的最大利润；</p><p>对于$f[1] = max(f[1], f[0] + prices[i])$来说，左边的 $f[1]$代表<strong>今天</strong>第一次没有股票的最大利润，右边的 $f[1]$代表昨天第一次没有股票的最大利润，此时 $f[0]$应该是代表<strong>昨天</strong>第一次持有股票的最大利润，但由于我们刚才已经把值更新为<strong>今天</strong>第一次持有股票的最大利润。为什么这样转移方程依然正确？</p><blockquote><p>将今天的 <code>f[0]</code>带入 <code>f[1]</code> 计算公式中，得到$f[1] = max(f[1], max(f[0], -prices[i])\ )$，此时 $f[0]$是代表<strong>昨天</strong>第一次持有股票的最大利润。<strong>我们多考虑了第 i 天买入股票的情况，但同时计算 $f[1]$时，又将股票卖出，这样的利润为 0</strong> 。所以我们将新的 $f[0]$值用于计算不会导致错误结果。</p></blockquote><p>后面的依此类推。</p><p>最后，我们手中肯定没有股票，结果在  0, $f[1]$，$f[3]$中选择最大的，由于在状态转移中我们维护的是最大值，且$f[1]$，$f[3]$初始值为 0，0不可能为结果。如果最优解为交易一次，即$f[1]$，那么它也会因为我们在转移时允许在同一天买入并且卖出这一宽松的条件，从$f[1]$转移到$f[3]$，因此最后答案为 $f[3]$。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = prices.length;</span><br><span class="line">        <span class="keyword">int</span>[] f = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>];</span><br><span class="line">        <span class="comment">// 分为 5 个阶段：没买也没卖，买了一次，卖了一次，买了两次且卖了一次，卖了两次</span></span><br><span class="line">        f[<span class="number">0</span>] = f[<span class="number">2</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        f[<span class="number">1</span>] = f[<span class="number">3</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">            f[<span class="number">0</span>] = Math.max(f[<span class="number">0</span>], -prices[i]);</span><br><span class="line">            f[<span class="number">1</span>] = Math.max(f[<span class="number">1</span>], f[<span class="number">0</span>] + prices[i]);</span><br><span class="line">            f[<span class="number">2</span>] = Math.max(f[<span class="number">2</span>], f[<span class="number">1</span>] - prices[i]);</span><br><span class="line">            f[<span class="number">3</span>] = Math.max(f[<span class="number">3</span>], f[<span class="number">2</span>] + prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[<span class="number">3</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>时间：$O(n)$</p></li><li><p>空间：$O(1)$ </p></li></ul><h4 id="188-买卖股票的最佳时机-IV"><a href="#188-买卖股票的最佳时机-IV" class="headerlink" title="188. 买卖股票的最佳时机 IV"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/" target="_blank" rel="noopener">188. 买卖股票的最佳时机 IV</a></h4><p>难度：困难</p><p>给定一个整数数组 <code>prices</code> ，它的第 <code>i</code> 个元素 <code>prices[i]</code> 是一支给定的股票在第 <code>i</code> 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 <strong>k</strong> 笔交易。</p><p><strong>注意：</strong>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p> <strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：k &#x3D; 2, prices &#x3D; [2,4,1]</span><br><span class="line">输出：2</span><br><span class="line">解释：在第 1 天 (股票价格 &#x3D; 2) 的时候买入，在第 2 天 (股票价格 &#x3D; 4) 的时候卖出，这笔交易所能获得利润 &#x3D; 4-2 &#x3D; 2 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：k &#x3D; 2, prices &#x3D; [3,2,6,5,0,3]</span><br><span class="line">输出：7</span><br><span class="line">解释：在第 2 天 (股票价格 &#x3D; 2) 的时候买入，在第 3 天 (股票价格 &#x3D; 6) 的时候卖出, 这笔交易所能获得利润 &#x3D; 6-2 &#x3D; 4 。</span><br><span class="line">     随后，在第 5 天 (股票价格 &#x3D; 0) 的时候买入，在第 6 天 (股票价格 &#x3D; 3) 的时候卖出, 这笔交易所能获得利润 &#x3D; 3-0 &#x3D; 3 。</span><br></pre></td></tr></table></figure><p> <strong>提示：</strong></p><ul><li><code>0 &lt;= k &lt;= 100</code></li><li><code>0 &lt;= prices.length &lt;= 1000</code></li><li><code>0 &lt;= prices[i] &lt;= 1000</code></li></ul><p>此题与 123 类似，但可交易 k 次，由之前的经验可以推导，每天应该有 <code>2 * k + 1</code>个状态。</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20211022200055327.png" alt="image-20211022200055327"></p><p>初始化数组 $f$ ，长度为 $2k + 1$，$f[0] = 0$ 表示没有参与任何交易的利润。$f[2<em>j - 1]$表示第 <code>j</code>次*</em>持有股票<strong>的最大利润，$f[2 * j ]$表示第<code>j</code>次</strong>没有股票**的最大利润，其中$1 &lt;= j &lt;= k$。</p><p>令 $j$ 为 数组 $f$  下标，我们可以写出转移方程：<br>$$<br>f[j] = max(f[j], f[j - 1] - prices[i]), j 为奇数<br>$$</p><p>$$<br>f[j] = max(f[j], f[j - 1] + prices[i]), j 为偶数<br>$$</p><p>同样的，最后的结果为第 k 次没有股票的最大利润$f[2 * k]$。</p><p>初始条件：所有奇数下标位置为 $ -prices[0]$, 所有偶数下标位置为 0，分析过程同 123 题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> n = prices.length;</span><br><span class="line">        <span class="keyword">int</span>[] f = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span> * k + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">2</span> * k; j += <span class="number">2</span>)&#123;</span><br><span class="line">            f[j] = -prices[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">2</span> * k; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>((j &amp; <span class="number">1</span>) == <span class="number">1</span>)&#123; <span class="comment">// 买</span></span><br><span class="line">                    f[j] = Math.max(f[j], f[j - <span class="number">1</span>] - prices[i]);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123; <span class="comment">//卖</span></span><br><span class="line">                    f[j] = Math.max(f[j], f[j - <span class="number">1</span>] + prices[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> f[<span class="number">2</span> * k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>时间：$O(nk)$</p></li><li><p>空间：$O(k)$ </p></li></ul><h4 id="309-最佳买卖股票时机含冷冻期"><a href="#309-最佳买卖股票时机含冷冻期" class="headerlink" title="309. 最佳买卖股票时机含冷冻期"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/" target="_blank" rel="noopener">309. 最佳买卖股票时机含冷冻期</a></h4><p>难度：中等</p><p>给定一个整数数组，其中第 <em>i</em> 个元素代表了第 <em>i</em> 天的股票价格 。</p><p>设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:</p><ul><li>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</li><li>卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。</li></ul><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,0,2]</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]</span><br></pre></td></tr></table></figure><p>显然，每天的状态有：持有股票，没有股票，冷冻期。我们画出今天和昨天的关系图：</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20211022213057682.png" alt="image-20211022213057682"></p><p>定义 $f[i][0]$ 第 <code>i</code> 天有股票， $f[i][1]$ 第 <code>i</code> 天无股票冷冻期， $f[i][2]$ 第 <code>i</code> 天无股票非冷冻期。可得到如下转移方程：<br>$$<br>f[i][0] = max(f[i - 1][0], f[i - 1][2] - prices[i])<br>$$</p><p>$$<br>f[i][1] = f[i - 1][0] + prices[i]<br>$$</p><p>$$<br>f[i][2] = max(f[i - 1][1], f[i - 1][2])<br>$$</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.length &lt; <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> n = prices.length;</span><br><span class="line">        <span class="keyword">int</span>[][] f = <span class="keyword">new</span> <span class="keyword">int</span>[n][<span class="number">3</span>];</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">            f[i][<span class="number">0</span>] = Math.max(f[i - <span class="number">1</span>][<span class="number">0</span>], f[i - <span class="number">1</span>][<span class="number">2</span>] - prices[i]);</span><br><span class="line">            f[i][<span class="number">1</span>] = f[i - <span class="number">1</span>][<span class="number">0</span>] + prices[i];</span><br><span class="line">            f[i][<span class="number">2</span>] = Math.max(f[i - <span class="number">1</span>][<span class="number">2</span>], f[i - <span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(f[n - <span class="number">1</span>][<span class="number">1</span>], f[n - <span class="number">1</span>][<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>时间：$O(n)$</p></li><li><p>空间：$O(n)$ </p></li></ul><p>我们可以只保存最近两天的数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.length &lt; <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> n = prices.length;</span><br><span class="line">        <span class="comment">// f[0] 表示第 i 天持有股票时的最大利润，f[1] 表示无股票冷冻期，f[2] 表示无股票非冷冻期</span></span><br><span class="line">        <span class="keyword">int</span>[] f = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line">        f[<span class="number">0</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span>[] newF = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line">            newF[<span class="number">0</span>] = Math.max(f[<span class="number">0</span>], f[<span class="number">2</span>] - prices[i]);</span><br><span class="line">            newF[<span class="number">1</span>] = f[<span class="number">0</span>] + prices[i];</span><br><span class="line">            newF[<span class="number">2</span>] = Math.max(f[<span class="number">2</span>], f[<span class="number">1</span>]);</span><br><span class="line">            f = newF;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(f[<span class="number">1</span>], f[<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间：$O(n)$</li><li>空间：$O(1)$ </li></ul><h4 id="714-买卖股票的最佳时机含手续费"><a href="#714-买卖股票的最佳时机含手续费" class="headerlink" title="714. 买卖股票的最佳时机含手续费"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/" target="_blank" rel="noopener">714. 买卖股票的最佳时机含手续费</a></h4><p>难度：中等</p><p>给定一个整数数组 <code>prices</code>，其中第 <code>i</code> 个元素代表了第 <code>i</code> 天的股票价格 ；整数 <code>fee</code> 代表了交易股票的手续费用。</p><p>你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。</p><p>返回获得利润的最大值。</p><p><strong>注意：</strong>这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：prices &#x3D; [1, 3, 2, 8, 4, 9], fee &#x3D; 2</span><br><span class="line">输出：8</span><br><span class="line">解释：能够达到的最大利润:  </span><br><span class="line">在此处买入 prices[0] &#x3D; 1</span><br><span class="line">在此处卖出 prices[3] &#x3D; 8</span><br><span class="line">在此处买入 prices[4] &#x3D; 4</span><br><span class="line">在此处卖出 prices[5] &#x3D; 9</span><br><span class="line">总利润: ((8 - 1) - 2) + ((9 - 4) - 2) &#x3D; 8</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：prices &#x3D; [1,3,7,5,10,3], fee &#x3D; 3</span><br><span class="line">输出：6</span><br></pre></td></tr></table></figure><p> <strong>提示：</strong></p><ul><li><code>1 &lt;= prices.length &lt;= 5 * 104</code></li><li><code>1 &lt;= prices[i] &lt; 5 * 104</code></li><li><code>0 &lt;= fee &lt; 5 * 104</code></li></ul><p>此题就是 121 加上卖出手续费。关系图如下：</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20211022214139191.png" alt="image-20211022214139191"></p><p>令 $ f[i][0]$ 为第 i 天<strong>有股票</strong>时的最大利润，令 $ f[i][1]$ 为第 i 天<strong>没股票</strong>时的最大利润，可以得到如下转移方程：<br>$$<br>f[i][0] = max(f[i - 1][0], f[i - 1][1] - prices[i])<br>$$</p><p>$$<br>f[i][1] = max(f[i - 1][1], f[i - 1][0] + prices[i] -fee)<br>$$</p><p>初始条件：$ f[i][0] = -prices[0]$，$ f[i][1] = 0$</p><p>只保存最近两天的数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices, <span class="keyword">int</span> fee)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.length &lt; <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> n = prices.length;</span><br><span class="line">        <span class="keyword">int</span>[] f = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        f[<span class="number">0</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// f[0] 代表持有股票，f[1]代表没有股票</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span>[] newF = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">            newF[<span class="number">0</span>] = Math.max(f[<span class="number">0</span>], f[<span class="number">1</span>] - prices[i]);</span><br><span class="line">            <span class="comment">// 卖出收手续费</span></span><br><span class="line">            newF[<span class="number">1</span>] = Math.max(f[<span class="number">1</span>], f[<span class="number">0</span>] + prices[i] - fee);</span><br><span class="line">            f = newF;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>时间：$O(n)$</p></li><li><p>空间：$O(1)$ </p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;121-买卖股票的最佳时机&quot;&gt;&lt;a href=&quot;#121-买卖股票的最佳时机&quot; class=&quot;headerlink&quot; title=&quot;121. 买卖股票的最佳时机&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;121. 买卖股票的最佳时机&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;难度：简单&lt;/p&gt;
&lt;p&gt;给定一个数组 &lt;code&gt;prices&lt;/code&gt; ，它的第 &lt;code&gt;i&lt;/code&gt; 个元素 &lt;code&gt;prices[i]&lt;/code&gt; 表示一支给定股票第 &lt;code&gt;i&lt;/code&gt; 天的价格。&lt;/p&gt;
&lt;p&gt;你只能选择 &lt;strong&gt;某一天&lt;/strong&gt; 买入这只股票，并选择在 &lt;strong&gt;未来的某一个不同的日子&lt;/strong&gt; 卖出该股票。设计一个算法来计算你所能获取的最大利润。&lt;/p&gt;
&lt;p&gt;返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 &lt;code&gt;0&lt;/code&gt; 。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="动态规划" scheme="https://hoo334.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>Java 八股文</title>
    <link href="https://hoo334.github.io/2021/09/04/%E5%85%AB%E8%82%A1%E6%96%87/"/>
    <id>https://hoo334.github.io/2021/09/04/%E5%85%AB%E8%82%A1%E6%96%87/</id>
    <published>2021-09-04T11:54:17.277Z</published>
    <updated>2021-10-17T09:20:03.634Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h1><p>八股文集合</p><a id="more"></a><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="Java-语言特点"><a href="#Java-语言特点" class="headerlink" title="Java 语言特点"></a>Java 语言特点</h3><ul><li>面向对象（封装、继承、多态）</li><li>平台无关性（Java 虚拟机实现平台无关性）</li><li>多线程（较好的多线程支持）</li></ul><h3 id="JVM-vs-JDK-vs-JRE"><a href="#JVM-vs-JDK-vs-JRE" class="headerlink" title="JVM vs JDK vs JRE"></a>JVM vs JDK vs JRE</h3><h4 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h4><p>JVM是运行 Java 字节码的虚拟机。JVM 有针对不同系统的特定实现，目的是使用相同的字节码，它们都会给出相同的结果。字节码和不同系统的 JVM 实现是 Java 语言“一次编译，随处可以运行”的关键所在。</p><h4 id="JDK"><a href="#JDK" class="headerlink" title="JDK"></a>JDK</h4><p>DK 是 Java Development Kit 缩写，它是功能齐全的 Java SDK。它拥有 JRE 所拥有的一切，还有编译器（javac）和工具（如 javadoc 和 jdb），能够创建和编译程序。</p><h4 id="JRE"><a href="#JRE" class="headerlink" title="JRE"></a>JRE</h4><p>JRE 是 Java 运行时环境。它是运行已编译 Java 程序所需的所有内容的集合，包括 Java 虚拟机（JVM），Java 类库，java 命令和其他的一些基础构件。但是，它不能用于创建新程序。</p><h3 id="Java-语言“编译与解释并存”"><a href="#Java-语言“编译与解释并存”" class="headerlink" title="Java 语言“编译与解释并存”"></a>Java 语言“编译与解释并存”</h3><p>Java 程序要经过先编译，后解释两个步骤，由 Java 编写的程序需要先经过编译步骤，生成字节码（<code>\*.class</code> 文件），这种字节码必须由 Java 解释器来解释执行。</p><h3 id="Java-与-C-的区别"><a href="#Java-与-C-的区别" class="headerlink" title="Java 与 C++ 的区别"></a>Java 与 C++ 的区别</h3><ul><li>都是面向对象的语言</li><li>Java 不支持通过指针进行内存访问</li><li>Java 类只支持单继承，但可以实现多个接口，C++ 支持多继承</li><li>Java 有 GC 机制，不用手动释放内存</li><li>C++ 同时支持<strong>方法重载</strong>和<strong>运算符重载</strong>，<strong>Java 只支持方法重载</strong></li></ul><h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20210804200000105.png" alt="image-20210804200000105"></p><ul><li><p>strictfp 浮点运算更加精确，不会因为不同的硬件平台所执行的结果不一致</p></li><li><p>transient 修饰字段，用transient关键字标记的成员变量不参与序列化过程。</p></li><li><p>volatile 当把变量声明为volatile类型后，编译器与运行时都会注意到这个变量是共享的，因此不会将该变量上的操作与其他内存操作一起重排序。在访问volatile变量时不会执行加锁操作，因此也就不会使执行线程阻塞，因此volatile变量是一种比 sychronized 关键字更轻量级的同步机制。</p></li></ul><h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><p>泛型的本质是参数化类型。Java的泛型是伪泛型，Java 在编译期间，所有的泛型信息都会被擦除，这通常叫做<strong>类型擦除</strong>。</p><p>泛型通常有三种使用方式：泛型类、泛型接口、泛型方法</p><h4 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Generic</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T key;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实例化一个泛型类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Generic&lt;Integer&gt; genericInteger = <span class="keyword">new</span> Generic&lt;Integer&gt;(<span class="number">123456</span>);</span><br></pre></td></tr></table></figure><h4 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Generator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">method</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现泛型接口，不指定类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GeneratorImpl</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Generator</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现泛型接口，指定类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GeneratorImpl</span> <span class="keyword">implements</span> <span class="title">Generator</span>&lt;<span class="title">String</span>&gt;</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; <span class="function"><span class="keyword">void</span> <span class="title">printArray</span><span class="params">(E[] inputArray)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (E element : inputArray) &#123;</span><br><span class="line">        System.out.printf(<span class="string">"%s "</span>, element);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建不同类型数组： Integer, Double 和 Character</span></span><br><span class="line">Integer[] intArray = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line">String[] stringArray = &#123; <span class="string">"Hello"</span>, <span class="string">"World"</span> &#125;;</span><br><span class="line">printArray(intArray);</span><br><span class="line">printArray(stringArray);</span><br></pre></td></tr></table></figure><p><strong>常用的通配符为： T，E，K，V，？</strong></p><ul><li>？ 表示不确定的 java 类型</li><li>T (type) 表示具体的一个 java 类型</li><li>K V (key value) 分别代表 java 键值中的 Key Value</li><li>E (element) 代表 Element</li></ul><h3 id="和-equals-的区别"><a href="#和-equals-的区别" class="headerlink" title="==== 和 equals 的区别=="></a>==== 和 equals 的区别==</h3><p>对于基本数据类型来说，== 比较的是值。对于引用数据类型来说， == 比较的是对象的内存地址（也是值比较）。</p><p>equals 方法只能用来比较两个对象是否相等：</p><ul><li><p>当类没有覆盖 equals 方法时，等价于通过 == 比较这两个对象，调用 Object 类的 equals 方法。</p></li><li><p>当类覆盖了 equals 方法，一般我们都覆盖 equals 方法来比较两个对象中的属性是否相等，若它们的属性相等，则返回true。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String a = <span class="keyword">new</span> String(<span class="string">"ab"</span>); <span class="comment">// a 为一个引用</span></span><br><span class="line">        String b = <span class="keyword">new</span> String(<span class="string">"ab"</span>); <span class="comment">// b为另一个引用,对象的内容一样</span></span><br><span class="line">        String aa = <span class="string">"ab"</span>; <span class="comment">// 放在常量池中</span></span><br><span class="line">        String bb = <span class="string">"ab"</span>; <span class="comment">// 从常量池中查找</span></span><br><span class="line">        <span class="keyword">if</span> (aa == bb) <span class="comment">// true  aa 和 bb 指向常量池中同一个字符串"ab"</span></span><br><span class="line">            System.out.println(<span class="string">"aa==bb"</span>);</span><br><span class="line">        <span class="keyword">if</span> (a == b) <span class="comment">// false，非同一对象</span></span><br><span class="line">            System.out.println(<span class="string">"a==b"</span>);</span><br><span class="line">        <span class="keyword">if</span> (a.equals(b)) <span class="comment">// true</span></span><br><span class="line">            System.out.println(<span class="string">"aEQb"</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">42</span> == <span class="number">42.0</span>) &#123; <span class="comment">// true</span></span><br><span class="line">            System.out.println(<span class="string">"true"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="hashCode-和-equals"><a href="#hashCode-和-equals" class="headerlink" title="==hashCode 和 equals=="></a>==hashCode 和 equals==</h3><p>hashCode 的作用是获取散列码，它的作用是<strong>确定该对象在哈希表中的索引位置</strong>。hashCode 方法在 Object 类中定义，它返回对象的内存地址。</p><p>哈希表存储键值对，它能根据“键”快速找出对应的“值”，存储一个对象时，key 就是这个对象的 hashCode，value 就是这个对象。</p><h3 id="为什么重写-equals-方法时必须重写-hashCode-方法？"><a href="#为什么重写-equals-方法时必须重写-hashCode-方法？" class="headerlink" title="==为什么重写 equals 方法时必须重写 hashCode 方法？=="></a>==为什么重写 equals 方法时必须重写 hashCode 方法？==</h3><p>我们看一下Object类中关于hashCode()方法的注释</p><blockquote><p>1.在 Java 应用程序执行期间，在对同一对象多次调用 hashCode 方法时，必须一致地返回相同的整数，前提是将对象进行 equals 比较时所用的信息没有被修改。从某一应用程序的一次执行到同一应用程序的另一次执行，该整数无需保持一致。</p><p>2.如果根据 equals(Object) 方法，两个对象是相等的，那么对这两个对象中的每个对象调用 hashCode 方法都必须生成相同的整数结果。</p><p>3.如果根据 equals(java.lang.Object) 方法，两个对象不相等，那么对这两个对象中的任一对象上调用 hashCode 方法不要求一定生成不同的整数结果。但是，程序员应该意识到，为不相等的对象生成不同整数结果可以提高哈希表的性能</p></blockquote><p>如果 <code>a.equals(b) == true</code>，那么<code>a.hashCode() == b.hashCode()</code>；如果<code>a.equals(b) == false</code>，对象a 和 b 的哈希值不必相等，但程序员应该知道，为不相等的对象生成不同的哈希值可以提高哈希表的性能（避免哈希冲突）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> code;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">(<span class="keyword">int</span> code)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.code = code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        A a = (A) o;</span><br><span class="line">        <span class="keyword">return</span> code == a.code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    @Override</span></span><br><span class="line"><span class="comment">//    public int hashCode() &#123;</span></span><br><span class="line"><span class="comment">//        return Objects.hash(code);</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"A&#123;"</span> +</span><br><span class="line">                <span class="string">"code="</span> + code +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        A a = <span class="keyword">new</span> A(<span class="number">1</span>);</span><br><span class="line">        A b = <span class="keyword">new</span> A(<span class="number">1</span>);</span><br><span class="line">        HashSet&lt;A&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        set.add(a);</span><br><span class="line">        set.add(b);</span><br><span class="line">        System.out.println(set.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当只重写了 equals 方法时，输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[A&#123;code&#x3D;1&#125;, A&#123;code&#x3D;1&#125;]</span><br></pre></td></tr></table></figure><p>当重写了 equals 和 hashCode 方法时，输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[A&#123;code&#x3D;1&#125;]</span><br></pre></td></tr></table></figure><p>可以看到 equals 相等的两个等价对象因为 hashCode 不同，所以在 hashMap 中的 table 数组下标不同，从而这两个对象就会同时存在于集合中，由于 hashSet 就是 hashMap 实现的，在值不重复的 Set 中出现了两个等价对象，这就会出现逻辑错误，如果需要使用集合类，在重写 equals 方法时必须重写 hashCode 方法。</p><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20210804205811181.png" alt="image-20210804205811181"></p><p>对于 <code>boolean</code>，官方文档未明确定义，它依赖于 JVM 厂商的具体实现。</p><p><strong>基本数据类型直接存放在 Java 虚拟机栈中栈帧的局部变量表中</strong>，而包装类型属于对象类型，我们知道对象实例都存在于堆中。相比于对象类型， 基本数据类型占用的空间非常小。</p><p>Java 基本类型的包装类的大部分都实现了==常量池==技术。<strong><code>Byte</code>,<code>Short</code>,<code>Integer</code>,<code>Long</code> 这 4 种包装类默认创建了数值 [-128，127] 的相应类型的缓存数据，<code>Character</code> 创建了数值在[0,127]范围的缓存数据，<code>Boolean</code> 直接返回 <code>True</code> Or <code>False</code>。</strong></p><h3 id="在一个静态方法内调用一个非静态方法为什么是非法的？"><a href="#在一个静态方法内调用一个非静态方法为什么是非法的？" class="headerlink" title="在一个静态方法内调用一个非静态方法为什么是非法的？"></a>在一个静态方法内调用一个非静态方法为什么是非法的？</h3><p>静态方法属于类，在类加载时就会分配内存，可以通过类名直接访问。非静态成员属于实例对象，只有在对象实例化之后才存在。在静态方法中调用内存中还不存在的非静态成员属于非法操作。</p><h3 id="静态方法和实例方法有何不同？"><a href="#静态方法和实例方法有何不同？" class="headerlink" title="静态方法和实例方法有何不同？"></a>静态方法和实例方法有何不同？</h3><p>静态方法可使用 类名.方法名 和 对象名.方法名 这两种方式使用，实例方法只能使用后一种方法，<strong>调用静态方法无需创建对象</strong></p><p>静态方法只能使用类的静态成员变量和方法，不能访问实例成员变量和实例方法，实例方法中无限制。</p><h3 id="为什么-Java-中只有值传递？"><a href="#为什么-Java-中只有值传递？" class="headerlink" title="为什么 Java 中只有值传递？"></a>为什么 Java 中只有值传递？</h3><p>Java 总是采用按值调用，方法得到的所有参数值的一个拷贝。当参数为基本数据类型时，传递的是基本类型的拷贝值，当参数为引用对象时，传递的是对象引用的拷贝（这个拷贝的对象引用和原始对象引用<strong>同时</strong>指向堆中的对象内存）。</p><p>Java 中方法参数的使用情况：</p><ul><li>一个方法不能修改一个基本数据类型的参数（即数值型或布尔型）。</li><li>一个方法可以改变一个对象参数的状态。</li><li>一个方法不能让对象参数引用一个新的对象。</li></ul><h3 id="重载和重写的区别"><a href="#重载和重写的区别" class="headerlink" title="重载和重写的区别"></a>重载和重写的区别</h3><p>重载- 同名方法可以有不同的方法签名，根据输入数据的不同，做出不同的处理。</p><p>重写- 子列继承父类的相同方法（不允许更改方法签名）,需要做出有别于父类的响应时，就要覆盖父类方法。</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20210804211851235.png" alt="image-20210804211851235"></p><p>其中子类返回值类型比父类方法返回值类型更小的意思是：如果父类方法返回类 B 的对象，子类方法可返回 B 的子类 C 的对象，但不能返回 B 的父类 A 的对象。对象只能向上转型，不能向下转型。子类的对象可以赋值给父类，父类的对象却不可以赋值给子类，这样对于这个限制我们就能很好理解了。</p><h3 id="Java-面向对象"><a href="#Java-面向对象" class="headerlink" title="Java 面向对象"></a>Java 面向对象</h3><h4 id="面向过程和面向对象"><a href="#面向过程和面向对象" class="headerlink" title="面向过程和面向对象"></a>面向过程和面向对象</h4><ul><li><p><strong>面向过程</strong> ：<strong>面向过程性能比面向对象高。</strong>但是，<strong>面向过程没有面向对象易维护、易复用、易扩展。</strong></p></li><li><p><strong>面向对象</strong> ：<strong>面向对象易维护、易复用、易扩展。</strong> 但是，<strong>面向对象性能比面向过程低</strong>。</p></li></ul><h4 id="成员变量和局部变量的区别"><a href="#成员变量和局部变量的区别" class="headerlink" title="成员变量和局部变量的区别"></a>成员变量和局部变量的区别</h4><ol><li>成员变量是属于类的，局部变量是在方法或代码块中定义的。成员变量可以被 public、static、private 等修饰符修饰，局部变量不能被这些修饰符修饰，成员变量和局部变量都能被 final 关键字修饰。</li><li>成员变量是对象的一部分，随对象的创建而存在，局部变量随着方法的调用而自动消失</li><li>成员变量如果没有赋初值，则会自动以类型的默认值为初值（被 final 修饰的成员变量必须显式地赋值），局部变量不会自动赋初值</li></ol><h4 id="一个类的构造方法的作用是什么？若一个类没有声明构造方法，该程序能正确执行吗？"><a href="#一个类的构造方法的作用是什么？若一个类没有声明构造方法，该程序能正确执行吗？" class="headerlink" title="一个类的构造方法的作用是什么？若一个类没有声明构造方法，该程序能正确执行吗？"></a>一个类的构造方法的作用是什么？若一个类没有声明构造方法，该程序能正确执行吗？</h4><p>构造方法主要完成类对象的初始化工作。</p><p>如果一个类没有声明构造方法，也可以执行！一个类即使没有声明构造方法也会有默认的不带参数的构造方法。（如果自己添加类的构造方法，Java 就不会再添加默认的无参数构造方法了）</p><h4 id="构造方法有哪些特点？是否可被重写？"><a href="#构造方法有哪些特点？是否可被重写？" class="headerlink" title="构造方法有哪些特点？是否可被重写？"></a>构造方法有哪些特点？是否可被重写？</h4><p>特点：</p><ol><li>名字与类名相同</li><li>没有返回值，但不能用 void 声明构造函数</li><li>生成类的对象时自动执行，无需调用</li></ol><p>构造方法不能被重写，但是可以重载，一个类中可以有多个构造函数</p><h4 id="面向对象三大特征"><a href="#面向对象三大特征" class="headerlink" title="面向对象三大特征"></a>面向对象三大特征</h4><ol><li><p>封装，把一个对象的状态信息隐藏在对象内部，不允许外部对象直接访问对象的内部信息。但是可以提供一些被外界访问的方法来操作属性。</p></li><li><p>继承，使用已存在的类的定义作为基础建立新类，新类的定义可以增加新的数据或新的功能，也可以使用父类的功能，通过继承，可以提高代码的重用性。（子类拥有父类所有对象属性和方法，但父类中的私有属性和方法不能访问，子类可以对父类进行扩展，子类可以重写父类的方法）</p></li><li><p>多态，表示一个对象有多种状态，具体表现为父类的引用指向子类的实例。</p><p>多态的特点：</p><ul><li>对象类型和引用类型之间具有继承（类）/实现（接口）的关系</li><li>引用类型变量调用的方法必须在程序运行期间才能确定</li><li>多态不能调用“只在子类存在但父类不存在”的方法</li><li>如果子类重写了父类的方法，真正执行的是子类覆盖的方法，如果没有重写，执行父类的方法。</li></ul></li></ol><h4 id="StringBuffer-和-StringBuilder-的区别是什么？String-为什么是不可变的？"><a href="#StringBuffer-和-StringBuilder-的区别是什么？String-为什么是不可变的？" class="headerlink" title="StringBuffer 和 StringBuilder 的区别是什么？String 为什么是不可变的？"></a>StringBuffer 和 StringBuilder 的区别是什么？String 为什么是不可变的？</h4><h5 id="不可变性"><a href="#不可变性" class="headerlink" title="不可变性"></a>不可变性</h5><p>String 类中<strong>使用 final 关键字修饰字符数组来保存字符串</strong>，<code>private final char value[]</code>，所以 <strong>String 对象是不可变的</strong>。</p><blockquote><p>在 Java 9 之后，String、StringBuffer 与 StringBuilder 的实现改为 byte 数组存储字符串 <code>private final byte[] value</code></p></blockquote><p>StringBuilder 和 StringBuffer 都继承自 AbstractStringBuilder 类，在这个类中的字符数组没有用 final 关键字修饰，所以这两种对象都是可变的。</p><h5 id="线程安全性"><a href="#线程安全性" class="headerlink" title="线程安全性"></a>线程安全性</h5><p>String 对象是不可变的，不可变对象都是线程安全的。</p><p>AbstractStringBuilder 定义的一些字符串的基本操作，如 expandCapacity、append、insert、indexOf 等公共方法。StringBuffer 对方法加了同步锁或对调用的方法加了同步锁，所以是线程安全的。StringBuilder 并没有对方法进行加锁，所以是非线程安全的。</p><h5 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h5><p>每次对 String 类型进行改变时，都会生成一个新的 String 对象，然后将引用指向新的 String 对象。StringBuffer 每次都会对StringBuffer 对象本身进行操作。</p><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><ol><li>操作少量的数据，使用 String</li><li>单线程操作字符串缓冲区大量数据：使用 StringBuilder</li><li>多线程操作字符串缓冲区大量数据：使用 StringBuffer</li></ol><h4 id="Object-类的常见方法总结"><a href="#Object-类的常见方法总结" class="headerlink" title="==Object 类的常见方法总结=="></a>==Object 类的常见方法总结==</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> Class&lt;?&gt; getClass()<span class="comment">//native方法，用于返回当前运行时对象的Class对象，使用了final关键字修饰，故不允许子类重写。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> <span class="comment">//native方法，用于返回对象的哈希码，主要使用在哈希表中，比如JDK中的HashMap。</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span><span class="comment">//用于比较2个对象的内存地址是否相等，String类对该方法进行了重写用户比较字符串的值是否相等。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException<span class="comment">//naitive方法，用于创建并返回当前对象的一份拷贝。一般情况下，对于任何对象 x，表达式 x.clone() != x 为true，x.clone().getClass() == x.getClass() 为true。Object本身没有实现Cloneable接口，所以不重写clone方法并且进行调用的话会发生CloneNotSupportedException异常。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span><span class="comment">//返回类的名字@实例的哈希码的16进制的字符串。建议Object所有的子类都重写这个方法。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">()</span><span class="comment">//native方法，并且不能重写。唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">notifyAll</span><span class="params">()</span><span class="comment">//native方法，并且不能重写。跟notify一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException<span class="comment">//native方法，并且不能重写。暂停线程的执行。注意：sleep方法没有释放锁，而wait方法释放了锁 。timeout是等待时间。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout, <span class="keyword">int</span> nanos)</span> <span class="keyword">throws</span> InterruptedException<span class="comment">//多了nanos参数，这个参数表示额外时间（以毫微秒为单位，范围是 0-999999）。 所以超时的时间还需要加上nanos毫秒。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException<span class="comment">//跟之前的2个wait方法一样，只不过该方法一直等待，没有超时时间这个概念</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123; &#125;<span class="comment">//实例被垃圾回收器回收的时候触发的操作</span></span><br></pre></td></tr></table></figure><h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>反射赋予了我们在运行时分析类以及执行类中方法的能力。</p><p>通过反射你可以获取任意一个类的所有属性和方法，并可以调用这些方法和属性。</p><h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><ul><li>优点：让代码更加灵活，为各种框架提供开箱即用功能提供便利</li><li>缺点：让我们在运行时有了分析类和操作类的能力。这同样增加了安全问题。比如可以无视泛型参数的安全检查（泛型参数的安全检查发生在编译时），同时，反射的性能稍差。</li></ul><h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><p>SpringBoot 等框架中大量使用了反射机制，<strong>这些框架中也大量使用了动态代理，而动态代理的实现也依赖反射</strong>。</p><p>另外，Java 中的注解也使用了反射，例如 Spring 中，@Component 注解声明一个类为 Spring Bean。这些都是因为可以基于反射分析类，然后获取到 类/属性/方法/方法参数 上的注解。获取到注解后，就可以进一步处理。</p><h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><h4 id="层次结构图"><a href="#层次结构图" class="headerlink" title="层次结构图"></a>层次结构图</h4><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20210815200456496.png" alt="image-20210815200456496"></p><p><code>Exception</code> 和 <code>Error</code> 二者都是 Java 异常处理的重要子类，各自都包含大量子类。</p><ul><li><strong><code>Exception</code></strong> :程序本身可以处理的异常，可以通过 <code>catch</code> 来进行捕获。<code>Exception</code> 又可以分为 <strong>受检查异常(必须处理) 和 不受检查异常(可以不处理)</strong>。</li><li><strong><code>Error</code></strong> ：<code>Error</code> 属于程序无法处理的错误 ，我们没办法通过 <code>catch</code> 来进行捕获 。例如，Java 虚拟机运行错误（<code>Virtual MachineError</code>）、虚拟机内存不够错误(<code>OutOfMemoryError</code>)、类定义错误（<code>NoClassDefFoundError</code>）等 。这些异常发生时，Java 虚拟机（JVM）一般会选择线程终止。</li></ul><p>==Java 代码在编译过程中 ，我们即使不处理不受检查异常也可以正常通过编译。==</p><h4 id="try-catch-finally"><a href="#try-catch-finally" class="headerlink" title="try-catch-finally"></a>try-catch-finally</h4><p>finally 块不会执行的情况</p><ul><li>在 try 或 finally 块中用了 System.exit(int) 退出程序。</li><li>程序所在线程死亡</li><li>关闭 CPU</li></ul><p>当 try 和 finally 语句中都有 return 语句时，finally 语句的内容将被执行。</p><h4 id="使用-try-with-resource-来代替-try-catch-finally"><a href="#使用-try-with-resource-来代替-try-catch-finally" class="headerlink" title="使用 try-with-resource 来代替 try-catch-finally"></a>使用 try-with-resource 来代替 try-catch-finally</h4><p>适用范围（资源）：任何实现 <code>java.lang.AutoCloseable</code>或者 <code>java.io.Closeable</code> 的类</p><p>在 finally 块中手动关闭资源</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Scanner scanner = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    scanner = <span class="keyword">new</span> Scanner(<span class="keyword">new</span> File(<span class="string">"D://read.txt"</span>)));</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(scanner != <span class="keyword">null</span>)&#123;</span><br><span class="line">        scanner.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 try-with-resource 自动关闭</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>(Scanner scanner = <span class="keyword">new</span> Scanner(<span class="keyword">new</span> File(<span class="string">"D://read.txt"</span>)));)&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="I-O-流"><a href="#I-O-流" class="headerlink" title="I/O 流"></a>I/O 流</h3><h4 id="序列化与反序列化"><a href="#序列化与反序列化" class="headerlink" title="序列化与反序列化"></a>序列化与反序列化</h4><ul><li>序列化：将数据结构或对象转换成二进制字节流的过程</li><li>反序列化：将在序列化过程中所生成的二进制字节流的过程转换为数据结构或对象的过程</li></ul><h4 id="Java-中有些字段不想进行序列化"><a href="#Java-中有些字段不想进行序列化" class="headerlink" title="Java 中有些字段不想进行序列化"></a>Java 中有些字段不想进行序列化</h4><p>使用 transient 关键字修饰，当对象被反序列化时，被 transient 修饰的变量值不会被持久化和恢复。</p><h4 id="关于-transient"><a href="#关于-transient" class="headerlink" title="关于 transient"></a>关于 transient</h4><ul><li>只能修饰变量</li><li>被它修饰的变量，在反序列化后变量值会被置成类型的默认值</li><li>static 变量不属于任何对象，不会被序列化</li></ul><h4 id="获取键盘输入的两种方法"><a href="#获取键盘输入的两种方法" class="headerlink" title="获取键盘输入的两种方法"></a>获取键盘输入的两种方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过 Scanner</span></span><br><span class="line">Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">String s  = input.nextLine();</span><br><span class="line">input.close();</span><br><span class="line"><span class="comment">//通过 BufferReader</span></span><br><span class="line">BufferedReader input = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">String s = input.readLine();</span><br></pre></td></tr></table></figure><h4 id="Java-中-IO-流分几种？"><a href="#Java-中-IO-流分几种？" class="headerlink" title="Java 中 IO 流分几种？"></a>Java 中 IO 流分几种？</h4><ul><li>按流的流向分，可以分为输入流和输出流</li><li>按操作单元划分，可以划分为字节流和字符流</li><li>按流的角色分为节点流和处理流</li></ul><p>Java IO 流的 40 多个类都是从如下 4 个抽象类基类中派生出来的。</p><ul><li>InputStream/Reader: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。</li><li>OutputStream/Writer: 所有输出流的基类，前者是字节输出流，后者是字符输出流。</li></ul><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20210815203343090.png" alt="image-20210815203343090"></p><h4 id="为什么分字节流和字符流"><a href="#为什么分字节流和字符流" class="headerlink" title="为什么分字节流和字符流"></a>为什么分字节流和字符流</h4><p>字符流由虚拟机将字节转化得到的，这个过程非常耗时，并且在编码类型未知时容易出现乱码问题。IO流就直接提供了一个操作字符的接口，方便对字符进行六操作。如果音频、文件、图片等使用字节流比较好。</p><h4 id="BIO、NIO、AIO"><a href="#BIO、NIO、AIO" class="headerlink" title="==BIO、NIO、AIO=="></a>==BIO、NIO、AIO==</h4><p>我们在平常开发过程中接触最多的就是 <strong>磁盘 IO（读写文件）</strong> 和 <strong>网络 IO（网络请求和相应）</strong>。</p><p><strong>从应用程序的视角来看的话，我们的应用程序对操作系统的内核发起 IO 调用（系统调用），操作系统负责的内核执行具体的 IO 操作。也就是说，我们的应用程序实际上只是发起了 IO 操作的调用而已，具体 IO 的执行是由操作系统的内核来完成的。</strong></p><p>当应用程序发起 I/O 调用后，会经历两个步骤：</p><ol><li>内核等待 I/O 设备准备好数据</li><li>内核将数据从内核空间拷贝到用户空间。</li></ol><h5 id="BIO-Blocking-IO"><a href="#BIO-Blocking-IO" class="headerlink" title="BIO(Blocking IO)"></a>BIO(Blocking IO)</h5><p>同步阻塞 IO 模型，应用程序发起 read 调用后会一直阻塞，直到在内核把数据拷贝回用户空间</p><p>在客户端连接数量不高的情况下可以使用。</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/6a9e704af49b4380bb686f0c96d33b81~tplv-k3u1fbpfcp-watermark.image" alt="图源：《深入拆解Tomcat &amp; Jetty》"></p><h5 id="NIO-Non-blocking-New-IO"><a href="#NIO-Non-blocking-New-IO" class="headerlink" title="NIO(Non-blocking/ New IO)"></a>NIO(Non-blocking/ New IO)</h5><p>Java 中的 NIO 于 Java 1.4 中引入，对应 <code>java.nio</code> 包，提供了 <code>Channel</code> , <code>Selector</code>，<code>Buffer</code> 等抽象。NIO 中的 N 可以理解为 Non-blocking，不单纯是 New。它支持面向缓冲的，基于通道的 I/O 操作方法。 对于高负载、高并发的（网络）应用，应使用 NIO 。</p><p>Java 中的 NIO 可以看作是 <strong>I/O 多路复用模型</strong>。也有很多人认为，Java 中的 NIO 属于同步非阻塞 IO 模型。</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/bb174e22dbe04bb79fe3fc126aed0c61~tplv-k3u1fbpfcp-watermark.image" alt="图源：《深入拆解Tomcat &amp; Jetty》"></p><p>同步非阻塞 IO 模型中，应用程序会一直发起 read 调用，等待数据从内核空间拷贝到用户空间的这段时间里，线程依然是阻塞的，直到在内核把数据拷贝到用户空间。</p><p>但是，这种 IO 模型同样存在问题：<strong>应用程序不断进行 I/O 系统调用轮询数据是否已经准备好的过程是十分消耗 CPU 资源的。</strong></p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/88ff862764024c3b8567367df11df6ab~tplv-k3u1fbpfcp-watermark.image" alt="img"></p><p>IO 多路复用模型中，线程首先发起 select 调用，询问内核数据是否准备就绪，等内核把数据准备好了，用户线程再发起 read 调用。read 调用的过程（数据从内核空间-&gt;用户空间）还是阻塞的。</p><p><strong>IO 多路复用模型，通过减少无效的系统调用，减少了对 CPU 资源的消耗。</strong></p><p>Java 中的 NIO ，有一个非常重要的<strong>选择器 ( Selector )</strong> 的概念，也可以被称为 <strong>多路复用器</strong>。通过它，只需要一个线程便可以管理多个客户端连接。当客户端数据到了之后，才会为其服务。</p><h5 id="AIO（Asynchronous-IO）"><a href="#AIO（Asynchronous-IO）" class="headerlink" title="AIO（Asynchronous IO）"></a>AIO（Asynchronous IO）</h5><p>异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/3077e72a1af049559e81d18205b56fd7~tplv-k3u1fbpfcp-watermark.image" alt="img"></p><h5 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h5><h5 id=""><a href="#" class="headerlink" title=""></a><img src="https://gitee.com/hoo334/picgo/raw/master//img/33b193457c928ae02217480f994814b6.png" alt="img"></h5><h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>在 Java 中除了以 <code>Map</code> 结尾的类之外， 其他类都实现了 <code>Collection</code> 接口。以 <code>Map</code> 结尾的类都实现了 <code>Map</code> 接口。</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/java-collection-hierarchy.png" alt="img"></p><h4 id="List，Set，Map-三者的区别"><a href="#List，Set，Map-三者的区别" class="headerlink" title="List，Set，Map 三者的区别"></a>List，Set，Map 三者的区别</h4><ol><li>List，存储的元素是==有序的、可重复==的</li><li>Set，存储的元素是==无序的、不可重复==的</li><li>Map，键值对存储，==key 是无序的、不可重复的，value 是无需的、可重复的==</li></ol><h4 id="集合底层数据结构"><a href="#集合底层数据结构" class="headerlink" title="集合底层数据结构"></a>集合底层数据结构</h4><h6 id="List"><a href="#List" class="headerlink" title="List"></a>List</h6><p>ArrayList、Vector：Object[] 数组，LinkedList：双向链表（JDK1.6 之前为循环链表）</p><h6 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h6><p>HashSet（无序、唯一）：基于 HashMap 实现</p><p>LinkedHashSet：是 HashSet 的子类，其内部是通过 LinkedHashMap 实现的</p><p>TreeSet（有序、唯一）：红黑树</p><h6 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h6><p>HashMap：JDK1.8 之前为数组+链表，之后当链表长度大于阈值（默认为 8 ）将链表转换为红黑树</p><p>LinkedHashMap：继承自 HashMap，在 HashMap 基础上，增加了一条双向链表，可以保持键值对的插入顺序，同时对链表进行相应的操作，实现了访问顺序相关逻辑</p><p>HashTable：数组+链表</p><p>TreeMap：红黑树</p><h3 id="如何选用集合"><a href="#如何选用集合" class="headerlink" title="如何选用集合"></a>如何选用集合</h3><p>当需要键值对存储时使用 Map 接口下的集合，排序用 TreeMap，不需要排序用HashMap，保证线程安全用 ConcurrentHashMap</p><p>当只用存放元素值时使用 Collection 接口下的集合，保证唯一性用 Set接口的集合例如 TreeSet 和 HashSet，不需要则选择实现 List 接口的如 ArrayList，LinkedList</p><h3 id="Collection-子接口-List"><a href="#Collection-子接口-List" class="headerlink" title="Collection 子接口 - List"></a>Collection 子接口 - List</h3><h4 id="ArrayList-和-LinkedList-的区别"><a href="#ArrayList-和-LinkedList-的区别" class="headerlink" title="ArrayList 和 LinkedList 的区别"></a>ArrayList 和 LinkedList 的区别</h4><ol><li><p>线程安全：都是不保证线程安全</p></li><li><p>底层数据结构：ArrayList 底层使用 <strong>Object 数组</strong>，LinkedList 使用<strong>双向链表</strong>数据结构</p></li><li><p>插入和删除是否受元素位置影响：</p><ul><li>ArrayList：操作末尾元素 $O(1)$时间复杂度，操作数组头部和中间元素$O(n)$时间复杂度</li><li>LinkedList：操作头尾元素$O(1)$时间复杂度，操作中间元素$O(n)$时间复杂度</li></ul></li><li><p>是否支持快速随机访问：ArrayList 底层是数组，所以支持，LinkedList 不支持</p></li><li><p>内存空间占用：ArrayList 为数组尾部空余空间浪费，LinkedList 为指针域空间占用</p></li></ol><h4 id="ArrayList-扩容机制"><a href="#ArrayList-扩容机制" class="headerlink" title="ArrayList 扩容机制"></a>ArrayList 扩容机制</h4><ol><li><p>构造方法：<strong>以无参数构造方法创建 <code>ArrayList</code> 时，实际上初始化赋值的是一个空数组。当真正对数组进行添加元素操作时，才真正分配容量。即向数组中添加第一个元素时，数组容量扩为 10</strong></p></li><li><p>扩容（grow 方法）：<strong>int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1),所以 ArrayList 每次扩容之后容量都会变为原来的 1.5 倍左右（oldCapacity 为偶数就是 1.5 倍，否则是 1.5 倍左右）</strong>，在添加大量元素时，显示调用 ensureCapacity 方法可以让ArrayList扩容</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// oldCapacity为旧容量，newCapacity为新容量</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="comment">//将oldCapacity 右移一位，其效果相当于oldCapacity /2，</span></span><br><span class="line">    <span class="comment">//我们知道位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍，</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量，</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="comment">//再检查新容量是否超出了ArrayList所定义的最大容量，</span></span><br><span class="line">    <span class="comment">//若超出了，则调用hugeCapacity()来比较minCapacity和 MAX_ARRAY_SIZE，</span></span><br><span class="line">    <span class="comment">//如果minCapacity大于MAX_ARRAY_SIZE，则新容量则为Interger.MAX_VALUE，否则，新容量大小则为 MAX_ARRAY_SIZE。</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Collection-子接口-Set"><a href="#Collection-子接口-Set" class="headerlink" title="Collection 子接口 - Set"></a>Collection 子接口 - Set</h3><h4 id="Comparable-和-Comparator-的区别"><a href="#Comparable-和-Comparator-的区别" class="headerlink" title="Comparable 和 Comparator 的区别"></a>Comparable 和 Comparator 的区别</h4><ul><li><code>comparable</code> 接口实际上是出自<code>java.lang</code>包 它有一个 <code>compareTo(Object obj)</code>方法用来排序</li><li><code>comparator</code>接口实际上是出自 java.util 包它有一个<code>compare(Object obj1, Object obj2)</code>方法用来排序</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// person对象没有实现Comparable接口，所以必须实现，这样才不会出错，才可以使treemap中的数据按顺序排列</span></span><br><span class="line"><span class="comment">// 前面一个例子的String类已经默认实现了Comparable接口，详细可以查看String类的API文档，另外其他</span></span><br><span class="line"><span class="comment">// 像Integer类等都已经实现了Comparable接口，所以不需要另外实现了</span></span><br><span class="line"><span class="keyword">public</span>  <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Person</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"><span class="comment">//省略 getter、setter、构造方法</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重写compareTo方法实现按年龄来排序</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Person o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.age &gt; o.getAge()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.age &lt; o.getAge()) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定制排序的用法</span></span><br><span class="line">Collections.sort(arrayList, <span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> o2.compareTo(o1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="HashSet、LinkedHashSet-和-TreeSet-三者异同"><a href="#HashSet、LinkedHashSet-和-TreeSet-三者异同" class="headerlink" title="HashSet、LinkedHashSet 和 TreeSet 三者异同"></a>HashSet、LinkedHashSet 和 TreeSet 三者异同</h4><p><code>HashSet</code> 是 <code>Set</code> 接口的主要实现类 ，<code>HashSet</code> 的底层是 <code>HashMap</code>，线程不安全的，可以存储 null 值；</p><p><code>LinkedHashSet</code> 是 <code>HashSet</code> 的子类，<strong>能够按照添加的顺序遍历</strong>；</p><p><code>TreeSet</code> 底层使用红黑树，能够按照添加元素的顺序进行遍历，排序的方式有自然排序和定制排序。</p><h3 id="Collection-子接口-Queue"><a href="#Collection-子接口-Queue" class="headerlink" title="Collection 子接口 - Queue"></a>Collection 子接口 - Queue</h3><h4 id="Queue-和-Deque-的区别"><a href="#Queue-和-Deque-的区别" class="headerlink" title="Queue 和 Deque 的区别"></a>Queue 和 Deque 的区别</h4><p>Queue 是单端队列，只能从一端插入元素，另一端删除元素，一般遵循先进先出原则。</p><p><code>Queue</code> 扩展了 <code>Collection</code> 的接口，根据 <strong>因为容量问题而导致操作失败后处理方式的不同</strong> 可以分为两类方法: 一种在操作失败后会抛出异常，另一种则会返回特殊值。</p><table><thead><tr><th><code>Queue</code> 接口</th><th>抛出异常</th><th>返回特殊值</th></tr></thead><tbody><tr><td>插入队尾</td><td>add(E e)</td><td>offer(E e)</td></tr><tr><td>删除队首</td><td>remove()</td><td>poll()</td></tr><tr><td>查询队首元素</td><td>element()</td><td>peek()</td></tr></tbody></table><p>Deque 是双端队列，在队列的两端均可插入或删除元素</p><p><code>Deque</code> 扩展了 <code>Queue</code> 的接口, 增加了在队首和队尾进行插入和删除的方法，同样根据失败后处理方式的不同分为两类：</p><table><thead><tr><th><code>Deque</code> 接口</th><th>抛出异常</th><th>返回特殊值</th></tr></thead><tbody><tr><td>插入队首</td><td>addFirst(E e)</td><td>offerFirst(E e)</td></tr><tr><td>插入队尾</td><td>addLast(E e)</td><td>offerLast(E e)</td></tr><tr><td>删除队首</td><td>removeFirst()</td><td>pollFirst()</td></tr><tr><td>删除队尾</td><td>removeLast()</td><td>pollLast()</td></tr><tr><td>查询队首元素</td><td>getFirst()</td><td>peekFirst()</td></tr><tr><td>查询队尾元素</td><td>getLast()</td><td>peekLast()</td></tr></tbody></table><p>事实上，<code>Deque</code> 还提供有 <code>push()</code> 和 <code>pop()</code> 等其他方法，可用于模拟栈。</p><h4 id="ArrayDeque-和-LinkedList-的区别"><a href="#ArrayDeque-和-LinkedList-的区别" class="headerlink" title="ArrayDeque 和 LinkedList 的区别"></a>ArrayDeque 和 LinkedList 的区别</h4><p>它们都实现了 Deque 接口，两者都有队列的功能</p><ul><li>ArrayDeque 基于可变长的数组和双指针实现，LinkedList 通过双向链表实现</li><li>ArrayDeque 不支持 Null 数据，LinkedList 支持</li><li>ArrayDeque 插入时可能存在扩容过程，均摊后的操作时间复杂度$O(1)$，LinkedList 每次插入数据时均需要申请新的堆空间，均摊性能更慢。</li></ul><p>从性能的角度上，选用 <code>ArrayDeque</code> 来实现队列要比 <code>LinkedList</code> 更好。此外，<code>ArrayDeque</code> 也可以用于实现栈。</p><h4 id="PriorityQueue"><a href="#PriorityQueue" class="headerlink" title="PriorityQueue"></a>PriorityQueue</h4><p>优先级队列，总是优先级最高的元素先出队</p><p>它使用二叉堆来实现，底层使用可变长的数组来存储数据，插入元素和删除堆顶元素时间复杂度为$O(log\ n)$，非线程安全，不支持 Null 和 没有实现 Comparable 的对象，默认为小顶堆，可以接受一个 Comparator 自定优先级。</p><h3 id="Map-接口"><a href="#Map-接口" class="headerlink" title="Map 接口"></a>Map 接口</h3><h4 id="HashMap-和-HashTable"><a href="#HashMap-和-HashTable" class="headerlink" title="HashMap 和 HashTable"></a>HashMap 和 HashTable</h4><ol><li><p>线程安全，HashMap 非线程安全，HashTable 内部的方法基本都使用 synchronized 修饰，是线程安全的</p></li><li><p>效率，由于线程安全的操作，HashTable 比 HashMap 效率低</p></li><li><p>对空键和空值的支持，HashMap 支持一个空键，多个空值；HashTable 不允许有空键和空值，否则抛空指针异常</p></li><li><p>数据结构，HashTable 数组+链表，jdk1.7 HashMap 也是数组+链表，jdk1.8 后当链表长度大于阈值会将链表转换为红黑树</p></li><li><p>初始容量和扩容不同，HashTabl默认大小为 11，每次扩容容量变为原来的 2n + 1 ，HashMap 初始大小为16，每次扩容为原来的 2 倍。如果给定容量大小，HashTable 直接扩容到给定的大小，HashMap 将会把它扩容到 2 的幂次方。</p></li></ol><h4 id="HashMap-和-HashSet"><a href="#HashMap-和-HashSet" class="headerlink" title="HashMap 和 HashSet"></a>HashMap 和 HashSet</h4><p>如果你看过 <code>HashSet</code> 源码的话就应该知道：<code>HashSet</code> 底层就是基于 <code>HashMap</code> 实现的。（<code>HashSet</code> 的源码非常非常少，因为除了 <code>clone()</code>、<code>writeObject()</code>、<code>readObject()</code>是 <code>HashSet</code> 自己不得不实现之外，其他方法都是直接调用 <code>HashMap</code> 中的方法。</p><table><thead><tr><th><code>HashMap</code></th><th><code>HashSet</code></th></tr></thead><tbody><tr><td>实现了 <code>Map</code> 接口</td><td>实现 <code>Set</code> 接口</td></tr><tr><td>存储键值对</td><td>仅存储对象</td></tr><tr><td>调用 <code>put()</code>向 map 中添加元素</td><td>调用 <code>add()</code>方法向 <code>Set</code> 中添加元素</td></tr><tr><td><code>HashMap</code> 使用键（Key）计算 <code>hashcode</code></td><td><code>HashSet</code> 使用成员对象来计算 <code>hashcode</code> 值，对于两个对象来说 <code>hashcode</code> 可能相同，所以<code>equals()</code>方法用来判断对象的相等性</td></tr></tbody></table><h4 id="HashMap-和-TreeMap"><a href="#HashMap-和-TreeMap" class="headerlink" title="HashMap 和 TreeMap"></a>HashMap 和 TreeMap</h4><p><code>TreeMap</code> 和<code>HashMap</code> 都继承自<code>AbstractMap</code> ，但是需要注意的是<code>TreeMap</code>它还实现了<code>NavigableMap</code>接口和<code>SortedMap</code> 接口。</p><p>实现 <code>NavigableMap</code> 接口让 <code>TreeMap</code> 有了对集合内元素的搜索的能力。</p><p>实现<code>SortMap</code>接口让 <code>TreeMap</code> 有了对集合中的元素根据键排序的能力。</p><h4 id="HashSet如何检查重复"><a href="#HashSet如何检查重复" class="headerlink" title="==HashSet如何检查重复=="></a>==HashSet如何检查重复==</h4><p>当你把对象加入<code>HashSet</code>时，<code>HashSet</code> 会先计算对象的<code>hashcode</code>值来判断对象加入的位置，同时也会与其他加入的对象的 <code>hashcode</code> 值作比较，如果没有相符的 <code>hashcode</code>，<code>HashSet</code> 会假设对象没有重复出现。但是如果发现有相同 <code>hashcode</code> 值的对象，这时会调用<code>equals()</code>方法来检查 <code>hashcode</code> 相等的对象是否真的相同。如果两者相同，<code>HashSet</code> 就不会让加入操作成功。</p><h4 id="HashMap-底层实现"><a href="#HashMap-底层实现" class="headerlink" title="HashMap 底层实现"></a>HashMap 底层实现</h4><p>JDK1.8 HashMap 的 hash 方法源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="comment">// key.hashCode()：返回散列值也就是hashcode</span></span><br><span class="line">    <span class="comment">// ^ ：按位异或</span></span><br><span class="line">    <span class="comment">// &gt;&gt;&gt;:无符号右移，忽略符号位，空位都以0补齐</span></span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JDK1.8 之后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。</p><h4 id="HashMap-的长度为什么是-2-的幂次方"><a href="#HashMap-的长度为什么是-2-的幂次方" class="headerlink" title="==HashMap 的长度为什么是 2 的幂次方=="></a>==HashMap 的长度为什么是 2 的幂次方==</h4><p>一般我们使用 hash 值取余数组的长度 n ，得到存放到数组的下标。但取余操作很慢，HashMap 使用的是 <code>(n - 1) &amp; hash</code>快速求下标的方式。但只有当 n 为 2 的幂次时，<code>hash % n == hash &amp; (n - 1)</code>，所以 HashMap 的长度必须为 2 的幂次。</p><h4 id="HashMap-类属性"><a href="#HashMap-类属性" class="headerlink" title="HashMap 类属性"></a>HashMap 类属性</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 序列号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">362498820763181265L</span>;</span><br><span class="line">    <span class="comment">// 默认的初始容量是16</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>;</span><br><span class="line">    <span class="comment">// 最大容量</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line">    <span class="comment">// 默认的填充因子</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line">    <span class="comment">// 当桶(bucket)上的结点数大于这个值时会转成红黑树</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line">    <span class="comment">// 当桶(bucket)上的结点数小于这个值时树转链表</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line">    <span class="comment">// 桶中结构转化为红黑树对应的table的最小大小</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br><span class="line">    <span class="comment">// 存储元素的数组，总是2的幂次倍</span></span><br><span class="line">    <span class="keyword">transient</span> Node&lt;k,v&gt;[] table;</span><br><span class="line">    <span class="comment">// 存放具体元素的集</span></span><br><span class="line">    <span class="keyword">transient</span> Set&lt;map.entry&lt;k,v&gt;&gt; entrySet;</span><br><span class="line">    <span class="comment">// 存放元素的个数，注意这个不等于数组的长度。</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="comment">// 每次扩容和更改map结构的计数器</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br><span class="line">    <span class="comment">// 临界值 当实际大小(容量*填充因子)超过临界值时，会进行扩容</span></span><br><span class="line">    <span class="keyword">int</span> threshold;</span><br><span class="line">    <span class="comment">// 加载因子</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="HashMap-多线程操作死循环问题"><a href="#HashMap-多线程操作死循环问题" class="headerlink" title="HashMap 多线程操作死循环问题"></a>HashMap 多线程操作死循环问题</h4><p>在并发情况下，Rehash 方法会造成元素之间形成一个循环链表</p><p><a href="https://coolshell.cn/articles/9606.html" target="_blank" rel="noopener">详解</a></p><h4 id="ConcurrentHashMap-和-HashTable"><a href="#ConcurrentHashMap-和-HashTable" class="headerlink" title="ConcurrentHashMap 和 HashTable"></a>ConcurrentHashMap 和 HashTable</h4><ol><li>底层数据结构：JDK1.7 之前 ConcurrentHashMap 底层采用分段数组+链表实现，JDK1.8 采用数组 + 链表/红黑树。HashTable 采用数组+链表实现</li><li>实现线程安全的方式：<ul><li>JDK1.7时 ConcurrentHashMap 对整个桶数组进行了分段分割（segment），每一把锁只锁一部分数据。到JDK1.8时，直接使用 Node 数组+链表/红黑树来实现，并发控制使用 synchronzied 和 CAS 来操作</li><li>HashTable 使用全表锁，效率十分低下，一个线程使用 put 添加元素，另一个线程既不能 get 也不能 put。</li></ul></li></ol><h4 id="Concurrent底层实现"><a href="#Concurrent底层实现" class="headerlink" title="Concurrent底层实现"></a>Concurrent底层实现</h4><p>JDK1.7</p><p>首先将数据分为一段一段，然后给每段数据配一把锁，当一个线程占用锁访问其中一个段数据时，其他段的数据也能被其他线程访问。</p><p>ConcurrentHashMap 是由 Segment 数组结构和 HashEntry 数组结构组成。</p><p>Segment 实现了 ReentrantLock，Segment 是一种可重入锁，扮演锁的角色。HashEntry 用于存储键值对数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Segment</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">ReentrantLock</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个 ConcurrentHashMap 里包含一个Segment数组，一个 Segment 包含一个 HashEntry 数组，每个 HashEntry 是一个链表结构的元素，当对当前 Segment 内的 HashEntry 进行修改时，必须先获得 Segment 的锁。</p><p>JDK1.8</p><p><code>ConcurrentHashMap</code> 取消了 <code>Segment</code> 分段锁，采用 CAS 和 <code>synchronized</code> 来保证并发安全。数据结构跟 HashMap1.8 的结构类似，数组+链表/红黑二叉树。Java 8 在链表长度超过一定阈值（8）时将链表（寻址时间复杂度为 O(N)）转换为红黑树（寻址时间复杂度为 $O(logN）$</p><h3 id="Collections-工具类"><a href="#Collections-工具类" class="headerlink" title="Collections 工具类"></a>Collections 工具类</h3><h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(List list)</span><span class="comment">//反转</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shuffle</span><span class="params">(List list)</span><span class="comment">//随机排序</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(List list)</span><span class="comment">//按自然排序的升序排序</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(List list, Comparator c)</span><span class="comment">//定制排序，由Comparator控制排序逻辑</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(List list, <span class="keyword">int</span> i , <span class="keyword">int</span> j)</span><span class="comment">//交换两个索引位置的元素</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(List list, <span class="keyword">int</span> distance)</span><span class="comment">//旋转。当distance为正数时，将list后distance个元素整体移到前面。当distance为负数时，将 list的前distance个元素整体移到后面</span></span></span><br></pre></td></tr></table></figure><h4 id="查找、替换操作"><a href="#查找、替换操作" class="headerlink" title="查找、替换操作"></a>查找、替换操作</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(List list, Object key)</span><span class="comment">//对List进行二分查找，返回索引，注意List必须是有序的</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(Collection coll)</span><span class="comment">//根据元素的自然顺序，返回最大的元素。 类比int min(Collection coll)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(Collection coll, Comparator c)</span><span class="comment">//根据定制排序，返回最大元素，排序规则由Comparatator类控制。类比int min(Collection coll, Comparator c)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fill</span><span class="params">(List list, Object obj)</span><span class="comment">//用指定的元素代替指定list中的所有元素</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">frequency</span><span class="params">(Collection c, Object o)</span><span class="comment">//统计元素出现次数</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexOfSubList</span><span class="params">(List list, List target)</span><span class="comment">//统计target在list中第一次出现的索引，找不到则返回-1，类比int lastIndexOfSubList(List source, list target)</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">replaceAll</span><span class="params">(List list, Object oldVal, Object newVal)</span><span class="comment">//用新元素替换旧元素</span></span></span><br></pre></td></tr></table></figure><h4 id="同步（不推荐，建议使用-JUC-包下的并发集合）"><a href="#同步（不推荐，建议使用-JUC-包下的并发集合）" class="headerlink" title="同步（不推荐，建议使用 JUC 包下的并发集合）"></a>同步（不推荐，建议使用 JUC 包下的并发集合）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">synchronizedCollection(Collection&lt;T&gt;  c) <span class="comment">//返回指定 collection 支持的同步（线程安全的）collection。</span></span><br><span class="line">synchronizedList(List&lt;T&gt; list)<span class="comment">//返回指定列表支持的同步（线程安全的）List。</span></span><br><span class="line">synchronizedMap(Map&lt;K,V&gt; m) <span class="comment">//返回由指定映射支持的同步（线程安全的）Map。</span></span><br><span class="line">synchronizedSet(Set&lt;T&gt; s) <span class="comment">//返回指定 set 支持的同步（线程安全的）set。</span></span><br></pre></td></tr></table></figure><h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><h3 id="基础-1"><a href="#基础-1" class="headerlink" title="基础"></a>基础</h3><h4 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h4><p>进程是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。在 Java 中，当我们启动 main 函数时就是启动了一个 JVM 的进程。</p><p>线程与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是，同类的多个线程共享进程的<strong>堆</strong>和<strong>方法区</strong>资源，但每个线程都有自己的<strong>程序计数器</strong>、<strong>虚拟机栈</strong>和<strong>本地方法栈</strong>。</p><h4 id="程序计数器为什么是线程私有的？"><a href="#程序计数器为什么是线程私有的？" class="headerlink" title="程序计数器为什么是线程私有的？"></a>程序计数器为什么是线程私有的？</h4><ol><li>字节码解释器通过程序计数器来读取指令，从而实现代码的流程控制</li><li>在多线程情况下，程序计数器用于记录当前线程执行的位置</li></ol><p>如果执行的是 native 方法，程序计数器记录的是 undefined 地址，只有执行的是 Java 代码时，程序计数器才指向下一条指令的地址</p><p>程序计数器私有是为了<strong>线程切换后能恢复到正确的执行位置</strong></p><h4 id="虚拟机栈和本地方法栈为什么是私有的？"><a href="#虚拟机栈和本地方法栈为什么是私有的？" class="headerlink" title="虚拟机栈和本地方法栈为什么是私有的？"></a>虚拟机栈和本地方法栈为什么是私有的？</h4><p>虚拟机栈：每个 Java 方法在执行的同时会创建一个栈帧用于存储<strong>局部变量表</strong>，<strong>操作数栈</strong>，<strong>常量池引用</strong>等信息。从方法调用直至执行完成，就对应着一个栈帧在 Java 虚拟机中入栈和出栈的过程</p><p>本地方法栈：和虚拟机栈所发挥的作用非常相似，区别是虚拟机栈为虚拟机执行 Java 方法服务，本地方法为虚拟机使用到的 Native 方法服务</p><p>为了<strong>保证线程中的局部变量不被其他线程访问到</strong>，虚拟机栈和本地方法栈是私有的</p><h4 id="堆和方法区"><a href="#堆和方法区" class="headerlink" title="堆和方法区"></a>堆和方法区</h4><p>堆和方法区是所有线程共享的资源，堆是进程中最大的一块内存，主要用于存放新创建的对象，方法区主要存放已被加载的类信息、常量、静态变量、JIT编译后的数据。</p><h4 id="并行和并发"><a href="#并行和并发" class="headerlink" title="并行和并发"></a>并行和并发</h4><ul><li>并发：同一时间段，多个任务都在执行，同一时刻只执行一个任务</li><li>并发：单位时间内，多个任务同时执行</li></ul><h4 id="为什么使用多线程以及带来的问题"><a href="#为什么使用多线程以及带来的问题" class="headerlink" title="为什么使用多线程以及带来的问题"></a>为什么使用多线程以及带来的问题</h4><p>多核时代，使用多线程主要为了利用多核 CPU 的能力，创建多个线程，这些线程可以被映射到底层多个CPU核心上执行，这会提高任务执行的效率。</p><p>并发编程目的就是提高程序执行效率，但这也不是绝对的，它还会带来内存泄漏，死锁，线程不安全等问题。</p><h4 id="线程的生命周期和状态"><a href="#线程的生命周期和状态" class="headerlink" title="线程的生命周期和状态"></a>线程的生命周期和状态</h4><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20210827192442845.png" alt="image-20210827192442845"></p><h4 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h4><p>线程在执行过程中会有自己的运行条件和状态（也称上下文），比如程序计数器，栈信息等，当出现如下情况时，线程会从占用 CPU 状态中退出。</p><ul><li>主动让出 CPU，比如调用 sleep(), wait()等</li><li>时间片用完</li><li>调用了阻塞类型的系统终端，比如请求 IO</li><li>被终止或结束运行</li></ul><p>前三种状态都会发生线程切换，线程切换意味着需要保存当前线程的上下文，并加载下一个要占用 CPU 的线程上下文。频繁的上下文切换会导致效率低下。</p><h4 id="什么是死锁？如何避免死锁"><a href="#什么是死锁？如何避免死锁" class="headerlink" title="什么是死锁？如何避免死锁"></a>什么是死锁？如何避免死锁</h4><p>死锁：多个线程被同时阻塞，它们中的一个或多个都在等待某个资源被释放，由于线程被无限期地阻塞，程序不可能正常终止。</p><h4 id="产生死锁的四个条件"><a href="#产生死锁的四个条件" class="headerlink" title="产生死锁的四个条件"></a>产生死锁的四个条件</h4><ol><li>请求并保持，一个进程因请求资源而阻塞时，对已获得的资源保持不放</li><li>不可剥夺，线程已获得的资源在未使用完之前不能被其他线程强行剥夺</li><li>循环等待，若干进程之间形成一种头尾相接的循环等待资源关系。</li><li>互斥，资源任意一个时刻只由一个线程占用</li></ol><h4 id="预防死锁"><a href="#预防死锁" class="headerlink" title="预防死锁"></a>预防死锁</h4><ol><li>破坏请求与保持条件，一次性申请所有资源</li><li>破坏不可剥夺条件，占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放占有的资源</li><li>破坏循环等待条件，按序申请资源，释放资源则反序释放</li></ol><h4 id="避免死锁"><a href="#避免死锁" class="headerlink" title="避免死锁"></a>避免死锁</h4><p>在资源分配时，借助算法（银行家）对资源分配进行计算评估，使其进入安全状态。</p><h4 id="sleep-方法和-wait-方法"><a href="#sleep-方法和-wait-方法" class="headerlink" title="sleep() 方法和 wait() 方法"></a>sleep() 方法和 wait() 方法</h4><p>两者最大区别是：sleep() 方法没有释放锁，而 wait() 方法释放了锁</p><p>两者都可以暂停线程的执行。</p><p>wait() 通常被用于线程间交互/通信，sleep() 通常被用于暂停执行</p><p>wait() 方法被调用后，需要其他线程调用同一个对象上的 notify() 方法和 notifyAll() 方法。sleep() 方法执行完成后会自动苏醒</p><h4 id="为什么不能直接调用-run-方法"><a href="#为什么不能直接调用-run-方法" class="headerlink" title="==为什么不能直接调用 run() 方法=="></a>==为什么不能直接调用 run() 方法==</h4><p>新建一个 线程，调用 start() 方法，会启动一个线程并使其进入就绪状态，当分配到时间片后就可以开始运行了。而调用run() 方法会把 run() 方法当成 main 线程下一个普通方法执行，并不会在某个线程中执行它。</p><h3 id="synchronized-关键字"><a href="#synchronized-关键字" class="headerlink" title="==synchronized 关键字=="></a>==synchronized 关键字==</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><p><strong>synchronized 解决多个线程访问资源的同步性，它可以保证被修饰的方法或代码块在任意时刻只能有一个线程执行。</strong></p><p>因为监视器锁（monitor）是依赖于底层的操作系统的 <code>Mutex Lock</code> 来实现的，Java 的线程是映射到操作系统的原生线程之上的。如果要挂起或者唤醒一个线程，都需要操作系统帮忙完成，而操作系统实现线程之间的切换时需要从用户态转换到内核态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高。</p><p>庆幸的是在 Java 6 之后 Java 官方对从 JVM 层面对 <code>synchronized</code> 较大优化，所以现在的 <code>synchronized</code> 锁效率也优化得很不错了。JDK1.6 对锁的实现引入了大量的优化，如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销。</p><h4 id="synchronized-关键字使用方式"><a href="#synchronized-关键字使用方式" class="headerlink" title="synchronized 关键字使用方式"></a>synchronized 关键字使用方式</h4><ol><li>修饰实例方法：作用于当前对象实例加锁，进入同步代码前要获得==当前对象实例的锁==</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//业务代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>修饰静态方法：给当前类加锁，会作用于类的所有对象实例，进入同步代码前要获得==当前 class 的锁==。如果线程 A 调用实例对象的非静态 synchronized 方法，线程 B 调用实例对象所在类的静态 synchronized 方法，不会发生互斥现象。线程 A 占用的实例对象的锁，线程 B 占用的时当前类的锁。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//业务代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>修饰代码块：指定加锁对象，对给对象/类加锁</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;</span><br><span class="line">    <span class="comment">// 业务代码</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">synchronized</span>(A<span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//业务代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="构造方法可用-synchronized-关键字修饰么？"><a href="#构造方法可用-synchronized-关键字修饰么？" class="headerlink" title="构造方法可用 synchronized 关键字修饰么？"></a>构造方法可用 synchronized 关键字修饰么？</h4><p>不能，构造方法本身就是线程安全的</p><h4 id="synchronized-底层原理"><a href="#synchronized-底层原理" class="headerlink" title="==synchronized 底层原理=="></a>==synchronized 底层原理==</h4><ol><li><p>修饰语句块的情况（monitorenter、monitorexit）</p><p>使用 <strong>monitorenter</strong> 和 <strong>monitorexit</strong> 指令，同步代码块指令放在二者中间，当执行 monitorenter指令时，线程尝试获取锁（对象监视器 monitor）的持有权。在执行 monitorenter 之后，锁计数器加一，变为1。执行monitorexit指令后，锁计数器减一，变为0，此时可重新获取锁。</p></li><li><p>修饰方法的情况（ACC_SYNCHRONIZED）</p><p><code>synchronized</code> 修饰的方法并没有 <code>monitorenter</code> 指令和 <code>monitorexit</code> 指令，取得代之的确实是 <code>ACC_SYNCHRONIZED</code> 标识，该标识指明了该方法是一个同步方法。JVM 通过该 <code>ACC_SYNCHRONIZED</code> 访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用。两者的本质都是对象监视器锁 monitor 的获取。</p></li></ol><h4 id="JDK1-6-后-synchronized-关键字的优化"><a href="#JDK1-6-后-synchronized-关键字的优化" class="headerlink" title="JDK1.6 后 synchronized 关键字的优化"></a>JDK1.6 后 synchronized 关键字的优化</h4><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20210830155558454.png" alt="image-20210830155558454"></p><p>锁的级别从低到高分别为：无锁、偏向锁、轻量级锁、重量级锁，锁能升级但不能降级。</p><p>左下角图可以看到，当对象状态为偏向锁时， <strong>Mark Word 存储的是偏向的线程ID</strong>；当状态为 轻量级锁时， Mark Word 存储的是指向<strong>线程栈中 Lock Record 的指针</strong>；当状态为重量级锁时， Mark Word 为指向<strong>堆中的monitor对象的指针</strong>。</p><h5 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h5><p>大多数情况下锁不紧不存在多线程竞争，而且总是由同一线程多次获得。偏向锁会偏向第一个访问锁的线程，如果在接下的运行过程中，该锁没有被其他线程访问，则持有偏向锁的线程将永远不会出发同步。</p><p><strong>加锁</strong>：新线程在进入同步块时，尝试将对象头 MarkWord 中 的线程 ID 改为新线程 ID，如果成功，获得偏向锁，如果失败，开始撤销偏向锁并升级为轻量级锁</p><p><strong>撤销</strong>：当其他线程尝试竞争偏向锁时就会撤销锁并升级。偏向锁在升级成轻量级锁时，会暂停拥有偏向锁的线程，重置偏向锁标识，在一个安全点（这个时间点没有字节码运行）停止锁的线程，遍历线程栈，如果存在锁记录，需修复锁记录和 MarkWord 让它变成无锁状态，唤醒被暂停的线程，将当前锁升级为轻量级锁</p><h5 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a><strong>轻量级锁</strong></h5><p>多个线程在不同时间段获取同一把锁，即不存在锁竞争的情况，也就没有线程阻塞。</p><p><strong>加锁</strong>：JVM会为每个线程在当前线程的栈帧中创建⽤于存储锁记录的空间，我们称为 Displaced Mark Word。如果⼀个线程获得锁的时候发现是轻量级锁，会把锁的Mark Word复制到⾃⼰的Displaced Mark Word⾥⾯。然后线程尝试⽤CAS将锁的Mark Word替换为指向锁记录的指针。如果成功，当前 线程获得锁，如果失败，表示Mark Word已经被替换成了其他线程的锁记录，说明 在与其它线程竞争锁，当前线程就尝试使⽤⾃旋来获取锁。 自旋超过一定次数时，这个锁就会升级成重量级锁。</p><p><strong>撤销</strong>：判断对象头中的锁记录指针是否指向当前线程锁记录，并比较Displaced Mark Word 和锁的 MarkWord 是否相等，如果相等直接释放锁，如果失败则说明锁已经升级成了重量级锁。</p><h5 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h5><p>重量级锁依赖于操作系统的互斥量（mutex） 实现的，⽽操作系统中线程间状态的 转换需要相对⽐较⻓的时间，所以重量级锁效率很低，但被阻塞的线程不会消耗CPU.</p><p>每⼀个对象都可以当做⼀个锁，当多个线程同时请求某个对象锁时，对 象锁会设置⼏种状态⽤来区分请求的线程：</p><blockquote><p>Contention List：所有请求锁的线程将被⾸先放置到该竞争队列</p><p>Entry List：Contention List中那些有资格成为候选⼈的线程被移到Entry List</p><p>Wait Set：那些调⽤wait⽅法被阻塞的线程被放置到Wait Set</p><p>OnDeck：任何时刻最多只能有⼀个线程正在竞争锁，该线程称为OnDeck</p><p>Owner：获得锁的线程称为Owner</p><p>!Owner：释放锁的线程 </p></blockquote><p>当⼀个线程尝试获得锁时，如果该锁已经被占⽤，则会将该线程封装成⼀ 个 ObjectWaiter 对象插⼊到Contention List的队列的队⾸，然后调⽤ park 函数挂 起当前线程。 当线程释放锁时，会从Contention List或EntryList中挑选⼀个线程唤醒，被选中的 线程叫做 Heir presumptive 即假定继承⼈，假定继承⼈被唤醒后会尝试获得锁， 但 synchronized 是⾮公平的，所以假定继承⼈不⼀定能获得锁。这是因为对于重 量级锁，线程先⾃旋尝试获得锁，这样做的⽬的是为了减少执⾏操作系统同步操作 带来的开销。如果⾃旋不成功再进⼊等待队列。</p><h5 id="锁升级的流程"><a href="#锁升级的流程" class="headerlink" title="==锁升级的流程=="></a>==锁升级的流程==</h5><p>每个线程在准备获取共享资源时：</p><ol><li>检查 MarkWord 里放的是不是自己的线程 ID，如果是，代表当前线程有这个偏向锁；如果不是，尝试 CAS 更改共享对象 MarkWord 里的线程 ID，成功的话就获得了偏向锁。失败则代表另一个线程在使用这个共享对象，在等到安全点（这个时间点上没有正在执行的字节码）时如果还有竞争，锁升级</li><li>原本持有偏向锁的线程栈中存储共享对象 MarkWord 的拷贝，<strong>原本持有偏向锁的进程获得轻量级锁</strong>（共享对象 MarkWord 中的地址指向这条拷贝的记录），唤醒原来持有偏向锁的线程，从安全点继续执行。想要抢锁的线程也拷贝一个共享对象的 MarkWord，然后就开始 CAS 抢锁（尝试将共享对象 MarkWord 的锁记录指针指向自己的记录），如果经过一定次数的 CAS 还没抢到，证明竞争激烈，锁升级</li><li>将共享对象中的MarkWord 换为重量级锁，挂起当前线程，等待当前有锁的线程执行完成后唤醒自己。</li></ol><table><thead><tr><th>锁</th><th>优点</th><th>缺点</th><th>适用场景</th></tr></thead><tbody><tr><td>偏向锁</td><td>加锁和解锁不需要额外的消耗，和执行非同步方法仅存在纳秒级的差距</td><td>如果线程间存在锁竞争会带来额外的锁撤销的消耗</td><td>适用于只有一个线程访问同步块的场景</td></tr><tr><td>轻量级锁</td><td>竞争的线程不会阻塞，提高程序的响应速度</td><td>如果始终得不到锁，竞争的线程会使用自旋消耗 CPU</td><td>追求响应时间，同步块执行时间非常快</td></tr><tr><td>重量级锁</td><td>线程竞争不会使用自旋，不消耗 CPU</td><td>线程阻塞，响应时间长</td><td>追求吞吐量，同步块执行时间较长</td></tr></tbody></table><h4 id="synchronized-和-ReentrantLock"><a href="#synchronized-和-ReentrantLock" class="headerlink" title="synchronized 和 ReentrantLock"></a>synchronized 和 ReentrantLock</h4><p>两者都是可重入锁，“可重入”指的是自己可以再次获取自己的内部锁。</p><p>synchronized 依赖 JVM 而 ReentrantLock 依赖于 API，ReentrantLock 需要 lock() 和 unlock() 配合 try/finally 语句块来实现。</p><p>ReentrantLock 比 synchronized 增加了一些高级功能</p><ul><li><p>等待可中断：ReentrantLock 提供了一种能够中断等待锁的机制，通过 lock.lockInterruptibly() 来实现，正在等待的线程可以放弃等待，改为处理其他事情</p></li><li><p>实现公平锁：公平锁就是先等待的线程先获得锁，synchronized 只能是非公平的，ReentrantLock 默认为非公平的。</p></li><li><p>可实现选择性通知（锁可以绑定多个条件）：<code>synchronized</code>关键字与<code>wait()</code>和<code>notify()</code>/<code>notifyAll()</code>方法相结合可以实现等待/通知机制。<code>ReentrantLock</code>类当然也可以实现，但是需要借助于<code>Condition</code>接口与<code>newCondition()</code>方法。</p></li></ul><h3 id="volatile-关键字"><a href="#volatile-关键字" class="headerlink" title="volatile 关键字"></a>volatile 关键字</h3><h4 id="JMM（Java-内存模型）"><a href="#JMM（Java-内存模型）" class="headerlink" title="JMM（Java 内存模型）"></a>JMM（Java 内存模型）</h4><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20210902152656544.png" alt="image-20210902152656544"></p><p>在 JDK1.2 之前，Java 内存模型总是从<strong>主存</strong>读取变量，不用处理一致性问题。根据JMM的规定，<strong>线程对共享变量的所有操作都必须在⾃⼰的本地内存中进行，不能直接从主内存中读取</strong>。在现在的 Java 内存模型下，线程可以<strong>把变量保存到本地内存（寄存器）中</strong>，而不是直接在主存中读写，这就造成了主存数据和寄存器数据不一致的情况。</p><p>要解决这个问题，就需要把变量声明为 volatile，指示 JVM，这个变量是共享且不稳定的，每次使用它都到主存中进行读取。volatile 关键字除了防止 JVM 指令重排，还有一个重要的作用就是保证可见性。</p><h4 id="内存可见性"><a href="#内存可见性" class="headerlink" title="内存可见性"></a>内存可见性</h4><p>内存可⻅性，指的是当⼀个线程对 volatile 修饰的变量进⾏写操作时，<strong>JMM会⽴即把该线程对应的本地内存中的共享变量的值刷新到主内 存</strong>；当⼀个线程对 volatile 修饰的变量进⾏读操作时，JMM会把⽴即该线程对应的本地内存置为⽆效，从主内存中读取共享变量的值。 </p><h4 id="禁止重排序"><a href="#禁止重排序" class="headerlink" title="禁止重排序"></a>禁止重排序</h4><p>JVM 通过内存屏障实现限制处理器的重排序。在硬件层面，内存屏障分为两种：读屏障（Load Barrier）和写屏障（Store Barrier）。它有两个作用：</p><ol><li>阻止屏障两侧的指令重排序</li><li>强制把 CPU 写缓冲区/高速缓存中的脏数据写回主内存，或者让缓存中的响应数据失效</li></ol><p>编译器在⽣成字节码时，会在指令序列中插⼊内存屏障来禁⽌特定类型的处理器重排序。编译器选择了⼀个⽐较保守的<strong>JMM</strong>内存屏障插⼊策略，这样可以保证在任何处理器平台，任何程序中都能得到正确的volatile内存语义。</p><p>这个策略是： </p><ul><li><p>在每个volatile写操作前插⼊⼀个StoreStore屏障； </p></li><li><p>在每个volatile写操作后插⼊⼀个StoreLoad屏障； </p></li><li><p>在每个volatile读操作后插⼊⼀个LoadLoad屏障； </p></li><li><p>在每个volatile读操作后再插⼊⼀个LoadStore屏障。 </p></li></ul><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20210902155135199.png" alt="image-20210902155135199"></p><blockquote><p>LoadLoad 屏障：在第二个 Load 操作开始前，保证第一个 Load 的数据读取完</p><p>StoreStore 屏障：在第二个 Store 操作开始前，保证第一个 Store 的写入操作对其他处理器可见</p><p>LoadStore 屏障：在 Store 操作开始前，保证 Load 的数据读取完毕</p><p>StoreLoad 屏障：在 Load 操作开始前，保证 Store 的写入对所有处理器可见的（写后读最浪费时间）</p></blockquote><h4 id="synchronized-和-volatile-的区别"><a href="#synchronized-和-volatile-的区别" class="headerlink" title="==synchronized 和 volatile 的区别=="></a>==synchronized 和 volatile 的区别==</h4><ul><li>volatile 是线程同步的轻量级实现，性能比 synchronized 稍好。volatile 只能用于变量，synchronized 关键字可以修饰方法或代码块</li><li>volatile 可以保证数据的可见性，但不能保证原子性，synchronized 两者都能保证</li><li>volatile 主要解决变量在多个线程之间的可见性，synchronized 解决的是多个线程之间访问资源的同步性</li></ul><h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h3><p>通常，我们创建的变量可以被任意线程修改，如果香实现每个线程又自己的专属本地变量怎么解决呢？ThreadLocal 类主要解决的就是让每个线程绑定自己的值。</p><p>如果你创建了一个 Thread Local 变量，那么访问这个变量的每个线程都会有这个变量的本地副本，这也是 ThreadLocal 变量名的由来，可以使用 get() 和 set() 方法来获取默认值或将其值改为当前线程所存的副本的值，从而避免了线程安全问题。</p><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalExample</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// SimpleDateFormat 不是线程安全的，所以每个线程都要有自己独立的副本</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;SimpleDateFormat&gt; formatter = ThreadLocal.withInitial(() -&gt; <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyyMMdd HHmm"</span>));</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ThreadLocalExample obj = <span class="keyword">new</span> ThreadLocalExample();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span> ; i&lt;<span class="number">5</span>; i++)&#123;</span><br><span class="line">            Thread t = <span class="keyword">new</span> Thread(obj, <span class="string">""</span>+i);</span><br><span class="line">            Thread.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">1000</span>));</span><br><span class="line">            t.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Thread Name= "</span>+Thread.currentThread().getName()+<span class="string">" default Formatter = "</span>+formatter.get().toPattern());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">1000</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//formatter pattern is changed here by thread, but it won't reflect to other threads</span></span><br><span class="line">        formatter.set(<span class="keyword">new</span> SimpleDateFormat());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"Thread Name= "</span>+Thread.currentThread().getName()+<span class="string">" formatter = "</span>+formatter.get().toPattern());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输出</span><br><span class="line">Thread Name&#x3D; 0 default Formatter &#x3D; yyyyMMdd HHmm</span><br><span class="line">Thread Name&#x3D; 0 formatter &#x3D; yy-M-d ah:mm</span><br><span class="line">Thread Name&#x3D; 1 default Formatter &#x3D; yyyyMMdd HHmm</span><br><span class="line">Thread Name&#x3D; 1 formatter &#x3D; yy-M-d ah:mm</span><br><span class="line">Thread Name&#x3D; 2 default Formatter &#x3D; yyyyMMdd HHmm</span><br><span class="line">Thread Name&#x3D; 2 formatter &#x3D; yy-M-d ah:mm</span><br><span class="line">Thread Name&#x3D; 3 default Formatter &#x3D; yyyyMMdd HHmm</span><br><span class="line">Thread Name&#x3D; 3 formatter &#x3D; yy-M-d ah:mm</span><br><span class="line">Thread Name&#x3D; 4 default Formatter &#x3D; yyyyMMdd HHmm</span><br><span class="line">Thread Name&#x3D; 4 formatter &#x3D; yy-M-d ah:mm</span><br></pre></td></tr></table></figure><p>从输出中可以看出，Thread-0 已经改变了 formatter 的值，但仍然是 thread-2 默认格式化程序与初始化值相同，其他线程也一样。</p><h4 id="ThreadLocal-原理"><a href="#ThreadLocal-原理" class="headerlink" title="==ThreadLocal 原理=="></a>==ThreadLocal 原理==</h4><p>我们先看 Thread 类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">     <span class="comment">/* ThreadLocal values pertaining to this thread. This map is maintained</span></span><br><span class="line"><span class="comment">     * by the ThreadLocal class. */</span></span><br><span class="line">    ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * InheritableThreadLocal values pertaining to this thread. This map is</span></span><br><span class="line"><span class="comment">     * maintained by the InheritableThreadLocal class.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ThreadLocal.ThreadLocalMap inheritableThreadLocals = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出 ThreadLocal 副本值存储在线程的 ThreadLocal.ThradLocalMap 中，继续看 ThreadLocalMap </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalMap</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * The entries in this hash map extend WeakReference, using</span></span><br><span class="line"><span class="comment">         * its main ref field as the key (which is always a</span></span><br><span class="line"><span class="comment">         * ThreadLocal object).  Note that null keys (i.e. entry.get()</span></span><br><span class="line"><span class="comment">         * == null) mean that the key is no longer referenced, so the</span></span><br><span class="line"><span class="comment">         * entry can be expunged from table.  Such entries are referred to</span></span><br><span class="line"><span class="comment">         * as "stale entries" in the code that follows.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">        <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">        Object value;</span><br><span class="line"></span><br><span class="line">        Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">            <span class="keyword">super</span>(k);</span><br><span class="line">            value = v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ThreadLocal 的 Entry 键值对，key 是 ThradLocal 对象，value 为 Object 对象。</p><p>再看 ThreadLocal 类中的 get() 和 set() 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 ThreadLocal get() 和 set() 方法都是首先通过 Thread.currentThread() 来获取当前对象 t，进而获取线程的 ThreadLocalMap 对象 t.threadlocals，类似hashmap 操作, get(this) 或者 put(this, value)。</p><p>总结：副本值存在每个线程的 ThreadLocalMap 对象中，ThreadLocalMap 存储的键值对，key 为 ThreadLocal 对象，value 为 Object 对象</p><h4 id="ThreadLocal-内存泄漏"><a href="#ThreadLocal-内存泄漏" class="headerlink" title="ThreadLocal 内存泄漏"></a>ThreadLocal 内存泄漏</h4><p>ThreadLocalMap 中使用的 key 为 ThreadLocal 的弱引用，而 value 是强引用。如果 ThreadLocal 没有被外部强引用的情况下，在垃圾回收时，key 会被清除掉，而 value 不会知恶扬就会出现 key 为 null 的 Entry。我们不做任何措施的话，value 永远不会被 GC 回收，这样就会产生内存泄漏。</p><p>ThreadLocalMap 实现中已经考虑了这种情况，在调用 <code>set()</code>、<code>get()</code>、<code>remove()</code> 方法的时候，会清理掉 key 为 null 的记录。使用完 <code>ThreadLocal</code>方法后 最好手动调用<code>remove()</code>方法，手动删除每个线程的 ThreadLocalMap</p><blockquote><p>如果一个对象只具有弱引用，那就类似于<strong>可有可无的生活用品</strong>。弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它 所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。</p><p>弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java 虚拟机就会把这个弱引用加入到与之关联的引用队列中。</p></blockquote><h3 id="Atomic-原子类"><a href="#Atomic-原子类" class="headerlink" title="Atomic 原子类"></a>Atomic 原子类</h3><p>Atomic 指一个操作是不可中断的。即使是多个线程一起执行时，一个操作一旦开始，就不会被其他线程干扰。简单来说，原子类就是具有原子/原子操作特征的类。</p><p>java.util.concurrent 的原子类都存放在 java.util.concurrent.atomic 下</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20210831141012291.png" alt="image-20210831141012291"></p><h4 id="JUC-包原子类是哪-4-类？"><a href="#JUC-包原子类是哪-4-类？" class="headerlink" title="JUC 包原子类是哪 4 类？"></a>JUC 包原子类是哪 4 类？</h4><ol><li><p>基本类型，使用原子方式更新基本类型。AtomicInteger、AtomicLong、AtomicBoolean</p></li><li><p>数组类型，使用原子的方式更新数组里的某个元素。AtomicIntegerArray、AtomicLongArray、AtomicReferenceArray</p></li><li><p>引用类型</p><ul><li>AtomicReference：引用类型原子类</li><li>AtomicStampedReference：原子更新带有版本号的引用类型。该类将整数值与引用关联起来，可用于解决原子的更新数据和数据的版本号，可以解决使用 CAS 进行原子更新是可能出现的 ABA 问题</li><li>AtomicMarkableReference：原子更新带有标记位的引用类型</li></ul></li><li><p>对象的属性修改器</p><ul><li>AtomicIntegerFieldUpdater：原子更新整形字段的更新器</li><li>AtomicLongFieldUpdater：原子更新长整型的更新器</li><li>AtomicReferenceFieldUpdator：原子更新引用类型字段的更新器</li></ul></li></ol><h4 id="AtomicInteger-的使用"><a href="#AtomicInteger-的使用" class="headerlink" title="AtomicInteger 的使用"></a>AtomicInteger 的使用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> <span class="comment">//获取当前的值</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndSet</span><span class="params">(<span class="keyword">int</span> newValue)</span><span class="comment">//获取当前的值，并设置新的值</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndIncrement</span><span class="params">()</span><span class="comment">//获取当前的值，并自增</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndDecrement</span><span class="params">()</span> <span class="comment">//获取当前的值，并自减</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAdd</span><span class="params">(<span class="keyword">int</span> delta)</span> <span class="comment">//获取当前的值，并加上预期的值</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> <span class="comment">//如果输入的数值等于预期值，则以原子方式将该值设置为输入值（update）</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lazySet</span><span class="params">(<span class="keyword">int</span> newValue)</span><span class="comment">//最终设置为newValue,使用 lazySet 设置之后可能导致其他线程在之后的一小段时间内还是可以读到旧的值。</span></span></span><br></pre></td></tr></table></figure><p>使用 AtomicInteger 后不对方法加锁也是线程安全的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class AtomicIntegerTest &#123;</span><br><span class="line">    private AtomicInteger count &#x3D; new AtomicInteger();</span><br><span class="line">    &#x2F;&#x2F;使用AtomicInteger之后，不需要对该方法加锁，也可以实现线程安全。</span><br><span class="line">    public void increment() &#123;</span><br><span class="line">        count.incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getCount() &#123;</span><br><span class="line">        return count.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="AtomicInteger-类的原理"><a href="#AtomicInteger-类的原理" class="headerlink" title="==AtomicInteger 类的原理=="></a>==AtomicInteger 类的原理==</h4><p>AtomicInteger 部分源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// setup to use Unsafe.compareAndSwapInt for updates（更新操作时提供“比较并替换”的作用）</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> valueOffset;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        valueOffset = unsafe.objectFieldOffset</span><br><span class="line">            (AtomicInteger.class.getDeclaredField("value"));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> Error(ex); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, valueOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AtomicInteger 主要利用 CAS + volatile 和 native 方法来保证原子操作，避免 synchronized 的高开销。这里的 valueOffset 就是 value 在内存中的地址，直接调用 native 方法 compareAndSwapInt 实现 CAS 操作。</p><blockquote><p>CAS的全称为<code>Compare And Swap</code>，直译就是比较交换。是一条CPU的原子指令，其作用是让<code>CPU</code>先进行比较两个值是否相等，然后原子地更新某个位置的值，其实现方式是给予硬件平台的汇编指令，在<code>intel</code>的<code>CPU</code>中，使用的<code>cmpxchg</code>指令，就是说<code>CAS</code>是靠硬件实现的，从而在硬件层面提升效率。</p></blockquote><h4 id="CAS存在的问题"><a href="#CAS存在的问题" class="headerlink" title="CAS存在的问题"></a>CAS存在的问题</h4><ol><li><strong>ABA 问题</strong><br>所谓ABA问题，就是⼀个值原来是A，变成了B，⼜变回了A。这个时候使⽤CAS是 检查不出变化的，但实际上却被更新了两次。部分乐观锁的实现是通过==<strong>版本号</strong>==（version）的方式来解决ABA问题，<strong>乐观锁每次在执行数据的修改操作时，都会带上一个版本号，一旦版本号和数据的版本号一致就可以执行修改操作并对版本号执行+1操作，否则就执行失败</strong>。因为每次操作的版本号都会随之增加，所以不会出现ABA问题，因为版本号只会增加不会减少。JDK的atomic包⾥提供了⼀个类 AtomicStampedReference 类来解决ABA问题。</li><li><strong>循环时间长开销大</strong>。CAS操作如果长时间不成功，会导致其一直自旋，给CPU带来非常大的开销。</li><li><strong>只能保证一个共享变量的原子操作</strong>。对一个共享变量执行操作时，CAS能够保证原子操作，但是对多个共享变量操作时，CAS是无法保证操作的原子性的。</li></ol><h3 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h3><h4 id="原理概览"><a href="#原理概览" class="headerlink" title="原理概览"></a>原理概览</h4><p>*<em>AbstractQueuedSynchronizer *</em> 这个类在 java.util.concurrent.locks 包下面</p><p><strong>AQS 核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制 AQS 是用 CLH 队列锁实现的，即将暂时获取不到锁的线程加入到队列中。</strong></p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20210831162636969.png" alt="image-20210831162636969"></p><p>AQS 使用一个 int 成员变量来表示同步状态，通过内置的 FIFO 队列来完成获取资源线程的排队工作。AQS 使用 CAS 对该同步状态进行原子操作实现对其值的修改。</p><h4 id="AQS-结构"><a href="#AQS-结构" class="headerlink" title="AQS 结构"></a>AQS 结构</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 头结点，你直接把它当做 当前持有锁的线程 可能是最好理解的</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node head;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 阻塞的尾节点，每个新的节点进来，都插入到最后，也就形成了一个链表</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个是最重要的，代表当前锁的状态，0代表没有被占用，大于 0 代表有线程持有当前锁</span></span><br><span class="line"><span class="comment">// 这个值可以大于 1，是因为锁可以重入，每次重入都加上 1</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代表当前持有独占锁的线程，举个最重要的使用例子，因为锁可以重入</span></span><br><span class="line"><span class="comment">// reentrantLock.lock()可以嵌套调用多次，所以每次用这个来判断当前线程是否已经拥有了锁</span></span><br><span class="line"><span class="comment">// if (currentThread == getExclusiveOwnerThread()) &#123;state++&#125;</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Thread exclusiveOwnerThread; <span class="comment">//继承自AbstractOwnableSynchronizer</span></span><br></pre></td></tr></table></figure><p>状态信息通过 protected 类型的 getState，setState，compareAndSetState 进行操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回同步状态的当前值</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> state;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//设置同步状态的值</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(<span class="keyword">int</span> newState)</span> </span>&#123;</span><br><span class="line">    state = newState;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//原子地（CAS操作）将同步状态值设置为给定值update如果当前同步状态的值等于expect（期望值）</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSetState</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="AQS-对资源的共享方式"><a href="#AQS-对资源的共享方式" class="headerlink" title="AQS 对资源的共享方式"></a>AQS 对资源的共享方式</h4><ul><li><strong>Exclusive</strong>（独占）：只有一个线程执行，如 ReentrantLock，又可分为公平锁和非公平锁</li><li><strong>Share</strong>（共享）：多个线程可同时执行，如CountDownLatch，Semaphore、CyclicBarrier、ReadWriteLock</li></ul><p><code>ReentrantReadWriteLock</code> 可以看成是组合式，因为 <code>ReentrantReadWriteLock</code> 也就是读写锁允许多个线程同时对某一资源进行读。</p><p>AQS中关于这两种资源共享模式的定义源码（均在内部类Node中）。我们来看看Node的结构：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 标记⼀个结点（对应的线程）在共享模式下等待</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Node SHARED = <span class="keyword">new</span> Node();</span><br><span class="line">    <span class="comment">// 标记⼀个结点（对应的线程）在独占模式下等待</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Node EXCLUSIVE = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// waitStatus的值，表示该结点（对应的线程）已被取消</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED =  <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// waitStatus的值，表示后继结点（对应的线程）需要被唤醒</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIGNAL    = -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// waitStatus的值，表示该结点（对应的线程）在等待某⼀条件</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONDITION = -<span class="number">2</span>;</span><br><span class="line">    <span class="comment">/*waitStatus的值，表示有资源可⽤，新head结点需要继续唤醒后继结点*/</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PROPAGATE = -<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待状态，取值范围，-3，-2，-1，0，1</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus;</span><br><span class="line">    <span class="keyword">volatile</span> Node prev; <span class="comment">// 前驱结点</span></span><br><span class="line">    <span class="keyword">volatile</span> Node next; <span class="comment">// 后继结点</span></span><br><span class="line">    <span class="keyword">volatile</span> Thread thread; <span class="comment">// 结点对应的线程</span></span><br><span class="line">    Node nextWaiter; <span class="comment">// 等待队列⾥下⼀个等待条件的结点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断共享模式的⽅法</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nextWaiter == SHARED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node(Thread thread, Node mode) &#123;     <span class="comment">// Used by addWaiter</span></span><br><span class="line">        <span class="keyword">this</span>.nextWaiter = mode;</span><br><span class="line">        <span class="keyword">this</span>.thread = thread;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node(Thread thread, <span class="keyword">int</span> waitStatus) &#123; <span class="comment">// Used by Condition</span></span><br><span class="line">        <span class="keyword">this</span>.waitStatus = waitStatus;</span><br><span class="line">        <span class="keyword">this</span>.thread = thread;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="AQS-底层使用了模板方法模式"><a href="#AQS-底层使用了模板方法模式" class="headerlink" title="AQS 底层使用了模板方法模式"></a>AQS 底层使用了模板方法模式</h4><p>同步器的设计是基于模板方法模式的，如果需要自定义同步器一般步骤有：</p><ol><li><p>使用者继承 <code>AbstractQueuedSynchronizer</code> 并重写指定的方法</p></li><li><p>将 AQS 组合在自定义同步组件的实现中，并调用其模板方法，而这些模板方法会调用使用者重写的方法。</p></li></ol><p>自定义同步器时需要重写下面几个 AQS 提供的模板方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">isHeldExclusively()<span class="comment">//该线程是否正在独占资源。只有用到condition才需要去实现它。</span></span><br><span class="line">tryAcquire(<span class="keyword">int</span>)<span class="comment">//独占方式。尝试获取资源，成功则返回true，失败则返回false。</span></span><br><span class="line">tryRelease(<span class="keyword">int</span>)<span class="comment">//独占方式。尝试释放资源，成功则返回true，失败则返回false。</span></span><br><span class="line">tryAcquireShared(<span class="keyword">int</span>)<span class="comment">//共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</span></span><br><span class="line">tryReleaseShared(<span class="keyword">int</span>)<span class="comment">//共享方式。尝试释放资源，成功则返回true，失败则返回false。</span></span><br></pre></td></tr></table></figure><p>一般来说，自定义同步器要么是独占方法，要么是共享方式，他们也只需实现<code>tryAcquire-tryRelease</code>、<code>tryAcquireShared-tryReleaseShared</code>中的一种即可。但 AQS 也支持自定义同步器同时实现独占和共享两种方式，如<code>ReentrantReadWriteLock</code>。</p><h4 id="获取资源"><a href="#获取资源" class="headerlink" title="获取资源"></a>获取资源</h4><p>⾸先调⽤tryAcquire(arg)尝试去获取资源，这个⽅法是在<strong>⼦类</strong>具体实现的。如果成功 AQS 的 waitStauts 值变化args, exclusiveOwnerThread 值为当前线程；如果获取资源失败，就通过addWaiter(Node.EXCLUSIVE)⽅法把这个线程插⼊到等待队列中。其中传⼊的参数代表要插⼊的Node是独占式的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp; <span class="comment">// 尝试独占获取锁</span></span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg) <span class="comment">//获锁失败，将当前线程挂起并放入阻塞队列中</span></span><br><span class="line">       )</span><br><span class="line">        selfInterrupt();<span class="comment">//线程中断</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来看 addWaiter 方法，将一个独占模式节点放进队列末尾</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">    <span class="comment">//尝试把 node 加入到链表最后</span></span><br><span class="line">    Node pred = tail;</span><br><span class="line">    <span class="comment">//阻塞队列不为空时</span></span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="comment">// 用CAS把自己设置为队尾, 如果成功后，tail == node 了，这个节点成为阻塞队列新的尾巴</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            <span class="comment">//设置成功，将自己与之前的队尾相连</span></span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="comment">// 线程入队了，可以返回了</span></span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 到这里说明 pred==null(队列是空的) 或者 CAS失败(有线程在竞争入队)</span></span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node t = tail;</span><br><span class="line">        <span class="comment">//队列为空，初始时 head 和 tail 都是 null</span></span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// Must initialize</span></span><br><span class="line">            <span class="comment">//可能有多个进程同时设置 head，需要 CAS设置head</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                tail = head; <span class="comment">//设置 tail，马上 t 就不是 null 了，许多线程要抢了。</span></span><br><span class="line">            <span class="comment">//注意这里没有返回，下一次循环就要 else 分支了</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//将当前节点加入到队尾，如果 CAS 抢不到就自旋，一直抢，直到成功加入队尾</span></span><br><span class="line">            node.prev = t;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来回到 acquireQueued 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 下面这个方法，参数node，经过addWaiter(Node.EXCLUSIVE)，此时已经进入阻塞队列</span></span><br><span class="line">    <span class="comment">// 注意一下：如果acquireQueued(addWaiter(Node.EXCLUSIVE), arg))返回true的话，</span></span><br><span class="line">    <span class="comment">// 意味着上面这段代码将进入selfInterrupt()，所以正常情况下，下面应该返回false</span></span><br><span class="line">    <span class="comment">// 这个方法非常重要，应该说真正的线程挂起，然后被唤醒后去获取锁，都在这个方法里了</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// 当前节点的前驱节点为 p</span></span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="comment">// p == head 代表当前节点是阻塞队列第一个，可以尝试抢一下锁</span></span><br><span class="line">            <span class="comment">// 这里我们说一下，为什么可以去试试：</span></span><br><span class="line">            <span class="comment">// 首先，它是队头，这个是第一个条件，其次，当前的head有可能是刚刚初始化的node，</span></span><br><span class="line">            <span class="comment">// enq(node) 方法里面有提到，head是延时初始化的，而且new Node()的时候没有设置任何线程</span></span><br><span class="line">            <span class="comment">// 也就是说，当前的head不属于任何一个线程，所以作为队头，可以去试一试，</span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                <span class="comment">//当前节点成为 head</span></span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 到这里，说明上面的if分支没有成功，要么当前node本来就不是队头，</span></span><br><span class="line">            <span class="comment">// 要么就是tryAcquire(arg)没有抢赢别人，继续往下看</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//failed 为 true 代表 tryAcquire 抛异常了</span></span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 刚刚说过，会到这里就是没有抢到锁呗，这个方法说的是："当前线程没有抢到锁，是否需要挂起当前线程？"</span></span><br><span class="line">        <span class="comment">// 第一个参数是前驱节点，第二个参数才是代表当前线程的节点</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ws = pred.waitStatus;</span><br><span class="line">        <span class="comment">//前驱节点 waitStatus == - 1，说明前驱节点状态正常，当前线程需要挂起，直接可以返回true</span></span><br><span class="line">        <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 前驱节点 waitStatus大于0 ，之前说过，大于0 说明前驱节点取消了排队。</span></span><br><span class="line">            <span class="comment">// 这里需要知道这点：进入阻塞队列排队的线程会被挂起，而唤醒的操作是由前驱节点完成的。</span></span><br><span class="line">            <span class="comment">// 所以下面这块代码说的是将当前节点的prev指向waitStatus&lt;=0的节点，</span></span><br><span class="line">            <span class="comment">// 简单说，就是为了找个好爹，因为你还得依赖它来唤醒呢，如果前驱节点取消了排队，</span></span><br><span class="line">            <span class="comment">// 找前驱节点的前驱节点做爹，往前遍历总能找到一个好爹的</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                node.prev = pred = pred.prev;</span><br><span class="line">            &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">            pred.next = node;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 仔细想想，如果进入到这个分支意味着什么</span></span><br><span class="line">            <span class="comment">// 前驱节点的waitStatus不等于-1和1，那也就是只可能是0，-2，-3</span></span><br><span class="line">            <span class="comment">// 在我们前面的源码中，都没有看到有设置waitStatus的，所以每个新的node入队时，waitStatu都是0</span></span><br><span class="line">            <span class="comment">// 正常情况下，前驱节点是之前的 tail，那么它的 waitStatus 应该是 0</span></span><br><span class="line">            <span class="comment">// 用CAS将前驱节点的waitStatus设置为Node.SIGNAL(也就是-1)</span></span><br><span class="line">            compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果这个方法返回 false，那么会在 acquireQueued 方法中的 for 循环再走一遍，这次队尾元素前驱节点 waitStatus 一定为 -1，然后会从第一个分支返回 true</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//阻塞当前线程</span></span><br><span class="line">        LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20210902203746074.png" alt="image-20210902203746074"></p><h4 id="释放资源"><a href="#释放资源" class="headerlink" title="释放资源"></a>释放资源</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="comment">//到这里代表锁已经释放了，接下来如果有后继节点则唤醒后继节点，h.waitStatus &lt; 0 代表有等待的后继节点</span></span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//唤醒一个后面正在等待的节点</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">    <span class="comment">// 如果head节点当前waitStatus&lt;0, 将其修改为0</span></span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    Node s = node.next;</span><br><span class="line">    <span class="comment">//如果阻塞队列第一个节点为空或者该节点取消等待，就队列后面往前找一个正在等待的节点（waitStatus &lt;= 0）</span></span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        s = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//唤醒节点</span></span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h4><p>ReentrantLock 可实现公平锁和非公平锁，默认为非公平锁，除非在构造函数中传入参数 true。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 默认非公平锁</span></span><br><span class="line">    sync = <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Reentrant Lock 是独占锁，需要实现 tryAcquire 方法和 tryRelease 方法。首先看 FairSync 和 NonFariSync 的基类 Sync，它提供了基本实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line"><span class="comment">//子类需要实现 lock 方法</span></span><br><span class="line">       <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//非公平抢锁</span></span><br><span class="line">       <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">           <span class="keyword">int</span> c = getState();</span><br><span class="line">           <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">               <span class="comment">//非公平抢锁，直接开抢，</span></span><br><span class="line">               <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                   setExclusiveOwnerThread(current);</span><br><span class="line">                   <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">               <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">               <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">                   <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">               setState(nextc);</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line"><span class="comment">//释放锁，非公平锁和公平锁都是通过 AQS 的 release调用此方法</span></span><br><span class="line">       <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">           <span class="comment">//当前进程没有占有锁</span></span><br><span class="line">           <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">           <span class="comment">//是否完全释放锁</span></span><br><span class="line">           <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">           <span class="comment">//完全释放锁之后将占有锁的进程设为空</span></span><br><span class="line">           <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">               free = <span class="keyword">true</span>;</span><br><span class="line">               setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           setState(c);</span><br><span class="line">           <span class="keyword">return</span> free;</span><br><span class="line">       &#125;</span><br><span class="line"><span class="comment">//当前线程是否独占锁</span></span><br><span class="line">       <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> getExclusiveOwnerThread() == Thread.currentThread();</span><br><span class="line">       &#125;</span><br><span class="line"><span class="comment">//省略其他方法</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>接下来看 NonFairSync</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//和公平锁相比，这里会直接先进行一次CAS，成功就返回了</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//直接调用父类方法</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再看 FairSync</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="comment">// state == 0 此时此刻没有线程持有锁</span></span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//虽然锁此时可用，但这是公平锁，先看看有没有别人在队列中等待</span></span><br><span class="line">            <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                <span class="comment">//没有其他线程在队列中，就用 CAS 尝试获取锁，如果不成功，锁就是被别人抢了（刚才还没有线程持有锁）</span></span><br><span class="line">                compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                <span class="comment">//标记获取到锁的线程是当前线程</span></span><br><span class="line">                setExclusiveOwnerThread(current);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果当前线程已经获得了锁，代表重入了，这里没有并发问题（自己已经有锁了，想怎么改 state 就怎么改）</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">            <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">            <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">            setState(nextc);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//尝试获锁失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：公平锁和非公平锁只有两处不同：</p><ol><li>非公平锁在调用 lock 后，首先就会调用 CAS 进行一次抢锁，如果这个时候恰巧锁没有被占用，那么直接就获取到锁返回了。</li><li>非公平锁在 CAS 失败后，和公平锁一样都会进入到 tryAcquire 方法，在 tryAcquire 方法中，如果发现锁这个时候被释放了（state == 0），非公平锁会直接 CAS 抢锁，但是公平锁会判断等待队列是否有线程处于等待状态，如果有则不去抢锁，乖乖排到后面。</li></ol><h4 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h4><p>condition 是依赖于 ReentrantLock 的，不管是调用 await 进入等待还是 signal 唤醒，<strong>都必须获取到锁才能进行操作</strong>。每个 ReentrantLock 实例可以通过调用多次 newCondition 方法产生多个 ConditionObject 实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> ConditionObject <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 实例化一个 ConditionObject</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ConditionObject();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们首先来看下我们关注的 Condition 的实现类 <code>AbstractQueuedSynchronizer</code> 类中的 <code>ConditionObject</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConditionObject</span> <span class="keyword">implements</span> <span class="title">Condition</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 条件队列的第一个节点</span></span><br><span class="line">          <span class="comment">// 不要管这里的关键字 transient，是不参与序列化的意思</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">transient</span> Node firstWaiter;</span><br><span class="line">        <span class="comment">// 条件队列的最后一个节点</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">transient</span> Node lastWaiter;</span><br><span class="line">        ......</span><br></pre></td></tr></table></figure><p>在介绍 AQS 的时候，我们有一个<strong>阻塞队列</strong>，用于保存等待获取锁的线程的队列，这里引用一个新概念，叫条件队列，如下图：</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20210904194159096.png" alt="image-20210904194159096"></p><p>前面 Node 结构中 prev 和 next 域用于实现阻塞队列的双向链表，nextWaiter 用于实现条件队列的单向链表。</p><ul><li>条件队列和阻塞队列的节点都是 Node 节点，因为条件队列的节点是需要转移到阻塞队列中的。</li><li>每个 ReentrantLock 实例可以调用 newCondition 方法来生成多个 Condition 实例，这里对应 condition1 和 condition2，注意 ConditionObject 只有两个属性 firstWaiter 和 lastWaiter。</li><li>每个 condition 有一个关联的<strong>条件队列</strong>，如线程 1 调用 <code>condition1.await()</code> 方法即可将当前线程 1 包装成 Node 后加入到条件队列中，然后阻塞在这里，不继续往下执行，条件队列是一个单向链表；</li><li>调用<code>condition1.signal()</code> 触发一次唤醒，此时唤醒的是队头，会将condition1 对应的<strong>条件队列</strong>的 firstWaiter（队头） 移到<strong>阻塞队列的队尾</strong>，等待获取锁，获取锁后 await 方法才能返回，继续往下执行。</li></ul><p>我们先来看 await 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首先，这个方法是可被中断的，不可被中断的是另一个方法 awaitUninterruptibly()</span></span><br><span class="line"><span class="comment">// 这个方法会阻塞，直到调用 signal 方法（指 signal() 和 signalAll()，下同），或被中断</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">//既然方法要响应中断，那么在最开始就判断中断状态</span></span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="comment">//添加到 condition 的条件队列中</span></span><br><span class="line">    Node node = addConditionWaiter();</span><br><span class="line">    <span class="comment">// 释放锁，返回值是释放锁之前的 state 值</span></span><br><span class="line">    <span class="comment">// await() 之前，当前线程是必须持有锁的，这里肯定要释放掉</span></span><br><span class="line">    <span class="keyword">int</span> savedState = fullyRelease(node);</span><br><span class="line">    <span class="keyword">int</span> interruptMode = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 这里退出循环有两种情况，之后再仔细分析</span></span><br><span class="line">    <span class="comment">// 1. isOnSyncQueue(node) 返回 true，即当前 node 已经转移到阻塞队列了</span></span><br><span class="line">    <span class="comment">// 2. checkInterruptWhileWaiting(node) != 0 会到 break，然后退出循环，代表的是线程中断</span></span><br><span class="line">    <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">        <span class="comment">//线程挂起</span></span><br><span class="line">        LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 被唤醒后，将进入阻塞队列，等待获取锁</span></span><br><span class="line">    <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">        interruptMode = REINTERRUPT;</span><br><span class="line">    <span class="keyword">if</span> (node.nextWaiter != <span class="keyword">null</span>) <span class="comment">// clean up if cancelled</span></span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">    <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">        reportInterruptAfterWait(interruptMode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="将节点加入条件队列"><a href="#将节点加入条件队列" class="headerlink" title="将节点加入条件队列"></a>将节点加入条件队列</h5><p>由于调用  await 和 singnal 方法需要手动先获取独占锁，没有锁的线程无法操作条件队列，所以在条件队列里的操作是线程安全的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将当前线程对应的节点入队，插入队尾</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addConditionWaiter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node t = lastWaiter;</span><br><span class="line">    <span class="comment">// 如果条件队列的最后一个节点取消了，将其清除出去</span></span><br><span class="line">    <span class="comment">// 为什么这里把 waitStatus 不等于 Node.CONDITION，就判定为该节点发生了取消排队？</span></span><br><span class="line">    <span class="keyword">if</span> (t != <span class="keyword">null</span> &amp;&amp; t.waitStatus != Node.CONDITION) &#123;</span><br><span class="line">        <span class="comment">// 这个方法会遍历整个条件队列，然后会将已取消的所有节点清除出队列</span></span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">        t = lastWaiter;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// node 在初始化的时候，指定 waitStatus 为 Node.CONDITION</span></span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), Node.CONDITION);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// t 此时是 lastWaiter，队尾</span></span><br><span class="line">    <span class="comment">// 如果队列为空</span></span><br><span class="line">    <span class="keyword">if</span> (t == <span class="keyword">null</span>)</span><br><span class="line">        firstWaiter = node;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        t.nextWaiter = node;</span><br><span class="line">    lastWaiter = node;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这段代码就是将当前线程 Node 插入到条件队列的队尾。 unlinkCancelledWaiters() 方法用于清除队列中已经取消等待的节点。当 await 的时候如果发生了取消操作（这点之后会说），或者是在节点入队的时候，发现最后一个节点是被取消的，会调用一次这个方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 等待队列是一个单向链表，遍历链表将已经取消等待的节点清除出去</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unlinkCancelledWaiters</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 等待队列是一个单向链表，遍历链表将已经取消等待的节点清除出去</span></span><br><span class="line">    Node t = firstWaiter;</span><br><span class="line">    Node trail = <span class="keyword">null</span>; <span class="comment">// trail 指向为 CONDITION 状态的最后一个节点</span></span><br><span class="line">    <span class="keyword">while</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Node next = t.nextWaiter;</span><br><span class="line">        <span class="comment">// 如果节点的状态不是 Node.CONDITION 的话，这个节点就是被取消的</span></span><br><span class="line">        <span class="keyword">if</span> (t.waitStatus != Node.CONDITION) &#123;</span><br><span class="line">            <span class="comment">//把节点 t 从链表上拿下来</span></span><br><span class="line">            t.nextWaiter = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//目前没有 CONDITION 状态的节点，直接将链表头设置为 next</span></span><br><span class="line">            <span class="keyword">if</span> (trail == <span class="keyword">null</span>)</span><br><span class="line">                firstWaiter = next;</span><br><span class="line">            <span class="keyword">else</span><span class="comment">//否则将 t.next 连到 trail 后面</span></span><br><span class="line">                trail.nextWaiter = next;</span><br><span class="line">            <span class="keyword">if</span> (next == <span class="keyword">null</span>)</span><br><span class="line">                lastWaiter = trail;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span><span class="comment">//当前节点状态是 CONDITION，维护 trail，t 后移</span></span><br><span class="line">            trail = t;</span><br><span class="line">        t = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="完全释放独占锁"><a href="#完全释放独占锁" class="headerlink" title="完全释放独占锁"></a>完全释放独占锁</h5><p>在节点入队后，会执行<code>int savedState = fullyRelease(node)</code>这一行，完全释放独占锁，注意是完全释放，ReentrantLock 是可重入的。</p><blockquote><p>考虑一下这里的 savedState。如果在 condition1.await() 之前，假设线程先执行了 2 次 lock() 操作，那么 state 为 2，我们理解为该线程持有 2 把锁，这里 await() 方法必须将 state 设置为 0，然后再进入挂起状态，这样其他线程才能持有锁。当它被唤醒的时候，它需要重新持有 2 把锁，才能继续下去。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首先，我们要先观察到返回值 savedState 代表 release 之前的 state 值</span></span><br><span class="line"><span class="comment">// 对于最简单的操作：先 lock.lock()，然后 condition1.await()。</span></span><br><span class="line"><span class="comment">//         那么 state 经过这个方法由 1 变为 0，锁释放，此方法返回 1</span></span><br><span class="line"><span class="comment">//         相应的，如果 lock 重入了 n 次，savedState == n</span></span><br><span class="line"><span class="comment">// 如果这个方法失败，会将节点设置为"取消"状态，并抛出异常 IllegalMonitorStateException</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">fullyRelease</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> savedState = getState();</span><br><span class="line">        <span class="comment">// 这里使用了当前的 state 作为 release 的参数，也就是完全释放掉锁，将 state 置为 0</span></span><br><span class="line">        <span class="keyword">if</span> (release(savedState)) &#123;</span><br><span class="line">            failed = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">return</span> savedState;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed) <span class="comment">//释放独占锁失败，直接将节点设为 CANCELLED</span></span><br><span class="line">            node.waitStatus = Node.CANCELLED;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>如果一个线程不在持有独占锁的基础上，调用await 方法，它能进入条件队列（但此时条件队列就不是线程安全了，可能导致条件队列节点丢失，某些线程可能永远不能被唤醒），由于它不持有锁，release 方法肯定返回 false，进入异常分支，然后设置节点为 CANCELLED，这个入队的节点会被后面入队的节点清除。</p></blockquote><h5 id="等待进入阻塞队列"><a href="#等待进入阻塞队列" class="headerlink" title="等待进入阻塞队列"></a>等待进入阻塞队列</h5><p>释放掉锁以后，接下来是这段，这边会自旋，<strong>如果发现自己还没到阻塞队列，那么挂起</strong>，等待被转移到阻塞队列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> interruptMode = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 如果不在阻塞队列中，注意了，是阻塞队列</span></span><br><span class="line"><span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">    <span class="comment">// 线程挂起</span></span><br><span class="line">    LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里可以先不用看了，等看到它什么时候被 unpark 再说</span></span><br><span class="line">    <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>isOnSyncQueue(Node node) 用于判断节点是否已经转移到阻塞队列了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在节点入条件队列的时候，初始化时设置了 waitStatus = Node.CONDITION</span></span><br><span class="line"><span class="comment">// 前面我提到，signal 的时候需要将节点从条件队列移到阻塞队列，</span></span><br><span class="line"><span class="comment">// 这个方法就是判断 node 是否已经移动到阻塞队列了</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isOnSyncQueue</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移动过去的时候，node 的 waitStatus 会置为 0，这个之后在说 signal 方法的时候会说到</span></span><br><span class="line">    <span class="comment">// 如果 waitStatus 还是 Node.CONDITION，也就是 -2，那肯定就是还在条件队列中</span></span><br><span class="line">    <span class="comment">// 如果 node 的前驱 prev 指向还是 null，说明肯定没有在 阻塞队列(prev是阻塞队列链表中使用的)</span></span><br><span class="line">    <span class="keyword">if</span> (node.waitStatus == Node.CONDITION || node.prev == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 如果 node 已经有后继节点 next 的时候，那肯定是在阻塞队列了</span></span><br><span class="line">    <span class="keyword">if</span> (node.next != <span class="keyword">null</span>) </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面这个方法从阻塞队列的队尾开始从后往前遍历找，如果找到相等的，说明在阻塞队列，否则就是不在阻塞队列</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可以通过判断 node.prev() != null 来推断出 node 在阻塞队列吗？答案是：不能。</span></span><br><span class="line">    <span class="comment">// 这个可以看上篇 AQS 的入队方法，首先设置的是 node.prev 指向 tail，</span></span><br><span class="line">    <span class="comment">// 然后是 CAS 操作将自己设置为新的 tail，可是这次的 CAS 是可能失败的。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> findNodeFromTail(node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从阻塞队列的队尾往前遍历，如果找到，返回 true</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">findNodeFromTail</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    Node t = tail;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (t == node)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        t = t.prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回到前面的循环，isOnSyncQueue(node) 返回 false 的话，那么进到 <code>LockSupport.park(this);</code> 这里线程挂起。</p><h5 id="signal-唤醒线程，转移到阻塞队列"><a href="#signal-唤醒线程，转移到阻塞队列" class="headerlink" title="signal 唤醒线程，转移到阻塞队列"></a>signal 唤醒线程，转移到阻塞队列</h5><p>这里我们先看唤醒操作，因为刚刚到 <code>LockSupport.park(this);</code> 把线程挂起了，等待唤醒。</p><p>唤醒操作通常由另一个线程来操作，就像生产者-消费者模式中，如果线程因为等待消费而挂起，那么当生产者生产了一个东西后，会调用 signal 唤醒正在等待的线程来消费。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 唤醒等待了最久的线程</span></span><br><span class="line"><span class="comment">// 其实就是，将这个线程对应的 node 从条件队列转移到阻塞队列</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调用 signal 方法的线程必须持有当前的独占锁</span></span><br><span class="line">    <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    Node first = firstWaiter;</span><br><span class="line">    <span class="keyword">if</span> (first != <span class="keyword">null</span>)</span><br><span class="line">        doSignal(first);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从条件队列队头往后遍历，找出第一个需要转移的 node</span></span><br><span class="line"><span class="comment">// 因为前面我们说过，有些线程会取消排队，但是可能还在队列中</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSignal</span><span class="params">(Node first)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">          <span class="comment">// 将 firstWaiter 指向 first 节点后面的第一个，因为 first 节点马上要离开了</span></span><br><span class="line">        <span class="comment">// 如果将 first 移除后，后面没有节点在等待了，那么需要将 lastWaiter 置为 null</span></span><br><span class="line">        <span class="keyword">if</span> ( (firstWaiter = first.nextWaiter) == <span class="keyword">null</span>)</span><br><span class="line">            lastWaiter = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 因为 first 马上要被移到阻塞队列了，和条件队列的链接关系在这里断掉</span></span><br><span class="line">        first.nextWaiter = <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span> (!transferForSignal(first) &amp;&amp;</span><br><span class="line">             (first = firstWaiter) != <span class="keyword">null</span>);</span><br><span class="line">      <span class="comment">// 这里 while 循环，如果 first 转移不成功，那么选择 first 后面的第一个节点进行转移，依此类推</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将节点从条件队列转移到阻塞队列</span></span><br><span class="line"><span class="comment">// true 代表成功转移</span></span><br><span class="line"><span class="comment">// false 代表在 signal 之前，节点已经取消了</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">transferForSignal</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// CAS 如果失败，说明此 node 的 waitStatus 已不是 Node.CONDITION，说明节点已经取消，</span></span><br><span class="line">    <span class="comment">// 既然已经取消，也就不需要转移了，方法返回，转移后面一个节点</span></span><br><span class="line">    <span class="comment">// 否则，将 waitStatus 置为 0</span></span><br><span class="line">    <span class="keyword">if</span> (!compareAndSetWaitStatus(node, Node.CONDITION, <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// enq(node): 自旋进入阻塞队列的队尾</span></span><br><span class="line">    <span class="comment">// 注意，这里的返回值 p 是 node 在阻塞队列的前驱节点</span></span><br><span class="line">    Node p = enq(node);</span><br><span class="line">    <span class="keyword">int</span> ws = p.waitStatus;</span><br><span class="line">    <span class="comment">// ws &gt; 0 说明 node 在阻塞队列中的前驱节点取消了等待锁，直接唤醒 node 对应的线程。唤醒之后会怎么样，后面再解释</span></span><br><span class="line">    <span class="comment">// 如果 ws &lt;= 0, 那么 compareAndSetWaitStatus 将会被调用，上篇介绍的时候说过，节点入队后，需要把前驱节点的状态设为 Node.SIGNAL(-1)</span></span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span> || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))</span><br><span class="line">        <span class="comment">// 如果前驱节点取消或者 CAS 失败，会进到这里唤醒线程，之后的操作看下一节</span></span><br><span class="line">        LockSupport.unpark(node.thread);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正常情况下，<code>ws &gt; 0 || !compareAndSetWaitStatus(p, ws, Node.SIGNAL)</code> 这句中，ws &lt;= 0，而且 <code>compareAndSetWaitStatus(p, ws, Node.SIGNAL)</code> 会返回 true，所以一般也不会进去 if 语句块中唤醒 node 对应的线程。然后这个方法返回 true，也就意味着 signal 方法结束了，节点进入了阻塞队列。</p><p>假设发生了阻塞队列中的前驱节点取消等待，或者 CAS 失败，只要唤醒线程，让其进到下一步即可。</p><h5 id="唤醒后检查中断"><a href="#唤醒后检查中断" class="headerlink" title="唤醒后检查中断"></a>唤醒后检查中断</h5><p>上一步 signal 之后，我们的线程由条件队列转移到了阻塞队列，之后就准备获取锁了。只要重新获取到锁了以后，继续往下执行。</p><p>等线程从挂起中恢复过来，继续往下看</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> interruptMode = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">    <span class="comment">// 线程挂起</span></span><br><span class="line">    LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先解释下 interruptMode。interruptMode 可以取值为 REINTERRUPT（1），THROW_IE（-1），0</p><ul><li>REINTERRUPT： 代表 await 返回的时候，需要重新设置中断状态</li><li>THROW_IE： 代表 await 返回的时候，需要抛出 InterruptedException 异常</li><li>0 ：说明在 await 期间，没有发生中断</li></ul><p>有以下三种情况会让 LockSupport.park(this); 这句返回继续往下执行：</p><ol><li>常规路径。signal -&gt; 转移节点到阻塞队列 -&gt; 获取了锁（unpark）</li><li>线程中断。在 park 的时候，另外一个线程对这个线程进行了中断</li><li>signal 的时候我们说过，转移以后的前驱节点取消了，或者对前驱节点的CAS操作失败了</li><li>假唤醒。这个也是存在的，和 Object.wait() 类似，都有这个问题</li></ol><p>线程唤醒后第一步是调用 checkInterruptWhileWaiting(node) 这个方法，此方法用于判断是否在线程挂起期间发生了中断，如果发生了中断，是 signal 调用之前中断的，还是 signal 之后发生的中断。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 如果在 signal 之前已经中断，返回 THROW_IE</span></span><br><span class="line"><span class="comment">// 2. 如果是 signal 之后中断，返回 REINTERRUPT</span></span><br><span class="line"><span class="comment">// 3. 没有发生中断，返回 0</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">checkInterruptWhileWaiting</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted() ?</span><br><span class="line">        (transferAfterCancelledWait(node) ? THROW_IE : REINTERRUPT) :</span><br><span class="line">        <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Thread.interrupted()：如果当前线程已经处于中断状态，那么该方法返回 true，同时将中断状态重置为 false，所以，才有后续的 <code>重新中断（REINTERRUPT）</code> 的使用。</p></blockquote><p>看看怎么判断是 signal 之前还是之后发生的中断：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只有线程处于中断状态，才会调用此方法</span></span><br><span class="line"><span class="comment">// 如果需要的话，将这个已经取消等待的节点转移到阻塞队列</span></span><br><span class="line"><span class="comment">// 返回 true：如果此线程在 signal 之前被取消，</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">transferAfterCancelledWait</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 用 CAS 将节点状态设置为 0 </span></span><br><span class="line">    <span class="comment">// 如果这步 CAS 成功，说明是 signal 方法之前发生的中断，因为如果 signal 先发生的话，signal 中会将 waitStatus 设置为 0</span></span><br><span class="line">    <span class="keyword">if</span> (compareAndSetWaitStatus(node, Node.CONDITION, <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="comment">// 将节点放入阻塞队列</span></span><br><span class="line">        <span class="comment">// 这里我们看到，即使中断了，依然会转移到阻塞队列</span></span><br><span class="line">        enq(node);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 到这里是因为 CAS 失败，肯定是因为 signal 方法已经将 waitStatus 设置为了 0</span></span><br><span class="line">    <span class="comment">// signal 方法会将节点转移到阻塞队列，但是可能还没完成，这边自旋等待其完成</span></span><br><span class="line">    <span class="comment">// 当然，这种事情还是比较少的吧：signal 调用之后，没完成转移之前，发生了中断</span></span><br><span class="line">    <span class="keyword">while</span> (!isOnSyncQueue(node))</span><br><span class="line">        Thread.yield();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里再说一遍，即使发生了中断，节点依然会转移到阻塞队列。</p></blockquote><p>到这里，大家应该都知道这个 while 循环怎么退出了吧。要么中断，要么转移成功。</p><p>这里描绘了一个场景，本来有个线程，它是排在条件队列的后面的，但是因为它被中断了，那么它会被唤醒，然后它发现自己不是被 signal 的那个，但是它会自己主动去进入到阻塞队列。</p><h5 id="获取独占锁"><a href="#获取独占锁" class="headerlink" title="获取独占锁"></a>获取独占锁</h5><p>while 循环出来以后，下面是这段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">    interruptMode = REINTERRUPT;</span><br></pre></td></tr></table></figure><p>由于 while 出来后，我们确定节点已经进入了阻塞队列，准备获取锁。</p><p>这里的 acquireQueued(node, savedState) 的第一个参数 node 之前已经经过 enq(node) 进入了队列，参数 savedState 是之前释放锁前的 state，这个方法返回的时候，代表当前线程获取了锁，而且 state == savedState了。</p><p>注意，前面我们说过，不管有没有发生中断，都会进入到阻塞队列，而 acquireQueued(node, savedState) 的返回值就是代表线程是否被中断。如果返回 true，说明被中断了，而且 interruptMode != THROW_IE，说明在 signal 之前就发生中断了，这里将 interruptMode 设置为 REINTERRUPT，用于待会重新中断。</p><p>继续往下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (node.nextWaiter != <span class="keyword">null</span>) <span class="comment">// clean up if cancelled</span></span><br><span class="line">    unlinkCancelledWaiters();</span><br><span class="line"><span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">    reportInterruptAfterWait(interruptMode);</span><br></pre></td></tr></table></figure><p>本着一丝不苟的精神，这边说说 <code>node.nextWaiter != null</code> 怎么满足。我前面也说了 signal 的时候会将节点转移到阻塞队列，有一步是 node.nextWaiter = null，将断开节点和条件队列的联系。</p><p>可是，<code>在判断发生中断的情况下，是 signal 之前还是之后发生的？</code> 这部分的时候，我也介绍了，如果 signal 之前就中断了，也需要将节点进行转移到阻塞队列，这部分转移的时候，是没有设置 node.nextWaiter = null 的。</p><p>之前我们说过，如果有节点取消，也会调用 unlinkCancelledWaiters 这个方法，就是这里了。</p><h5 id="处理中断状态"><a href="#处理中断状态" class="headerlink" title="处理中断状态"></a>处理中断状态</h5><p>到这里，我们终于可以好好说下这个 interruptMode 干嘛用了。</p><ul><li>0：什么都不做，没有被中断过；</li><li>THROW_IE：await 方法抛出 InterruptedException 异常，因为它代表在 await() 期间发生了中断；</li><li>REINTERRUPT：重新中断当前线程，因为它代表 await() 期间没有被中断，而是 signal() 以后发生的中断</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reportInterruptAfterWait</span><span class="params">(<span class="keyword">int</span> interruptMode)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (interruptMode == THROW_IE)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (interruptMode == REINTERRUPT)</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="带超时机制的-await"><a href="#带超时机制的-await" class="headerlink" title="* 带超时机制的 await"></a>* 带超时机制的 await</h5><p>经过前面的 7 步，整个 ConditionObject 类基本上都分析完了，接下来简单分析下带超时机制的 await 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">long</span> <span class="title">awaitNanos</span><span class="params">(<span class="keyword">long</span> nanosTimeout)</span> </span></span><br><span class="line"><span class="function">                  <span class="keyword">throws</span> InterruptedException</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">awaitUntil</span><span class="params">(Date deadline)</span></span></span><br><span class="line"><span class="function">                <span class="keyword">throws</span> InterruptedException</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">await</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">                <span class="keyword">throws</span> InterruptedException</span></span><br></pre></td></tr></table></figure><p>这三个方法都差不多，我们就挑一个出来看看吧：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">await</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 等待这么多纳秒</span></span><br><span class="line">    <span class="keyword">long</span> nanosTimeout = unit.toNanos(time);</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    Node node = addConditionWaiter();</span><br><span class="line">    <span class="keyword">int</span> savedState = fullyRelease(node);</span><br><span class="line">    <span class="comment">// 当前时间 + 等待时长 = 过期时间</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> deadline = System.nanoTime() + nanosTimeout;</span><br><span class="line">    <span class="comment">// 用于返回 await 是否超时</span></span><br><span class="line">    <span class="keyword">boolean</span> timedout = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">int</span> interruptMode = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">        <span class="comment">// 时间到啦</span></span><br><span class="line">        <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">            <span class="comment">// 这里因为要 break 取消等待了。取消等待的话一定要调用 transferAfterCancelledWait(node) 这个方法</span></span><br><span class="line">            <span class="comment">// 如果这个方法返回 true，在这个方法内，将节点转移到阻塞队列成功</span></span><br><span class="line">            <span class="comment">// 返回 false 的话，说明 signal 已经发生，signal 方法将节点转移了。也就是说没有超时嘛</span></span><br><span class="line">            timedout = transferAfterCancelledWait(node);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// spinForTimeoutThreshold 的值是 1000 纳秒，也就是 1 毫秒</span></span><br><span class="line">        <span class="comment">// 也就是说，如果不到 1 毫秒了，那就不要选择 parkNanos 了，自旋的性能反而更好</span></span><br><span class="line">        <span class="keyword">if</span> (nanosTimeout &gt;= spinForTimeoutThreshold)</span><br><span class="line">            LockSupport.parkNanos(<span class="keyword">this</span>, nanosTimeout);</span><br><span class="line">        <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 得到剩余时间</span></span><br><span class="line">        nanosTimeout = deadline - System.nanoTime();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">        interruptMode = REINTERRUPT;</span><br><span class="line">    <span class="keyword">if</span> (node.nextWaiter != <span class="keyword">null</span>)</span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">    <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">        reportInterruptAfterWait(interruptMode);</span><br><span class="line">    <span class="keyword">return</span> !timedout;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>超时的思路还是很简单的，不带超时参数的 await 是 park，然后等待别人唤醒。而现在就是调用 parkNanos 方法来休眠指定的时间，醒来后判断是否 signal 调用了，调用了就是没有超时，否则就是超时了。超时的话，自己来进行转移到阻塞队列，然后抢锁。</p><h5 id="不抛出-InterruptedException-的-await"><a href="#不抛出-InterruptedException-的-await" class="headerlink" title="* 不抛出 InterruptedException 的 await"></a>* 不抛出 InterruptedException 的 await</h5><p>关于 Condition 最后一小节了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">awaitUninterruptibly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node node = addConditionWaiter();</span><br><span class="line">    <span class="keyword">int</span> savedState = fullyRelease(node);</span><br><span class="line">    <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">        LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">            interrupted = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (acquireQueued(node, savedState) || interrupted)</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="AQS-独占锁的取消排队"><a href="#AQS-独占锁的取消排队" class="headerlink" title="AQS 独占锁的取消排队"></a>AQS 独占锁的取消排队</h4><p>接下来，我想说说怎么取消对锁的竞争？</p><p>上篇文章提到过，最重要的方法是这个，我们要在这里面找答案：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，到这个方法的时候，节点一定是入队成功的。</p><p>我把 parkAndCheckInterrupt() 代码贴过来：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这两段代码联系起来看，是不是就清楚了。</p><p>如果我们要取消一个线程的排队，我们需要在另外一个线程中对其进行中断。比如某线程调用 lock() 老久不返回，我想中断它。一旦对其进行中断，此线程会从 <code>LockSupport.park(this);</code> 中唤醒，然后 <code>Thread.interrupted();</code> 返回 true。</p><p>我们发现一个问题，即使是中断唤醒了这个线程，也就只是设置了 <code>interrupted = true</code> 然后继续下一次循环。而且，由于 <code>Thread.interrupted();</code>  会清除中断状态，第二次进 parkAndCheckInterrupt 的时候，返回会是 false。</p><p>所以，我们要看到，在这个方法中，interrupted 只是用来记录是否发生了中断，然后用于方法返回值，其他没有做任何相关事情。</p><p>所以，我们看外层方法怎么处理 acquireQueued 返回 false 的情况。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selfInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread.currentThread().interrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以说，lock() 方法处理中断的方法就是，你中断归中断，我抢锁还是照样抢锁，几乎没关系，只是我抢到锁了以后，设置线程的中断状态而已，也不抛出任何异常出来。调用者获取锁后，可以去检查是否发生过中断，也可以不理会。</p><p>我们来看 ReentrantLock 的另一个 lock 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    sync.acquireInterruptibly(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法上多了个 <code>throws InterruptedException</code> ，经过前面那么多知识的铺垫，这里我就不再啰里啰嗦了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg))</span><br><span class="line">        doAcquireInterruptibly(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续往里：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.EXCLUSIVE);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                <span class="comment">// 就是这里了，一旦异常，马上结束这个方法，抛出异常。</span></span><br><span class="line">                <span class="comment">// 这里不再只是标记这个方法的返回值代表中断状态</span></span><br><span class="line">                <span class="comment">// 而是直接抛出异常，而且外层也不捕获，一直往外抛到 lockInterruptibly</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 如果通过 InterruptedException 异常出去，那么 failed 就是 true 了</span></span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>既然到这里了，顺便说说 cancelAcquire 这个方法吧：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cancelAcquire</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Ignore if node doesn't exist</span></span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    node.thread = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// Skip cancelled predecessors</span></span><br><span class="line">    <span class="comment">// 找一个合适的前驱。其实就是将它前面的队列中已经取消的节点都”请出去“</span></span><br><span class="line">    Node pred = node.prev;</span><br><span class="line">    <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>)</span><br><span class="line">        node.prev = pred = pred.prev;</span><br><span class="line">    <span class="comment">// predNext is the apparent node to unsplice. CASes below will</span></span><br><span class="line">    <span class="comment">// fail if not, in which case, we lost race vs another cancel</span></span><br><span class="line">    <span class="comment">// or signal, so no further action is necessary.</span></span><br><span class="line">    Node predNext = pred.next;</span><br><span class="line">    <span class="comment">// Can use unconditional write instead of CAS here.</span></span><br><span class="line">    <span class="comment">// After this atomic step, other Nodes can skip past us.</span></span><br><span class="line">    <span class="comment">// Before, we are free of interference from other threads.</span></span><br><span class="line">    node.waitStatus = Node.CANCELLED;</span><br><span class="line">    <span class="comment">// If we are the tail, remove ourselves.</span></span><br><span class="line">    <span class="keyword">if</span> (node == tail &amp;&amp; compareAndSetTail(node, pred)) &#123;</span><br><span class="line">        compareAndSetNext(pred, predNext, <span class="keyword">null</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// If successor needs signal, try to set pred's next-link</span></span><br><span class="line">        <span class="comment">// so it will get one. Otherwise wake it up to propagate.</span></span><br><span class="line">        <span class="keyword">int</span> ws;</span><br><span class="line">        <span class="keyword">if</span> (pred != head &amp;&amp;</span><br><span class="line">            ((ws = pred.waitStatus) == Node.SIGNAL ||</span><br><span class="line">             (ws &lt;= <span class="number">0</span> &amp;&amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &amp;&amp;</span><br><span class="line">            pred.thread != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Node next = node.next;</span><br><span class="line">            <span class="keyword">if</span> (next != <span class="keyword">null</span> &amp;&amp; next.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                compareAndSetNext(pred, predNext, next);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            unparkSuccessor(node);</span><br><span class="line">        &#125;</span><br><span class="line">        node.next = node; <span class="comment">// help GC</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实这个方法没什么好说的，一行行看下去就是了，节点取消，只要把 waitStatus 设置为 Node.CANCELLED，会有非常多的情况被从阻塞队列中请出去，主动或被动。</p><h4 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h4><p>CountDownLatch 这个类是比较典型的 AQS 的共享模式的使用，这是一个高频使用的类。latch 的中文意思是<strong>门栓、栅栏</strong>，具体怎么解释我就不废话了，大家随意，看两个例子就知道在哪里用、怎么用了。</p><h5 id="使用例子"><a href="#使用例子" class="headerlink" title="使用例子"></a>使用例子</h5><p>我们看下 Doug Lea 在 java doc 中给出的例子，这个例子非常实用，我经常会写到这个代码。</p><p>假设我们有 N ( N &gt; 0 ) 个任务，那么我们会用 N 来初始化一个 CountDownLatch，然后将这个 latch 的引用传递到各个线程中，在每个线程完成了任务后，调用 latch.countDown() 代表完成了一个任务。</p><p>调用 latch.await() 的方法的线程会阻塞，直到所有的任务完成。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Driver2</span> </span>&#123; <span class="comment">// ...</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        CountDownLatch doneSignal = <span class="keyword">new</span> CountDownLatch(N);</span><br><span class="line">        Executor e = Executors.newFixedThreadPool(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建 N 个任务，提交给线程池来执行</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) <span class="comment">// create and start threads</span></span><br><span class="line">            e.execute(<span class="keyword">new</span> WorkerRunnable(doneSignal, i));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等待所有的任务完成，这个方法才会返回</span></span><br><span class="line">        doneSignal.await();           <span class="comment">// wait for all to finish</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WorkerRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CountDownLatch doneSignal;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    WorkerRunnable(CountDownLatch doneSignal, <span class="keyword">int</span> i) &#123;</span><br><span class="line">        <span class="keyword">this</span>.doneSignal = doneSignal;</span><br><span class="line">        <span class="keyword">this</span>.i = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            doWork(i);</span><br><span class="line">            <span class="comment">// 这个线程的任务完成了，调用 countDown 方法</span></span><br><span class="line">            doneSignal.countDown();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">        &#125; <span class="comment">// return;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doWork</span><span class="params">()</span> </span>&#123; ...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以说 CountDownLatch 非常实用，我们常常会将一个比较大的任务进行拆分，然后开启多个线程来执行，等所有线程都执行完了以后，再往下执行其他操作。这里例子中，<strong>只有 main 线程调用了 await 方法</strong>。</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20210905143440305.png" alt="image-20210905143440305"></p><p>如果始终只有一个线程调用 await 方法等待任务完成，那么 CountDownLatch 就会简单很多，所以之后的源码分析读者一定要在脑海中构建出这么一个场景：有 m 个线程是做任务的，有 n 个线程在某个栅栏上等待这 m 个线程做完任务，直到所有 m 个任务完成后，n 个线程同时通过栅栏。</p><h5 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h5><p>构造方法，需要传入一个不小于 0 的整数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CountDownLatch</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (count &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"count &lt; 0"</span>);</span><br><span class="line">    <span class="keyword">this</span>.sync = <span class="keyword">new</span> Sync(count);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 老套路了，内部封装一个 Sync 类继承自 AQS</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">    Sync(<span class="keyword">int</span> count) &#123;</span><br><span class="line">        <span class="comment">// 这样就 state == count 了</span></span><br><span class="line">        setState(count);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>代码都是套路，先分析套路：AQS 里面的 state 是一个整数值，这边用一个 int count 参数其实初始化就是设置了这个值，所有调用了 await 方法的等待线程会挂起，然后有其他一些线程会做 state = state - 1 操作，当 state 减到 0 的同时，那个将 state 减为 0 的线程会负责唤醒 所有调用了 await 方法的线程。都是套路啊，只是 Doug Lea 的套路很深，代码很巧妙，不然我们也没有要分析源码的必要。</p></blockquote><p>对于 CountDownLatch，我们仅仅需要关心两个方法，一个是 countDown() 方法，另一个是 await() 方法。</p><p>countDown() 方法每次调用都会将 state 减 1，直到 state 的值为 0；而 await 是一个阻塞方法，当 state 减为 0 的时候，await 方法才会返回。await 可以被多个线程调用，读者这个时候脑子里要有个图：所有调用了 await 方法的线程阻塞在 AQS 的阻塞队列中，等待条件满足（state == 0），将线程从队列中一个个唤醒过来。</p><p>我们用以下程序来分析源码，t1 和 t2 负责调用 countDown() 方法，t3 和 t4 调用 await 方法阻塞：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException ignore) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 休息 5 秒后(模拟线程工作了 5 秒)，调用 countDown()</span></span><br><span class="line">                latch.countDown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"t1"</span>);</span><br><span class="line"></span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException ignore) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 休息 10 秒后(模拟线程工作了 10 秒)，调用 countDown()</span></span><br><span class="line">                latch.countDown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"t2"</span>);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line">        Thread t3 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 阻塞，等待 state 减为 0</span></span><br><span class="line">                    latch.await();</span><br><span class="line">                    System.out.println(<span class="string">"线程 t3 从 await 中返回了"</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"线程 t3 await 被中断"</span>);</span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"t3"</span>);</span><br><span class="line">        Thread t4 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 阻塞，等待 state 减为 0</span></span><br><span class="line">                    latch.await();</span><br><span class="line">                    System.out.println(<span class="string">"线程 t4 从 await 中返回了"</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"线程 t4 await 被中断"</span>);</span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"t4"</span>);</span><br><span class="line"></span><br><span class="line">        t3.start();</span><br><span class="line">        t4.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述程序，大概在过了 10 秒左右的时候，会输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">线程 t3 从 await 中返回了</span><br><span class="line">线程 t4 从 await 中返回了</span><br></pre></td></tr></table></figure><blockquote><p>这两条输出，顺序不是绝对的</p><p>后面的分析，我们假设 t3 先进入阻塞队列</p></blockquote><p>接下来，我们按照流程一步一步走：先 await 等待，然后被唤醒，await 方法返回。</p><p>首先，我们来看 await() 方法，它代表线程阻塞，等待 state 的值减为 0。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 这也是老套路了，我在第二篇的中断那一节说过了</span></span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// t3 和 t4 调用 await 的时候，state 都大于 0（state 此时为 2）。</span></span><br><span class="line">    <span class="comment">// 也就是说，这个 if 返回 true，然后往里看</span></span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        doAcquireSharedInterruptibly(arg);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 只有当 state == 0 的时候，这个方法才会返回 1</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (getState() == <span class="number">0</span>) ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从方法名我们就可以看出，这个方法是获取共享锁，并且此方法是可中断的（中断的时候抛出 InterruptedException 退出这个方法）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 入队</span></span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                <span class="comment">// 同上，只要 state 不等于 0，那么这个方法返回 -1</span></span><br><span class="line">                <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 2</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来仔细分析这个方法，线程 t3 经过第 1 步 addWaiter 入队以后，我们应该可以得到这个：</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/2.png" alt="2"></p><p>由于 tryAcquireShared 这个方法会返回 -1，所以 if (r &gt;= 0) 这个分支不会进去。到 shouldParkAfterFailedAcquire 的时候，t3 将 head 的 waitStatus 值设置为 -1，如下：</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/3.png" alt="3"></p><p>然后进入到 parkAndCheckInterrupt 的时候，t3 挂起。</p><p>我们再分析 t4 入队，t4 会将前驱节点 t3 所在节点的 waitStatus 设置为 -1，t4 入队后，应该是这样的：</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/4.png" alt="4"></p><p>然后，t4 也挂起。接下来，t3 和 t4 就等待唤醒了。</p><p>接下来，我们来看唤醒的流程。为了让下面的示意图更丰富些，我们假设用 10 初始化 CountDownLatch。</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/1.png" alt="1"></p><p>当然，我们的例子中，其实没有 10 个线程，只有 2 个线程 t1 和 t2，只是为了让图好看些罢了。</p><p>我们再一步步看具体的流程。首先，我们看 countDown() 方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countDown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 只有当 state 减为 0 的时候，tryReleaseShared 才返回 true</span></span><br><span class="line">    <span class="comment">// 否则只是简单的 state = state - 1 那么 countDown() 方法就结束了</span></span><br><span class="line">    <span class="comment">//    将 state 减到 0 的那个操作才是最复杂的，继续往下吧</span></span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        <span class="comment">// 唤醒 await 的线程</span></span><br><span class="line">        doReleaseShared();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这个方法很简单，用自旋的方法实现 state 减 1</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> nextc = c-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">            <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>countDown 方法就是每次调用都将 state 值减 1，如果 state 减到 0 了，那么就调用下面的方法进行唤醒阻塞队列中的线程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用这个方法的时候，state == 0</span></span><br><span class="line"><span class="comment">// 这个方法先不要看所有的代码，按照思路往下到我写注释的地方，我们先跑通一个流程，其他的之后还会仔细分析</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">            <span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line">            <span class="comment">// t3 入队的时候，已经将头节点的 waitStatus 设置为 Node.SIGNAL（-1） 了</span></span><br><span class="line">            <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                <span class="comment">// 将 head 的 waitStatue 设置为 0</span></span><br><span class="line">                <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                    <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></span><br><span class="line">                <span class="comment">// 就是这里，唤醒 head 的后继节点，也就是阻塞队列中的第一个节点</span></span><br><span class="line">                <span class="comment">// 在这里，也就是唤醒 t3</span></span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                     !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE)) <span class="comment">// todo</span></span><br><span class="line">                <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一旦 t3 被唤醒后，我们继续回到 await 的这段代码，parkAndCheckInterrupt 返回，我们先不考虑中断的情况：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    setHeadAndPropagate(node, r); <span class="comment">// 2. 这里是下一步</span></span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                <span class="comment">// 1. 唤醒后这个方法返回</span></span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，t3 会进到 setHeadAndPropagate(node, r) 这个方法，先把 head 给占了，然后唤醒队列中其他的线程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHeadAndPropagate</span><span class="params">(Node node, <span class="keyword">int</span> propagate)</span> </span>&#123;</span><br><span class="line">    Node h = head; <span class="comment">// Record old head for check below</span></span><br><span class="line">    setHead(node);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面说的是，唤醒当前 node 之后的节点，即 t3 已经醒了，马上唤醒 t4</span></span><br><span class="line">    <span class="comment">// 类似的，如果 t4 后面还有 t5，那么 t4 醒了以后，马上将 t5 给唤醒了</span></span><br><span class="line">    <span class="keyword">if</span> (propagate &gt; <span class="number">0</span> || h == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span> ||</span><br><span class="line">        (h = head) == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        Node s = node.next;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.isShared())</span><br><span class="line">            <span class="comment">// 又是这个方法，只是现在的 head 已经不是原来的空节点了，是 t3 的节点了</span></span><br><span class="line">            doReleaseShared();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>又回到这个方法了，那么接下来，我们好好分析 doReleaseShared 这个方法，我们根据流程，头节点 head 此时是 t3 节点了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用这个方法的时候，state == 0</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="comment">// 1. h == null: 说明阻塞队列为空</span></span><br><span class="line">        <span class="comment">// 2. h == tail: 说明头结点可能是刚刚初始化的头节点，</span></span><br><span class="line">        <span class="comment">//   或者是普通线程节点，但是此节点既然是头节点了，那么代表已经被唤醒了，阻塞队列没有其他节点了</span></span><br><span class="line">        <span class="comment">// 所以这两种情况不需要进行唤醒后继节点</span></span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">            <span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line">            <span class="comment">// t4 将头节点(此时是 t3)的 waitStatus 设置为 Node.SIGNAL（-1） 了</span></span><br><span class="line">            <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                <span class="comment">// 这里 CAS 失败的场景请看下面的解读</span></span><br><span class="line">                <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                    <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></span><br><span class="line">                <span class="comment">// 就是这里，唤醒 head 的后继节点，也就是阻塞队列中的第一个节点</span></span><br><span class="line">                <span class="comment">// 在这里，也就是唤醒 t4</span></span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                     <span class="comment">// 这个 CAS 失败的场景是：执行到这里的时候，刚好有一个节点入队，入队会将这个 ws 设置为 -1</span></span><br><span class="line">                     !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果到这里的时候，前面唤醒的线程已经占领了 head，那么再循环</span></span><br><span class="line">        <span class="comment">// 否则，就是 head 没变，那么退出循环，</span></span><br><span class="line">        <span class="comment">// 退出循环是不是意味着阻塞队列中的其他节点就不唤醒了？当然不是，唤醒的线程之后还是会调用这个方法的</span></span><br><span class="line">        <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们分析下最后一个 if 语句，然后才能解释第一个 CAS 为什么可能会失败：</p><ol><li>h == head：说明头节点还没有被刚刚用 unparkSuccessor 唤醒的线程（这里可以理解为 t4）占有，此时 break 退出循环。</li><li>h != head：头节点被刚刚唤醒的线程（这里可以理解为 t4）占有，那么这里重新进入下一轮循环，唤醒下一个节点（这里是 t4 ）。我们知道，等到 t4 被唤醒后，其实是会主动唤醒 t5、t6、t7…，那为什么这里要进行下一个循环来唤醒 t5 呢？我觉得是出于吞吐量的考虑。</li></ol><p>满足上面的 2 的场景，那么我们就能知道为什么上面的 CAS 操作 compareAndSetWaitStatus(h, Node.SIGNAL, 0) 会失败了？</p><p>因为当前进行 for 循环的线程到这里的时候，可能刚刚唤醒的线程 t4 也刚刚好到这里了，那么就有可能 CAS 失败了。</p><p>for 循环第一轮的时候会唤醒 t4，t4 醒后会将自己设置为头节点，如果在 t4 设置头节点后，for 循环才跑到 if (h == head)，那么此时会返回 false，for 循环会进入下一轮。t4 唤醒后也会进入到这个方法里面，那么 for 循环第二轮和 t4 就有可能在这个 CAS 相遇，那么就只会有一个成功了。</p><h4 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h4><p>字面意思是“可重复使用的栅栏”或“周期性的栅栏”，总之不是用了一次就没用了的，CyclicBarrier 相比 CountDownLatch 来说，要简单很多，其源码没有什么高深的地方，它是 ReentrantLock 和 Condition 的组合使用。看如下示意图，CyclicBarrier 和 CountDownLatch 是不是很像，只是 CyclicBarrier 可以有不止一个栅栏，因为它的栅栏（Barrier）可以重复使用（Cyclic）。</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/cyclicbarrier-2.png" alt="cyclicbarrier-2"></p><p>首先，CyclicBarrier 的源码实现和 CountDownLatch 大相径庭，CountDownLatch 基于 AQS 的共享模式的使用，而 CyclicBarrier 基于 Condition 来实现。</p><p>因为 CyclicBarrier 的源码相对来说简单许多，读者只要熟悉了前面关于 Condition 的分析，那么这里的源码是毫无压力的，就是几个特殊概念罢了。</p><p>先用一张图来描绘下 CyclicBarrier 里面的一些概念，和它的基本使用流程：</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/cyclicbarrier-3.png" alt="cyclicbarrier-3"></p><blockquote><p>看图我们也知道了，CyclicBarrier 的源码最重要的就是 await() 方法了。</p></blockquote><p>大家先把图看完，然后我们开始源码分析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrier</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 我们说了，CyclicBarrier 是可以重复使用的，我们把每次从开始使用到穿过栅栏当做"一代"，或者"一个周期"</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Generation</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> broken = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** The lock for guarding barrier entry */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// CyclicBarrier 是基于 Condition 的</span></span><br><span class="line">    <span class="comment">// Condition 是“条件”的意思，CyclicBarrier 的等待线程通过 barrier 的“条件”是大家都到了栅栏上</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition trip = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 参与的线程数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> parties;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果设置了这个，代表越过栅栏之前，要执行相应的操作</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Runnable barrierCommand;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前所处的“代”</span></span><br><span class="line">    <span class="keyword">private</span> Generation generation = <span class="keyword">new</span> Generation();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 还没有到栅栏的线程数，这个值初始为 parties，然后递减</span></span><br><span class="line">    <span class="comment">// 还没有到栅栏的线程数 = parties - 已经到栅栏的数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties, Runnable barrierAction)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (parties &lt;= <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        <span class="keyword">this</span>.parties = parties;</span><br><span class="line">        <span class="keyword">this</span>.count = parties;</span><br><span class="line">        <span class="keyword">this</span>.barrierCommand = barrierAction;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(parties, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>首先，先看怎么开启新的一代：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 开启新的一代，当最后一个线程到达栅栏上的时候，调用这个方法来唤醒其他线程，同时初始化“下一代”</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">nextGeneration</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 首先，需要唤醒所有的在栅栏上等待的线程</span></span><br><span class="line">    trip.signalAll();</span><br><span class="line">    <span class="comment">// 更新 count 的值</span></span><br><span class="line">    count = parties;</span><br><span class="line">    <span class="comment">// 重新生成“新一代”</span></span><br><span class="line">    generation = <span class="keyword">new</span> Generation();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>开启新的一代，类似于重新实例化一个 CyclicBarrier 实例</p></blockquote><p>看看怎么打破一个栅栏：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">breakBarrier</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 设置状态 broken 为 true</span></span><br><span class="line">    generation.broken = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">// 重置 count 为初始值 parties</span></span><br><span class="line">    count = parties;</span><br><span class="line">    <span class="comment">// 唤醒所有已经在等待的线程</span></span><br><span class="line">    trip.signalAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这两个方法之后用得到，现在开始分析最重要的等待通过栅栏方法 await 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不带超时机制</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, BrokenBarrierException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dowait(<span class="keyword">false</span>, <span class="number">0L</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (TimeoutException toe) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Error(toe); <span class="comment">// cannot happen</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 带超时机制，如果超时抛出 TimeoutException 异常</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">await</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException,</span></span><br><span class="line"><span class="function">           BrokenBarrierException,</span></span><br><span class="line"><span class="function">           TimeoutException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dowait(<span class="keyword">true</span>, unit.toNanos(timeout));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续往里看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dowait</span><span class="params">(<span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, BrokenBarrierException,</span></span><br><span class="line"><span class="function">               TimeoutException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    <span class="comment">// 先要获取到锁，然后在 finally 中要记得释放锁</span></span><br><span class="line">    <span class="comment">// 如果记得 Condition 部分的话，我们知道 condition 的 await() 会释放锁，被 signal() 唤醒的时候需要重新获取锁</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> Generation g = generation;</span><br><span class="line">        <span class="comment">// 检查栅栏是否被打破，如果被打破，抛出 BrokenBarrierException 异常</span></span><br><span class="line">        <span class="keyword">if</span> (g.broken)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BrokenBarrierException();</span><br><span class="line">        <span class="comment">// 检查中断状态，如果中断了，抛出 InterruptedException 异常</span></span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">            breakBarrier();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// index 是这个 await 方法的返回值</span></span><br><span class="line">        <span class="comment">// 注意到这里，这个是从 count 递减后得到的值</span></span><br><span class="line">        <span class="keyword">int</span> index = --count;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果等于 0，说明所有的线程都到栅栏上了，准备通过</span></span><br><span class="line">        <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;  <span class="comment">// tripped</span></span><br><span class="line">            <span class="keyword">boolean</span> ranAction = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 如果在初始化的时候，指定了通过栅栏前需要执行的操作，在这里会得到执行</span></span><br><span class="line">                <span class="keyword">final</span> Runnable command = barrierCommand;</span><br><span class="line">                <span class="keyword">if</span> (command != <span class="keyword">null</span>)</span><br><span class="line">                    command.run();</span><br><span class="line">                <span class="comment">// 如果 ranAction 为 true，说明执行 command.run() 的时候，没有发生异常退出的情况</span></span><br><span class="line">                ranAction = <span class="keyword">true</span>;</span><br><span class="line">                <span class="comment">// 唤醒等待的线程，然后开启新的一代</span></span><br><span class="line">                nextGeneration();</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!ranAction)</span><br><span class="line">                    <span class="comment">// 进到这里，说明执行指定操作的时候，发生了异常，那么需要打破栅栏</span></span><br><span class="line">                    <span class="comment">// 之前我们说了，打破栅栏意味着唤醒所有等待的线程，设置 broken 为 true，重置 count 为 parties</span></span><br><span class="line">                    breakBarrier();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// loop until tripped, broken, interrupted, or timed out</span></span><br><span class="line">        <span class="comment">// 如果是最后一个线程调用 await，那么上面就返回了</span></span><br><span class="line">        <span class="comment">// 下面的操作是给那些不是最后一个到达栅栏的线程执行的</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 如果带有超时机制，调用带超时的 Condition 的 await 方法等待，直到最后一个线程调用 await</span></span><br><span class="line">                <span class="keyword">if</span> (!timed)</span><br><span class="line">                    trip.await();</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (nanos &gt; <span class="number">0L</span>)</span><br><span class="line">                    nanos = trip.awaitNanos(nanos);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">                <span class="comment">// 如果到这里，说明等待的线程在 await（是 Condition 的 await）的时候被中断</span></span><br><span class="line">                <span class="keyword">if</span> (g == generation &amp;&amp; ! g.broken) &#123;</span><br><span class="line">                    <span class="comment">// 打破栅栏</span></span><br><span class="line">                    breakBarrier();</span><br><span class="line">                    <span class="comment">// 打破栅栏后，重新抛出这个 InterruptedException 异常给外层调用的方法</span></span><br><span class="line">                    <span class="keyword">throw</span> ie;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 到这里，说明 g != generation, 说明新的一代已经产生，即最后一个线程 await 执行完成，</span></span><br><span class="line">                    <span class="comment">// 那么此时没有必要再抛出 InterruptedException 异常，记录下来这个中断信息即可</span></span><br><span class="line">                    <span class="comment">// 或者是栅栏已经被打破了，那么也不应该抛出 InterruptedException 异常，</span></span><br><span class="line">                    <span class="comment">// 而是之后抛出 BrokenBarrierException 异常</span></span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">              <span class="comment">// 唤醒后，检查栅栏是否是“破的”</span></span><br><span class="line">            <span class="keyword">if</span> (g.broken)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BrokenBarrierException();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 这个 for 循环除了异常，就是要从这里退出了</span></span><br><span class="line">            <span class="comment">// 我们要清楚，最后一个线程在执行完指定任务(如果有的话)，会调用 nextGeneration 来开启一个新的代</span></span><br><span class="line">            <span class="comment">// 然后释放掉锁，其他线程从 Condition 的 await 方法中得到锁并返回，然后到这里的时候，其实就会满足 g != generation 的</span></span><br><span class="line">            <span class="comment">// 那什么时候不满足呢？barrierCommand 执行过程中抛出了异常，那么会执行打破栅栏操作，</span></span><br><span class="line">            <span class="comment">// 设置 broken 为true，然后唤醒这些线程。这些线程会从上面的 if (g.broken) 这个分支抛 BrokenBarrierException 异常返回</span></span><br><span class="line">            <span class="comment">// 当然，还有最后一种可能，那就是 await 超时，此种情况不会从上面的 if 分支异常返回，也不会从这里返回，会执行后面的代码</span></span><br><span class="line">            <span class="keyword">if</span> (g != generation)</span><br><span class="line">                <span class="keyword">return</span> index;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果醒来发现超时了，打破栅栏，抛出异常</span></span><br><span class="line">            <span class="keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">                breakBarrier();</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> TimeoutException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好了，我想我应该讲清楚了吧，我好像几乎没有漏掉任何一行代码吧？</p><p>下面开始收尾工作。</p><p>首先，我们看看怎么得到有多少个线程到了栅栏上，处于等待状态：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNumberWaiting</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> parties - count;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断一个栅栏是否被打破了，这个很简单，直接看 broken 的值即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBroken</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> generation.broken;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前面我们在说 await 的时候也几乎说清楚了，什么时候栅栏会被打破，总结如下：</p><ol><li>中断，我们说了，如果某个等待的线程发生了中断，那么会打破栅栏，同时抛出 InterruptedException 异常；</li><li>超时，打破栅栏，同时抛出 TimeoutException 异常；</li><li>指定执行的操作抛出了异常，这个我们前面也说过。</li></ol><p>最后，我们来看看怎么重置一个栅栏：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        breakBarrier();   <span class="comment">// break the current generation</span></span><br><span class="line">        nextGeneration(); <span class="comment">// start a new generation</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们设想一下，如果初始化时，指定了线程 parties = 4，前面有 3 个线程调用了 await 等待，在第 4 个线程调用 await 之前，我们调用 reset 方法，那么会发生什么？</p><p>首先，打破栅栏，那意味着所有等待的线程（3个等待的线程）会唤醒，await 方法会通过抛出 BrokenBarrierException 异常返回。然后开启新的一代，重置了 count 和 generation，相当于一切归零了。</p><p>怎么样，CyclicBarrier 源码很简单吧。</p><h4 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h4><p>有了 CountDownLatch 的基础后，分析 Semaphore 会简单很多。Semaphore 是什么呢？它类似一个资源池（读者可以类比线程池），每个线程需要调用 acquire() 方法获取资源，然后才能执行，执行完后，需要 release 资源，让给其他的线程用。</p><p>大概大家也可以猜到，Semaphore 其实也是 AQS 中共享锁的使用，因为每个线程共享一个池嘛。</p><p>套路解读：创建 Semaphore 实例的时候，需要一个参数 permits，这个基本上可以确定是设置给 AQS 的 state 的，然后每个线程调用 acquire 的时候，执行 state = state - 1，release 的时候执行 state = state + 1，当然，acquire  的时候，如果 state = 0，说明没有资源了，需要等待其他线程 release。</p><p>构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits)</span> </span>&#123;</span><br><span class="line">    sync = <span class="keyword">new</span> NonfairSync(permits);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits, <span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> FairSync(permits) : <span class="keyword">new</span> NonfairSync(permits);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里和 ReentrantLock 类似，用了公平策略和非公平策略。</p><p>看 acquire 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquireUninterruptibly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.acquireShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> permits)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (permits &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    sync.acquireSharedInterruptibly(permits);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquireUninterruptibly</span><span class="params">(<span class="keyword">int</span> permits)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (permits &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    sync.acquireShared(permits);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这几个方法也是老套路了，大家基本都懂了吧，这边多了两个可以传参的 acquire 方法，不过大家也都懂的吧，如果我们需要一次获取超过一个的资源，会用得着这个的。</p><p>我们接下来看不抛出 InterruptedException 异常的 acquireUninterruptibly() 方法吧：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquireUninterruptibly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.acquireShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        doAcquireShared(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前面说了，Semaphore 分公平策略和非公平策略，我们对比一下两个 tryAcquireShared 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 公平策略：</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 区别就在于是不是会先判断是否有线程在排队，然后才进行 CAS 减操作</span></span><br><span class="line">        <span class="keyword">if</span> (hasQueuedPredecessors())</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> available = getState();</span><br><span class="line">        <span class="keyword">int</span> remaining = available - acquires;</span><br><span class="line">        <span class="keyword">if</span> (remaining &lt; <span class="number">0</span> ||</span><br><span class="line">            compareAndSetState(available, remaining))</span><br><span class="line">            <span class="keyword">return</span> remaining;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 非公平策略：</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nonfairTryAcquireShared(acquires);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">nonfairTryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> available = getState();</span><br><span class="line">        <span class="keyword">int</span> remaining = available - acquires;</span><br><span class="line">        <span class="keyword">if</span> (remaining &lt; <span class="number">0</span> ||</span><br><span class="line">            compareAndSetState(available, remaining))</span><br><span class="line">            <span class="keyword">return</span> remaining;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也是老套路了，所以从源码分析角度的话，我们其实不太需要关心是不是公平策略还是非公平策略，它们的区别往往就那么一两行。</p><p>我们再回到 acquireShared 方法，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        doAcquireShared(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于 tryAcquireShared(arg) 返回小于 0 的时候，说明 state 已经小于 0 了（没资源了），此时 acquire 不能立马拿到资源，需要进入到阻塞队列等待，虽然贴了很多代码，不在乎多这点了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    <span class="keyword">if</span> (interrupted)</span><br><span class="line">                        selfInterrupt();</span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法我就不介绍了，线程挂起后等待有资源被 release 出来。接下来，我们就要看 release 的方法了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 任务介绍，释放一个资源</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> current = getState();</span><br><span class="line">        <span class="keyword">int</span> next = current + releases;</span><br><span class="line">        <span class="comment">// 溢出，当然，我们一般也不会用这么大的数</span></span><br><span class="line">        <span class="keyword">if</span> (next &lt; current) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum permit count exceeded"</span>);</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(current, next))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>tryReleaseShared 方法总是会返回 true，然后是 doReleaseShared，这个也是我们熟悉的方法了，我就贴下代码，不分析了，这个方法用于唤醒所有的等待线程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">            <span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line">            <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                    <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                     !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Semphore 的源码确实很简单，基本上都是分析过的老代码的组合使用了。</p><h4 id="AQS-组件总结"><a href="#AQS-组件总结" class="headerlink" title="AQS 组件总结"></a>AQS 组件总结</h4><ul><li><strong><code>Semaphore</code>(信号量)-允许多个线程同时访问：</strong> <code>synchronized</code> 和 <code>ReentrantLock</code> 都是一次只允许一个线程访问某个资源，<code>Semaphore</code>(信号量)可以指定多个线程同时访问某个资源。</li><li><strong><code>CountDownLatch</code>（倒计时器）：</strong> <code>CountDownLatch</code> 是一个同步工具类，用来协调多个线程之间的同步。这个工具通常用来控制线程等待，它可以让某一个线程等待直到倒计时结束，再开始执行。</li><li><strong><code>CyclicBarrier</code>(循环栅栏)：</strong> <code>CyclicBarrier</code> 和 <code>CountDownLatch</code> 非常类似，它也可以实现线程间的技术等待，但是它的功能比 <code>CountDownLatch</code> 更加复杂和强大。让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程继续执行。</li></ul><h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><h4 id="为什么要用线程池？"><a href="#为什么要用线程池？" class="headerlink" title="为什么要用线程池？"></a>为什么要用线程池？</h4><ol><li>降低资源消耗。通知重复利用已创建的线程降低线程创建和销毁造成的消耗</li><li>提高响应速度。当任务到达时，任务可以不需要等待线程创建</li><li>提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一分配、调优和监控</li></ol><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20210831164907239.png" alt="image-20210831164907239"></p><h4 id="实现-Runnable-和-Callable-接口的区别"><a href="#实现-Runnable-和-Callable-接口的区别" class="headerlink" title="实现 Runnable 和 Callable 接口的区别"></a>实现 Runnable 和 Callable 接口的区别</h4><p>Callable 接口引入是为了处理 Runnable 不支持的用例。Runnable 接口不会返回结果或抛出异常，Callable 接口可以。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 被线程执行，没有返回值也无法抛出异常</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callable</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 计算结果，或在无法这样做时抛出异常。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 计算得出的结果</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> 如果无法计算结果，则抛出异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">V <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="执行-execute-方法和-submit-方法的区别是什么？"><a href="#执行-execute-方法和-submit-方法的区别是什么？" class="headerlink" title="执行 execute() 方法和 submit() 方法的区别是什么？"></a>执行 execute() 方法和 submit() 方法的区别是什么？</h4><ol><li>execute() 方法用于提交不需要返回值的任务，无法判断任务是否被线程池成功执行与否</li><li>submit() 方法用于提交需要返回值的任务，线程池会返回一个 Future 对象，通过这个 Future 对象可以判断任务是否执行成功，并且可以通过 Future 的 get() 方法来获取返回值，get() 方法会阻塞当前线程直到任务完成。</li></ol><p>我们以 <strong><code>AbstractExecutorService</code> 接口</strong> 中的一个 <code>submit</code> 方法为例子来看看源代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, <span class="keyword">null</span>);</span><br><span class="line">    execute(ftask);</span><br><span class="line">    <span class="keyword">return</span> ftask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面方法调用的 <code>newTaskFor</code> 方法返回了一个 <code>FutureTask</code> 对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">RunnableFuture&lt;T&gt; <span class="title">newTaskFor</span><span class="params">(Runnable runnable, T value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FutureTask&lt;T&gt;(runnable, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="如何创建线程池"><a href="#如何创建线程池" class="headerlink" title="如何创建线程池"></a>如何创建线程池</h4><p>通常不建议使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式。</p><blockquote><p>Executors 返回线程池对象的弊端如下：</p><ul><li><strong>FixedThreadPool 和 SingleThreadExecutor</strong> ： 允许请求的队列长度为 Integer.MAX_VALUE ，可能堆积大量的请求，从而导致 OOM。</li><li><strong>CachedThreadPool 和 ScheduledThreadPool</strong> ： 允许创建的线程数量为 Integer.MAX_VALUE ，可能会创建大量线程，从而导致 OOM。</li></ul></blockquote><p>通过构造方法实现</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20210830203732695.png" alt="image-20210830203732695"></p><h4 id="ThreadPoolExecutors-类分析"><a href="#ThreadPoolExecutors-类分析" class="headerlink" title="ThreadPoolExecutors 类分析"></a>ThreadPoolExecutors 类分析</h4><p>这里分析最后一个最长的构造函数，其余三个都是在这个构造方法基础上产生。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用给定的初始参数创建一个新的ThreadPoolExecutor。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                      TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                      BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                      ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                      RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">        keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || handler == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">    <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">    <span class="keyword">this</span>.workQueue = workQueue;</span><br><span class="line">    <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">    <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">    <span class="keyword">this</span>.handler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ThreadPoolExecutor 3 个最重要的参数：</p><ul><li>corePoolSize：核心线程数定义了最小可以同时运行的线程数量</li><li>maximumPoolSize：当队列中存放的任务达到队列容量时，当前可以同时运行的线程数量变为最大线程数。</li><li>workQueue：当新任务来时，会判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被放到队列中</li></ul><p>其他常见参数</p><ol><li>keepAliveTime，当线程池中的线程数量大于 corePoolSize 时，如果没有新的任务提交，<strong>核心线程外的线程不会立即销毁而是等待时间超过了 keepAliveTime 后被回收销毁</strong></li><li>unit，keepAliveTime 参数的时间单位</li><li>threadFactory，executor 创建新线程会用到</li><li>handler，饱和策略</li></ol><h4 id="ThreadPoolExecutor-饱和策略"><a href="#ThreadPoolExecutor-饱和策略" class="headerlink" title="ThreadPoolExecutor 饱和策略"></a>ThreadPoolExecutor 饱和策略</h4><p>当同时运行的线程数量达到 maximumPoolSize 时，且队列也满时，ThreadPoolTaskExecutor 定义一些策略：</p><ul><li><p>ThreadPoolExecutor.AbortPolicy：抛出 RejectExecutionException 来拒绝新任务的处理</p></li><li><p>ThreadPoolExecutor.CallerRunsPolicy： 调用执行自己的线程运行任务，也就是直接在调用<code>execute</code>方法的线程中运行(<code>run</code>)被拒绝的任务，如果执行程序已关闭，则会丢弃该任务。因此这种策略会降低对于新任务提交速度，影响程序的整体性能。</p></li><li><p>ThreadPoolExecutor.DiscardPolicy：不处理新任务，直接丢弃掉</p></li><li><p>ThreadPoolExecutor.DiscardOldestPolicy：丢弃最早未处理的任务请求</p></li></ul><h4 id="线程池Demo"><a href="#线程池Demo" class="headerlink" title="线程池Demo"></a>线程池Demo</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Runnable r = () -&gt; &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" Start. Time = "</span> + <span class="keyword">new</span> Date());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" End. Time = "</span> + <span class="keyword">new</span> Date());</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    ThreadPoolExecutor executor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">5</span>, <span class="number">10</span>, <span class="number">1L</span>, TimeUnit.SECONDS,</span><br><span class="line">            <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">100</span>), <span class="keyword">new</span> ThreadPoolExecutor.CallerRunsPolicy());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        executor.execute(r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//终止线程池</span></span><br><span class="line">    executor.shutdown();</span><br><span class="line">    <span class="keyword">while</span> (!executor.isTerminated()) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"Finished all threads"</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">输出：</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span> Start. Time = Mon Aug <span class="number">30</span> <span class="number">21</span>:<span class="number">13</span>:<span class="number">45</span> CST <span class="number">2021</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span> Start. Time = Mon Aug <span class="number">30</span> <span class="number">21</span>:<span class="number">13</span>:<span class="number">45</span> CST <span class="number">2021</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">4</span> Start. Time = Mon Aug <span class="number">30</span> <span class="number">21</span>:<span class="number">13</span>:<span class="number">45</span> CST <span class="number">2021</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">3</span> Start. Time = Mon Aug <span class="number">30</span> <span class="number">21</span>:<span class="number">13</span>:<span class="number">45</span> CST <span class="number">2021</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">5</span> Start. Time = Mon Aug <span class="number">30</span> <span class="number">21</span>:<span class="number">13</span>:<span class="number">45</span> CST <span class="number">2021</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">3</span> End. Time = Mon Aug <span class="number">30</span> <span class="number">21</span>:<span class="number">13</span>:<span class="number">50</span> CST <span class="number">2021</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span> End. Time = Mon Aug <span class="number">30</span> <span class="number">21</span>:<span class="number">13</span>:<span class="number">50</span> CST <span class="number">2021</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">4</span> End. Time = Mon Aug <span class="number">30</span> <span class="number">21</span>:<span class="number">13</span>:<span class="number">50</span> CST <span class="number">2021</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">3</span> Start. Time = Mon Aug <span class="number">30</span> <span class="number">21</span>:<span class="number">13</span>:<span class="number">50</span> CST <span class="number">2021</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">4</span> Start. Time = Mon Aug <span class="number">30</span> <span class="number">21</span>:<span class="number">13</span>:<span class="number">50</span> CST <span class="number">2021</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span> End. Time = Mon Aug <span class="number">30</span> <span class="number">21</span>:<span class="number">13</span>:<span class="number">50</span> CST <span class="number">2021</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">5</span> End. Time = Mon Aug <span class="number">30</span> <span class="number">21</span>:<span class="number">13</span>:<span class="number">50</span> CST <span class="number">2021</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span> Start. Time = Mon Aug <span class="number">30</span> <span class="number">21</span>:<span class="number">13</span>:<span class="number">50</span> CST <span class="number">2021</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span> Start. Time = Mon Aug <span class="number">30</span> <span class="number">21</span>:<span class="number">13</span>:<span class="number">50</span> CST <span class="number">2021</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">5</span> Start. Time = Mon Aug <span class="number">30</span> <span class="number">21</span>:<span class="number">13</span>:<span class="number">50</span> CST <span class="number">2021</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">4</span> End. Time = Mon Aug <span class="number">30</span> <span class="number">21</span>:<span class="number">13</span>:<span class="number">55</span> CST <span class="number">2021</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span> End. Time = Mon Aug <span class="number">30</span> <span class="number">21</span>:<span class="number">13</span>:<span class="number">55</span> CST <span class="number">2021</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span> End. Time = Mon Aug <span class="number">30</span> <span class="number">21</span>:<span class="number">13</span>:<span class="number">55</span> CST <span class="number">2021</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">3</span> End. Time = Mon Aug <span class="number">30</span> <span class="number">21</span>:<span class="number">13</span>:<span class="number">55</span> CST <span class="number">2021</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">5</span> End. Time = Mon Aug <span class="number">30</span> <span class="number">21</span>:<span class="number">13</span>:<span class="number">55</span> CST <span class="number">2021</span></span><br><span class="line">Finished all threads</span><br><span class="line">Finished all threads</span><br></pre></td></tr></table></figure><h4 id="线程池原理分析"><a href="#线程池原理分析" class="headerlink" title="==线程池原理分析=="></a>==线程池原理分析==</h4><p>上面 Demo 可以看出，共 10 个任务，线程池先执行 5 个，等待这些任务结束后，继续执行剩下的 5 个任务。</p><p>我们看看 execute(worker) 源码 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 存放线程池的运行状态 (runState) 和线程池内有效线程的数量 (workerCount)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">workerCountOf</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c &amp; CAPACITY;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;Runnable&gt; workQueue;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果任务为null，则抛出异常。</span></span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">// ctl 中保存的线程池当前的一些状态信息</span></span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  下面会涉及到 3 步 操作</span></span><br><span class="line">    <span class="comment">// 1.首先判断当前线程池中执行的任务数量是否小于 corePoolSize</span></span><br><span class="line">    <span class="comment">// 如果小于的话，通过addWorker(command, true)新建一个线程，并将任务(command)添加到该线程中；然后，启动该线程从而执行任务。</span></span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2.如果当前执行的任务数量大于等于 corePoolSize 的时候就会走到这里</span></span><br><span class="line">    <span class="comment">// 通过 isRunning 方法判断线程池状态，线程池处于 RUNNING 状态才会被并且队列可以加入任务，该任务才会被加入进去</span></span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">        <span class="comment">// 再次获取线程池状态，如果线程池状态不是 RUNNING 状态就需要从任务队列中移除任务，并尝试判断线程是否全部执行完毕。同时执行拒绝策略。</span></span><br><span class="line">        <span class="keyword">if</span> (!isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            reject(command);</span><br><span class="line">            <span class="comment">// 如果当前线程池为空就新创建一个线程并执行。</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">            addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3. 通过addWorker(command, false)新建一个线程，并将任务(command)添加到该线程中；然后，启动该线程从而执行任务。</span></span><br><span class="line">    <span class="comment">//如果addWorker(command, false)执行失败，则通过reject()执行相应的拒绝策略的内容。</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20210830211740198.png" alt="image-20210830211740198"></p><h4 id="线程池大小确定"><a href="#线程池大小确定" class="headerlink" title="==线程池大小确定=="></a>==线程池大小确定==</h4><p>有一个简单并且适用面比较广的公式：</p><ul><li><strong>CPU 密集型任务(N+1)：</strong> 这种任务消耗的主要是 CPU 资源，可以将线程数设置为 N（CPU 核心数）+1，<strong>比 CPU 核心数多出来的一个线程是为了防止线程偶发的缺页中断，或者其它原因导致的任务暂停而带来的影响</strong>。一旦任务暂停，CPU 就会处于空闲状态，而在这种情况下多出来的一个线程就可以充分利用 CPU 的空闲时间。</li><li><strong>I/O 密集型任务(2N)：</strong> 这种任务应用起来，系统会用大部分的时间来处理 I/O 交互，<strong>而线程在处理 I/O 的时间段内不会占用 CPU 来处理，这时就可以将 CPU 交出给其它线程使用</strong>。因此在 I/O 密集型任务的应用中，我们可以多配置一些线程，具体的计算方法是 2N。</li></ul><p><strong>如何判断是 CPU 密集任务还是 IO 密集任务？</strong></p><p>CPU 密集型简单理解就是利用 CPU 计算能力的任务比如你在内存中对大量数据进行排序。单凡涉及到网络读取，文件读取这类都是 IO 密集型，这类任务的特点是 CPU 计算耗费时间相比于等待 IO 操作完成的时间来说很少，大部分时间都花在了等待 IO 操作完成上。</p><h4 id="四种常见的线程池"><a href="#四种常见的线程池" class="headerlink" title="四种常见的线程池"></a>四种常见的线程池</h4><h5 id="newCachedThreadPool"><a href="#newCachedThreadPool" class="headerlink" title="newCachedThreadPool"></a>newCachedThreadPool</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,  <span class="comment">//核心池大小 0，最大池大小为整型最大可能导致 OOM</span></span><br><span class="line"> <span class="number">60L</span>, TimeUnit.SECONDS, <span class="comment">// keepAliveTime 60s</span></span><br><span class="line"> <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;()); <span class="comment">//SynchronousQueue队列</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="newFixedThreadPool"><a href="#newFixedThreadPool" class="headerlink" title="newFixedThreadPool"></a>newFixedThreadPool</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads, <span class="comment">//核心池和最大池大小都是传入的参数，只能创建核心线程</span></span><br><span class="line"> <span class="number">0L</span>, TimeUnit.MILLISECONDS,<span class="comment">//只能创建核心线程 keepAliveTime 也没啥用</span></span><br><span class="line"> <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()); <span class="comment">//LinkedBlockingQueue的默认⼤⼩Integer.MAX_VALUE</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="newSingleThreadExecutor"><a href="#newSingleThreadExecutor" class="headerlink" title="newSingleThreadExecutor"></a><strong>newSingleThreadExecutor</strong></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService(<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,<span class="comment">//核心池和最大池大小都是1</span></span><br><span class="line"> <span class="number">0L</span>, TimeUnit.MILLISECONDS,<span class="comment">//只能创建核心线程 keepAliveTime 也没啥用</span></span><br><span class="line"> <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;())); <span class="comment">//所有任务按照FIFO执行，任务队列大小默认为Integer.MAX_VALUE</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="newScheduledThreadPool"><a href="#newScheduledThreadPool" class="headerlink" title="newScheduledThreadPool"></a><strong>newScheduledThreadPool</strong></h5><p>创建⼀个定⻓线程池，⽀持定时及周期性任务执⾏。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize</span></span></span><br><span class="line"><span class="function"><span class="params"> return new ScheduledThreadPoolExecutor(corePoolSize)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//ScheduledThreadPoolExecutor():</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ScheduledThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">super</span>(corePoolSize, Integer.MAX_VALUE,   <span class="comment">//核心池大小 corePoolSize，最大池大小为整型最大可能导致 OOM</span></span><br><span class="line"> DEFAULT_KEEPALIVE_MILLIS, MILLISECONDS,</span><br><span class="line"> <span class="keyword">new</span> DelayedWorkQueue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h3><p>BlockingQueue⼀般⽤于⽣产者-消费者模式，⽣产者是往队列⾥添加元素的线程， 消费者是从队列⾥拿元素的线程。<strong>BlockingQueue</strong>就是存放元素的容器。 </p><h4 id="BlockingQueue-的操作方法"><a href="#BlockingQueue-的操作方法" class="headerlink" title="BlockingQueue 的操作方法"></a>BlockingQueue 的操作方法</h4><p>阻塞队列提供了四组不同的方法用于插入、移除、检查元素：</p><table><thead><tr><th>方法/处理方式</th><th>抛出异常</th><th>返回特殊值</th><th>一直阻塞</th><th>超时退出</th></tr></thead><tbody><tr><td>插入方法</td><td>add(e)</td><td>offer(e)</td><td>put(e)</td><td>offer(e, time, unit)</td></tr><tr><td>移除方法</td><td>remove</td><td>poll()</td><td>take()</td><td>poll(time, unit)</td></tr><tr><td>检查方法</td><td>element()</td><td>peek()</td><td>-</td><td>-</td></tr></tbody></table><ul><li>抛出异常：当队列满时插入元素，抛出IllegalStateException(“Queue full”)异常，当队列为空取元素，抛出NoSuchElementException异常</li><li>返回特殊值：一般为 true/false</li><li>一直阻塞：试图的操作无法立即执行，一直阻塞</li><li>超时退出，阻塞超过一定时间后，返回一个特定值告知该操作是否完成</li></ul><p>注意：不能往阻塞队列中插入 null</p><h4 id="BlockingQueue-的实现类"><a href="#BlockingQueue-的实现类" class="headerlink" title="BlockingQueue 的实现类"></a>BlockingQueue 的实现类</h4><h5 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h5><p>由数组结构组成的有界阻塞队列。内部结构是数组，故具有数组的特性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity, <span class="keyword">boolean</span> fair)</span></span>&#123;</span><br><span class="line"> <span class="comment">//..省略代码 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以初始化队列⼤⼩， 且⼀旦初始化不能改变。构造⽅法中的fair表示控制对象的 内部锁是否采⽤公平锁，默认是⾮公平锁。</p><h5 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a><strong>LinkedBlockingQueue</strong></h5><p>由链表结构组成的有界阻塞队列。内部结构是链表，具有链表的特性。默认队列的 ⼤⼩是 Integer.MAX_VALUE ，也可以指定⼤⼩。此队列按照先进先出的原则对元素 进⾏排序。</p><h5 id="DelayQueue"><a href="#DelayQueue" class="headerlink" title="DelayQueue"></a><strong>DelayQueue</strong></h5><p>该队列中的元素只有当其指定的延迟时间到了，才能够从队列中获取到该元素 。注⼊其中的元素必须实现 Delayed 接口。DelayQueue是⼀个没有⼤⼩限制的队列，因此往队列中插⼊数据的操作（⽣产者）永远不会被阻塞。</p><h5 id="PriorityBlockingQueue"><a href="#PriorityBlockingQueue" class="headerlink" title="PriorityBlockingQueue"></a><strong>PriorityBlockingQueue</strong></h5><p>基于优先级的⽆界阻塞队列（优先级的判断通过构造函数传⼊的Compator对象来决定）</p><h5 id="SynchronousQueue"><a href="#SynchronousQueue" class="headerlink" title="SynchronousQueue"></a><strong>SynchronousQueue</strong></h5><p>这个队列⽐较特殊，没有任何内部容量，甚⾄连⼀个队列的容量都没有。并且每个put 必须等待⼀个 take，反之亦然。 </p><p><strong>==注意==</strong></p><p><strong>PriorityBlockingQueue</strong>不会阻塞数据⽣产者（因为队列是⽆界的），⽽只会在没 有可消费的数据时，阻塞数据的消费者。因此使⽤的时候要特别注意，⽣产者⽣产数据的速度绝对不能快于消费者消费数据的速度，否则时间⼀⻓，会最终耗尽所有 的可⽤堆内存空间。对于使⽤默认⼤⼩的<strong>LinkedBlockingQueue</strong>也是⼀样的。 </p><h4 id="阻塞队列原理"><a href="#阻塞队列原理" class="headerlink" title="阻塞队列原理"></a>阻塞队列原理</h4><p>阻塞队列的原理很简单，利⽤了Lock锁的多条件（Condition）阻塞控制。接下来我们分析ArrayBlockingQueue JDK 1.8 的源码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数据元素数组</span></span><br><span class="line"><span class="keyword">final</span> Object[] items;</span><br><span class="line"><span class="comment">//下⼀个待取出元素索引</span></span><br><span class="line"><span class="keyword">int</span> takeIndex;</span><br><span class="line"><span class="comment">//下⼀个待添加元素索引</span></span><br><span class="line"><span class="keyword">int</span> putIndex;</span><br><span class="line"><span class="comment">//元素个数</span></span><br><span class="line"><span class="keyword">int</span> count;</span><br><span class="line"><span class="comment">//内部锁</span></span><br><span class="line"><span class="keyword">final</span> ReentrantLock lock;</span><br><span class="line"><span class="comment">//消费者监视器</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty;</span><br><span class="line"><span class="comment">//⽣产者监视器</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notFull; </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity, <span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line"> <span class="comment">//..省略其他代码</span></span><br><span class="line"> lock = <span class="keyword">new</span> ReentrantLock(fair);</span><br><span class="line"> notEmpty = lock.newCondition();</span><br><span class="line"> notFull = lock.newCondition();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="put-方法"><a href="#put-方法" class="headerlink" title="put 方法"></a>put 方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">     checkNotNull(e);</span><br><span class="line">     <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">     <span class="comment">// 1.⾃旋拿锁</span></span><br><span class="line">     lock.lockInterruptibly();</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">// 2.判断队列是否满了</span></span><br><span class="line">         <span class="keyword">while</span> (count == items.length)</span><br><span class="line">             <span class="comment">// 2.1如果满了，阻塞该线程，并标记为notFull线程，</span></span><br><span class="line">             <span class="comment">// 等待notFull的唤醒，唤醒之后继续执⾏while循环。</span></span><br><span class="line">             notFull.await();</span><br><span class="line">         <span class="comment">// 3.如果没有满，则进⼊队列</span></span><br><span class="line">         enqueue(e);</span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">         lock.unlock();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(E x)</span> </span>&#123;</span><br><span class="line">     <span class="comment">// assert lock.getHoldCount() == 1;</span></span><br><span class="line">     <span class="comment">// assert items[putIndex] == null;</span></span><br><span class="line">     <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line">     items[putIndex] = x;</span><br><span class="line">     <span class="keyword">if</span> (++putIndex == items.length)</span><br><span class="line">         putIndex = <span class="number">0</span>;</span><br><span class="line">     count++;</span><br><span class="line">     <span class="comment">// 4 唤醒⼀个等待的线程</span></span><br><span class="line">     notEmpty.signal();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="take-方法"><a href="#take-方法" class="headerlink" title="take 方法"></a>take 方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">     <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    <span class="comment">//自旋拿锁</span></span><br><span class="line">     lock.lockInterruptibly();</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="keyword">while</span> (count == <span class="number">0</span>)</span><br><span class="line">             notEmpty.await(); <span class="comment">//队列为空，阻塞该线程，直到队列不为空</span></span><br><span class="line">         <span class="keyword">return</span> dequeue();</span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">         lock.unlock();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="comment">// assert lock.getHoldCount() == 1;</span></span><br><span class="line"> <span class="comment">// assert items[takeIndex] != null;</span></span><br><span class="line">     <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line">     <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">     E x = (E) items[takeIndex];</span><br><span class="line">     items[takeIndex] = <span class="keyword">null</span>;</span><br><span class="line">     <span class="keyword">if</span> (++takeIndex == items.length)</span><br><span class="line">         takeIndex = <span class="number">0</span>;</span><br><span class="line">     count--;</span><br><span class="line">     <span class="keyword">if</span> (itrs != <span class="keyword">null</span>)</span><br><span class="line">         itrs.elementDequeued();</span><br><span class="line">     notFull.signal();<span class="comment">//唤醒一个等待的线程</span></span><br><span class="line">     <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用场景：生产者消费者"><a href="#使用场景：生产者消费者" class="headerlink" title="使用场景：生产者消费者"></a>使用场景：生产者消费者</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ArrayBlockingQueue&lt;Integer&gt; q = <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">10</span>);</span><br><span class="line">    Thread consumer = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">"取走："</span> + q.take() + <span class="string">" 剩余："</span> + q.size());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    Thread producer = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Integer num = (<span class="keyword">int</span>) (Math.random() * <span class="number">100</span>);</span><br><span class="line">                q.put(num);</span><br><span class="line">                System.out.println(<span class="string">"装入："</span> + num + <span class="string">" 剩余："</span> + q.size());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    producer.start();</span><br><span class="line">    consumer.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="锁接口和类"><a href="#锁接口和类" class="headerlink" title="锁接口和类"></a>锁接口和类</h3><h4 id="synchronized-不足之处"><a href="#synchronized-不足之处" class="headerlink" title="synchronized 不足之处"></a>synchronized 不足之处</h4><ul><li>如果临界区是只读的，synchronized 排他锁效率较低</li><li>synchronized 不知道线程有没有成功获得锁</li><li>使用 synchronized ，如果临界区阻塞，当前线程又没有释放锁，就会导致所有线程等待。</li></ul><h4 id="锁分类"><a href="#锁分类" class="headerlink" title="锁分类"></a>锁分类</h4><h5 id="可重入和非重入锁"><a href="#可重入和非重入锁" class="headerlink" title="可重入和非重入锁"></a>可重入和非重入锁</h5><p>支持线程对资源重复加锁，成为可重入锁。synchronized 也是可重入锁、ReentrantLock 也是可重入锁。</p><h5 id="公平锁和非公平锁"><a href="#公平锁和非公平锁" class="headerlink" title="公平锁和非公平锁"></a>公平锁和非公平锁</h5><p>按请求锁的顺序拥有锁，反之锁就是不公平的。非公平锁能提升一定的效率，但可能导致线程饥饿。ReentrantLock 支持公平和非公平锁。</p><h5 id="读写锁和排他锁"><a href="#读写锁和排他锁" class="headerlink" title="读写锁和排他锁"></a>读写锁和排他锁</h5><p>synchronized 和 ReentrantLock 都是排他锁，这些锁只允许一个线程进行访问。 Java 提供 ReentrantReadWriteLock 作为读写锁，内部维护了一个读锁和一个写锁，在读多写少的环境下，提高了性能。</p><h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><h4 id="什么是数据库-数据库管理系统-数据库系统-数据库管理员"><a href="#什么是数据库-数据库管理系统-数据库系统-数据库管理员" class="headerlink" title="什么是数据库,数据库管理系统,数据库系统,数据库管理员?"></a>什么是数据库,数据库管理系统,数据库系统,数据库管理员?</h4><ul><li><strong>数据库</strong> :数据库(DataBase 简称 DB)就是信息的集合或者说数据库是由数据库管理系统管理的数据的集合。</li><li><strong>数据库管理系统</strong> : 数据库管理系统(Database Management System 简称 DBMS)是一种操纵和管理数据库的大型软件，通常用语用于建立、使用和维护数据库。</li><li><strong>数据库系统</strong> : 数据库系统(Data Base System，简称 DBS)通常由软件、数据库和数据管理员(DBA)组成。</li><li><strong>数据库管理员</strong> : 数据库管理员(Database Administrator,简称 DBA)负责全面管理和控制数据库系统。</li></ul><h4 id="什么是元组-码-候选码-主码-外码-主属性-非主属性"><a href="#什么是元组-码-候选码-主码-外码-主属性-非主属性" class="headerlink" title="什么是元组,码,候选码,主码,外码,主属性,非主属性"></a>什么是元组,码,候选码,主码,外码,主属性,非主属性</h4><ul><li><strong>元组</strong> ： 元组（tuple）是关系数据库中的基本概念，关系是一张表，表中的每行就是一个元组，每列就是一个属性。</li><li><strong>码</strong> ：码就是能唯一标识实体的属性，对应表中的列。</li><li><strong>候选码</strong> ： 若关系中的某一属性或属性组的值能<strong>唯一的标识一个元组，而其任何、子集都不能再标识</strong>，则称该属性组为候选码。</li><li><strong>主码</strong> : 主码也叫主键。主码是从候选码中选出来的。 <strong>一个实体集中只能有一个主码，但可以有多个候选码</strong>。</li><li><strong>外码</strong> : 外码也叫外键。如果一个关系中的一个属性是另外一个关系中的主码则这个属性为外码。</li><li><strong>主属性</strong> ： <strong>候选码中出现过的属性称为主属性</strong>。</li><li><strong>非主属性：</strong> 不包含在任何一个候选码中的属性称为非主属性。</li></ul><h4 id="主键和外键有什么区别"><a href="#主键和外键有什么区别" class="headerlink" title="主键和外键有什么区别"></a>主键和外键有什么区别</h4><ul><li><strong>主键(主码)</strong> ：主键用于唯一标识一个元组，不能有重复，不允许为空。一个表只能有一个主键。</li><li><strong>外键(外码)</strong> ：外键用来和其他表建立联系用，外键是另一表的主键，外键是可以有重复的，可以是空值。一个表可以有多个外键。</li></ul><h4 id="什么是-ER-图"><a href="#什么是-ER-图" class="headerlink" title="什么是 ER 图"></a>什么是 ER 图</h4><p><strong>E-R 图</strong>也称实体-联系图(Entity Relationship Diagram)，提供了表示实体类型、属性和联系的方法，用来描述现实世界的概念模型。 它是描述现实世界关系概念模型的有效方法。 是表示概念关系模型的一种方式。</p><h4 id="数据库范式了解吗"><a href="#数据库范式了解吗" class="headerlink" title="数据库范式了解吗"></a>数据库范式了解吗</h4><p><strong>1NF(第一范式)</strong></p><p><strong>属性（对应于表中的字段）不能再被分割</strong>，也就是这个字段只能是一个值，不能再分为多个其他的字段了。<strong>1NF 是所有关系型数据库的最基本要求</strong> ，也就是说关系型数据库中创建的表一定满足第一范式。</p><p><strong>2NF(第二范式)</strong></p><p>2NF 在 1NF 的基础之上，<strong>消除了非主属性对于码的部分函数依赖</strong>。如下图所示，展示了第一范式到第二范式的过渡。第二范式在第一范式的基础上增加了一个列，这个列称为主键，非主属性都依赖于主键。</p><p>一些重要的概念：</p><ul><li><strong>函数依赖（functional dependency）</strong> ：若在一张表中，在属性（或属性组）X 的值确定的情况下，必定能确定属性 Y 的值，那么就可以说 Y 函数依赖于 X，写作 X → Y。</li><li><strong>部分函数依赖（partial functional dependency）</strong> ：如果 X→Y，并且存在 X 的一个真子集 X0，使得 X0→Y，则称 Y 对 X 部分函数依赖。比如学生基本信息表 R 中（学号，身份证号，姓名）当然学号属性取值是唯一的，在 R 关系中，（学号，身份证号）-&gt;（姓名），（学号）-&gt;（姓名），（身份证号）-&gt;（姓名）；所以姓名部分函数依赖与（学号，身份证号）；</li><li><strong>完全函数依赖(Full functional dependency)</strong> ：在一个关系中，若某个非主属性数据项依赖于全部关键字称之为完全函数依赖。比如学生基本信息表 R（学号，班级，姓名）假设不同的班级学号有相同的，班级内学号不能相同，在 R 关系中，（学号，班级）-&gt;（姓名），但是（学号）-&gt;(姓名)不成立，（班级）-&gt;(姓名)不成立，所以姓名完全函数依赖与（学号，班级）；</li><li><strong>传递函数依赖</strong> ： 在关系模式 R(U)中，设 X，Y，Z 是 U 的不同的属性子集，如果 X 确定 Y、Y 确定 Z，且有 X 不包含 Y，Y 不确定 X，（X∪Y）∩Z=空集合，则称 Z 传递函数依赖(transitive functional dependency) 于 X。传递函数依赖会导致数据冗余和异常。传递函数依赖的 Y 和 Z 子集往往同属于某一个事物，因此可将其合并放到一个表中。比如在关系 R(学号 ,姓名, 系名，系主任)中，学号 → 系名，系名 → 系主任，所以存在非主属性系主任对于学号的传递函数依赖。。</li></ul><p><strong>3NF(第三范式)</strong></p><p>3NF 在 2NF 的基础之上，消除了<strong>非主属性对于码的传递函数依赖</strong> 。符合 3NF 要求的数据库设计，<strong>基本</strong>上解决了数据冗余过大，插入异常，修改异常，删除异常的问题。比如在关系 R(学号 ,姓名, 系名，系主任)中，学号 → 系名，系名 → 系主任，所以存在非主属性系主任对于学号的传递函数依赖，所以该表的设计，不符合 3NF 的要求。</p><p><strong>总结</strong></p><ul><li>1NF：属性不可再分。</li><li>2NF：1NF 的基础之上，消除了非主属性对于码的部分函数依赖。</li><li>3NF：3NF 在 2NF 的基础之上，消除了非主属性对于码的传递函数依赖 。</li></ul><h4 id="什么是存储过程"><a href="#什么是存储过程" class="headerlink" title="什么是存储过程"></a>什么是存储过程</h4><p>我们可以把存储过程看成是一些 SQL 语句的集合，中间加了点逻辑控制语句。存储过程在业务比较复杂的时候是非常实用的，比如很多时候我们完成一个操作可能需要写一大串 SQL 语句，这时候我们就可以写有一个存储过程，这样也方便了我们下一次的调用。存储过程一旦调试完成通过后就能稳定运行，另外，使用存储过程比单纯 SQL 语句执行要快，因为存储过程是预编译过的。</p><p><strong>存储过程在互联网公司应用不多，因为存储过程难以调试和扩展，而且没有移植性，还会消耗数据库资源。</strong></p><h4 id="drop、delete-与-truncate-trvŋˈkeɪt-区别"><a href="#drop、delete-与-truncate-trvŋˈkeɪt-区别" class="headerlink" title="drop、delete 与 truncate ([trʌŋˈkeɪt]) 区别"></a>drop、delete 与 truncate ([trʌŋˈkeɪt]) 区别</h4><ul><li>drop(删除表结构及数据): <code>drop table 表名</code> ，直接将表都删除掉，在删除表的时候使用。</li><li>truncate (清空数据) : <code>truncate table 表名</code> ，<strong>只删除表中的数据，再插入数据的时候自增长 id 又从 1 开始</strong>。</li><li>delete（删除数据） : <code>delete from 表名 where 列名=值</code>，删除某一列的数据</li></ul><h4 id="数据库设计通常分为哪几步"><a href="#数据库设计通常分为哪几步" class="headerlink" title="数据库设计通常分为哪几步"></a>数据库设计通常分为哪几步</h4><ol><li><strong>需求分析</strong> : 分析用户的需求，包括数据、功能和性能需求。</li><li><strong>概念结构设计</strong> : 主要采用 E-R 模型进行设计，包括画 E-R 图。</li><li><strong>逻辑结构设计</strong> : 通过将 E-R 图转换成表，实现从 E-R 模型到关系模型的转换。</li><li><strong>物理结构设计</strong> : 主要是为所设计的数据库选择合适的存储结构和存取路径。</li><li><strong>数据库实施</strong> : 包括编程、测试和试运行</li><li><strong>数据库的运行和维护</strong> : 系统的运行与数据库的日常维护。</li></ol><h3 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h3><p>查看 MySQL 提供的所有存储引擎</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show engines</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/mysql-engines.png" alt="查看MySQL提供的所有存储引擎"></p><p><strong>查看表的存储引擎</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">table</span> <span class="keyword">status</span> <span class="keyword">like</span> <span class="string">"table_name"</span> ;</span><br></pre></td></tr></table></figure><h4 id="MyISAM-和-InnoDB-的区别"><a href="#MyISAM-和-InnoDB-的区别" class="headerlink" title="==MyISAM 和 InnoDB 的区别=="></a>==MyISAM 和 InnoDB 的区别==</h4><p>MySQL 5.5 之前，MyISAM 是默认的存储引擎，MyISAM 的性能还行，但它不支持事务和行级锁，而且最大的缺陷是崩溃后无法安全恢复。5.5 版本之后，MySQL 引入了 InnoDB。</p><ul><li><p>MyISAM 只有表级锁，InnoDB 支持行级锁，和表级锁，默认为行级锁。</p></li><li><p>MyISAM 不支持事务，InnoDB 支持，具有提交和回滚的能力</p></li><li><p>MyISAM 不支持外键，InnoDB 支持。一般不建议再数据库层使用外键，通常在应用层进行处理，不过这会对数据一致性造成威胁</p></li><li><p>MyISAM 不支持崩溃后安全恢复，InnoDB 支持。使用 InnoDB 的数据库在异常崩溃后，数据库重新启动时会恢复到崩溃前的状态，这个恢复过程基于 redo log</p></li></ul><p>🌈 拓展一下：</p><ul><li>MySQL InnoDB 引擎使用 <strong>redo log(重做日志)</strong> 保证事务的<strong>持久性</strong>，使用 <strong>undo log(回滚日志)</strong> 来保证事务的<strong>原子性</strong>。</li><li>MySQL InnoDB 引擎通过 <strong>锁机制</strong>、<strong>MVCC</strong> 等手段来保证事务的隔离性（ 默认支持的隔离级别是 <strong><code>REPEATABLE-READ</code></strong> ）。</li><li>保证了事务的持久性、原子性、隔离性之后，一致性才能得到保障。</li></ul><h3 id="锁机制与-InnoDB-锁算法"><a href="#锁机制与-InnoDB-锁算法" class="headerlink" title="锁机制与 InnoDB 锁算法"></a>锁机制与 InnoDB 锁算法</h3><p><strong>表级锁和行级锁对比：</strong></p><ul><li><strong>表级锁：</strong> MySQL 中锁定 <strong>粒度最大</strong> 的一种锁，对当前操作的整张表加锁，实现简单，资源消耗也比较少，加锁快，不会出现死锁。其锁定粒度最大，触发锁冲突的概率最高，并发度最低，MyISAM 和 InnoDB 引擎都支持表级锁。</li><li><strong>行级锁：</strong> MySQL 中锁定 <strong>粒度最小</strong> 的一种锁，只针对当前操作的行进行加锁。 行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。</li></ul><p><strong>InnoDB 存储引擎的锁的算法有三种：</strong></p><ul><li>Record lock：记录锁，单个行记录上的锁</li><li>Gap lock：间隙锁，锁定一个范围，不包括记录本身</li><li>Next-key lock：record+gap 临键锁，锁定一个范围，包含记录本身</li></ul><h3 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h3><p>执行查询语句的时候，会先查询缓存。不过，MySQL 8.0 版本后移除，因为这个功能不太实用</p><p><code>my.cnf</code> 加入以下配置，重启 MySQL 开启查询缓存</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">query_cache_type</span>=<span class="string">1</span></span><br><span class="line"><span class="attr">query_cache_size</span>=<span class="string">600000Copy to clipboardErrorCopied</span></span><br></pre></td></tr></table></figure><p>MySQL 执行以下命令也可以开启查询缓存</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">set</span> <span class="string">global  query_cache_type=1;</span></span><br><span class="line"><span class="attr">set</span> <span class="string">global  query_cache_size=600000;</span></span><br></pre></td></tr></table></figure><p>开启查询缓存后在同样的查询条件以及数据情况下，会直接在缓存中返回结果。查询条件包括：查询本身、当前药拆线呢的数据库、客户端协议版本号等一些可能影响结果的信息。</p><p>缓存不命中的情况：</p><ul><li>任何两个查询任何字符上的不同</li><li>查询中包含任何用户自定义函数、存储函数、用户变量、临时表、MySQL 中的系统表</li><li>缓存建立后，表（数据和结构）发生改变，与此表关联的所有缓存将失效</li></ul><p><strong>缓存虽然能够提升数据库的查询性能，但是缓存同时也带来了额外的开销，每次查询后都要做一次缓存操作，失效后还要销毁。</strong> 因此，开启查询缓存要谨慎，尤其对于写密集的应用来说更是如此。</p><p><strong>还可以通过 sql_cache 和 sql_no_cache 来控制某个查询语句是否需要缓存：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> sql_no_cache <span class="keyword">count</span>(*) <span class="keyword">from</span> usr;</span><br></pre></td></tr></table></figure><h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>事务是逻辑上的一组操作，要么都执行，要么都不执行。</p><h4 id="数据库事务"><a href="#数据库事务" class="headerlink" title="数据库事务"></a>数据库事务</h4><p>数据库事务可以保证多个对数据库的操作（也就是 SQL 语句）构成一个逻辑上的整体。构成这个逻辑上的整体的这些数据库操作遵循：<strong>要么全部执行成功,要么全部不执行</strong> 。</p><h4 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h4><p>关系型数据库（例如：<code>MySQL</code>、<code>SQL Server</code>、<code>Oracle</code> 等）事务都有 <strong>ACID</strong> 特性</p><ol><li><strong>原子性</strong>（<code>Atomicity</code>） ： <strong>事务是最小的执行单位</strong>，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；</li><li><strong>一致性</strong>（<code>Consistency</code>）： <strong>执行事务前后，数据保持一致</strong>，例如转账业务中，无论事务是否成功，转账者和收款人的总额应该是不变的；</li><li><strong>隔离性</strong>（<code>Isolation</code>）： 并发访问数据库时，<strong>一个用户的事务不被其他事务所干扰</strong>，各并发事务之间数据库是独立的；</li><li><strong>持久性</strong>（<code>Durability</code>）： <strong>一个事务被提交之后。它对数据库中数据的改变是持久的</strong>，即使数据库发生故障也不应该对其有任何影响。</li></ol><h4 id="数据库事务的实现原理"><a href="#数据库事务的实现原理" class="headerlink" title="数据库事务的实现原理"></a>数据库事务的实现原理</h4><p>MySQL InnoDB 引擎使用 <strong>redo log(重做日志)</strong> 保证事务的<strong>持久性</strong>，使用 <strong>undo log(回滚日志)</strong> 来保证事务的<strong>原子性</strong>。</p><p>MySQL InnoDB 引擎通过 <strong>锁机制</strong>、<strong>MVCC</strong> 等手段来保证事务的隔离性（ 默认支持的隔离级别是 <strong><code>REPEATABLE-READ</code></strong> ）。</p><p>保证了事务的持久性、原子性、隔离性之后，一致性才能得到保障。</p><h4 id="并发事务带来的问题"><a href="#并发事务带来的问题" class="headerlink" title="并发事务带来的问题"></a>并发事务带来的问题</h4><p>在典型应用程序中，多个事务并发运行，经常会操作相同的数据来完成各自的任务（多个用户对同一数据进行操作）。并发是必须的，但这会导致以下问题：</p><ul><li>脏读：当一个事务正在访问数据并对数据进行了修改，这种修改还没提交，另一个事务就读到了未提交的数据</li><li>丢失数据：当一个事务修改了数据后，修改还未提交，此时第二个事务也修改了数据，此时第一个事务的修改丢失</li><li>不可重复读：一个事务多次读同一数据，在多次读的过程中，另一个事务<strong>对数据进行了修改</strong>，这就发生了多次读数据不一样的情况</li><li>幻读：一个事务多次读同一数据，在多次读的过程中，另一个事务<strong>插入了一些数据</strong>，在随后的查询中，第一个事务就发现了一些原本不存在的数据</li></ul><h4 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h4><p>SQL 标准定义了四个隔离级别：</p><ul><li><strong>READ-UNCOMMITTED(读取未提交)：</strong> 最低的隔离级别，允许读取尚未提交的数据变更，<strong>可能会导致脏读、幻读或不可重复读</strong>。</li><li><strong>READ-COMMITTED(读取已提交)：</strong> 允许读取并发事务已经提交的数据，<strong>可以阻止脏读，但是幻读或不可重复读仍有可能发生</strong>。</li><li><strong>REPEATABLE-READ(可重复读)：</strong> 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，<strong>可以阻止脏读和不可重复读，但幻读仍有可能发生</strong>。</li><li><strong>SERIALIZABLE(可串行化)：</strong> 最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，<strong>该级别可以防止脏读、不可重复读以及幻读</strong>。</li></ul><hr><table><thead><tr><th>隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>READ-UNCOMMITTED</td><td>√</td><td>√</td><td>√</td></tr><tr><td>READ-COMMITTED</td><td>×</td><td>√</td><td>√</td></tr><tr><td>REPEATABLE-READ</td><td>×</td><td>×</td><td>√</td></tr><tr><td>SERIALIZABLE</td><td>×</td><td>×</td><td>×</td></tr></tbody></table><h4 id="MySQL-默认隔离级别"><a href="#MySQL-默认隔离级别" class="headerlink" title="MySQL 默认隔离级别"></a>MySQL 默认隔离级别</h4><p>MySQL InnoDB 存储引擎的默认支持的隔离级别是 <strong>REPEATABLE-READ（可重读）</strong>。</p><p><strong>MySQL InnoDB 的 REPEATABLE-READ（可重读）并不保证避免幻读，需要应用使用加锁读来保证。而这个加锁度使用到的机制就是 Next-Key Locks。</strong></p><p>因为隔离级别越低，事务请求的锁越少，所以大部分数据库系统的隔离级别都是 <strong>READ-COMMITTED(读取提交内容)</strong> ，但是你要知道的是 InnoDB 存储引擎默认使用 <strong>REPEATABLE-READ（可重读）</strong> 并不会有任何性能损失。</p><p>InnoDB 存储引擎在 <strong>分布式事务</strong> 的情况下一般会用到 <strong>SERIALIZABLE(可串行化)</strong> 隔离级别。</p><blockquote><p>InnoDB 存储引擎提供了对 XA 事务的支持，并通过 XA 事务来支持分布式事务的实现。分布式事务指的是允许多个独立的事务资源（transactional resources）参与到一个全局的事务中。事务资源通常是关系型数据库系统，但也可以是其他类型的资源。全局事务要求在其中的所有参与的事务要么都提交，要么都回滚，这对于事务原有的 ACID 要求又有了提高。另外，在使用分布式事务时，InnoDB 存储引擎的事务隔离级别必须设置为 SERIALIZABLE。</p></blockquote><h4 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h4><h5 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h5><p>重做日志用来实现事务的持久性，即 ACID 中的 D。其由两部分组成：内存中的<strong>重做日志缓冲（redo log buffer）</strong>，其是易失的；重做文件日志（redo log file），其是持久的。</p><p>InnoDB 是事务的存储引擎，其通过 Force Log at Commit 机制实现事务的持久化，即当事务提交（Commit）时，必须先将事务的所有日志写入到 redo log file 中持久化，待事务的 Commit 操作完成才算完成。redo log 基本上都是顺序写的，在数据库运行时不需要对 redo log 文件进行读取操作。</p><p>为了确保重做日志写入磁盘，必须进行一次 fsync 操作，清空 redo log buffer，刷盘到 redo log file 中。</p><p><strong>InnoDB 引擎刷盘策略</strong></p><p>参数 <code>innodb_flush_log_at_trx_commit</code>用来控制重做日志刷新到磁盘的策略，它支持 3 种策略：</p><ul><li>0 ，事务提交时不进行写入重做日志操作，这个操作仅在 master thread 完成，master thread 中每 1 秒会进行一次重做日志文件的 fsync 操作，还有一种情况，当 <code>redo log buffer</code> 占用的空间即将达到 <code>innodb_log_buffer_size</code> 一半的时候，后台线程会主动刷盘。<strong>如果 MySQL 挂了或宕机会有 1 秒的数据丢失</strong>。</li><li>1，为默认值。事务提交时必须调用一次 fsync 操作，只要事务提交成功 ，redo log 就一定在磁盘里，不会有任何数据丢失。如果事务执行期间 MySQL 挂了或宕机，这部分日志丢了，但事务没有提交，所以日志丢了也不会有损失</li><li>2，事务只要提交成功， redo log buffer 中的内容值写入文件系统缓存（page cache），<strong>如果仅仅只是 MySQL 挂了不会有任何损失，宕机可能会有 1 秒的数据损失。</strong></li></ul><p>虽然可以通过设置为 0 和 2 来提高事务提交的性能，但这种设置方法丧失了事务的 ACID 特性。</p><p><strong>为什么不直接把修改的数据刷回磁盘，而是采用 redo log 方式？</strong></p><p>数据页较大，把修改的数据也刷回磁盘时随机写，时间效率较低；如果写 redo log，一行记录占用空间较小，而且是顺序写，性能更好。</p><h5 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h5><p>事务有时需要进行回滚操作，这就需要 undo。在对数据库进行修改时，InnoDB 引擎不仅会产生 redo，还会产生一定量的 undo。如果用户执行的事务或语句由于某种原因失败了，又或者用户用一条 rollback 语句请求回滚，就可以利用这些 undo 信息将数据回滚到修改前的样子。</p><p>与 redo 不同，undo 存放在数据库内部的一个特殊段中，这个段称为 undo 段。许多用户常常有这样的误解：undo 用于将数据库物理地恢复到执行语句或事务之前的样子，但事实并非如此。比如一个事务在修改一个页中的某几条数据，但另一个事务在修改同一个页中的另外几条数据，<strong>不能将一个页回滚到事务开始的样子，这会影响到其他事务正在进行的任务</strong>。当用户 rollback 时，会将插入的事务进行回滚，但表空间的大小并不会因此收缩。对于每个 INSERT，InnoDB 会完成一个 DELETE；对于每个 DELETE，InnoDB 会执行一个 INSERT；对于每个 UPDATE，InnoDB 会执行一个相反的 UPDATE，将修改之前的行放回去。</p><p>除了回滚操作，undo 的另一个作用是 MVCC，当用户读取一行记录时，若该记录已经被其他事务占用，当前事务可以通过 undo 读取之前的行版本信息，以实现非锁定读取。</p><h5 id="binlog"><a href="#binlog" class="headerlink" title="binlog"></a>binlog</h5><p>==<strong>二进制日志（bin log）记录了对 MySQL 数据库执行更改的所有操作</strong>==，不包括 SELECT 和 SHOW 这类操作。若操作本身并没有导致数据库发生变化，那么该操作可能也会写入二进制日志。例如 <code>update t set a = 1 where a = 2</code>，没有 a = 2 的记录，也会写入 bin log。</p><p><code>binlog</code> 日志有三种格式，可以通过<code>binlog_format</code>参数指定。</p><ul><li><strong>statement</strong>，保存原始的 sql 语句，但对于<code>update T set update_time=now() where id=1</code>这条语句来说，直接执行会获取当前时间，这是不对的。</li><li><strong>row</strong>，包含操作的具体数据，<code>update_time=now()</code>变成了具体的时间<code>update_time=1627112756247</code>，@1 表示数据第一个字段的原始值</li><li><strong>mixed</strong>，当数据会产生不一致时使用 row，否则使用 statement</li></ul><h6 id="写入"><a href="#写入" class="headerlink" title="写入"></a>写入</h6><p><code>binlog</code>的写入时机也非常简单，事务执行过程中，先把日志写到<code>binlog cache</code>，事务提交的时候，再把<code>binlog cache</code>写到<code>binlog</code>文件中。因为一个事务的<code>binlog</code>不能被拆开，无论这个事务多大，也要确保一次性写入，所以系统会给每个线程分配一个块内存作为<code>binlog cache</code>。我们可以通过<code>binlog_cache_size</code>参数控制单个线程 binlog cache 大小，如果存储内容超过了这个参数，就要暂存到磁盘（<code>Swap</code>）。</p><p>和 redo log 一样也有 fsync 写入磁盘的策略：</p><p><code>write</code>和<code>fsync</code>的时机，可以由参数<code>sync_binlog</code>控制，默认是<code>0</code>。</p><ul><li><p>为<code>0</code>的时候，表示每次提交事务都只<code>write</code>，由系统自行判断什么时候执行<code>fsync</code>。虽然性能得到提升，但是机器宕机，<code>page cache</code>里面的 binglog 会丢失。</p></li><li><p>可以设置为<code>1</code>，表示每次提交事务都会执行<code>fsync</code>，就如同<strong>redo log 日志刷盘流程</strong>一样。</p></li><li><p>最后还有一种折中方式，可以设置为<code>N(N&gt;1)</code>，表示每次提交事务都<code>write</code>，但累积<code>N</code>个事务后才<code>fsync</code>。</p></li></ul><h6 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a>两阶段提交</h6><p><code>redo log</code>（重做日志）让<code>InnoDB</code>存储引擎拥有了崩溃恢复能力。<code>binlog</code>（归档日志）保证了<code>MySQL</code>集群架构的数据一致性。</p><p>虽然它们都属于持久化的保证，但是则重点不同。在执行更新语句过程，会记录<code>redo log</code>与<code>binlog</code>两块日志，以基本的事务为单位，<code>redo log</code>在事务执行过程中可以不断写入，而<code>binlog</code>只有在提交事务时才写入，所以<code>redo log</code>与<code>binlog</code>的写入时机不一样。</p><p>假设执行过程中写完<code>redo log</code>日志后，<code>binlog</code>日志写期间发生了异常，这会导致两个日志之间逻辑不一致，为了解决这个问题，InnoDB 使用两阶段提交方案，将 redo log 的写入拆成了两个步骤 prepare 和 commit</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/04.png" alt="img"></p><p>使用<strong>两阶段提交</strong>后，写入<code>binlog</code>时发生异常也不会有影响，因为<code>MySQL</code>根据<code>redo log</code>日志恢复数据时，发现<code>redo log</code>还处于<code>prepare</code>阶段，并且没有对应<code>binlog</code>日志，就会回滚该事务。</p><p>再看一个场景，<code>redo log</code>设置<code>commit</code>阶段发生异常，那会不会回滚事务呢？并不会回滚事务，它会执行上图框住的逻辑，虽然<code>redo log</code>是处于<code>prepare</code>阶段，但是能通过事务<code>id</code>找到对应的<code>binlog</code>日志，所以<code>MySQL</code>认为是完整的，就会提交事务恢复数据。</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20210907113348007.png" alt="image-20210907113348007"></p><h4 id="一致性非锁定读和锁定读"><a href="#一致性非锁定读和锁定读" class="headerlink" title="一致性非锁定读和锁定读"></a>一致性非锁定读和锁定读</h4><h5 id="一致性非锁定读"><a href="#一致性非锁定读" class="headerlink" title="一致性非锁定读"></a>一致性非锁定读</h5><p>指 InnoDB 存储引擎通过行多版本控制的方式来读取当前执行时间数据库中行的数据。如果去读的行正在执行 DELETE 或 UPDATE 操作，这时读取操作不会因此等待行上锁的释放。相反地，InnoDB 存储引擎会读取行的一个快照数据。快照数据指该行之前版本的数据，该实现是通过 undo 段来完成。</p><p>在事务隔离级别 READ COMMITTED 和 REPEATABLE READ下，InnoDB 使用非锁定的一致性读。在 READ COMMITTED 事务隔离级别下，对于快照数据，非一致读总是读取<strong>被锁定行的最新一份快照数</strong>据。而在 REPEATABLE READ 事务隔离级别下，对于快照数据，总是<strong>读取事务开始时的行数据版本</strong>。</p><p>在 <code>Repeatable Read</code> 和 <code>Read Committed</code> 两个隔离级别下，如果是执行普通的 <code>select</code> 语句（不包括 <code>select ... lock in share mode</code> ,<code>select ... for update</code>）则会使用 <code>一致性非锁定读（MVCC）</code>。并且在 <code>Repeatable Read</code> 下 <code>MVCC</code> 实现了可重复读和==<strong>防止部分幻读</strong>==</p><h5 id="锁定读"><a href="#锁定读" class="headerlink" title="锁定读"></a>锁定读</h5><p>如果执行的是下列语句，就是 锁定读（Locking Reads）</p><ul><li><code>select ... lock in share mode</code></li><li><code>select ... for update</code></li><li><code>insert</code>、<code>update</code>、<code>delete</code> 操作</li></ul><p>在锁定读下，读取的是数据的最新版本，这种读也被称为 <code>当前读（current read）</code>。锁定读会对读取到的记录加锁：</p><ul><li><code>select ... lock in share mode</code>：对记录加 <code>S</code> 锁，其它事务也可以加<code>S</code>锁，如果加 <code>x</code> 锁则会被阻塞</li><li><code>select ... for update</code>、<code>insert</code>、<code>update</code>、<code>delete</code>：对记录加 <code>X</code> 锁，且其它事务不能加任何锁</li></ul><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><p>索引是一种用于快速查询和检索数据的数据结构。常见的索引结构有：B 树、B+树和 Hash。</p><h4 id="索引的优缺点"><a href="#索引的优缺点" class="headerlink" title="索引的优缺点"></a>索引的优缺点</h4><p>优点：可以大大加快数据的检索速度（大大减少检索的数据量），通过创建唯一索引，可以保证数据库表中每一行数据的唯一性。</p><p>缺点：创建索引和维护索引需要耗费许多时间，当对表中的数据增删改时，如果有索引，也需要动态的修改索引，影响执行效率。索引需要使用物理文件存储，也会消耗一定空间。</p><p>大多数情况下，索引查询都是全表扫描快，如果数据量不大，索引也不一定带来很大提升。</p><h4 id="索引的底层数据结构"><a href="#索引的底层数据结构" class="headerlink" title="索引的底层数据结构"></a>索引的底层数据结构</h4><h5 id="Hash-表"><a href="#Hash-表" class="headerlink" title="Hash 表"></a>Hash 表</h5><p>哈希表是键值对的集合，通过键（key）可以快速取出对应的值（value），因此哈希表可以快速检索数据。处理 Hash 冲突的方法有链地址法和红黑树。</p><p>为什么 MySQL 没有使用其作为索引的数据结构？</p><ol><li>Hash 冲突问题</li><li>Hash 索引不支持顺序和范围查询，这是它最大的缺点</li></ol><p>例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> tb1 <span class="keyword">WHERE</span> <span class="keyword">id</span> &lt; <span class="number">500</span></span><br></pre></td></tr></table></figure><p>在这种情况下，Hash 索引只能把 1- 500 都进行一次hash计算来找到每一行记录，时间复杂度太高。</p><h5 id="B-树-amp-B-树"><a href="#B-树-amp-B-树" class="headerlink" title="B 树 &amp; B+ 树"></a>B 树 &amp; B+ 树</h5><p>B 树也称为 B- 树，全称为多路平衡树，B+ 树是 B 树的一种变体，B 树和 B+ 树中的 B 是 Balanced（平衡）的意思。</p><p><strong>B 树&amp; B+树两者有何异同呢？</strong></p><ul><li>B 树的<strong>所有节点既存放键(key) 也存放 数据(data)</strong>，而 <strong>B+树只有叶子节点存放 key 和 data，其他内节点只存放 key</strong>。</li><li>B 树的叶子节点都是独立的;B+树的叶子节点有一条引用链指向与它相邻的叶子节点。</li><li>B 树的检索的过程相当于对范围内的每个节点的关键字做二分查找，可能还没有到达叶子节点，检索就结束了。而 B+树的检索效率就很稳定了，任何查找都是从根节点到叶子节点的过程，叶子节点的顺序检索很明显。</li></ul><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20210906145735073.png" alt="image-20210906145735073"></p><blockquote><p>MyISAM 引擎中，B+Tree 叶节点的 data 域存放的是数据记录的地址。在索引检索的时候，首先按照 B+Tree 搜索算法搜索索引，如果指定的 Key 存在，则取出其 data 域的值，然后以 data 域的值为地址读取相应的数据记录。这被称为“非聚簇索引”。</p><p>InnoDB 引擎中，其数据文件本身就是索引文件。相比 MyISAM，索引文件和数据文件是分离的，其表数据文件本身就是按 B+Tree 组织的一个索引结构，树的叶节点 data 域保存了完整的数据记录。这个索引的 key 是数据表的主键，因此 InnoDB 表数据文件本身就是主索引。这被称为“聚簇索引（或聚集索引）”，而其余的索引都作为辅助索引，辅助索引的 data 域存储相应记录主键的值而不是地址，这也是和 MyISAM 不同的地方。在根据主索引搜索时，直接找到 key 所在的节点即可取出数据；在根据辅助索引查找时，则需要先取出主键的值，在走一遍主索引。 因此，在设计表的时候，不建议使用过长的字段作为主键，也不建议使用非单调的字段作为主键，这样会造成主索引频繁分裂。</p></blockquote><h4 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h4><h5 id="主键索引（primary-key）"><a href="#主键索引（primary-key）" class="headerlink" title="主键索引（primary key）"></a>主键索引（primary key）</h5><p>数据库的主键列使用的就是主键索引，一张数据表只能由一个主键，并且主键不能为 null，不能重复。</p><p>在 MySQL 的 InnoDB 中，当没有显示地指定表地主键时，InnoDB会自动先检查表中是否有唯一索引的字段，如果有，则选择该字段为默认的主键，否则 InnoDB 会自动创建一个 6B 的自增主键。</p><h5 id="二级索引（辅助索引）"><a href="#二级索引（辅助索引）" class="headerlink" title="二级索引（辅助索引）"></a>二级索引（辅助索引）</h5><p>二级索引又称为辅助索引，是因为<strong>二级索引的叶子节点存储的数据是主键</strong>。也就是说，通过二级索引，可以定位主键的位置。</p><p>唯一索引，普通索引，前缀索引等属于二级索引。</p><ol><li><strong>唯一索引(Unique Key)</strong> ：唯一索引也是一种约束。<strong>唯一索引的属性列不能出现重复的数据，但是允许数据为 NULL，一张表允许创建多个唯一索引。</strong> 建立唯一索引的目的大部分时候都是为了该属性列的数据的唯一性，而不是为了查询效率。</li><li><strong>普通索引(Index)</strong> ：<strong>普通索引的唯一作用就是为了快速查询数据，一张表允许创建多个普通索引，并允许数据重复和 NULL。</strong></li><li><strong>前缀索引(Prefix)</strong> ：前缀索引只适用于字符串类型的数据。前缀索引是对文本的前几个字符创建索引，相比普通索引建立的数据更小， 因为只取前几个字符。</li><li><strong>全文索引(Full Text)</strong> ：全文索引主要是为了检索大文本数据中的关键字的信息，是目前搜索引擎数据库使用的一种技术。Mysql5.6 之前只有 MYISAM 引擎支持全文索引，5.6 之后 InnoDB 也支持了全文索引。</li></ol><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20210906150839294.png" alt="image-20210906150839294"></p><h4 id="聚集索引与非聚集索引"><a href="#聚集索引与非聚集索引" class="headerlink" title="聚集索引与非聚集索引"></a>聚集索引与非聚集索引</h4><h5 id="聚集索引"><a href="#聚集索引" class="headerlink" title="聚集索引"></a><strong>聚集索引</strong></h5><p><strong>结构和数据一起存放的索引，主键索引属于聚集索引。</strong></p><blockquote><p>在 Mysql 中，InnoDB 引擎的表的 <code>.ibd</code>文件就包含了该表的索引和数据，对于 InnoDB 引擎表来说，该表的索引(B+树)的每个非叶子节点存储索引，叶子节点存储索引和索引对应的数据。</p></blockquote><p>聚集索引优点：查询速度快，因为整个 B+ 树本身就是一颗多叉平衡树，叶子节点也是有序的，定位到索引的节点，就相当于定位到了数据。</p><p>聚集索引的缺点：</p><ol><li><strong>依赖于有序的数据</strong>：因为 B+ 树是多路平衡树，如果索引的数据不是有序的，就需要在插入时排序，当数据是字符串或者 UUID 这种又长又没有顺序的数据，插入或查找的速度肯定比较慢。</li><li><strong>更新代价大</strong>：如果对索引列的数据被修改时，那么对应的索引也将会被修改，所以对于主键索引来说，主键一般是不可以修改的。</li></ol><h5 id="非聚集索引"><a href="#非聚集索引" class="headerlink" title="非聚集索引"></a><strong>非聚集索引</strong></h5><p><strong>结构和数据分开的索引</strong></p><p><strong>二级索引属于非聚集索引。</strong></p><blockquote><p>MYISAM 引擎的表的.MYI 文件包含了表的索引， 该表的索引(B+树)的每个叶子非叶子节点存储索引， 叶子节点存储索引和索引对应数据的指针，指向.MYD 文件的数据。</p><p><strong>非聚集索引的叶子节点并不一定存放数据的指针， 因为二级索引的叶子节点就存放的是主键，根据主键再回表查数据。</strong></p></blockquote><p>非聚集索引的优点</p><p><strong>更新代价比聚集索引要小</strong> 。非聚集索引的更新代价就没有聚集索引那么大了，非聚集索引的叶子节点是不存放数据的</p><p>非聚集索引的缺点</p><ol><li>跟聚集索引一样，非聚集索引也依赖于有序的数据</li><li>==<strong>可能会二次查询(回表)</strong>== :这应该是非聚集索引最大的缺点了。 <strong>当查到索引对应的指针或主键后，可能还需要根据指针或主键再到数据文件或表中查询</strong>。</li></ol><p>这是 MySQL 的表的文件截图:</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/20210420165311654.png" alt="img"></p><p>聚集索引和非聚集索引:</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/20210420165326946.png" alt="img"></p><p>非聚集索引一定回表查询吗？（覆盖索引）</p><p>非聚集索引不一定回表查询。</p><p>如果仅仅查询索引本身的信息，那么无需回表查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">name</span> <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> <span class="keyword">name</span>=<span class="string">'guang19'</span>;</span><br></pre></td></tr></table></figure><h4 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h4><p>如果一个索引包含（或者说覆盖）所有要查询的字段的值，我们就称之为“覆盖索引“。</p><p>在 InnoDB 存储引擎中，如果不是主键索引，叶子节点存储的是主键+列值。最终还是要通过主键查询一次，这样就会比较慢。覆盖索引就是把要查询的列和索引对应，不做回表操作。</p><p>覆盖索引，即要查询的字段正好是索引的字段，那么直接根据该索引，就可查到数据了，无需回表查询。</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20211017161206969.png" alt="image-20211017161206969"></p><h4 id="创建索引的注意事项"><a href="#创建索引的注意事项" class="headerlink" title="创建索引的注意事项"></a>创建索引的注意事项</h4><ol><li><p><strong>选择合适的字段创建索引</strong></p><ul><li><strong>不为 Null 的字段</strong>，索引字段的数据应该尽量不为 Null，对于数据为Null 的字段，数据库较难优化。</li><li><strong>频繁查询的字段</strong></li><li><strong>条件查询的字段</strong>，被作为 WHERE 条件查询的字段，应该被考虑建立索引 </li><li><strong>频繁需要排序的字段</strong>，索引已经排序，可以利用这个特性加快排序查询时间</li><li><strong>频繁用于连接的字段</strong>，提高多表连接查询的效率</li></ul></li><li><p><strong>被频繁更新的字段应该慎重建立索引</strong></p><p>索引能提高查询的性能，但同时维护索引的成本也不小，如果字段少查询、多修改，这个字段就不适合建立索引</p></li><li><p><strong>尽可能建立联合索引而不是单列索引</strong></p><p>每个索引都对应一颗 B+ 树，如果一个表的字段过多，索引过多，那么占用的磁盘空间也很多。如果是联合索引（多列索引），多个字段在一个索引上，那么会节约很多磁盘空间。</p></li><li><p><strong>避免冗余索引</strong></p><p>冗余索引指的是索引的功能相同，能够命中索引(a, b)就肯定能命中索引(a) ，那么索引(a)就是冗余索引。如（name,city ）和（name ）这两个索引就是冗余索引</p></li><li><p><strong>考虑在字符串类型的字段上使用前缀索引代替普通索引</strong></p><p>前缀索引仅限于字符串类型，较普通索引会占用更小的空间。</p></li></ol><h4 id="使用索引的一些建议"><a href="#使用索引的一些建议" class="headerlink" title="使用索引的一些建议"></a>使用索引的一些建议</h4><ul><li>特大型表不适合建索引，维护开销会很大</li><li>避免 where 子句中对字段施加函数，这会造成无法命中索引</li><li>在使用 InnoDB 时，使用与业务无关的自增主键作为主键</li><li>删除长时间未使用的索引</li><li>在使用 limit 查询缓慢时，可借助索引来提高性能</li></ul><h4 id="MySQL-为表字段添加索引"><a href="#MySQL-为表字段添加索引" class="headerlink" title="MySQL 为表字段添加索引"></a>MySQL 为表字段添加索引</h4><ol><li><p>主键索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="string">`table_name`</span> <span class="keyword">ADD</span> PRIMARY <span class="keyword">KEY</span> ( <span class="string">`column`</span> )</span><br></pre></td></tr></table></figure></li><li><p>唯一索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="string">`table_name`</span> <span class="keyword">ADD</span> <span class="keyword">UNIQUE</span> ( <span class="string">`column`</span> )</span><br></pre></td></tr></table></figure></li><li><p>普通索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="string">`table_name`</span> <span class="keyword">ADD</span> <span class="keyword">INDEX</span> index_name ( <span class="string">`column`</span> )</span><br></pre></td></tr></table></figure></li><li><p>全文索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="string">`table_name`</span> <span class="keyword">ADD</span> FULLTEXT ( <span class="string">`column`</span>)</span><br></pre></td></tr></table></figure></li><li><p>多列索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="string">`table_name`</span> <span class="keyword">ADD</span> <span class="keyword">INDEX</span> index_name ( <span class="string">`column1`</span>, <span class="string">`column2`</span>, <span class="string">`column3`</span> )</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Java&quot;&gt;&lt;a href=&quot;#Java&quot; class=&quot;headerlink&quot; title=&quot;Java&quot;&gt;&lt;/a&gt;Java&lt;/h1&gt;&lt;p&gt;八股文集合&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>动态规划总结</title>
    <link href="https://hoo334.github.io/2021/07/31/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%80%BB%E7%BB%93/"/>
    <id>https://hoo334.github.io/2021/07/31/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%80%BB%E7%BB%93/</id>
    <published>2021-07-31T07:58:56.000Z</published>
    <updated>2021-08-24T08:24:13.069Z</updated>
    
    <content type="html"><![CDATA[<h3 id="坐标型动态规划"><a href="#坐标型动态规划" class="headerlink" title="坐标型动态规划"></a>坐标型动态规划</h3><p>是最简单的动态规划类型，通常给定一个序列或网格，记为 A。需要找到序列中某个/些子序列或网格中的某条路径</p><ol><li>某种性质最大/最小</li><li>计数</li><li>存在性</li></ol><a id="more"></a><p>动态规划方程 <code>f[i]</code>中的下标 <code>i</code>表示以<code>A[i]</code>为结尾的满足条件的子序列性质，<code>f[i][j]</code>中的下标<code>i, j</code>表示以<code>A[i][j]</code>为结尾的满足条件的路径的性质。这些性质可能是：</p><ul><li>最大值/最小值</li><li>个数</li><li>是否存在</li></ul><p>坐标型动态规划的初始条件<code>f[0]</code>就是指以<code>A[0]</code>为结尾的子序列的性质，对于网格，初始条件<code>f[0][0]</code>就是以<code>A[0][0]</code>为结尾的子序列的性质。</p><p><a href="https://leetcode-cn.com/problems/longest-continuous-increasing-subsequence/" target="_blank" rel="noopener">674. 最长连续递增序列</a></p><p><a href="https://leetcode-cn.com/problems/minimum-path-sum/" target="_blank" rel="noopener">64. 最小路径和</a></p><p><a href="https://www.lintcode.com/problem/553/" target="_blank" rel="noopener">553 · 炸弹袭击 - LintCode</a></p><h3 id="序列型动态规划"><a href="#序列型动态规划" class="headerlink" title="序列型动态规划"></a>序列型动态规划</h3><p>给定一个序列，动态规划方程 <code>f[i]</code>中的下标 <code>i</code>表示前 <code>i</code>个元素 A[0], A[1], …, A[i - 1]的某种性质，初始化时<code>f[0]</code>表示空序列的性质。</p><p><a href="https://www.lintcode.com/problem/516/" target="_blank" rel="noopener">516 · 房屋染色 II - LintCode</a></p><p><a href="https://www.lintcode.com/problem/392/" target="_blank" rel="noopener">392 · 打劫房屋 - LintCode</a></p><p><a href="https://www.lintcode.com/problem/534/" target="_blank" rel="noopener">534 · 打劫房屋 II - LintCode</a></p><p><a href="https://www.lintcode.com/problem/149/" target="_blank" rel="noopener">149 · 买卖股票的最佳时机 - LintCode</a></p><p><a href="https://www.lintcode.com/problem/150/" target="_blank" rel="noopener">150 · 买卖股票的最佳时机 II - LintCode</a></p><p><a href="https://www.lintcode.com/problem/151/" target="_blank" rel="noopener">151 · 买卖股票的最佳时机 III - LintCode</a></p><p><a href="https://www.lintcode.com/problem/393/" target="_blank" rel="noopener">393 · 买卖股票的最佳时机 IV - LintCode</a></p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20210803154845696.png" alt="image-20210803154845696"></p><h3 id="最长序列型动态规划"><a href="#最长序列型动态规划" class="headerlink" title="最长序列型动态规划"></a>最长序列型动态规划</h3><p>给定一个序列，要求找出符合条件的最长子序列</p><p>方法：</p><ul><li>记录以每个元素 i 结尾的最长子序列的长度</li><li>计算时，在 i 之前枚举子序列的上一个元素</li></ul><p><a href="https://www.lintcode.com/problem/397/" target="_blank" rel="noopener">397 · 最长上升连续子序列 - LintCode</a></p><p><a href="https://www.lintcode.com/problem/76/" target="_blank" rel="noopener">76 · 最长上升子序列 - LintCode</a></p><p><a href="https://www.lintcode.com/problem/602/" target="_blank" rel="noopener">602 · 俄罗斯套娃信封 - LintCode</a></p><h3 id="划分型动态规划"><a href="#划分型动态规划" class="headerlink" title="划分型动态规划"></a>划分型动态规划</h3><p><a href="https://www.lintcode.com/problem/513" target="_blank" rel="noopener">513 · 完美平方 - LintCode</a></p><p><a href="https://www.lintcode.com/problem/108/" target="_blank" rel="noopener">108 · 分割回文串（二） - LintCode</a></p><p><a href="https://www.lintcode.com/problem/437/" target="_blank" rel="noopener">437 · 书籍复印 - LintCode</a></p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20210803155745658.png" alt="image-20210803155745658"></p><h3 id="博弈型动态规划"><a href="#博弈型动态规划" class="headerlink" title="博弈型动态规划"></a>博弈型动态规划</h3><p><a href="https://www.lintcode.com/problem/394/" target="_blank" rel="noopener">394 · 硬币排成线 - LintCode</a></p><h3 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h3><p><a href="https://www.lintcode.com/problem/92/" target="_blank" rel="noopener">92 · 背包问题 - LintCode</a></p><p><a href="https://www.lintcode.com/problem/563/" target="_blank" rel="noopener">563 · 背包问题 V - LintCode</a></p><p><a href="https://www.lintcode.com/problem/564/" target="_blank" rel="noopener">564 · 组合总和 IV - LintCode</a></p><p><a href="https://www.lintcode.com/problem/125/" target="_blank" rel="noopener">125 · 背包问题（二） - LintCode</a></p><p><a href="https://www.lintcode.com/problem/440/" target="_blank" rel="noopener">440 · 背包问题 III - LintCode</a></p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20210805110903881.png" alt="image-20210805110903881"></p><h3 id="区间型动态规划"><a href="#区间型动态规划" class="headerlink" title="区间型动态规划"></a>区间型动态规划</h3><p>给定一个序列/字符串，进行一些操作，最后一步将序列/字符串去头去尾， 剩下的会是一个区间<code>[i, j]</code>，状态自然定义为 <code>f[i][j]</code>，表示面对子序列<code>[i, ..., j]</code>时的最优性质。</p><p>  <a href="https://www.lintcode.com/problem/667/" target="_blank" rel="noopener">667 · 最长的回文序列 - LintCode</a></p><p><a href="https://www.lintcode.com/problem/396/" target="_blank" rel="noopener">396 · 硬币排成线 III - LintCode</a></p><p><a href="https://www.lintcode.com/problem/430/" target="_blank" rel="noopener">430 · 攀爬字符串 - LintCode</a></p><p><a href="https://www.lintcode.com/problem/168/" target="_blank" rel="noopener">168 · 吹气球 - LintCode</a></p><h3 id="双序列型动态规划"><a href="#双序列型动态规划" class="headerlink" title="双序列型动态规划"></a>双序列型动态规划</h3><p><a href="https://www.lintcode.com/problem/77" target="_blank" rel="noopener">77 · 最长公共子序列 - LintCode</a></p><p><a href="https://www.lintcode.com/problem/29" target="_blank" rel="noopener">29 · 交叉字符串 - LintCode</a></p><p><a href="https://www.lintcode.com/problem/119" target="_blank" rel="noopener">119 · 编辑距离 - LintCode</a></p><p><a href="https://www.lintcode.com/problem/118/" target="_blank" rel="noopener">118 · 不同的子序列 - LintCode</a></p><p><a href="https://www.lintcode.com/problem/154/" target="_blank" rel="noopener">154 · 正则表达式匹配 - LintCode</a></p><p><a href="https://www.lintcode.com/problem/192/" target="_blank" rel="noopener">192 · 通配符匹配 - LintCode</a></p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20210808203541323.png" alt="image-20210808203541323"></p><p><a href="https://www.lintcode.com/problem/668/" target="_blank" rel="noopener">668 · 一和零 - LintCode</a></p><p><a href="https://www.lintcode.com/problem/91/" target="_blank" rel="noopener">91 · 最小调整代价 - LintCode</a></p><p><a href="https://www.lintcode.com/problem/622/" target="_blank" rel="noopener">622 · 青蛙跳 - LintCode</a></p><p><a href="https://www.lintcode.com/problem/436/" target="_blank" rel="noopener">436 · 最大正方形 - LintCode</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;坐标型动态规划&quot;&gt;&lt;a href=&quot;#坐标型动态规划&quot; class=&quot;headerlink&quot; title=&quot;坐标型动态规划&quot;&gt;&lt;/a&gt;坐标型动态规划&lt;/h3&gt;&lt;p&gt;是最简单的动态规划类型，通常给定一个序列或网格，记为 A。需要找到序列中某个/些子序列或网格中的某条路径&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;某种性质最大/最小&lt;/li&gt;
&lt;li&gt;计数&lt;/li&gt;
&lt;li&gt;存在性&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="动态规划" scheme="https://hoo334.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>连续的子数组和</title>
    <link href="https://hoo334.github.io/2021/06/03/%E8%BF%9E%E7%BB%AD%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C/"/>
    <id>https://hoo334.github.io/2021/06/03/%E8%BF%9E%E7%BB%AD%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C/</id>
    <published>2021-06-03T02:44:31.000Z</published>
    <updated>2021-06-03T03:24:30.104Z</updated>
    
    <content type="html"><![CDATA[<h4 id="523-连续的子数组和"><a href="#523-连续的子数组和" class="headerlink" title="523. 连续的子数组和"></a><a href="https://leetcode-cn.com/problems/continuous-subarray-sum/" target="_blank" rel="noopener">523. 连续的子数组和</a></h4><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，编写一个函数来判断该数组是否含有同时满足下述条件的连续子数组：</p><ul><li>子数组大小 <strong>至少为 2</strong> ，且</li><li>子数组元素总和为 <code>k</code> 的倍数。</li></ul><p>如果存在，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p>如果存在一个整数 <code>n</code> ，令整数 <code>x</code> 符合 <code>x = n * k</code> ，则称 <code>x</code> 是 <code>k</code> 的一个倍数。</p> <a id="more"></a><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [23,2,4,6,7], k &#x3D; 6</span><br><span class="line">输出：true</span><br><span class="line">解释：[2,4] 是一个大小为 2 的子数组，并且和为 6 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [23,2,6,4,7], k &#x3D; 6</span><br><span class="line">输出：true</span><br><span class="line">解释：[23, 2, 6, 4, 7] 是大小为 5 的子数组，并且和为 42 。 </span><br><span class="line">42 是 6 的倍数，因为 42 &#x3D; 7 * 6 且 7 是一个整数。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [23,2,6,4,7], k &#x3D; 13</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p> <strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 105</code></li><li><code>0 &lt;= nums[i] &lt;= 109</code></li><li><code>0 &lt;= sum(nums[i]) &lt;= 231 - 1</code></li><li><code>1 &lt;= k &lt;= 231 - 1</code></li></ul><p><strong>方法一：前缀和+哈希表</strong></p><p>使用暴力直接枚举所有大小大于 2 的子数组，判断子数组和是否为 k 的倍数。这样做时间复杂度为 O(n^3)。</p><p>我们可以使用前缀和，这样就可以在 O(1) 时间内判断子数组和是否为 k 的倍数。</p><p>用 prefixSum[i] 表示 nums  从下标 0  到下标 i 的前缀和，则 nums 从下标 p + 1 到下标 q 的子数组长度为 q - p，该子数组的元素和为 prefixSum[q] - prefixSum[p]。</p><p>如果 prefixSum[q] - prefixSun[p] 为 k 的倍数，且 q - p &gt;= 2，则上述子数组即满足大小至少为 2 且元素和为 k 的倍数。</p><p>我们只需保存<strong>每个下标对应的前缀和除 k 的余数</strong>即可，使用哈希表存储每个余数第一次出现的下标。</p><p>规定空的前缀的结束下标为 -1，在哈希表中存入键值对(0, -1)。从小到大依次遍历每个 i ，计算每个下标对应的前缀和除以 k 的余数，并维护哈希表。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkSubarraySum</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> remainder = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            remainder = (remainder + nums[i]) % k; <span class="comment">//计算前缀和除 k 的余数</span></span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(remainder))&#123;<span class="comment">//如果存在余数，直接减去见面这个子数组就能得到和为 k 的倍数的子数组</span></span><br><span class="line">                <span class="keyword">int</span> preIndex = map.get(remainder);</span><br><span class="line">                <span class="keyword">if</span>(i - preIndex &gt;= <span class="number">2</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                map.put(remainder, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度O(m)，m 是数组 nums 的长度</li><li>空间复杂度最大O(m)</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;523-连续的子数组和&quot;&gt;&lt;a href=&quot;#523-连续的子数组和&quot; class=&quot;headerlink&quot; title=&quot;523. 连续的子数组和&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/continuous-subarray-sum/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;523. 连续的子数组和&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;给你一个整数数组 &lt;code&gt;nums&lt;/code&gt; 和一个整数 &lt;code&gt;k&lt;/code&gt; ，编写一个函数来判断该数组是否含有同时满足下述条件的连续子数组：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;子数组大小 &lt;strong&gt;至少为 2&lt;/strong&gt; ，且&lt;/li&gt;
&lt;li&gt;子数组元素总和为 &lt;code&gt;k&lt;/code&gt; 的倍数。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果存在，返回 &lt;code&gt;true&lt;/code&gt; ；否则，返回 &lt;code&gt;false&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;如果存在一个整数 &lt;code&gt;n&lt;/code&gt; ，令整数 &lt;code&gt;x&lt;/code&gt; 符合 &lt;code&gt;x = n * k&lt;/code&gt; ，则称 &lt;code&gt;x&lt;/code&gt; 是 &lt;code&gt;k&lt;/code&gt; 的一个倍数。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode Medium" scheme="https://hoo334.github.io/tags/Leetcode-Medium/"/>
    
      <category term="哈希表" scheme="https://hoo334.github.io/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>元素和为目标值的子矩阵数量</title>
    <link href="https://hoo334.github.io/2021/05/29/%E5%85%83%E7%B4%A0%E5%92%8C%E4%B8%BA%E7%9B%AE%E6%A0%87%E5%80%BC%E7%9A%84%E5%AD%90%E7%9F%A9%E9%98%B5%E6%95%B0%E9%87%8F/"/>
    <id>https://hoo334.github.io/2021/05/29/%E5%85%83%E7%B4%A0%E5%92%8C%E4%B8%BA%E7%9B%AE%E6%A0%87%E5%80%BC%E7%9A%84%E5%AD%90%E7%9F%A9%E9%98%B5%E6%95%B0%E9%87%8F/</id>
    <published>2021-05-29T02:30:18.000Z</published>
    <updated>2021-05-29T02:50:14.328Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1074-元素和为目标值的子矩阵数量"><a href="#1074-元素和为目标值的子矩阵数量" class="headerlink" title="1074. 元素和为目标值的子矩阵数量"></a><a href="https://leetcode-cn.com/problems/number-of-submatrices-that-sum-to-target/" target="_blank" rel="noopener">1074. 元素和为目标值的子矩阵数量</a></h4><p>给出矩阵 <code>matrix</code> 和目标值 <code>target</code>，返回元素总和等于目标值的非空子矩阵的数量。</p><p>子矩阵 <code>x1, y1, x2, y2</code> 是满足 <code>x1 &lt;= x &lt;= x2</code> 且 <code>y1 &lt;= y &lt;= y2</code> 的所有单元 <code>matrix[x][y]</code> 的集合。</p><p>如果 <code>(x1, y1, x2, y2)</code> 和 <code>(x1&#39;, y1&#39;, x2&#39;, y2&#39;)</code> 两个子矩阵中部分坐标不同（如：<code>x1 != x1&#39;</code>），那么这两个子矩阵也不同。</p><a id="more"></a><p><strong>示例 1：</strong></p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20210529103118283.png" alt="image-20210529103118283"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix &#x3D; [[0,1,0],[1,1,1],[0,1,0]], target &#x3D; 0</span><br><span class="line">输出：4</span><br><span class="line">解释：四个只含 0 的 1x1 子矩阵。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix &#x3D; [[1,-1],[-1,1]], target &#x3D; 0</span><br><span class="line">输出：5</span><br><span class="line">解释：两个 1x2 子矩阵，加上两个 2x1 子矩阵，再加上一个 2x2 子矩阵。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix &#x3D; [[904]], target &#x3D; 0</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure><p> <strong>提示：</strong></p><ul><li><code>1 &lt;= matrix.length &lt;= 100</code></li><li><code>1 &lt;= matrix[0].length &lt;= 100</code></li><li><code>-1000 &lt;= matrix[i] &lt;= 1000</code></li><li><code>-10^8 &lt;= target &lt;= 10^8</code></li></ul><p><strong>方法一：前缀和</strong></p><p>我们枚举 子矩阵的上下边界，并计算该边界内每列元素的和，则原问题转换为：</p><blockquote><p>给定一个整数数组和一个整数 target，计算该数组中子数组和等于 target 的子数组个数。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numSubmatrixSumTarget</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = matrix.length, n = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123; <span class="comment">// 枚举上边界</span></span><br><span class="line">            <span class="keyword">int</span>[] nums = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; m; j++)&#123; <span class="comment">//枚举下边界</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; n; c++)&#123;</span><br><span class="line">                    nums[c] += matrix[j][c]; <span class="comment">//逐行增加 nums 数组，避免重复计算</span></span><br><span class="line">                &#125;</span><br><span class="line">                ret += subArraySum(nums, target);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//计算子数组和等于 target 的子数组个数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">subArraySum</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="comment">//key 为子数组和，value 为子数组个数</span></span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">//初始化一个子数组和为 0 ，个数为 1</span></span><br><span class="line">        map.put(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// ret 为返回结果，cur 为前缀和变量</span></span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>, cur = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">            cur += num;</span><br><span class="line">            <span class="comment">//判断是否存在一个子数组加上 target 等于当前前缀和 cur，子数组的个数就是 子数组和为target的子数组个数</span></span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(cur - target))&#123;</span><br><span class="line">                ret += map.get(cur - target);</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(cur, map.getOrDefault(cur, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>时间复杂度：O(M^2*n)，其中 m 和 n 分别是矩阵 matrix 的行数和列数。</p></li><li><p>空间复杂度：O(n)。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1074-元素和为目标值的子矩阵数量&quot;&gt;&lt;a href=&quot;#1074-元素和为目标值的子矩阵数量&quot; class=&quot;headerlink&quot; title=&quot;1074. 元素和为目标值的子矩阵数量&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/number-of-submatrices-that-sum-to-target/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;1074. 元素和为目标值的子矩阵数量&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;给出矩阵 &lt;code&gt;matrix&lt;/code&gt; 和目标值 &lt;code&gt;target&lt;/code&gt;，返回元素总和等于目标值的非空子矩阵的数量。&lt;/p&gt;
&lt;p&gt;子矩阵 &lt;code&gt;x1, y1, x2, y2&lt;/code&gt; 是满足 &lt;code&gt;x1 &amp;lt;= x &amp;lt;= x2&lt;/code&gt; 且 &lt;code&gt;y1 &amp;lt;= y &amp;lt;= y2&lt;/code&gt; 的所有单元 &lt;code&gt;matrix[x][y]&lt;/code&gt; 的集合。&lt;/p&gt;
&lt;p&gt;如果 &lt;code&gt;(x1, y1, x2, y2)&lt;/code&gt; 和 &lt;code&gt;(x1&amp;#39;, y1&amp;#39;, x2&amp;#39;, y2&amp;#39;)&lt;/code&gt; 两个子矩阵中部分坐标不同（如：&lt;code&gt;x1 != x1&amp;#39;&lt;/code&gt;），那么这两个子矩阵也不同。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode Hard" scheme="https://hoo334.github.io/tags/Leetcode-Hard/"/>
    
      <category term="哈希表" scheme="https://hoo334.github.io/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
      <category term="数组" scheme="https://hoo334.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>汉明距离总和</title>
    <link href="https://hoo334.github.io/2021/05/28/%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB%E6%80%BB%E5%92%8C/"/>
    <id>https://hoo334.github.io/2021/05/28/%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB%E6%80%BB%E5%92%8C/</id>
    <published>2021-05-28T01:21:51.000Z</published>
    <updated>2021-05-28T01:30:20.479Z</updated>
    
    <content type="html"><![CDATA[<h4 id="477-汉明距离总和"><a href="#477-汉明距离总和" class="headerlink" title="477. 汉明距离总和"></a><a href="https://leetcode-cn.com/problems/total-hamming-distance/" target="_blank" rel="noopener">477. 汉明距离总和</a></h4><p>两个整数的 <a href="https://baike.baidu.com/item/汉明距离/475174?fr=aladdin" target="_blank" rel="noopener">汉明距离</a> 指的是这两个数字的二进制数对应位不同的数量。</p><p>计算一个数组中，任意两个数之间汉明距离的总和。</p><a id="more"></a><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入: 4, 14, 2</span><br><span class="line"></span><br><span class="line">输出: 6</span><br><span class="line"></span><br><span class="line">解释: 在二进制表示中，4表示为0100，14表示为1110，2表示为0010。（这样表示是为了体现后四位之间关系）</span><br><span class="line">所以答案为：</span><br><span class="line">HammingDistance(4, 14) + HammingDistance(4, 2) + HammingDistance(14, 2) &#x3D; 2 + 2 + 2 &#x3D; 6.</span><br></pre></td></tr></table></figure><p><strong>注意:</strong></p><ol><li>数组中元素的范围为从 <code>0</code>到 <code>10^9</code>。</li><li>数组的长度不超过 <code>10^4</code>。</li></ol><p><strong>方法一：逐位统计</strong></p><p>在计算汉明距离时，我们考虑的是同一比特位上的值是否不同，而不同比特位之间是互不影响的。</p><p>对于数组 nums 中的某个元素 val，若其二进制的第 i 位为 1，我们只需统计 nums 中有多少元素的第 i 位为 0 ，这样就就得到了 val 与其他元素在第 i 位上的汉明距离之和。</p><p>若长度为 n 的数组 nums 的所有元素二进制的第 i 位共有 c 个 1， n - c 个 0，这些元素在二进制第 i 位上的汉明距离位<code>c * (n - c)</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">totalHammingDistance</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">30</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">                c += (num &gt;&gt; i) &amp; <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ret += c * (n - c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度O(n * L)，n 为数组长度，L  = 30</li><li>空间复杂度O(1)</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;477-汉明距离总和&quot;&gt;&lt;a href=&quot;#477-汉明距离总和&quot; class=&quot;headerlink&quot; title=&quot;477. 汉明距离总和&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/total-hamming-distance/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;477. 汉明距离总和&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;两个整数的 &lt;a href=&quot;https://baike.baidu.com/item/汉明距离/475174?fr=aladdin&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;汉明距离&lt;/a&gt; 指的是这两个数字的二进制数对应位不同的数量。&lt;/p&gt;
&lt;p&gt;计算一个数组中，任意两个数之间汉明距离的总和。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode Medium" scheme="https://hoo334.github.io/tags/Leetcode-Medium/"/>
    
      <category term="位运算" scheme="https://hoo334.github.io/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>栈的压入、弹出序列</title>
    <link href="https://hoo334.github.io/2021/05/26/%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%E3%80%81%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97/"/>
    <id>https://hoo334.github.io/2021/05/26/%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%E3%80%81%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97/</id>
    <published>2021-05-26T12:26:58.000Z</published>
    <updated>2021-05-26T13:12:38.492Z</updated>
    
    <content type="html"><![CDATA[<h4 id="剑指-Offer-31-栈的压入、弹出序列"><a href="#剑指-Offer-31-栈的压入、弹出序列" class="headerlink" title="剑指 Offer 31. 栈的压入、弹出序列"></a><a href="https://leetcode-cn.com/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/" target="_blank" rel="noopener">剑指 Offer 31. 栈的压入、弹出序列</a></h4><p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如，序列 {1,2,3,4,5} 是某栈的压栈序列，序列 {4,5,3,2,1} 是该压栈序列对应的一个弹出序列，但 {4,3,5,1,2} 就不可能是该压栈序列的弹出序列。</p> <a id="more"></a><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：pushed &#x3D; [1,2,3,4,5], popped &#x3D; [4,5,3,2,1]</span><br><span class="line">输出：true</span><br><span class="line">解释：我们可以按以下顺序执行：</span><br><span class="line">push(1), push(2), push(3), push(4), pop() -&gt; 4,</span><br><span class="line">push(5), pop() -&gt; 5, pop() -&gt; 3, pop() -&gt; 2, pop() -&gt; 1</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：pushed &#x3D; [1,2,3,4,5], popped &#x3D; [4,3,5,1,2]</span><br><span class="line">输出：false</span><br><span class="line">解释：1 不能在 2 之前弹出。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li><code>0 &lt;= pushed.length == popped.length &lt;= 1000</code></li><li><code>0 &lt;= pushed[i], popped[i] &lt; 1000</code></li><li><code>pushed</code> 是 <code>popped</code> 的排列。</li></ol><p><strong>方法一：栈</strong></p><p>我们可以模拟做类似题时的思路：如果栈顶数字不等于当前出栈数字，将入栈序列中的数字依次加入栈中，直到栈顶元素与当前出栈数字相等。</p><p>以示例 1 为例，idx1 指向压入序列，idx2 指向弹出序列。</p><ol><li>栈为空，先将 1 压入栈中</li><li>栈顶数字 1 与数字 4 不相等，继续将 2 压入栈中</li><li>栈顶数字 2 与数字 4 不相等，继续将 3 压入栈中</li><li>栈顶数字 3 与数字 4 不相等，继续将 4 压入栈中</li><li>栈顶数字 4 与数字 4 相等，</li><li>栈顶数字 3 与数字 4 不相等，继续将 4 压入栈中</li><li>栈顶数字 5 与数字 5 相等，将 idx1 和 idx2 后移</li><li>数字 3 与栈顶数字 3 相等，idx2 后移，弹出栈顶元素</li><li>数字 2 与栈顶数字 2 相等，idx2 后移，弹出栈顶元素</li><li>数字 1 与栈顶数字 1 相等，idx2 后移，弹出栈顶元素</li><li>此时栈为空，代表第二个序列是第一个序列的弹出序列，返回 true。</li></ol><p>如果出现栈顶元素与当前弹出数字不相同且 idx1 已经指向入栈序列末尾，返回 false。</p><p>下图可以辅助理解</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/1.jpg" alt="1"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validateStackSequences</span><span class="params">(<span class="keyword">int</span>[] pushed, <span class="keyword">int</span>[] popped)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pushed.length != popped.length)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> n = popped.length;</span><br><span class="line">        Deque&lt;Integer&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> idx1 = <span class="number">0</span>, idx2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(idx2 &lt; n)&#123;</span><br><span class="line">            <span class="comment">//栈为空或者栈顶元素不等于当前弹出数字，直接将当前数字加入栈中</span></span><br><span class="line">            <span class="keyword">while</span>(idx1 &lt; n &amp;&amp; (stack.isEmpty() || stack.peek() != popped[idx2]))&#123;</span><br><span class="line">                stack.push(pushed[idx1]);</span><br><span class="line">                ++idx1;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//栈顶元素等于当前弹出数字</span></span><br><span class="line">            <span class="keyword">if</span>(stack.peek() == popped[idx2])&#123;</span><br><span class="line">                ++idx2;</span><br><span class="line">                stack.pop();</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="comment">//栈顶元素不等于当前弹出数字，出栈序列与入栈序列不匹配</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度O(n)</li><li>空间复杂度O(n)</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;剑指-Offer-31-栈的压入、弹出序列&quot;&gt;&lt;a href=&quot;#剑指-Offer-31-栈的压入、弹出序列&quot; class=&quot;headerlink&quot; title=&quot;剑指 Offer 31. 栈的压入、弹出序列&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;剑指 Offer 31. 栈的压入、弹出序列&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如，序列 {1,2,3,4,5} 是某栈的压栈序列，序列 {4,5,3,2,1} 是该压栈序列对应的一个弹出序列，但 {4,3,5,1,2} 就不可能是该压栈序列的弹出序列。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode Medium" scheme="https://hoo334.github.io/tags/Leetcode-Medium/"/>
    
      <category term="栈" scheme="https://hoo334.github.io/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>制作m束花所需的最少天数</title>
    <link href="https://hoo334.github.io/2021/05/09/%E5%88%B6%E4%BD%9Cm%E6%9D%9F%E8%8A%B1%E6%89%80%E9%9C%80%E7%9A%84%E6%9C%80%E5%B0%91%E5%A4%A9%E6%95%B0/"/>
    <id>https://hoo334.github.io/2021/05/09/%E5%88%B6%E4%BD%9Cm%E6%9D%9F%E8%8A%B1%E6%89%80%E9%9C%80%E7%9A%84%E6%9C%80%E5%B0%91%E5%A4%A9%E6%95%B0/</id>
    <published>2021-05-09T01:51:41.000Z</published>
    <updated>2021-05-09T02:30:41.930Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1482-制作-m-束花所需的最少天数"><a href="#1482-制作-m-束花所需的最少天数" class="headerlink" title="1482. 制作 m 束花所需的最少天数"></a><a href="https://leetcode-cn.com/problems/minimum-number-of-days-to-make-m-bouquets/" target="_blank" rel="noopener">1482. 制作 m 束花所需的最少天数</a></h4><p>给你一个整数数组 <code>bloomDay</code>，以及两个整数 <code>m</code> 和 <code>k</code> 。</p><p>现需要制作 <code>m</code> 束花。制作花束时，需要使用花园中 <strong>相邻的 <code>k</code> 朵花</strong> 。</p><p>花园中有 <code>n</code> 朵花，第 <code>i</code> 朵花会在 <code>bloomDay[i]</code> 时盛开，<strong>恰好</strong> 可以用于 <strong>一束</strong> 花中。</p><p>请你返回从花园中摘 <code>m</code> 束花需要等待的最少的天数。如果不能摘到 <code>m</code> 束花则返回 <strong>-1</strong> 。</p> <a id="more"></a><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：bloomDay &#x3D; [1,10,3,10,2], m &#x3D; 3, k &#x3D; 1</span><br><span class="line">输出：3</span><br><span class="line">解释：让我们一起观察这三天的花开过程，x 表示花开，而 _ 表示花还未开。</span><br><span class="line">现在需要制作 3 束花，每束只需要 1 朵。</span><br><span class="line">1 天后：[x, _, _, _, _]   &#x2F;&#x2F; 只能制作 1 束花</span><br><span class="line">2 天后：[x, _, _, _, x]   &#x2F;&#x2F; 只能制作 2 束花</span><br><span class="line">3 天后：[x, _, x, _, x]   &#x2F;&#x2F; 可以制作 3 束花，答案为 3</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：bloomDay &#x3D; [1,10,3,10,2], m &#x3D; 3, k &#x3D; 2</span><br><span class="line">输出：-1</span><br><span class="line">解释：要制作 3 束花，每束需要 2 朵花，也就是一共需要 6 朵花。而花园中只有 5 朵花，无法满足制作要求，返回 -1 。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：bloomDay &#x3D; [7,7,7,7,12,7,7], m &#x3D; 2, k &#x3D; 3</span><br><span class="line">输出：12</span><br><span class="line">解释：要制作 2 束花，每束需要 3 朵。</span><br><span class="line">花园在 7 天后和 12 天后的情况如下：</span><br><span class="line">7 天后：[x, x, x, x, _, x, x]</span><br><span class="line">可以用前 3 朵盛开的花制作第一束花。但不能使用后 3 朵盛开的花，因为它们不相邻。</span><br><span class="line">12 天后：[x, x, x, x, x, x, x]</span><br><span class="line">显然，我们可以用不同的方式制作两束花。</span><br></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：bloomDay &#x3D; [1000000000,1000000000], m &#x3D; 1, k &#x3D; 1</span><br><span class="line">输出：1000000000</span><br><span class="line">解释：需要等 1000000000 天才能采到花来制作花束</span><br></pre></td></tr></table></figure><p><strong>示例 5：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：bloomDay &#x3D; [1,10,2,9,3,8,4,7,5,6], m &#x3D; 4, k &#x3D; 2</span><br><span class="line">输出：9</span><br></pre></td></tr></table></figure><p> <strong>提示：</strong></p><ul><li><code>bloomDay.length == n</code></li><li><code>1 &lt;= n &lt;= 10^5</code></li><li><code>1 &lt;= bloomDay[i] &lt;= 10^9</code></li><li><code>1 &lt;= m &lt;= 10^6</code></li><li><code>1 &lt;= k &lt;= n</code></li></ul><p><strong>方法一：二分查找</strong></p><p>为了计算制作花束的最少天数，首先需要实现一个辅助函数用于判断在给定的天数内能否制作出指定数量的花束。我们可以遍历数组 bloomDay，计算其中的长度为 k 且最大元素不超过 days 的补充和的连续子数组额数量，如果符合要求的不重合连续子数组的数量大于或等于 m 则返回 True，否则返回 false。</p><p>当 days 很小时，辅助函数总是返回 false，引文天数太少不能收齐 m 个花束；当 days 很大的时候辅助函数总是返回 true，如果给定的序列可以制作出 m 个花束。在 days 慢慢变大的过程中，辅助函数的返回值会从false变为 true，所以我们可以认为这个辅助函数是关于 days 递增的，于是可以通过二分查找得到最少天数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDays</span><span class="params">(<span class="keyword">int</span>[] bloomDay, <span class="keyword">int</span> m, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(k * m &gt; bloomDay.length)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">1</span>, high = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> length = bloomDay.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++)&#123;</span><br><span class="line">            high = Math.max(high, bloomDay[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(low &lt; high)&#123;</span><br><span class="line">            <span class="keyword">int</span> days = (high - low) / <span class="number">2</span> + low;</span><br><span class="line">            <span class="keyword">if</span>(canMake(bloomDay, days, m, k))&#123;</span><br><span class="line">                high = days;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="comment">//从左向右逼近</span></span><br><span class="line">                low = days + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> low;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">canMake</span><span class="params">(<span class="keyword">int</span>[] bloomDay, <span class="keyword">int</span> days, <span class="keyword">int</span> m, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> bouquets = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> flowers = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> length = bloomDay.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length &amp;&amp; bouquets &lt; m; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(bloomDay[i] &lt;= days)&#123;</span><br><span class="line">                flowers++;</span><br><span class="line">                <span class="keyword">if</span>(flowers == k)&#123;</span><br><span class="line">                    bouquets++;</span><br><span class="line">                    flowers = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                flowers = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bouquets &gt;= m;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度 <em>O</em>(<em>n</em>log<em>h</em>) ，n 是数组 bloomDay 的长度，h 是数组 bloomDay 中的最大值。</li><li>空间复杂度O(1)</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1482-制作-m-束花所需的最少天数&quot;&gt;&lt;a href=&quot;#1482-制作-m-束花所需的最少天数&quot; class=&quot;headerlink&quot; title=&quot;1482. 制作 m 束花所需的最少天数&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/minimum-number-of-days-to-make-m-bouquets/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;1482. 制作 m 束花所需的最少天数&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;给你一个整数数组 &lt;code&gt;bloomDay&lt;/code&gt;，以及两个整数 &lt;code&gt;m&lt;/code&gt; 和 &lt;code&gt;k&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;现需要制作 &lt;code&gt;m&lt;/code&gt; 束花。制作花束时，需要使用花园中 &lt;strong&gt;相邻的 &lt;code&gt;k&lt;/code&gt; 朵花&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;花园中有 &lt;code&gt;n&lt;/code&gt; 朵花，第 &lt;code&gt;i&lt;/code&gt; 朵花会在 &lt;code&gt;bloomDay[i]&lt;/code&gt; 时盛开，&lt;strong&gt;恰好&lt;/strong&gt; 可以用于 &lt;strong&gt;一束&lt;/strong&gt; 花中。&lt;/p&gt;
&lt;p&gt;请你返回从花园中摘 &lt;code&gt;m&lt;/code&gt; 束花需要等待的最少的天数。如果不能摘到 &lt;code&gt;m&lt;/code&gt; 束花则返回 &lt;strong&gt;-1&lt;/strong&gt; 。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode Medium" scheme="https://hoo334.github.io/tags/Leetcode-Medium/"/>
    
      <category term="二分查找" scheme="https://hoo334.github.io/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>在D天内送达包裹的能力</title>
    <link href="https://hoo334.github.io/2021/04/28/%E5%9C%A8D%E5%A4%A9%E5%86%85%E9%80%81%E8%BE%BE%E5%8C%85%E8%A3%B9%E7%9A%84%E8%83%BD%E5%8A%9B/"/>
    <id>https://hoo334.github.io/2021/04/28/%E5%9C%A8D%E5%A4%A9%E5%86%85%E9%80%81%E8%BE%BE%E5%8C%85%E8%A3%B9%E7%9A%84%E8%83%BD%E5%8A%9B/</id>
    <published>2021-04-28T01:56:34.000Z</published>
    <updated>2021-04-28T03:13:44.217Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1011-在-D-天内送达包裹的能力"><a href="#1011-在-D-天内送达包裹的能力" class="headerlink" title="1011. 在 D 天内送达包裹的能力"></a><a href="https://leetcode-cn.com/problems/capacity-to-ship-packages-within-d-days/" target="_blank" rel="noopener">1011. 在 D 天内送达包裹的能力</a></h4><p>传送带上的包裹必须在 D 天内从一个港口运送到另一个港口。</p><p>传送带上的第 <code>i</code> 个包裹的重量为 <code>weights[i]</code>。每一天，我们都会按给出重量的顺序往传送带上装载包裹。我们装载的重量不会超过船的最大运载重量。</p><p>返回能在 <code>D</code> 天内将传送带上的所有包裹送达的船的最低运载能力。</p> <a id="more"></a><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入：weights &#x3D; [1,2,3,4,5,6,7,8,9,10], D &#x3D; 5</span><br><span class="line">输出：15</span><br><span class="line">解释：</span><br><span class="line">船舶最低载重 15 就能够在 5 天内送达所有包裹，如下所示：</span><br><span class="line">第 1 天：1, 2, 3, 4, 5</span><br><span class="line">第 2 天：6, 7</span><br><span class="line">第 3 天：8</span><br><span class="line">第 4 天：9</span><br><span class="line">第 5 天：10</span><br><span class="line"></span><br><span class="line">请注意，货物必须按照给定的顺序装运，因此使用载重能力为 14 的船舶并将包装分成 (2, 3, 4, 5), (1, 6, 7), (8), (9), (10) 是不允许的。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：weights &#x3D; [3,2,2,4,1,4], D &#x3D; 3</span><br><span class="line">输出：6</span><br><span class="line">解释：</span><br><span class="line">船舶最低载重 6 就能够在 3 天内送达所有包裹，如下所示：</span><br><span class="line">第 1 天：3, 2</span><br><span class="line">第 2 天：2, 4</span><br><span class="line">第 3 天：1, 4</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：weights &#x3D; [1,2,3,1,1], D &#x3D; 4</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">第 1 天：1</span><br><span class="line">第 2 天：2</span><br><span class="line">第 3 天：3</span><br><span class="line">第 4 天：1, 1</span><br></pre></td></tr></table></figure><p> <strong>提示：</strong></p><ul><li><code>1 &lt;= D &lt;= weights.length &lt;= 5 * 104</code></li><li><code>1 &lt;= weights[i] &lt;= 500</code></li></ul><p><strong>方法一：二分查找转化为判定问题</strong></p><p>假设当船的运载能力为 x 时，我们可以在 D 天内送完所有包裹，那么只要运载能力大于 x，我们同样可以在 D 天内运送完所有包裹，我们只需使用运载能力为 x 的运送方法即可。</p><p>在二分查找过程中，我们需要解决一个判定问题：给定船的运载能力 x，我们是否可以在 D 天内运送完所有包裹？这可以通过贪心来解决：</p><blockquote><p>由于我们必须按照数组 weights 中包裹的顺序进行运送，将连续的包裹都安排在同一天进行运送，当这批包裹重量大于 x 时，我们需要将最后一个包裹安排在下一天运送。当遍历完整个数组后，就得到了最少需要运送的天数。</p></blockquote><p>我们将在「最少需要运送的天数」与 D 比较，当其小于 D 时，证明我们的运载能力较强，可以适当减少，因此我们忽略二分的右半区间。当其大于 D 时，证明我们的运载能力较弱，需要增加，我们忽略二分的左半区间。</p><p>二分初始边界：</p><p>对于左边界而言，由于我们不能拆分一个包裹，因此船的运载能力不能小于包裹中最重的包裹，即左边界为 weights 数组中元素的最大值</p><p>对于右边界而言，船的运载能力也不会超过所有包裹的重量之和，即右边界为数组 weights 中元素的和。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">shipWithinDays</span><span class="params">(<span class="keyword">int</span>[] weights, <span class="keyword">int</span> D)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 确定二分查找左右边界</span></span><br><span class="line">        <span class="keyword">int</span> left = Arrays.stream(weights).max().getAsInt(), right = Arrays.stream(weights).sum();</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="comment">//判断运载能力为 mid 时，需要的天数</span></span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">// need 为需要运送的天数</span></span><br><span class="line">            <span class="comment">// cur 为当前这一天已经运送的包裹重量之和</span></span><br><span class="line">            <span class="keyword">int</span> need = <span class="number">1</span>, cur = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> weight : weights) &#123;</span><br><span class="line">                <span class="keyword">if</span> (cur + weight &gt; mid) &#123;</span><br><span class="line">                    ++need;</span><br><span class="line">                    cur = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                cur += weight;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//需要的天数小于 D，运载能力较强，舍弃右半区间</span></span><br><span class="line">            <span class="keyword">if</span> (need &lt;= D) &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">//需要的天数大于 D，运载能力较弱，舍弃左半区间</span></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>时间复杂度：<img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20210428111123523.png" alt="image-20210428111123523"></p></li><li><p>空间复杂度O(1)</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1011-在-D-天内送达包裹的能力&quot;&gt;&lt;a href=&quot;#1011-在-D-天内送达包裹的能力&quot; class=&quot;headerlink&quot; title=&quot;1011. 在 D 天内送达包裹的能力&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/capacity-to-ship-packages-within-d-days/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;1011. 在 D 天内送达包裹的能力&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;传送带上的包裹必须在 D 天内从一个港口运送到另一个港口。&lt;/p&gt;
&lt;p&gt;传送带上的第 &lt;code&gt;i&lt;/code&gt; 个包裹的重量为 &lt;code&gt;weights[i]&lt;/code&gt;。每一天，我们都会按给出重量的顺序往传送带上装载包裹。我们装载的重量不会超过船的最大运载重量。&lt;/p&gt;
&lt;p&gt;返回能在 &lt;code&gt;D&lt;/code&gt; 天内将传送带上的所有包裹送达的船的最低运载能力。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode Medium" scheme="https://hoo334.github.io/tags/Leetcode-Medium/"/>
    
      <category term="二分查找" scheme="https://hoo334.github.io/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>组合总和Ⅳ</title>
    <link href="https://hoo334.github.io/2021/04/28/%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C%E2%85%A3/"/>
    <id>https://hoo334.github.io/2021/04/28/%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C%E2%85%A3/</id>
    <published>2021-04-28T01:20:32.000Z</published>
    <updated>2021-08-24T08:25:30.967Z</updated>
    
    <content type="html"><![CDATA[<h4 id="377-组合总和-Ⅳ"><a href="#377-组合总和-Ⅳ" class="headerlink" title="377. 组合总和 Ⅳ"></a><a href="https://leetcode-cn.com/problems/combination-sum-iv/" target="_blank" rel="noopener">377. 组合总和 Ⅳ</a></h4><p>给你一个由 <strong>不同</strong> 整数组成的数组 <code>nums</code> ，和一个目标整数 <code>target</code> 。请你从 <code>nums</code> 中找出并返回总和为 <code>target</code> 的元素组合的个数。</p><p>题目数据保证答案符合 32 位整数范围。</p> <a id="more"></a><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [1,2,3], target &#x3D; 4</span><br><span class="line">输出：7</span><br><span class="line">解释：</span><br><span class="line">所有可能的组合为：</span><br><span class="line">(1, 1, 1, 1)</span><br><span class="line">(1, 1, 2)</span><br><span class="line">(1, 2, 1)</span><br><span class="line">(1, 3)</span><br><span class="line">(2, 1, 1)</span><br><span class="line">(2, 2)</span><br><span class="line">(3, 1)</span><br><span class="line">请注意，顺序不同的序列被视作不同的组合。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [9], target &#x3D; 3</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 200</code></li><li><code>1 &lt;= nums[i] &lt;= 1000</code></li><li><code>nums</code> 中的所有元素 <strong>互不相同</strong></li><li><code>1 &lt;= target &lt;= 1000</code></li></ul><p><strong>进阶：</strong>如果给定的数组中含有负数会发生什么？问题会产生何种变化？如果允许负数出现，需要向题目中添加哪些限制条件？</p><p><strong>方法一：回溯（超时）</strong></p><p>我们可以画出搜索路径，很自然写出如下回溯代码</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20210428094002017.png" alt="image-20210428094002017"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">combinationSum4</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> start = <span class="number">0</span>; start &lt; n; ++start)&#123;</span><br><span class="line">            res += backtrack(nums, target, nums[start]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target, <span class="keyword">int</span> cur)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">if</span>(cur &gt; target)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(target == cur)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//每次进入下一层都是从 1 开始</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            res += backtrack(nums, target, cur + nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>方法二：动态规划</strong></p><p>用 dp[x] 选取的元素之和等于 x 的方案数，目标是求 dp[target]。动态规划的边界是 dp[0] = 1。只有当不选取任何元素时，元素之和才为 0 ，因此只有 1 种方案。</p><p>当 <code>1 &lt;= i &lt;= target</code>时，如果存在一种排列，其元素之和等于 i，则该排列最后一个元素一定是数组 nums 种的元素。假设该排列最后一个元素是 num，则一定有 num &lt;= i，对于元素之和等于 i - num 的每一种排列，在最后添加 num 之后可以得到一个元素之和等于 i 的排列，因此在计算 dp[i] 时，应该计算所有的 dp[i - num] 之和。</p><p>当 <code>1 &lt;= i &lt;= target</code>时，得到如下转移方程：<br>$$<br>dp[i] = sum(dp[i - num]), num \leq i<br>$$<br>初始状态 dp[0] = 1。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">combinationSum4</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[target + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; dp.length; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">                <span class="keyword">if</span>(num &lt;= i)&#123;</span><br><span class="line">                    dp[i] += dp[i - num];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度O(target * n)，target 是 目标值，n 是 数组 nums 的长度。</li><li>空间复杂度O(target)</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;377-组合总和-Ⅳ&quot;&gt;&lt;a href=&quot;#377-组合总和-Ⅳ&quot; class=&quot;headerlink&quot; title=&quot;377. 组合总和 Ⅳ&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/combination-sum-iv/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;377. 组合总和 Ⅳ&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;给你一个由 &lt;strong&gt;不同&lt;/strong&gt; 整数组成的数组 &lt;code&gt;nums&lt;/code&gt; ，和一个目标整数 &lt;code&gt;target&lt;/code&gt; 。请你从 &lt;code&gt;nums&lt;/code&gt; 中找出并返回总和为 &lt;code&gt;target&lt;/code&gt; 的元素组合的个数。&lt;/p&gt;
&lt;p&gt;题目数据保证答案符合 32 位整数范围。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode Medium" scheme="https://hoo334.github.io/tags/Leetcode-Medium/"/>
    
      <category term="动态规划" scheme="https://hoo334.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>最大整除子集</title>
    <link href="https://hoo334.github.io/2021/04/23/%E6%9C%80%E5%A4%A7%E6%95%B4%E9%99%A4%E5%AD%90%E9%9B%86/"/>
    <id>https://hoo334.github.io/2021/04/23/%E6%9C%80%E5%A4%A7%E6%95%B4%E9%99%A4%E5%AD%90%E9%9B%86/</id>
    <published>2021-04-23T02:30:25.000Z</published>
    <updated>2021-08-24T08:26:01.846Z</updated>
    
    <content type="html"><![CDATA[<h4 id="368-最大整除子集"><a href="#368-最大整除子集" class="headerlink" title="368. 最大整除子集"></a><a href="https://leetcode-cn.com/problems/largest-divisible-subset/" target="_blank" rel="noopener">368. 最大整除子集</a></h4><p>给你一个由 <strong>无重复</strong> 正整数组成的集合 <code>nums</code> ，请你找出并返回其中最大的整除子集 <code>answer</code> ，子集中每一元素对 <code>(answer[i], answer[j])</code> 都应当满足：</p><ul><li><code>answer[i] % answer[j] == 0</code> ，或</li><li><code>answer[j] % answer[i] == 0</code></li></ul><p>如果存在多个有效解子集，返回其中任何一个均可。</p> <a id="more"></a><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [1,2,3]</span><br><span class="line">输出：[1,2]</span><br><span class="line">解释：[1,3] 也会被视为正确答案。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [1,2,4,8]</span><br><span class="line">输出：[1,2,4,8]</span><br></pre></td></tr></table></figure><p> <strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 1000</code></li><li><code>1 &lt;= nums[i] &lt;= 2 * 109</code></li><li><code>nums</code> 中的所有整数 <strong>互不相同</strong></li></ul><p><strong>方法一：动态规划</strong></p><ol><li>求最大整除子集的长度</li></ol><p>我们首先将输入数组按照升序排序，以便获得一个子集的最小整数或最大整数。dp[i] 定义为：以nums[i] 为最大整数的<strong>有序</strong>整除子集的数字个数，nums[i] 必须被选择。</p><p>从小到大计算 dp 数组的值，在计算 dp[i] 之前，我们已经计算出 dp[0 … i - 1]的值，状态转移方程为：<br>$$<br>dp[i] = max(dp[j]) + 1, 其中 0 \leq j&lt;i 且\ nums[i]\  %\  nums[j] == 0<br>$$<br>最大整除子集长度就是 dp 数组中的最大值。</p><p>在遍历过程中我们保存最大整除子集的长度 maxSize 和子集中的最大数字 maxVal。</p><ol start="2"><li>倒序找出最大整除子集</li></ol><p>假设输入数组为[2,4,7,8,9,12,16,18](已经有序)，得到的动态规划表格如下：</p><table><thead><tr><th>nums</th><th>2</th><th>4</th><th>7</th><th>8</th><th>9</th><th>12</th><th>16</th><th>18</th></tr></thead><tbody><tr><td>dp</td><td>1</td><td>2</td><td>1</td><td>3</td><td>1</td><td>3</td><td>4</td><td>3</td></tr></tbody></table><ol><li>初始时 maxSize = 4, maxVal = 16</li><li>寻找大小为 3 的最大整除子集，我们看到 8 和 12 对应的状态值都是 3，但 16 % 12 != 0，我们选择包含 8 的最大整除子集，此时maxSize = 3, maxVal = 8</li><li>继续向左寻找大小为 2 的最大整除子集，只有 4 对应的状态值为 2 ，选择包含 4 的最大整除子集，此时maxSize = 2, maxVal = 4</li><li>继续向左寻找大小为 1 的最大整除子集，2 对应的状态值为 1 ，选择包含 2 的最大整除子集，此时maxSize = 1, maxVal = 2</li></ol><p>我们就得到最大整除子集[16,8,4,2]。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">largestDivisibleSubset</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//动态规划找出最大子集的个数、最大子集中的最大整数</span></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> maxSize = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> maxVal = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++)&#123;</span><br><span class="line">            dp[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] % nums[j] == <span class="number">0</span>)&#123;</span><br><span class="line">                    dp[i] = Math.max(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(dp[i] &gt; maxSize)&#123;</span><br><span class="line">                maxSize = dp[i];</span><br><span class="line">                maxVal = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//倒推获得最大子集</span></span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(maxSize == <span class="number">1</span>)&#123;</span><br><span class="line">            res.add(nums[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; maxSize &gt; <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[i] == maxSize &amp;&amp; maxVal % nums[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                res.add(nums[i]);</span><br><span class="line">                maxSize--;</span><br><span class="line">                maxVal = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度O(n^2)</li><li>空间复杂度O(n)</li></ul><p>当前问题和使用动态规划解决的经典问题「<a href="https://leetcode-cn.com/problems/longest-increasing-subsequence" target="_blank" rel="noopener">300. 最长递增子序列</a>」有相似之处。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;368-最大整除子集&quot;&gt;&lt;a href=&quot;#368-最大整除子集&quot; class=&quot;headerlink&quot; title=&quot;368. 最大整除子集&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/largest-divisible-subset/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;368. 最大整除子集&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;给你一个由 &lt;strong&gt;无重复&lt;/strong&gt; 正整数组成的集合 &lt;code&gt;nums&lt;/code&gt; ，请你找出并返回其中最大的整除子集 &lt;code&gt;answer&lt;/code&gt; ，子集中每一元素对 &lt;code&gt;(answer[i], answer[j])&lt;/code&gt; 都应当满足：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;answer[i] % answer[j] == 0&lt;/code&gt; ，或&lt;/li&gt;
&lt;li&gt;&lt;code&gt;answer[j] % answer[i] == 0&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果存在多个有效解子集，返回其中任何一个均可。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode Medium" scheme="https://hoo334.github.io/tags/Leetcode-Medium/"/>
    
      <category term="动态规划" scheme="https://hoo334.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>最长递增子序列</title>
    <link href="https://hoo334.github.io/2021/04/23/%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/"/>
    <id>https://hoo334.github.io/2021/04/23/%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/</id>
    <published>2021-04-23T01:59:00.000Z</published>
    <updated>2021-08-24T08:26:26.037Z</updated>
    
    <content type="html"><![CDATA[<h4 id="300-最长递增子序列"><a href="#300-最长递增子序列" class="headerlink" title="300. 最长递增子序列"></a><a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/" target="_blank" rel="noopener">300. 最长递增子序列</a></h4><p>给你一个整数数组 <code>nums</code> ，找到其中最长严格递增子序列的长度。</p><p>子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，<code>[3,6,2,7]</code> 是数组 <code>[0,3,1,6,2,2,7]</code> 的子序列。</p><a id="more"></a><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [10,9,2,5,3,7,101,18]</span><br><span class="line">输出：4</span><br><span class="line">解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [0,1,0,3,2,3]</span><br><span class="line">输出：4</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [7,7,7,7,7,7,7]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p> <strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 2500</code></li><li><code>-104 &lt;= nums[i] &lt;= 104</code></li></ul><p>定义 dp[i] 为考虑前 i 个元素，以第 i 个数字结尾的最长上升子序列长度，<strong>nums[i] 必须被选择</strong>。</p><p>从小到大计算 dp 数组的值，在计算 dp[i] 之前，我们已经计算出 dp[0 … i - 1]的值，状态转移方程为：<br>$$<br>dp[i] = max(dp[j]) + 1, 其中 0 \leq j&lt;i 且nums[j] &lt; nums[i]<br>$$<br>即考虑往 dp[0 … i - 1]中的最长上升子序列后面再加一个 nums[i]，此时 nums[i]必须大于前面的最长子序列中的最后一个元素，假设我们选择最长上升子序列 dp[j]，nums[i] 就必须大于 nums[j]。</p><p>最后整个数组的最长上升子序列即为所有 dp[i] 中的最大值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">int</span> maxLen = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            dp[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//尝试在dp[0 ... i-1]中找一个最长递增子序列</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] &gt; nums[j])&#123;</span><br><span class="line">                    dp[i] = Math.max(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                maxLen = Math.max(maxLen, dp[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxLen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度O(n^2)</li><li>空间复杂度O(n)</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;300-最长递增子序列&quot;&gt;&lt;a href=&quot;#300-最长递增子序列&quot; class=&quot;headerlink&quot; title=&quot;300. 最长递增子序列&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/longest-increasing-subsequence/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;300. 最长递增子序列&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;给你一个整数数组 &lt;code&gt;nums&lt;/code&gt; ，找到其中最长严格递增子序列的长度。&lt;/p&gt;
&lt;p&gt;子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，&lt;code&gt;[3,6,2,7]&lt;/code&gt; 是数组 &lt;code&gt;[0,3,1,6,2,2,7]&lt;/code&gt; 的子序列。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode Medium" scheme="https://hoo334.github.io/tags/Leetcode-Medium/"/>
    
      <category term="动态规划" scheme="https://hoo334.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>解码方法</title>
    <link href="https://hoo334.github.io/2021/04/21/%E8%A7%A3%E7%A0%81%E6%96%B9%E6%B3%95/"/>
    <id>https://hoo334.github.io/2021/04/21/%E8%A7%A3%E7%A0%81%E6%96%B9%E6%B3%95/</id>
    <published>2021-04-21T02:12:39.000Z</published>
    <updated>2021-08-24T08:30:52.626Z</updated>
    
    <content type="html"><![CDATA[<h4 id="91-解码方法"><a href="#91-解码方法" class="headerlink" title="91. 解码方法"></a><a href="https://leetcode-cn.com/problems/decode-ways/" target="_blank" rel="noopener">91. 解码方法</a></h4><p>一条包含字母 <code>A-Z</code> 的消息通过以下映射进行了 <strong>编码</strong> ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#39;A&#39; -&gt; 1</span><br><span class="line">&#39;B&#39; -&gt; 2</span><br><span class="line">...</span><br><span class="line">&#39;Z&#39; -&gt; 26</span><br></pre></td></tr></table></figure><p>要 <strong>解码</strong> 已编码的消息，所有数字必须基于上述映射的方法，反向映射回字母（可能有多种方法）。例如，<code>&quot;11106&quot;</code> 可以映射为：</p><ul><li><code>&quot;AAJF&quot;</code> ，将消息分组为 <code>(1 1 10 6)</code></li><li><code>&quot;KJF&quot;</code> ，将消息分组为 <code>(11 10 6)</code></li></ul><p>注意，消息不能分组为 <code>(1 11 06)</code> ，因为 <code>&quot;06&quot;</code> 不能映射为 <code>&quot;F&quot;</code> ，这是由于 <code>&quot;6&quot;</code> 和 <code>&quot;06&quot;</code> 在映射中并不等价。</p><p>给你一个只含数字的 <strong>非空</strong> 字符串 <code>s</code> ，请计算并返回 <strong>解码</strong> 方法的 <strong>总数</strong> 。</p><p>题目数据保证答案肯定是一个 <strong>32 位</strong> 的整数。</p> <a id="more"></a><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;12&quot;</span><br><span class="line">输出：2</span><br><span class="line">解释：它可以解码为 &quot;AB&quot;（1 2）或者 &quot;L&quot;（12）。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;226&quot;</span><br><span class="line">输出：3</span><br><span class="line">解释：它可以解码为 &quot;BZ&quot; (2 26), &quot;VF&quot; (22 6), 或者 &quot;BBF&quot; (2 2 6) 。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;0&quot;</span><br><span class="line">输出：0</span><br><span class="line">解释：没有字符映射到以 0 开头的数字。</span><br><span class="line">含有 0 的有效映射是 &#39;J&#39; -&gt; &quot;10&quot; 和 &#39;T&#39;-&gt; &quot;20&quot; 。</span><br><span class="line">由于没有字符，因此没有有效的方法对此进行解码，因为所有数字都需要映射。</span><br></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;06&quot;</span><br><span class="line">输出：0</span><br><span class="line">解释：&quot;06&quot; 不能映射到 &quot;F&quot; ，因为字符串含有前导 0（&quot;6&quot; 和 &quot;06&quot; 在映射中并不等价）。</span><br></pre></td></tr></table></figure><p> <strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 100</code></li><li><code>s</code> 只包含数字，并且可能包含前导零。</li></ul><p>对于字符串s = “226”，我们从左至右分析，字符 ‘ 2 ’ 可以解码为‘B’，字符 ’22‘ 可以解码为 ‘V’，解码方法总数为剩下的 ”26“ 和 ”6“解码方法总和，我们可以轻松知道 ”26“的解码方法为 2 种，”6“ 的解码方法为 1 种。</p><p>因此我们可以使用递归来实现这种思想</p><p><strong>方法一：递归（超时）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numDecodings</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//字符串长度为 0 或字符串第一个字符为 0，直接返回 0 </span></span><br><span class="line">        <span class="keyword">if</span>(s.length() == <span class="number">0</span> || s.charAt(<span class="number">0</span>) == <span class="string">'0'</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">char</span>[] chars = s.toCharArray();</span><br><span class="line">        <span class="keyword">return</span> decode(chars, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">decode</span><span class="params">(<span class="keyword">char</span>[] chars, <span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = chars.length;</span><br><span class="line">        <span class="comment">//边界条件</span></span><br><span class="line">        <span class="keyword">if</span>(start == n)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//以 0 开头，直接返回 0 </span></span><br><span class="line">        <span class="keyword">if</span>(chars[start] == <span class="string">'0'</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//取一个字符</span></span><br><span class="line">        <span class="keyword">int</span> ret = decode(chars, start + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//取两个字符</span></span><br><span class="line">        <span class="keyword">if</span>(start + <span class="number">1</span> &lt; n &amp;&amp; isDigit(chars[start], chars[start + <span class="number">1</span>]))&#123;</span><br><span class="line">            ret += decode(chars, start + <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回相加的结果</span></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//判断两个字符是否能解码</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isDigit</span><span class="params">(<span class="keyword">char</span> upper, <span class="keyword">char</span> lower)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> up = (<span class="keyword">int</span>)(upper - <span class="string">'0'</span>);</span><br><span class="line">        <span class="keyword">int</span> low = (<span class="keyword">int</span>)(lower - <span class="string">'0'</span>);</span><br><span class="line">        <span class="keyword">if</span>( (up == <span class="number">1</span> &amp;&amp; <span class="number">0</span> &lt;= low &amp;&amp; low &lt;= <span class="number">9</span>) || (up == <span class="number">2</span> &amp;&amp; <span class="number">0</span> &lt;= low &amp;&amp; low &lt;= <span class="number">6</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>方法二：动态规划</strong></p><p>虽然递归方法超时了，但我们可以尝试使用动态规划。dp[i] 表示 s[i … n] 的解码方法总数，结果为 dp[0]。我们可以使用 dpi, dpi1, dpi2 三个变量来代替 dp 数组，初始时 dpi = 0, dpi1 = 1, dpi2 = 1。我们可以列出如下 dp 方程：<br>$$<br>dp[i] = 0,  s[i] = ‘0’<br>$$<br>$$<br>dp[i] = dp[i + 1],  s[i] \neq ‘0’ &amp; &amp; \ !isDigit(s[i], s[i + 1])<br>$$<br>$$<br>dp[i] = dp[i + 1] + dp[i + 2],  s[i] \neq ‘0’ &amp; &amp; \ isDigit(s[i], s[i + 1])<br>$$</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numDecodings</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span> || s.charAt(<span class="number">0</span>) == <span class="string">'0'</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> dpi = <span class="number">0</span>, dpi1 = <span class="number">1</span>, dpi2 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i) != <span class="string">'0'</span>)&#123;</span><br><span class="line">                dpi += dpi1;</span><br><span class="line">                <span class="keyword">if</span>(i + <span class="number">1</span> &lt; n &amp;&amp; isDigit(s.charAt(i), s.charAt(i + <span class="number">1</span>))) dpi += dpi2;</span><br><span class="line">            &#125;</span><br><span class="line">            dpi2 = dpi1;</span><br><span class="line">            dpi1 = dpi;</span><br><span class="line">            dpi = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dpi1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isDigit</span><span class="params">(<span class="keyword">char</span> upper, <span class="keyword">char</span> lower)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> up = (<span class="keyword">int</span>)(upper - <span class="string">'0'</span>);</span><br><span class="line">        <span class="keyword">int</span> low = (<span class="keyword">int</span>)(lower - <span class="string">'0'</span>);</span><br><span class="line">        <span class="keyword">if</span>( (up == <span class="number">1</span> &amp;&amp; <span class="number">0</span> &lt;= low &amp;&amp; low &lt;= <span class="number">9</span>) || (up == <span class="number">2</span> &amp;&amp; <span class="number">0</span> &lt;= low &amp;&amp; low &lt;= <span class="number">6</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度O(n)</li><li>空间复杂度O(1)</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;91-解码方法&quot;&gt;&lt;a href=&quot;#91-解码方法&quot; class=&quot;headerlink&quot; title=&quot;91. 解码方法&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/decode-ways/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;91. 解码方法&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;一条包含字母 &lt;code&gt;A-Z&lt;/code&gt; 的消息通过以下映射进行了 &lt;strong&gt;编码&lt;/strong&gt; ：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;#39;A&amp;#39; -&amp;gt; 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#39;B&amp;#39; -&amp;gt; 2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#39;Z&amp;#39; -&amp;gt; 26&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;要 &lt;strong&gt;解码&lt;/strong&gt; 已编码的消息，所有数字必须基于上述映射的方法，反向映射回字母（可能有多种方法）。例如，&lt;code&gt;&amp;quot;11106&amp;quot;&lt;/code&gt; 可以映射为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;quot;AAJF&amp;quot;&lt;/code&gt; ，将消息分组为 &lt;code&gt;(1 1 10 6)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;quot;KJF&amp;quot;&lt;/code&gt; ，将消息分组为 &lt;code&gt;(11 10 6)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;注意，消息不能分组为 &lt;code&gt;(1 11 06)&lt;/code&gt; ，因为 &lt;code&gt;&amp;quot;06&amp;quot;&lt;/code&gt; 不能映射为 &lt;code&gt;&amp;quot;F&amp;quot;&lt;/code&gt; ，这是由于 &lt;code&gt;&amp;quot;6&amp;quot;&lt;/code&gt; 和 &lt;code&gt;&amp;quot;06&amp;quot;&lt;/code&gt; 在映射中并不等价。&lt;/p&gt;
&lt;p&gt;给你一个只含数字的 &lt;strong&gt;非空&lt;/strong&gt; 字符串 &lt;code&gt;s&lt;/code&gt; ，请计算并返回 &lt;strong&gt;解码&lt;/strong&gt; 方法的 &lt;strong&gt;总数&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;题目数据保证答案肯定是一个 &lt;strong&gt;32 位&lt;/strong&gt; 的整数。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode Medium" scheme="https://hoo334.github.io/tags/Leetcode-Medium/"/>
    
      <category term="动态规划" scheme="https://hoo334.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>打家劫舍II</title>
    <link href="https://hoo334.github.io/2021/04/15/%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8DII/"/>
    <id>https://hoo334.github.io/2021/04/15/%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8DII/</id>
    <published>2021-04-15T01:17:21.000Z</published>
    <updated>2021-04-15T01:32:07.356Z</updated>
    
    <content type="html"><![CDATA[<h4 id="213-打家劫舍-II"><a href="#213-打家劫舍-II" class="headerlink" title="213. 打家劫舍 II"></a><a href="https://leetcode-cn.com/problems/house-robber-ii/" target="_blank" rel="noopener">213. 打家劫舍 II</a></h4><p>你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 <strong>围成一圈</strong> ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong> 。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你 <strong>在不触动警报装置的情况下</strong> ，能够偷窃到的最高金额。</p> <a id="more"></a><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [2,3,2]</span><br><span class="line">输出：3</span><br><span class="line">解释：你不能先偷窃 1 号房屋（金额 &#x3D; 2），然后偷窃 3 号房屋（金额 &#x3D; 2）, 因为他们是相邻的。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [1,2,3,1]</span><br><span class="line">输出：4</span><br><span class="line">解释：你可以先偷窃 1 号房屋（金额 &#x3D; 1），然后偷窃 3 号房屋（金额 &#x3D; 3）。</span><br><span class="line">     偷窃到的最高金额 &#x3D; 1 + 3 &#x3D; 4 。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [0]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure><p> <strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 100</code></li><li><code>0 &lt;= nums[i] &lt;= 1000</code></li></ul><p><strong>方法一：动态规划</strong></p><p>此题是<a href="https://hoo334.github.io/2020/07/01/%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D/">打家劫舍</a>的进阶，与打家劫舍不同的是，这题中的房屋是首尾相连的，第一间和最后一间房屋相邻，因此第一间房屋和最后一间房屋不能在同一晚上偷窃。</p><p>假设数组 nums 的长度为 n。如果不偷窃最后一间房屋，则偷窃房屋的下标范围是[0, n - 2]；如果偷最后一间房屋，则偷窃房屋的下标是[1, n - 1]。在确定偷窃房屋的下标范围之后，即可用打家劫舍中的方法解决。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//第一个房子和最后一个房子只能选择偷一个，因此做两次动态规划就可以了。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">1</span>)<span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">//偷第一个房子</span></span><br><span class="line">        <span class="keyword">int</span> first = robHelper(Arrays.copyOfRange(nums, <span class="number">0</span>, nums.length-<span class="number">1</span>));</span><br><span class="line">        <span class="comment">//偷最后一个房子</span></span><br><span class="line">        <span class="keyword">int</span> last = robHelper(Arrays.copyOfRange(nums, <span class="number">1</span>, nums.length));</span><br><span class="line">        <span class="keyword">return</span> Math.max(first,last);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">robHelper</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pre=<span class="number">0</span>,cur=<span class="number">0</span>,temp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.length; ++i)&#123;</span><br><span class="line">            temp = cur;</span><br><span class="line">            cur = Math.max(pre+nums[i], cur);</span><br><span class="line">            pre = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度O(n)</li><li>空间复杂度O(1)</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;213-打家劫舍-II&quot;&gt;&lt;a href=&quot;#213-打家劫舍-II&quot; class=&quot;headerlink&quot; title=&quot;213. 打家劫舍 II&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/house-robber-ii/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;213. 打家劫舍 II&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 &lt;strong&gt;围成一圈&lt;/strong&gt; ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，&lt;strong&gt;如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;给定一个代表每个房屋存放金额的非负整数数组，计算你 &lt;strong&gt;在不触动警报装置的情况下&lt;/strong&gt; ，能够偷窃到的最高金额。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode Medium" scheme="https://hoo334.github.io/tags/Leetcode-Medium/"/>
    
      <category term="动态规划" scheme="https://hoo334.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>Aspect Spring AOP</title>
    <link href="https://hoo334.github.io/2021/04/12/Aspect%20Spring%20AOP/"/>
    <id>https://hoo334.github.io/2021/04/12/Aspect%20Spring%20AOP/</id>
    <published>2021-04-12T02:34:09.000Z</published>
    <updated>2021-04-15T03:21:05.482Z</updated>
    
    <content type="html"><![CDATA[<h3 id="基于注解的-Spring-AOP-开发"><a href="#基于注解的-Spring-AOP-开发" class="headerlink" title="基于注解的 Spring AOP 开发"></a>基于注解的 Spring AOP 开发</h3><a id="more"></a><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/v2-b5c523e28bba91c11c8d7f510ab84a79_1440w.png" alt="img"></p><h4 id="定义切入点函数"><a href="#定义切入点函数" class="headerlink" title="定义切入点函数"></a>定义切入点函数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在执行完 UserDao.add() 方法后执行</span></span><br><span class="line"><span class="meta">@After</span>(value=<span class="string">"execution(* com.zejian.spring.springAop.dao.UserDao.addUser(..))"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span></span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"最终通知...."</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>还可采用 @PointCut 关键字定义切入点表达式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用Pointcut定义切点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"execution(* com.zejian.spring.springAop.dao.UserDao.addUser(..))"</span>)</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">myPointcut</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 应用切入点函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@After</span>(value=<span class="string">"myPointcut()"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterDemo</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"最终通知...."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="切入点指示符"><a href="#切入点指示符" class="headerlink" title="切入点指示符"></a>切入点指示符</h4><h5 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h5><p>在定义匹配表达式时，通配符几乎随处可见如 <code>*</code> , <code>..</code> , <code>+</code> ,它们的含义如下：</p><ul><li><code>..</code>：匹配方法定义中任意数量的参数，此外还匹配类定义中任意数量包</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//任意返回值，任意名称，任意参数的公共方法</span></span><br><span class="line">execution(<span class="keyword">public</span> * *(..))</span><br><span class="line"><span class="comment">//匹配com.zejian.dao包及其子包中所有类中的所有方法</span></span><br><span class="line">within(com.zejian.dao..*)</span><br></pre></td></tr></table></figure><ul><li><code>+</code>：匹配给定类的任意子类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//匹配实现了DaoUser接口的所有子类的方法</span></span><br><span class="line">within(com.zejian.dao.DaoUser+)</span><br></pre></td></tr></table></figure><ul><li><code>*</code>：匹配任意数量的字符</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//匹配com.zejian.service包及其子包中所有类的所有方法</span></span><br><span class="line">within(com.zejian.service..*)</span><br><span class="line"><span class="comment">//匹配以set开头，参数为int类型，任意返回值的方法</span></span><br><span class="line">execution(* set*(<span class="keyword">int</span>))</span><br></pre></td></tr></table></figure><h5 id="类型签名表达式"><a href="#类型签名表达式" class="headerlink" title="类型签名表达式"></a>类型签名表达式</h5><p>为了方便类型（如接口、类名、包名）过滤方法，Spring AOP 提供了within关键字。其语法格式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">within(&lt;type name&gt;)</span><br></pre></td></tr></table></figure><p>type name 则使用包名或者类名替换即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//匹配com.zejian.dao包及其子包中所有类中的所有方法</span></span><br><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"within(com.zejian.dao..*)"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//匹配UserDaoImpl类中所有方法</span></span><br><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"within(com.zejian.dao.UserDaoImpl)"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//匹配UserDaoImpl类及其子类中所有方法</span></span><br><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"within(com.zejian.dao.UserDaoImpl+)"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//匹配所有实现UserDao接口的类的所有方法</span></span><br><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"within(com.zejian.dao.UserDao+)"</span>)</span><br></pre></td></tr></table></figure><h5 id="方法签名表达式"><a href="#方法签名表达式" class="headerlink" title="方法签名表达式"></a>方法签名表达式</h5><p>如果想根据方法签名进行过滤，关键字 execution 可以帮到我们，语法表达式如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//scope ：方法作用域，如public,private,protect</span></span><br><span class="line"><span class="comment">//returnt-type：方法返回值类型</span></span><br><span class="line"><span class="comment">//fully-qualified-class-name：方法所在类的完全限定名称</span></span><br><span class="line"><span class="comment">//parameters 方法参数</span></span><br><span class="line">execution(&lt;scope&gt; &lt;<span class="keyword">return</span>-type&gt; &lt;fully-qualified-<span class="class"><span class="keyword">class</span>-<span class="title">name</span>&gt;.*(<span class="title">parameters</span>))</span></span><br></pre></td></tr></table></figure><p>对于给定的作用域、返回值类型、完全限定类名以及参数匹配的方法将会应用切点函数指定的通知，这里给出模型案例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//匹配UserDaoImpl类中的所有方法</span></span><br><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"execution(* com.zejian.dao.UserDaoImpl.*(..))"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//匹配UserDaoImpl类中的所有公共的方法</span></span><br><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"execution(public * com.zejian.dao.UserDaoImpl.*(..))"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//匹配UserDaoImpl类中的所有公共方法并且返回值为int类型</span></span><br><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"execution(public int com.zejian.dao.UserDaoImpl.*(..))"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//匹配UserDaoImpl类中第一个参数为int类型的所有公共的方法</span></span><br><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"execution(public * com.zejian.dao.UserDaoImpl.*(int , ..))"</span>)</span><br></pre></td></tr></table></figure><h5 id="其他指示符"><a href="#其他指示符" class="headerlink" title="其他指示符"></a>其他指示符</h5><ul><li><p>this：用于匹配当前 AOP 代理对象类型的执行方法；请注意是 <strong>AOP代理对象</strong>的类型匹配，这样就可能包括引入接口也类型匹配</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//匹配了任意实现了UserDao接口的代理对象的方法进行过滤</span></span><br><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"this(com.zejian.spring.springAop.dao.UserDao)"</span>)</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">myPointcut2</span><span class="params">()</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>bean：Spring AOP 扩展的，AspectJ没有对应指示符，用于匹配特定名称的 Bean 对象的执行方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//匹配名称中带有后缀Service的Bean。</span></span><br><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"bean(*Service)"</span>)</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">myPointcut1</span><span class="params">()</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>target：用于匹配当前目标对象类型的执行方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//匹配了任意实现了UserDao接口的目标对象的方法进行过滤</span></span><br><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"target(com.zejian.spring.springAop.dao.UserDao)"</span>)</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">myPointcut3</span><span class="params">()</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>@within：用于匹配所有持有指定注解类型内的方法；请注意与 within 是有区别的，within是用于匹配指定类型内的方法执行；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//匹配使用了MarkerAnnotation注解的类(注意是类)</span></span><br><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"@within(com.zejian.spring.annotation.MarkerAnnotation)"</span>)</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">myPointcut4</span><span class="params">()</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>@annotation(com.zejian.spring.MarkerMethodAnnotation) : 根据所应用的注解进行方法过滤</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//匹配使用了MarkerAnnotation注解的方法(注意是方法)</span></span><br><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"@annotation(com.zejian.spring.annotation.MarkerAnnotation)"</span>)</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">myPointcut5</span><span class="params">()</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure></li></ul><p>切点指示符可以使用运算符语法进行表达式的混编，如and、or、not（或者&amp;&amp;、||、！），如下一个简单例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//匹配了任意实现了UserDao接口的目标对象的方法并且该接口不在com.zejian.dao包及其子包下</span></span><br><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"target(com.zejian.spring.springAop.dao.UserDao) ！within(com.zejian.dao..*)"</span>)</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">myPointcut6</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//匹配了任意实现了UserDao接口的目标对象的方法并且该方法名称为addUser</span></span><br><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"target(com.zejian.spring.springAop.dao.UserDao)&amp;&amp;execution(* com.zejian.spring.springAop.dao.UserDao.addUser(..))"</span>)</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">myPointcut7</span><span class="params">()</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><h5 id="5-种通知函数"><a href="#5-种通知函数" class="headerlink" title="5 种通知函数"></a>5 种通知函数</h5><p>通知主要分5种类型，分别是前置通知、后置通知、异常通知、最终通知以及环绕通知，下面分别介绍。</p><ul><li><p>前置通知 @Before</p><p>前置通知通过 @Before 注解进行标注，并可直接传入切点表达式的值，该通知在目标函数执行前执行，JoinPoint 是 Spring 提供的静态变量，通过它，可以获取目标对象的信息，如类名称，方法参数，方法名等，该参数可选。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 前置通知</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> joinPoint 该参数可以获取目标对象的信息,如类名称,方法参数,方法名称等</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Before</span>(<span class="string">"execution(* com.zejian.spring.springAop.dao.UserDao.addUser(..))"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">(JoinPoint joinPoint)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"我是前置通知"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>后置通知 @AfterReturning</p><p>通过 @AfterReturning 标注，该函数在目标函数执行完成后执行，并可以获取到目标函数最终的返回值  returnVal，当目标函数没有返回值时，returnVal 将返回 null。</p><p>必须通过returning = “returnVal”注明参数的名称而且必须与通知函数的参数名称相同。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 后置通知，不需要参数时可以不提供</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@AfterReturning</span>(value=<span class="string">"execution(* com.zejian.spring.springAop.dao.UserDao.*User(..))"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AfterReturning</span><span class="params">()</span></span>&#123;</span><br><span class="line">   System.out.println(<span class="string">"我是后置通知..."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 后置通知</span></span><br><span class="line"><span class="comment">* returnVal,切点方法执行后的返回值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@AfterReturning</span>(value=<span class="string">"execution(* com.zejian.spring.springAop.dao.UserDao.*User(..))"</span>,returning = <span class="string">"returnVal"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AfterReturning</span><span class="params">(JoinPoint joinPoint,Object returnVal)</span></span>&#123;</span><br><span class="line">   System.out.println(<span class="string">"我是后置通知...returnVal+"</span>+returnVal);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>异常通知 @AfterThrowing</p><p>该通知只有在异常时才会被出发，并由 throwing 来声明一个接受异常信息的变量，同样异常通知也用于 Joinpoing 参数，需要时可以加上。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 抛出通知</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> e 抛出异常的信息</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@AfterThrowing</span>(value=<span class="string">"execution(* com.zejian.spring.springAop.dao.UserDao.addUser(..))"</span>,throwing = <span class="string">"e"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterThrowable</span><span class="params">(Throwable e)</span></span>&#123;</span><br><span class="line">  System.out.println(<span class="string">"出现异常:msg="</span>+e.getMessage());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>最终通知 @After</p><p>该通知有点类似于 finally 代码块，只要应用了，无论什么情况下都会执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 无论什么情况下都会执行的方法</span></span><br><span class="line"><span class="comment"> * joinPoint 参数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@After</span>(<span class="string">"execution(* com.zejian.spring.springAop.dao.UserDao.*User(..))"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">(JoinPoint joinPoint)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"最终通知...."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>环绕通知 @Around</p><p>环绕通知既可在目标方法前执行也可以在目标方法后执行，更重要的是环绕通知可以控制目标方法是否指向执行，但即使如此，我们应该尽量以最简单的方式满足需求，在仅需目标方法前执行时，使用前置通知而非环绕通知。</p><p>第一个参数必须是 ProceedingJoinPoint，通过该对象的 proceed() 方法来执行目标函数，proceed() 的返回值就是环绕通知的返回值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Around</span>(<span class="string">"execution(* com.zejian.spring.springAop.dao.UserDao.*User(..))"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">around</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"我是环绕通知前...."</span>);</span><br><span class="line">    <span class="comment">//执行目标函数</span></span><br><span class="line">    Object obj= (Object) joinPoint.proceed();</span><br><span class="line">    System.out.println(<span class="string">"我是环绕通知后...."</span>);</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="通知传递参数"><a href="#通知传递参数" class="headerlink" title="通知传递参数"></a>通知传递参数</h5><p>在 Spring AOP 中，除了 execution 和 bean 指示符不能传递参数给通知方法，其他指示符都可以将<strong>匹配的方法相应参数或对象</strong>自动传递给通知方法。获取到匹配的方法参数后通过 <code>argNames</code>属性指定参数名。如下，args(param)、argNames=”param”、before(int param)这三个参数<strong>命名必须保持一致</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Before</span>(value=<span class="string">"args(param)"</span>, argNames=<span class="string">"param"</span>) <span class="comment">//明确指定了    </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">(<span class="keyword">int</span> param)</span> </span>&#123;    </span><br><span class="line">    System.out.println(<span class="string">"param:"</span> + param);    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可直接使用 args 指示符不带 argNames 声明参数，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Before</span>(<span class="string">"execution(public * com.zejian..*.addUser(..)) &amp;&amp; args(userId,..)"</span>)  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">(<span class="keyword">int</span> userId)</span> </span>&#123;  </span><br><span class="line">    <span class="comment">//调用addUser的方法时如果与addUser的参数匹配则会传递进来会传递进来</span></span><br><span class="line">    System.out.println(<span class="string">"userId:"</span> + userId);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>args(userId,..)表达式表示：只匹配那些至少接收一个参数而且传入的类型必须与userId一致的方法，传递的参数可以简单类型或者对象，只有参数和目标方法也匹配时才有会有值传递进来。</p><h3 id="Aspect-优先级"><a href="#Aspect-优先级" class="headerlink" title="Aspect 优先级"></a>Aspect 优先级</h3><p>如果有多个通知需要在同一个切点函数指定的过滤目标方法上执行，在所有前置通知函数中，优先级最高的通知函数将会被先执行，在所有后置通知函数中，优先级最高的通知函数将会最后执行。</p><p>新建名为 aspectdemo 的工程，首先引入核心依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>添加启动类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AspectdemoApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(AspectdemoApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>开启 AspectJAutoProxy ，添加配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hoo.aspectdemo.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.EnableAspectJAutoProxy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在配置文件中启动<span class="doctag">@Aspect</span>支持后，</span></span><br><span class="line"><span class="comment"> * Spring容器只会尝试自动识别带<span class="doctag">@Aspect</span>的Bean，</span></span><br><span class="line"><span class="comment"> * 前提是任何定义的切面类都必须已在配置文件以Bean的形式声明。</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AspectJConfig</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加测试用 Controller</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/order"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先添加优先级较高的切面</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hoo.aspectdemo.aspect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.AfterReturning;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Before;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Pointcut;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.Ordered;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">切面实现 org.springframework.core.Ordered 接口，该接口用于控制切面类的优先级，同时重写getOrder方法，定制返回值，返回值(int 类型)越小优先级越大</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AspectOrderZero</span> <span class="keyword">implements</span> <span class="title">Ordered</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut</span>(<span class="string">"execution(* com.hoo.aspectdemo.controller.TestController.testOrder())"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pointCut</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"pointCut()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeOne</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"前置通知 ..优先级 0 .. 执行顺序 1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"pointCut()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeTwo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"前置通知 ..优先级 0 .. 执行顺序 2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterReturning</span>(<span class="string">"pointCut()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterReturningThree</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"后置通知 ..优先级 0 .. 执行顺序 3"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterReturning</span>(<span class="string">"pointCut()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterReturningFour</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"后置通知 ..优先级 0 .. 执行顺序 4"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后添加优先级较低的切面</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hoo.aspectdemo.aspect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.AfterReturning;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Before;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Pointcut;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.Ordered;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AspectOrderTwo</span> <span class="keyword">implements</span> <span class="title">Ordered</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut</span>(<span class="string">"execution(* com.hoo.aspectdemo.controller.TestController.testOrder())"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pointCut</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"pointCut()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeOne</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"前置通知 ..优先级 2 .. 执行顺序 1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"pointCut()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeTwo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"前置通知 ..优先级 2 .. 执行顺序 2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterReturning</span>(<span class="string">"pointCut()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterReturningThree</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"后置通知 ..优先级 2 .. 执行顺序 3"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterReturning</span>(<span class="string">"pointCut()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterReturningFour</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"后置通知 ..优先级 2 .. 执行顺序 4"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行，即可在控制台看到如下信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">前置通知 ..优先级 0 .. 执行顺序 1</span><br><span class="line">前置通知 ..优先级 0 .. 执行顺序 2</span><br><span class="line">前置通知 ..优先级 2 .. 执行顺序 1</span><br><span class="line">前置通知 ..优先级 2 .. 执行顺序 2</span><br><span class="line">后置通知 ..优先级 2 .. 执行顺序 3</span><br><span class="line">后置通知 ..优先级 2 .. 执行顺序 4</span><br><span class="line">后置通知 ..优先级 0 .. 执行顺序 3</span><br><span class="line">后置通知 ..优先级 0 .. 执行顺序 4</span><br></pre></td></tr></table></figure><p>总结：在同一个切面中定义多个通知响应同一个切点函数，执行顺序为声明顺序；如果在不同的切面中定义多个通知响应同一个切点，进入时则优先级高的切面类中的通知函数优先执行，退出时则最后执行。</p><h3 id="Spring-AOP-简单应用场景"><a href="#Spring-AOP-简单应用场景" class="headerlink" title="Spring AOP 简单应用场景"></a>Spring AOP 简单应用场景</h3><ol><li>性能监控</li></ol><p>首先我们定义用于测试的controller，并模拟这个接口需要 5s 来执行操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hoo.aspectdemo.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/monitor"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testMonitor</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread.sleep(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后定义性能监控信息类 MonitorTime</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hoo.aspectdemo.aspect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MonitorTime</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String className;</span><br><span class="line">    <span class="keyword">private</span> String methodName;</span><br><span class="line">    <span class="keyword">private</span> Date logTime;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> consumeTime;</span><br><span class="line"> <span class="comment">// 省略 getter 和 setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后定义一个监控的切面类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hoo.aspectdemo.aspect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.ProceedingJoinPoint;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Around;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Pointcut;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimerAspect</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut</span>(<span class="string">"within(com.hoo.aspectdemo.controller..*)"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pointCut</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around</span>(<span class="string">"pointCut()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">logTimer</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        MonitorTime monitor = <span class="keyword">new</span> MonitorTime();</span><br><span class="line">        <span class="comment">//获取目标类名称</span></span><br><span class="line">        String className = joinPoint.getTarget().getClass().getName();</span><br><span class="line">        <span class="comment">//获取目标类方法名称</span></span><br><span class="line">        String methodName = joinPoint.getSignature().getName();</span><br><span class="line"></span><br><span class="line">        monitor.setClassName(className);</span><br><span class="line">        monitor.setMethodName(methodName);</span><br><span class="line">        monitor.setLogTime(<span class="keyword">new</span> Date());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//计时并调用目标函数</span></span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        Object result = joinPoint.proceed();</span><br><span class="line">        <span class="keyword">long</span> time = System.currentTimeMillis() - start;</span><br><span class="line">        monitor.setConsumeTime(time);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//把 MonitorTime 记录的信息上传给监控系统，这里没有实现</span></span><br><span class="line"></span><br><span class="line">        System.out.println(monitor);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动程序，访问<a href="http://localhost:8080/monitor，查看控制台，打印出如下信息：" target="_blank" rel="noopener">http://localhost:8080/monitor，查看控制台，打印出如下信息：</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MonitorTime&#123;className=<span class="string">'com.hoo.aspectdemo.controller.TestController2'</span>, methodName=<span class="string">'testMonitor'</span>, logTime=Mon Apr <span class="number">12</span> <span class="number">17</span>:<span class="number">08</span>:<span class="number">53</span> CST <span class="number">2021</span>, consumeTime=<span class="number">11</span>&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>异常监控</li></ol><p>首先定义异常信息类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hoo.aspectdemo.aspect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionInfo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String className;</span><br><span class="line">    <span class="keyword">private</span> String methodName;</span><br><span class="line">    <span class="keyword">private</span> Date logTime;<span class="comment">//异常记录时间</span></span><br><span class="line">    <span class="keyword">private</span> String message;<span class="comment">//异常信息</span></span><br><span class="line"><span class="comment">// 省略 getter 和 setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义自己的异常类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hoo.aspectdemo.exception;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyException</span> <span class="keyword">extends</span> <span class="title">Exception</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyException</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 TestController2 中添加测试函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/monitor/&#123;mode&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testMonitor2</span><span class="params">(@PathVariable Integer mode)</span> <span class="keyword">throws</span> MyException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(mode == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> MyException(<span class="string">" testMonitor() 方法出错了！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>然后定义异常处理的切面</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hoo.aspectdemo.aspect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.ProceedingJoinPoint;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Around;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Pointcut;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionMonitorAspect</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut</span>(<span class="string">"within(com.hoo.aspectdemo.controller..*)"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">exceptionMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around</span>(<span class="string">"exceptionMethod()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">monitorMethods</span><span class="params">(ProceedingJoinPoint joinPoint)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> joinPoint.proceed();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            ExceptionInfo info = <span class="keyword">new</span> ExceptionInfo();</span><br><span class="line">            info.setClassName(joinPoint.getTarget().getClass().getName());</span><br><span class="line">            info.setMethodName(joinPoint.getSignature().getName());</span><br><span class="line">            info.setLogTime(<span class="keyword">new</span> Date());</span><br><span class="line">            info.setMessage(e.getMessage());</span><br><span class="line"></span><br><span class="line">            System.out.println(info);</span><br><span class="line">            <span class="comment">//上传日志系统，这里省略</span></span><br><span class="line">            <span class="comment">//返回失败信息</span></span><br><span class="line">            <span class="keyword">return</span> e.getMessage();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>浏览器访问 <a href="http://localhost:8080/monitor/0" target="_blank" rel="noopener">http://localhost:8080/monitor/0</a> ，可以看到返回 ”success“信息，并在控制台可以看到访问时间日志：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MonitorTime&#123;className&#x3D;&#39;com.hoo.aspectdemo.controller.TestController2&#39;, methodName&#x3D;&#39;testMonitor2&#39;, logTime&#x3D;Mon Apr 12 21:46:30 CST 2021, consumeTime&#x3D;11&#125;</span><br></pre></td></tr></table></figure><p>浏览器访问 <a href="http://localhost:8080/monitor/1" target="_blank" rel="noopener">http://localhost:8080/monitor/1</a> ，可以看到返回 ”testMonitor() 方法出错了！“信息，并在控制台可以看到访问时间日志：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ExceptionInfo&#123;className&#x3D;&#39;com.hoo.aspectdemo.controller.TestController2&#39;, methodName&#x3D;&#39;testMonitor2&#39;, logTime&#x3D;Mon Apr 12 21:47:15 CST 2021, message&#x3D;&#39; testMonitor() 方法出错了！&#39;&#125;</span><br></pre></td></tr></table></figure><h3 id="Spring-AOP-实现原理概要"><a href="#Spring-AOP-实现原理概要" class="headerlink" title="Spring AOP 实现原理概要"></a>Spring AOP 实现原理概要</h3><p>对于织入过程，一般分为动态织入和静态织入，动态织入在运行时动态地将要增强的代码织入到目标类中，这往往是通过动态代理技术完成的，如 Java JDK 的动态代理（底层通过反射实现）或者 CGLIB 的动态代理（底层通过继承实现）。</p><p>AspectJ 采用静态织入的方式。它在编译器使用 acj 编译器把 aspect 类编译成 class 字节码后，在 java 目标类编译时织入，先编译 aspect 类再编译目标类。</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20210414190852904.png" alt="image-20210414190852904"></p><h4 id="JDK-动态代理"><a href="#JDK-动态代理" class="headerlink" title="JDK 动态代理"></a>JDK 动态代理</h4><p>首先看一个简单的例子，声明一个 ExInterface 接口，利用 JDK 动态代理技术在 execute() 方法前后加入权限验证和日志记录。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自定义的接口类，JDK 动态代理的实现必须要有对应的接口类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ExInterface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//A类，实现了ExInterface接口类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">implements</span> <span class="title">ExInterface</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"---- A.execute() ----"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="comment">//代理类的实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDKProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 要被代理的目标对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> A target;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JDKProxy</span><span class="params">(A target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 创建代理类</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ExInterface <span class="title">createProxy</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (ExInterface) Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(),<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调用被代理类(目标对象)的任意方法都会触发invoke方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> proxy 代理类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> method 被代理类的方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args 被代理类的方法参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">//过滤不需要该业务的方法</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="string">"execute"</span>.equals(method.getName())) &#123;</span><br><span class="line">            <span class="comment">//调用前验证权限</span></span><br><span class="line">            <span class="comment">//AuthCheck.authCheck();</span></span><br><span class="line">            System.out.println(<span class="string">"---- 鉴权 ----"</span>);</span><br><span class="line">            <span class="comment">//调用目标对象的方法</span></span><br><span class="line">            Object result = method.invoke(target, args);</span><br><span class="line">            <span class="comment">//记录日志数据</span></span><br><span class="line">            <span class="comment">//Report.recordLog();</span></span><br><span class="line">            System.out.println(<span class="string">"---- 记录日志 ----"</span>);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">"delete"</span>.equals(method.getName()))&#123;</span><br><span class="line">            <span class="comment">//.....</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果不需要增强直接执行原方法</span></span><br><span class="line">        <span class="keyword">return</span> method.invoke(target,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        A a = <span class="keyword">new</span> A();</span><br><span class="line">        <span class="comment">//创建 JDK 代理</span></span><br><span class="line">        JDKProxy jdkProxy = <span class="keyword">new</span> JDKProxy(a);</span><br><span class="line">        <span class="comment">//创建代理对象</span></span><br><span class="line">        ExInterface proxy = jdkProxy.createProxy();</span><br><span class="line">        <span class="comment">//执行代理对象方法</span></span><br><span class="line">        proxy.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试结果</span></span><br><span class="line">---- 鉴权 ----</span><br><span class="line">---- A.execute() ----</span><br><span class="line">---- 记录日志 ----</span><br></pre></td></tr></table></figure><p>在 A 的 execute() 方法中没有调用任何权限和日志的 代码，也没有直接操作 a 对象，只是调用了 proxy 代理对象的方法，最终的结果却是预期的，这就是动态代理技术。动态代理的底层通过反射来实现，只要拿到 A 类的 class 文件和 A 类的实现接口，很自然就可以生成相同接口的代理类并调用  a 对象的方法。</p><p>实现 Java 动态代理是先决条件为：<strong>目标对象必须带接口</strong>，如果类的接口是 ExInterface，通过该接口，动态代理可以创建与 A 类类型相同的代理对象。</p><p>用JDK动态代理，被代理类(目标对象，如A类)，必须已有实现接口如(ExInterface)，因为JDK提供的Proxy类将通过目标对象的类加载器ClassLoader和Interface，以及句柄(Callback)创建与A类拥有相同接口的代理对象proxy，该代理对象将拥有接口ExInterface中的所有方法。同时，代理类必须实现一个类似回调函数的InvocationHandler接口并重写该接口中的invoke方法，当调用proxy的每个方法(如案例中的proxy#execute())时，invoke方法将被调用，利用该特性，可以在invoke方法中对目标对象(被代理对象如A)方法执行的前后动态添加其他外围业务操作，此时无需触及目标对象的任何代码，也就实现了外围业务的操作与目标对象(被代理对象如A)完全解耦合的目的。当然缺点也很明显需要拥有接口，这也就有了后来的CGLIB动态代理。  </p><h4 id="CGLIB-动态代理"><a href="#CGLIB-动态代理" class="headerlink" title="CGLIB 动态代理"></a><a href="https://github.com/cglib/cglib" target="_blank" rel="noopener">CGLIB</a> 动态代理</h4><p>通过CGLIB动态代理实现上述功能并不要求目标对象拥有接口类，实际上CGLIB动态代理是通过继承的方式实现的，因此可以减少没必要的接口，下面直接通过简单案例协助理解。</p><p>首先引入 <a href="https://repository.ow2.org/nexus/content/repositories/releases/org/ow2/asm/asm/8.0.1/asm-8.0.1.jar" target="_blank" rel="noopener">asm-8.0.1.jar</a> 和 <a href="https://github.com/cglib/cglib/releases/download/RELEASE_3_3_0/cglib-3.3.0.jar" target="_blank" rel="noopener">cglib-3.3.0.jar</a>，也可使用 maven 下载。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="comment">//被代理的类（目标对象）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"---- A.execute() ----"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.Enhancer;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodInterceptor;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodProxy;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CGLibProxy</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 被代理的目标类</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="keyword">private</span> A target;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CGLibProxy</span><span class="params">(A target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建代理对象</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> A <span class="title">createProxy</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//使用 CGLIB 生成代理</span></span><br><span class="line">        <span class="comment">//1.生成增强类实例，用于生产代理类</span></span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        <span class="comment">//2.设置被代理类字节码，CGLIB 根据字节码生成被代理类的子类</span></span><br><span class="line">        enhancer.setSuperclass(target.getClass());</span><br><span class="line">        <span class="comment">//3. 设置回调函数，即一个方法拦截</span></span><br><span class="line">        enhancer.setCallback(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">//4.创建代理</span></span><br><span class="line">        <span class="keyword">return</span> (A) enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 回调函数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> obj 代理对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> method 委托类方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args 方法参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> proxy 每个被代理的方法都对应一个MethodProxy对象，</span></span><br><span class="line"><span class="comment">     *                    methodProxy.invokeSuper方法最终调用委托类(目标类)的原始方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object obj, Method method, Object[] args, MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">//过滤不需要该业务的方法</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="string">"execute"</span>.equals(method.getName()))&#123;</span><br><span class="line">            <span class="comment">//调用前验证权限</span></span><br><span class="line">            System.out.println(<span class="string">"---- 鉴权 ----"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//调用目标对象的方法（执行 A 独享即被代理对象的 execute 方法）</span></span><br><span class="line">            Object result = proxy.invokeSuper(obj,args);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//记录日志数据（动态添加其他要执行业务）</span></span><br><span class="line">            System.out.println(<span class="string">"---- 日志 ----"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">"delete"</span>.equals(method.getName()))&#123;</span><br><span class="line">            <span class="keyword">return</span> proxy.invokeSuper(obj, args);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//不需要增强直接执行原方法</span></span><br><span class="line">        <span class="keyword">return</span> proxy.invokeSuper(obj,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CGLibTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        A a = <span class="keyword">new</span> A();</span><br><span class="line"></span><br><span class="line">        CGLibProxy cgLibProxy = <span class="keyword">new</span> CGLibProxy(a);</span><br><span class="line"></span><br><span class="line">        A proxy = cgLibProxy.createProxy();</span><br><span class="line"></span><br><span class="line">        proxy.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试结果</span></span><br><span class="line">---- 鉴权 ----</span><br><span class="line">---- A.execute() ----</span><br><span class="line">---- 日志 ----</span><br></pre></td></tr></table></figure><p>被代理的类无需接口即可实现动态代理，而CGLibProxy代理类需要实现一个方法拦截器接口MethodInterceptor并重写intercept方法，类似JDK动态代理的InvocationHandler接口，也是理解为回调函数，同理每次调用代理对象的方法时，intercept方法都会被调用，利用该方法便可以在运行时对方法执行前后进行动态增强。关于代理对象创建则通过Enhancer类来设置的，Enhancer是一个用于产生代理对象的类，作用类似JDK的Proxy类，因为CGLib底层是通过继承实现的动态代理，因此需要传递目标对象(如A)的Class，同时需要设置一个回调函数对调用方法进行拦截并进行相应处理，最后通过create()创建目标对象(如A)的代理对象，运行结果与前面的JDK动态代理效果相同。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>Spring AOP内部已都实现了这两种技术，Spring AOP 在使用时机上也进行自动化调整，当有接口时会自动选择JDK动态代理技术，如果没有则选择CGLIB技术，当然Spring AOP的底层实现并没有这么简单，为更简便生成代理对象，Spring AOP 内部实现了一个专注于生成代理对象的工厂类，这样就避免了大量的手动编码，这点也是十分人性化的，但最核心的还是动态代理技术。从性能上来说，Spring AOP 虽然无需特殊编译器协助，但性能上并不优于AspectJ的静态织入。<img src="https://gitee.com/hoo334/picgo/raw/master//img/v2-b091ac6fd64f493eaeabfeff4cee7fee_1440w.png" alt="img"></p><p><a href="https://blog.csdn.net/javazejian/article/details/56267036" target="_blank" rel="noopener">参考</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;基于注解的-Spring-AOP-开发&quot;&gt;&lt;a href=&quot;#基于注解的-Spring-AOP-开发&quot; class=&quot;headerlink&quot; title=&quot;基于注解的 Spring AOP 开发&quot;&gt;&lt;/a&gt;基于注解的 Spring AOP 开发&lt;/h3&gt;
    
    </summary>
    
    
      <category term="SpringBoot" scheme="https://hoo334.github.io/categories/SpringBoot/"/>
    
    
  </entry>
  
  <entry>
    <title>重构</title>
    <link href="https://hoo334.github.io/2021/04/11/%E9%87%8D%E6%9E%84/"/>
    <id>https://hoo334.github.io/2021/04/11/%E9%87%8D%E6%9E%84/</id>
    <published>2021-04-11T05:52:22.979Z</published>
    <updated>2020-10-16T07:14:52.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="代码的坏味道"><a href="#代码的坏味道" class="headerlink" title="代码的坏味道"></a>代码的坏味道</h2><h3 id="Duplicated-Code（重复代码）"><a href="#Duplicated-Code（重复代码）" class="headerlink" title="Duplicated Code（重复代码）"></a>Duplicated Code（重复代码）</h3><p>如果你在一个以上的地方看见相同的程序结构，将它们合二为一。</p><h3 id="Long-Method（过长函数）"><a href="#Long-Method（过长函数）" class="headerlink" title="Long Method（过长函数）"></a>Long Method（过长函数）</h3><p>将过长的函数分解为若干个小函数。</p><a id="more"></a><h3 id="Large-Class（过大的类）"><a href="#Large-Class（过大的类）" class="headerlink" title="Large Class（过大的类）"></a>Large Class（过大的类）</h3><p>单个类要做的事情太多，将其分解为几个类。</p><h3 id="Long-Parameter-List（过长参数列）"><a href="#Long-Parameter-List（过长参数列）" class="headerlink" title="Long Parameter List（过长参数列）"></a>Long Parameter List（过长参数列）</h3><p>如果参数太多，考虑使用参数对象。</p><h3 id="Divergent-Change（发散式变化）"><a href="#Divergent-Change（发散式变化）" class="headerlink" title="Divergent Change（发散式变化）"></a>Divergent Change（发散式变化）</h3><p>某个类经常因为不同的原因在不同的方向上发生变化。当你看见<strong>一个类</strong>说：“新加入一个数据库，我必须修改三个函数”</p><h3 id="Shotgun-Surgery（霰弹式修改）"><a href="#Shotgun-Surgery（霰弹式修改）" class="headerlink" title="Shotgun Surgery（霰弹式修改）"></a>Shotgun Surgery（霰弹式修改）</h3><p>如果每遇到某种变化，你都必须在许多<strong>不同</strong>的类中做出许多小修改。</p><h3 id="Feature-Envy（依恋情结）"><a href="#Feature-Envy（依恋情结）" class="headerlink" title="Feature Envy（依恋情结）"></a>Feature Envy（依恋情结）</h3><p>函数对某个类的兴趣高过于对自己所处类的兴趣。</p><h3 id="Data-Clumps（数据泥团）"><a href="#Data-Clumps（数据泥团）" class="headerlink" title="Data Clumps（数据泥团）"></a>Data Clumps（数据泥团）</h3><p>常在许多地方看到成群的数据，考虑将其抽取为类。</p><h3 id="Primitive-Obsession（基本类型偏执）"><a href="#Primitive-Obsession（基本类型偏执）" class="headerlink" title="Primitive Obsession（基本类型偏执）"></a>Primitive Obsession（基本类型偏执）</h3><p>尝试将原本单独存在的数据值替换为对象</p><h3 id="Switch-Statements（Switch-语句）"><a href="#Switch-Statements（Switch-语句）" class="headerlink" title="Switch Statements（Switch 语句）"></a>Switch Statements（Switch 语句）</h3><p>大多数时候，一看到 Switch ，就应该考虑使用<strong>多态</strong>来替换它。</p><h3 id="Parallel-Inheritance-Hierarchies（平行继承体系）"><a href="#Parallel-Inheritance-Hierarchies（平行继承体系）" class="headerlink" title="Parallel Inheritance Hierarchies（平行继承体系）"></a>Parallel Inheritance Hierarchies（平行继承体系）</h3><p>每当你为某个类增加一个子类，也必须为另一个类增加一个子类。消除策略：让一个继承体系的实例引用另一个继承体系的实例。</p><h3 id="Lazy-Class（冗余类）"><a href="#Lazy-Class（冗余类）" class="headerlink" title="Lazy Class（冗余类）"></a>Lazy Class（冗余类）</h3><p>删除它。</p><h3 id="Speculative-Generality（夸夸其谈未来性）"><a href="#Speculative-Generality（夸夸其谈未来性）" class="headerlink" title="Speculative Generality（夸夸其谈未来性）"></a>Speculative Generality（夸夸其谈未来性）</h3><p>删掉无用的函数和linshi函数中多余的参数。</p><h3 id="Temporary-Field（令人迷惑的暂时字段）"><a href="#Temporary-Field（令人迷惑的暂时字段）" class="headerlink" title="Temporary Field（令人迷惑的暂时字段）"></a>Temporary Field（令人迷惑的暂时字段）</h3><p>类中某个实例变量仅为某种特定情况而设置，通常你认为对象在所有时候都需要它的所有变量，在变量未被使用的情况下猜测其设置目的，会让你发疯的！将这些变量抽取为类。</p><h3 id="Message-Chains（过度耦合的消息链）"><a href="#Message-Chains（过度耦合的消息链）" class="headerlink" title="Message Chains（过度耦合的消息链）"></a>Message Chains（过度耦合的消息链）</h3><p>用户向一个对象请求另一个对象，然后再向后者请求另一个都西昂，然后再请求另一个对象 ……… 这就是消息链。</p><h3 id="Middle-Man（中间人）"><a href="#Middle-Man（中间人）" class="headerlink" title="Middle Man（中间人）"></a>Middle Man（中间人）</h3><p>某个类接口有一半的函数都委托给其他类，这是就应该去掉 Middle Man，直接和真正负责的对象打交道。</p><h3 id="Inappropriate-Intimacy（狎昵关系）"><a href="#Inappropriate-Intimacy（狎昵关系）" class="headerlink" title="Inappropriate Intimacy（狎昵关系）"></a>Inappropriate Intimacy（狎昵关系）</h3><p>两个类过于亲密，花费太多时间去探究彼此的 private 成分。应该将这两个类分开，帮它们划清界限。</p><h3 id="Alternative-Classes-with-Different-Interfaces（异曲同工的类）"><a href="#Alternative-Classes-with-Different-Interfaces（异曲同工的类）" class="headerlink" title="Alternative Classes with Different Interfaces（异曲同工的类）"></a>Alternative Classes with Different Interfaces（异曲同工的类）</h3><p>两个函数做着同样的事情，却有不同的签名，尝试根据它们的用途进行重命名。</p><h3 id="Data-Class（纯稚的数据类）"><a href="#Data-Class（纯稚的数据类）" class="headerlink" title="Data Class（纯稚的数据类）"></a>Data Class（纯稚的数据类）</h3><p>拥有一些字段，以及用于访问这些字段的函数。</p><h3 id="Refused-Bequest（被拒绝的捐赠）"><a href="#Refused-Bequest（被拒绝的捐赠）" class="headerlink" title="Refused Bequest（被拒绝的捐赠）"></a>Refused Bequest（被拒绝的捐赠）</h3><p>子类不想或不需要继承超类的函数和数据。</p><h3 id="Comments（过多的注释）"><a href="#Comments（过多的注释）" class="headerlink" title="Comments（过多的注释）"></a>Comments（过多的注释）</h3><p> 一段代码中有长长的注释，尝试重构复杂的地方。</p><h3 id="Incomplete-Library-Class（不完美的库类）"><a href="#Incomplete-Library-Class（不完美的库类）" class="headerlink" title="Incomplete Library Class（不完美的库类）"></a>Incomplete Library Class（不完美的库类）</h3><p>想要对库类添加或修改，可以引入本地扩展。</p><h2 id="重新组织函数"><a href="#重新组织函数" class="headerlink" title="重新组织函数"></a>重新组织函数</h2><h3 id="Extract-Method（提炼函数）"><a href="#Extract-Method（提炼函数）" class="headerlink" title="Extract Method（提炼函数）"></a>Extract Method（提炼函数）</h3><p>你有一段代码可以被组织在一起并独立出来。<strong>将这段代码放进一个独立函数中，并让函数名称解释该函数的用途。</strong></p><h3 id="Inline-Method（内联函数）"><a href="#Inline-Method（内联函数）" class="headerlink" title="Inline Method（内联函数）"></a>Inline Method（内联函数）</h3><p>一个函数的本体与名称同样清楚易懂。<strong>在函数调用点插入函数本体，然后删除函数。</strong></p><h3 id="Inline-Temp（内联临时变量）"><a href="#Inline-Temp（内联临时变量）" class="headerlink" title="Inline Temp（内联临时变量）"></a>Inline Temp（内联临时变量）</h3><p>你有一个临时变量，只被一个简单表达式肤质一次，而它妨碍了其他重构手法。</p><p><strong>将所有对该变量的引用动作，替换为对它赋值的表达式自身。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> basePrice = anOrder.basePrice();</span><br><span class="line"><span class="keyword">return</span> basePrice &gt; <span class="number">100</span>;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> anOrder.basePrice() &gt; <span class="number">100</span>;</span><br></pre></td></tr></table></figure><h3 id="Return-Temp-With-Query（以查询取代临时变量）"><a href="#Return-Temp-With-Query（以查询取代临时变量）" class="headerlink" title="Return Temp With Query（以查询取代临时变量）"></a>Return Temp With Query（以查询取代临时变量）</h3><p>你的此程序以一个临时变量保存某一表达式的运算结果。</p><p><strong>将这个表达式提炼到一个独立函数中。将这个临时变量的所有引用点替换为对新函数的调用。此后，新函数就可被其他函数使用。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> basePrice = _quantity * _itemPrice;</span><br><span class="line"><span class="keyword">if</span>(basePrice &gt; <span class="number">1000</span>)</span><br><span class="line">    <span class="keyword">return</span> basePrice * <span class="number">0.95</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> basePrice * <span class="number">0.99</span>;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(basePrice() &gt; <span class="number">1000</span>)</span><br><span class="line">    <span class="keyword">return</span> basePrice() * <span class="number">0.95</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> basePrice() * <span class="number">0.99</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">basePrice</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _quantity * _itemPrice;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Introduce-Explaining-Variable（引用解释性变量）"><a href="#Introduce-Explaining-Variable（引用解释性变量）" class="headerlink" title="Introduce Explaining Variable（引用解释性变量）"></a>Introduce Explaining Variable（引用解释性变量）</h3><p>你有一个复杂的表达式，<strong>将该复杂表达式（或其中一部分）的结果放进一个临时变量，以此变量名称来解释表达式用途。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>((platform.toUpperCase().indexOf(<span class="string">'MAC'</span>) &gt; -<span class="number">1</span>) &amp;&amp;</span><br><span class="line">  (browser.toUpperCase().indexOf(<span class="string">'IE'</span>) &gt; -<span class="number">1</span>) &amp;&amp;</span><br><span class="line">  wasInitialized() &amp;&amp; resize &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">//do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> isMacOS = platform.toUpperCase().indexOf(<span class="string">'MAC'</span>) &gt; -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> isIEBrowser = browser.toUpperCase().indexOf(<span class="string">'IE'</span>) &gt; -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> wasResized = resize &gt; <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(isMacOS &amp;&amp; isIEBrowser &amp;&amp; wasInitialized() &amp;&amp; wasResized)&#123;</span><br><span class="line"><span class="comment">// do something&#125;</span></span><br></pre></td></tr></table></figure><h3 id="Split-Temporary-Variable（分解临时变量）"><a href="#Split-Temporary-Variable（分解临时变量）" class="headerlink" title="Split Temporary Variable（分解临时变量）"></a>Split Temporary Variable（分解临时变量）</h3><p>你的程序有某个临时变量被赋值超过一次，它既不是循环变量，也不被用于收集计算结果。<strong>针对每次赋值，创造一个独立、对应的临时变量。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> temp = <span class="number">2</span> * (_height + _width);</span><br><span class="line">System.out.println(temp);</span><br><span class="line">temp = _height * _width;</span><br><span class="line">System.out.println(temp);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">double</span> perimeter = <span class="number">2</span> * (_height + _width);</span><br><span class="line">System.out.println(perimeter);</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">double</span> area = _height * _width;</span><br><span class="line">System.out.println(area);</span><br></pre></td></tr></table></figure><h3 id="Remove-Assignments-to-Parameters（移除对参数的赋值）"><a href="#Remove-Assignments-to-Parameters（移除对参数的赋值）" class="headerlink" title="Remove Assignments to Parameters（移除对参数的赋值）"></a>Remove Assignments to Parameters（移除对参数的赋值）</h3><p>代码对一个参数进行赋值。<strong>以一个临时变量取代该参数的位置</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">discount</span><span class="params">(<span class="keyword">int</span> inputVal, <span class="keyword">int</span> quantity, <span class="keyword">int</span> yearToDate)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(inputVal &gt; <span class="number">50</span>) inputVal -= <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">discount</span><span class="params">(<span class="keyword">int</span> inputVal, <span class="keyword">int</span> quantity, <span class="keyword">int</span> yearToDate)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = inputVal;</span><br><span class="line">    <span class="keyword">if</span>(result &gt; <span class="number">50</span>) result -= <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Replace-Method-with-Object（以函数对象取代函数）"><a href="#Replace-Method-with-Object（以函数对象取代函数）" class="headerlink" title="Replace Method with Object（以函数对象取代函数）"></a>Replace Method with Object（以函数对象取代函数）</h3><p>你有一个大型函数，其中对局部变量的使用使你无法采用<strong><em>Extract Method</em></strong>。</p><p><strong>将这个函数放进一个单独对象中，如此一来局部变量就成了对象内的字段。然后你可以在同一个对象中将这个大型函数分解为多个小函数。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Order</span></span>&#123;</span><br><span class="line">    <span class="comment">//长函数</span></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">price</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">double</span> primaryBasePrice;</span><br><span class="line">        <span class="keyword">double</span> secondaryBasePrice;</span><br><span class="line">        <span class="keyword">double</span> tertiaryBasePrice;</span><br><span class="line">        <span class="comment">// long computation</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Order</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">price</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PriceCalculator().compute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PriceCalculator</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> primaryBasePrice;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> secondaryBasePrice;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> tertiaryBasePrice;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">compute</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//long computation</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Subsititute-Algorithm（替换算法）"><a href="#Subsititute-Algorithm（替换算法）" class="headerlink" title="Subsititute Algorithm（替换算法）"></a>Subsititute Algorithm（替换算法）</h3><p>你想要把某个算法替换为另一个更清晰的算法。<strong>将函数本体替换为另一个算法。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">String <span class="title">foundPerson</span><span class="params">(String[] people)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; people.length(); i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(people[i].equals(<span class="string">"Don"</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Don"</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(people[i].equals(<span class="string">"John"</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"John"</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(people[i].equals(<span class="string">"Kent"</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Kent"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">String <span class="title">foundPerson</span><span class="params">(String[] people)</span></span>&#123;</span><br><span class="line">    List&lt;String&gt; candidates = Arrays.asList(<span class="keyword">new</span> String[]&#123;<span class="string">"Don"</span>, <span class="string">"John"</span>, <span class="string">"Kent"</span>&#125;);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; people.length(); i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(candidates.contains(people[i]))&#123;</span><br><span class="line">            <span class="keyword">return</span> people[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="在对象之间搬移特性"><a href="#在对象之间搬移特性" class="headerlink" title="在对象之间搬移特性"></a>在对象之间搬移特性</h2><h3 id="Move-Method（搬移函数）"><a href="#Move-Method（搬移函数）" class="headerlink" title="Move Method（搬移函数）"></a>Move Method（搬移函数）</h3><p>你的程序中，有个函数与其驻类之外的另一个类进行更多交流：调用后者，或被后者调用。</p><p>在该函数最常引用的类中建立一个有着类似行为的新函数。将旧函数变成一个单独的委托函数，或者将旧函数完全移除。</p><h3 id="Move-Field（搬移字段）"><a href="#Move-Field（搬移字段）" class="headerlink" title="Move Field（搬移字段）"></a>Move Field（搬移字段）</h3><p>在你的程序中，某个字段被其所驻类之外的另一个类更多地用到。</p><p><strong>在目标类新建一个字段，修改源字段地所有用户，令它们改用新字段。</strong></p><h3 id="Extract-Class（提炼类）"><a href="#Extract-Class（提炼类）" class="headerlink" title="Extract Class（提炼类）"></a>Extract Class（提炼类）</h3><p>某个类做了应该由两个类做的事。</p><p><strong>建立一个新类，将相关的字段和函数从旧类搬移到新类。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String officeAreaCode;</span><br><span class="line">    <span class="keyword">private</span> String officeNumber;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">getTelephoneNumber</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="string">"("</span> + officeAreaCode + <span class="string">")"</span> + officeNumber);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> TelephoneNumber tel;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">getTelephoneNumber</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> tel.getTelephoneNumber();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TelephoneNumber</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String officeAreaCode;</span><br><span class="line">    <span class="keyword">private</span> String officeNumber;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">getTelephoneNumber</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="string">"("</span> + officeAreaCode + <span class="string">")"</span> + officeNumber);</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Inline-Class（将类内联化）"><a href="#Inline-Class（将类内联化）" class="headerlink" title="Inline Class（将类内联化）"></a>Inline Class（将类内联化）</h3><p>某个类没有做太多事情。<strong>将这个类的所有特性搬移到另一个类中，然后移除原类。</strong></p><p>刚好与<strong><em>Extract Class</em></strong>相反。</p><h3 id="Hide-Delegate（隐藏“委托关系”）"><a href="#Hide-Delegate（隐藏“委托关系”）" class="headerlink" title="Hide Delegate（隐藏“委托关系”）"></a>Hide Delegate（隐藏“委托关系”）</h3><p>客户通过一个委托类来调用另一个对象。<strong>在服务类上建立客户所需的所有函数，用以隐藏委托关系。</strong></p><p>如果某个客户先通过服务对象的字段得到另一个对象，然后调用后者的函数，那么客户就必须知晓这一层委托关系。万一委托关系发生变化，客户也得相应变化。你可以在服务对象上放置一个简单的委托函数，将委托关系隐藏起来，然后去除这种依赖。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Department department;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Department <span class="title">getDepartmeent</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> department;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Department</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Person manager;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Persion <span class="title">getManager</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> manager;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果客户希望知道某人的经理是谁，他必须先取得 Department 对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">manager = john.getDepartment().getManager();</span><br></pre></td></tr></table></figure><p>这样就对客户暴露了 Department 的工作原理，我们在 Person 中建立一个简单的委托函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Person <span class="title">getManager</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> department.getManager();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后客户直接调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">manager = john.getManager();</span><br></pre></td></tr></table></figure><h3 id="Remove-Middle-Man（移除中间人）"><a href="#Remove-Middle-Man（移除中间人）" class="headerlink" title="Remove Middle Man（移除中间人）"></a>Remove Middle Man（移除中间人）</h3><p>某个类做了过多的简单委托动作。<strong>让客户直接调用委托类。</strong></p><p>在 <strong><em>Hide Delegate</em></strong> 中这层封装也是有代价的，它的代价就是：每当客户需要使用受托类的新特性时，你就必须在服务端添加一个简单委托函数。随着受托类的特性越来越多，这一过程会让你痛苦不已。这个时候你就应该让客户直接调用受托类。</p><h3 id="Introduce-Foreign-Method（引入外加函数）"><a href="#Introduce-Foreign-Method（引入外加函数）" class="headerlink" title="Introduce Foreign Method（引入外加函数）"></a>Introduce Foreign Method（引入外加函数）</h3><p>你需要为提供服务的类增加一个函数，但你无法修改这个类。<strong>在客户类中建立一个函数，并以第一参数形式传入一个服务类实例。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Date newStart = <span class="keyword">new</span> Date(previousEnd.getYear(), previousEnd.getMonth(), previousEnd.getDate() + <span class="number">1</span>);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Date <span class="keyword">new</span> Start = nextDay(previousEnd);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Date <span class="title">nextDay</span><span class="params">(Date arg)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Date(arg.getYear(), arg.getMonth(), arg.getDate() + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果可以修改源码，可以自行添加一个新函数；如果不能，就得在客户端编码，补足你要的那个函数。</p><p>如果你发现自己为一个服务类建立了大量外加函数，或者发现有许多类都需要同样的外加函数，就不应该再使用本项重构，而应该使用<strong><em>Introduce Local Extension</em></strong>。</p><h3 id="Introduce-Local-Extension（引入本地扩展）"><a href="#Introduce-Local-Extension（引入本地扩展）" class="headerlink" title="Introduce Local Extension（引入本地扩展）"></a>Introduce Local Extension（引入本地扩展）</h3><p>你需要为服务类提供一些额外函数，但你无法修改这个类。</p><p><strong>建立一个新类，使它包含这些额外函数。让这个扩展品成为源类的子类或包装类。</strong></p><p>我们需要将这些额外函数组织在一起，放到一个恰当地方去。有两种标准对象技术——<strong>子类化（subclassing）</strong>和<strong>包装（wrapping）。</strong>将子类和包装类统称为本地扩展（Local Extension）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//子类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MfDateSub</span> <span class="keyword">extends</span> <span class="title">Date</span></span>&#123;</span><br><span class="line">    MfDateSub(String dateString)&#123;</span><br><span class="line">        <span class="keyword">super</span>(dateString);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">Date <span class="title">nextDay</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Date(getYear(), getMonth(), getDate() + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//包装类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MfDateWrap</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Date original;</span><br><span class="line">    MfDateWrap(String dateString)&#123;</span><br><span class="line">        original = <span class="keyword">new</span> Date(dateString);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    MfDateWrap(Date arg)&#123;</span><br><span class="line">        original = arg;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getYear</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> original.getYear();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMonth</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> original.getMonth();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 省略其他对 Date 类函数的包装</span></span><br><span class="line">    </span><br><span class="line">    <span class="function">Date <span class="title">nextDay</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Date(getYear(), getMonth(), getDate() + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="重新组织数据"><a href="#重新组织数据" class="headerlink" title="重新组织数据"></a>重新组织数据</h2><h3 id="Self-Encapsulate-Field（自封装字段）"><a href="#Self-Encapsulate-Field（自封装字段）" class="headerlink" title="Self Encapsulate Field（自封装字段）"></a>Self Encapsulate Field（自封装字段）</h3><p>你直接访问一个字段，但与字段之间的耦合关系逐渐变得笨拙。<strong>为这个字段建立设值/取值函数，并只以这些函数来访问字段。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> low, high;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">includes</span><span class="params">(<span class="keyword">int</span> arg)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arg &gt;= low &amp;&amp; arg &lt;= high;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> low, hign;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">includes</span><span class="params">(<span class="keyword">int</span> arg)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arg &gt;= getLow() &amp;&amp; arg &lt;= getHigh();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Replace-Data-Value-with-Object（以对象取代数据值）"><a href="#Replace-Data-Value-with-Object（以对象取代数据值）" class="headerlink" title="Replace Data Value with Object（以对象取代数据值）"></a>Replace Data Value with Object（以对象取代数据值）</h3><p>你有一个数据项，需要与其他数据和行为一起使用才有意义。<strong>将数据项变成对象。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Order</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String customer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Order</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Customer customer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Customer</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Change-Value-to-Reference（将值对象改为引用对象）"><a href="#Change-Value-to-Reference（将值对象改为引用对象）" class="headerlink" title="Change Value to Reference（将值对象改为引用对象）"></a>Change Value to Reference（将值对象改为引用对象）</h3><p>你从一个类衍生出许多彼此相等的实例，希望将它们替换为同一个对象。<strong>将这个值对象变成引用对象。</strong></p><p>在<strong><em>Replace Data Value with Object</em></strong>中，留下了一个重构后的程序。到目前为止，Customer 对象还是值对象。就算多份订单属于同一用户，但每个 Order 对象还是拥有各自的 Customer 对象。我希望一个用户可以有多个订单，所有 Order 对象共同拥有同一个 Customer 对象<strong>（每一个客户名称只该对应一个Customer对象）</strong>。</p><p>首先使用<strong><em>Replace Constructor with Factory Method</em></strong>。这样，就可以控制 Customer 对象的创建过程。在 Customer 类中定义这个工厂函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Customer</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Customer <span class="title">create</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Customer(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后更改调用点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Order</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Order</span><span class="params">(String customer)</span></span>&#123;</span><br><span class="line">        customer = Customer.create(customer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后把 Customer 类的构造函数改为 private。</p><p>在 Customer 类中使用 HashMap 存储 Customer 对象，并更改工厂方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Customer</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, Customer&gt; instances = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">store</span><span class="params">()</span></span>&#123;</span><br><span class="line">        instances.put(<span class="keyword">this</span>.getName(), <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//直接写死几个数据(应该从数据库读取)</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loadCustomer</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Customer(<span class="string">"a"</span>).store();</span><br><span class="line">        <span class="keyword">new</span> Customer(<span class="string">"b"</span>).store();</span><br><span class="line">        <span class="keyword">new</span> Customer(<span class="string">"c"</span>).store();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//工厂方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Customer <span class="title">getNamed</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (Customer) instances.get(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Change-Reference-to-Value（将引用对象改为值对象）"><a href="#Change-Reference-to-Value（将引用对象改为值对象）" class="headerlink" title="Change Reference to Value（将引用对象改为值对象）"></a>Change Reference to Value（将引用对象改为值对象）</h3><p>你有一个引用对象，很小且<strong>不可变</strong>，而且不易管理。<strong>将它变成一个值对象（类没有修改对象数据的函数）。</strong></p><h3 id="Replace-Array-with-Object（以对象取代数组）"><a href="#Replace-Array-with-Object（以对象取代数组）" class="headerlink" title="Replace Array with Object（以对象取代数组）"></a>Replace Array with Object（以对象取代数组）</h3><p>你有一个数组，其中的元素各自代表不同的东西。<strong>以对象替换数组，对于数组中的每个元素，以一个字段来表示。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String[] row = <span class="keyword">new</span> String[<span class="number">3</span>];</span><br><span class="line">row[<span class="number">0</span>] = <span class="string">"Liverpool"</span>;</span><br><span class="line">row[<span class="number">1</span>] = <span class="string">"15"</span>;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Performance p = <span class="keyword">new</span> Performance();</span><br><span class="line">p.setName(<span class="string">"Livepool"</span>);</span><br><span class="line">p.setWins(<span class="string">"15"</span>);</span><br></pre></td></tr></table></figure><h3 id="Duplicate-Observed-Data-（复制“被监视数据”）"><a href="#Duplicate-Observed-Data-（复制“被监视数据”）" class="headerlink" title="Duplicate Observed Data （复制“被监视数据”）"></a>Duplicate Observed Data （复制“被监视数据”）</h3><p>你有一些领域（Model）数据置身于 GUI 控件中，而领域函数需要访问这些函数。</p><p>将该数据复制到一个领域对象中。建立一个Observer 模式，用以同步领域对象和 GUI 对象内的重复数据。</p><h3 id="Change-Unidirectional-Association-to-Bidirectional（将单向关联改为双向关联）"><a href="#Change-Unidirectional-Association-to-Bidirectional（将单向关联改为双向关联）" class="headerlink" title="Change Unidirectional Association to Bidirectional（将单向关联改为双向关联）"></a>Change Unidirectional Association to Bidirectional（将单向关联改为双向关联）</h3><p>两个类都需要使用对方特性，但其间只有一条单向连接。<strong>添加一个反向指针，并使修改函数（指改变双方关系的函数）能够同时更新两条连接。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个用户可以有多个订单</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Order</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Customer customer;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setCustomer</span><span class="params">(Customer arg)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(customer != <span class="keyword">null</span>)</span><br><span class="line">            customer.friendOrders().remove(<span class="keyword">this</span>);</span><br><span class="line">        customer = arg;</span><br><span class="line">        <span class="keyword">if</span>(customer != <span class="keyword">null</span>)</span><br><span class="line">            customer.friendOrders().add(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Customer</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Set&lt;Order&gt; orders = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="function">Set&lt;Order&gt; <span class="title">friengOrders</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> orders;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Change-Bidirectional-Association-to-Unidirectional-（将双向关联改为单向关联）"><a href="#Change-Bidirectional-Association-to-Unidirectional-（将双向关联改为单向关联）" class="headerlink" title="Change Bidirectional Association to Unidirectional （将双向关联改为单向关联）"></a>Change Bidirectional Association to Unidirectional （将双向关联改为单向关联）</h3><p>两个类之间有双向关联，但其中一个类如今不再需要另一个类的特性。<strong>去除不必要的关联。</strong></p><p>双向关联很有用，但你也为必须为它付出代价，那就是维护双向连接、确保对象被正确创建和删除而增加的复杂度。大量双向连接也容易造成“僵尸对象”：某个对象本来已经死亡了，却仍然保留在系统中，因为对它的引用还没有完全清除。</p><h3 id="Replace-Magic-Number-with-Symbolic-Constant（以字面常量取代魔法数）"><a href="#Replace-Magic-Number-with-Symbolic-Constant（以字面常量取代魔法数）" class="headerlink" title="Replace Magic Number with Symbolic Constant（以字面常量取代魔法数）"></a>Replace Magic Number with Symbolic Constant（以字面常量取代魔法数）</h3><p>你有一个字面数值，带有特别意义。<strong>创建一个常量，根据其意义为它命名，并将上述的字面数值替换为这个常量。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">potentialEnergy</span><span class="params">(<span class="keyword">double</span> mass, <span class="keyword">double</span> height)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mass * <span class="number">9.81</span> * height;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">double</span> GRAVITATIONAL_CONSTANT = <span class="number">9.81</span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">potentialEnergy</span><span class="params">(<span class="keyword">double</span> mass, <span class="keyword">double</span> height)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mass * GRAVITATIONAL_CONSTANT * height;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Encapsulate-Field（封装字段）"><a href="#Encapsulate-Field（封装字段）" class="headerlink" title="Encapsulate Field（封装字段）"></a>Encapsulate Field（封装字段）</h3><p>你的类中存在一个 public 字段。<strong>将它声明为 private，并提供相应的访问函数。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String name;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Encapsulate-Collection（封装集合）"><a href="#Encapsulate-Collection（封装集合）" class="headerlink" title="Encapsulate Collection（封装集合）"></a>Encapsulate Collection（封装集合）</h3><p>有个函数返回一个集合。<strong>让这个函数返回该集合的一个只读副本，并在这个类中提供添加/移除集合元素的函数。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    List&lt;String&gt; skills = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    String[] getSkills()&#123;</span><br><span class="line">        <span class="keyword">return</span> (String[])skills.toArray(<span class="keyword">new</span> String[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setSkill</span><span class="params">(<span class="keyword">int</span> index, String newSkill)</span></span>&#123;</span><br><span class="line">        skill.set(index, newSkill);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Replace-Record-with-Data-Class（以数据类取代记录）"><a href="#Replace-Record-with-Data-Class（以数据类取代记录）" class="headerlink" title="Replace Record with Data Class（以数据类取代记录）"></a>Replace Record with Data Class（以数据类取代记录）</h3><p>你需要面对传统编程环境中的记录结构。为该记录创建一个 POJO。</p><h3 id="Replace-Type-Code-with-Class（以类取代类型码）"><a href="#Replace-Type-Code-with-Class（以类取代类型码）" class="headerlink" title="Replace Type Code with Class（以类取代类型码）"></a>Replace Type Code with Class（以类取代类型码）</h3><p>类之中有一个数值类型码，但它不影响类的行为。<strong>以一个新的类替换该数值类型码。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> O = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> A = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> B = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> AB = <span class="number">3</span>;</span><br><span class="line">    privaet <span class="keyword">int</span> bloodGroup;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> BloodGroup bloddGroup;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BloodGroup</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> BloodGroup O = <span class="keyword">new</span> BloodGroup(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> BloodGroup A = <span class="keyword">new</span> BloodGroup(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> BloodGroup B = <span class="keyword">new</span> BloodGroup(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> BloodGroup AB = <span class="keyword">new</span> BloodGroup(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> BloodGroup[] values = &#123;O,A,B,AB&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> code;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">BloodGroup</span><span class="params">(<span class="keyword">int</span> code)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.code = code;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Replace-Type-Code-with-Subclasses（以子类取代类型码）"><a href="#Replace-Type-Code-with-Subclasses（以子类取代类型码）" class="headerlink" title="Replace Type Code with Subclasses（以子类取代类型码）"></a>Replace Type Code with Subclasses（以子类取代类型码）</h3><p>你有一个不可变的类型码，它会影响类的行为。<strong>以子类取代这个类型码。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ENGINEER = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SALESMAN = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MANAGER = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> type;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Engineer</span> <span class="keyword">extends</span> <span class="title">Employee</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getType</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Employee.ENGINEER;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//其他两个不写了</span></span><br></pre></td></tr></table></figure><h3 id="Replace-Type-Code-with-State-Strategy-（以State-Strategy取代类型码）"><a href="#Replace-Type-Code-with-State-Strategy-（以State-Strategy取代类型码）" class="headerlink" title="Replace Type Code with State/Strategy （以State/Strategy取代类型码）"></a>Replace Type Code with State/Strategy （以State/Strategy取代类型码）</h3><p>你有一个类型码，它会影响类的行为，但你无法通过继承手法消除它。<strong>以状态对象取代类型码。</strong></p><p>继续使用上面的 Employee 例子。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">EmployeeType</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">getTypeCode</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">extends</span> <span class="title">EmployeeType</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getTypeCode</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Employee.ENGNIEER;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//剩余两个省略</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ENGINEER = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SALESMAN = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MANAGER = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">private</span> EmployeeType type;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getType</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> type.getTypeCode();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setType</span><span class="params">(<span class="keyword">int</span> arg)</span></span>&#123;</span><br><span class="line">        <span class="keyword">switch</span>(arg)&#123;</span><br><span class="line">            <span class="keyword">case</span> ENGNIEER:</span><br><span class="line">                type = <span class="keyword">new</span> Engineer();<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> SALESMAN:</span><br><span class="line">                type = <span class="keyword">new</span> Salesman();<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MANAGER:</span><br><span class="line">                type = <span class="keyword">new</span> Manager();<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Incorrect Employee Code"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Replace-Subclass-with-Field（以字段取代子类）"><a href="#Replace-Subclass-with-Field（以字段取代子类）" class="headerlink" title="Replace Subclass with Field（以字段取代子类）"></a>Replace Subclass with Field（以字段取代子类）</h3><p>你的各个子类的唯一差别只在“返回常量数据”的函数上。<strong>修改这些函数，使它们返回超类中的某个（新增）字段，然后销毁子类。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">char</span> <span class="title">getCode</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Male</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">getCode</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'M'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Female</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">getCode</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'F'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> code;</span><br><span class="line">    Person(<span class="keyword">char</span> code)&#123;</span><br><span class="line">        <span class="keyword">this</span>.code = code;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">static</span> Person <span class="title">createMale</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Person(<span class="string">'M'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">static</span> Person <span class="title">createFemale</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Person(<span class="string">'F'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="简化条件表达式"><a href="#简化条件表达式" class="headerlink" title="简化条件表达式"></a>简化条件表达式</h2><h3 id="Decompose-Conditional（分解条件表达式）"><a href="#Decompose-Conditional（分解条件表达式）" class="headerlink" title="Decompose Conditional（分解条件表达式）"></a>Decompose Conditional（分解条件表达式）</h3><p>你有一个复杂的条件（if - then - else）语句。<strong>从 if、then、else 三个段落中分别提炼处独立函数。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(date.before (SUMMER_START) || date.after(SUMMER_END))</span><br><span class="line">    charge = quantity * winterRate + winterServiceCharge;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    charge = quantity * summerRate;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(notSummer(date))</span><br><span class="line">    charge = winterCharge(quantity);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    charge = summerCharge(quantity);</span><br></pre></td></tr></table></figure><h3 id="Consolidate-Conditional-Expression（合并条件表达式）"><a href="#Consolidate-Conditional-Expression（合并条件表达式）" class="headerlink" title="Consolidate Conditional Expression（合并条件表达式）"></a>Consolidate Conditional Expression（合并条件表达式）</h3><p>你有一系列条件测试，都得到相同结果。<strong>将这些测试合并为一个条件表达式，并将这个条件表达式提炼为一个独立函数。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">disabilityAmount</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(seniority &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(monthsDisabled &gt; <span class="number">12</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(isPartTime) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// compute the disability amount</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">disabilityAmount</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(isNotEligibleForDisability()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// compute the disability amount</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isNotEligibleForDisability</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> seniority &lt; <span class="number">2</span> || monthsDisabled &gt; <span class="number">12</span> || isPartTime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Consolidate-Duplicate-Conditional-Fragments（合并重复的条件片段）"><a href="#Consolidate-Duplicate-Conditional-Fragments（合并重复的条件片段）" class="headerlink" title="Consolidate Duplicate Conditional Fragments（合并重复的条件片段）"></a>Consolidate Duplicate Conditional Fragments（合并重复的条件片段）</h3><p>在条件表达式的每个分支上有着相同的一段代码。<strong>将这段重复代码搬移到条件表达式之外。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(isSpecialDeal())&#123;</span><br><span class="line">    total = price * <span class="number">0.95</span>;</span><br><span class="line">    send();</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    total = price * <span class="number">0.98</span>;</span><br><span class="line">    send();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(isSpecialDeal())</span><br><span class="line">    total = price * <span class="number">0.95</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    total = price * <span class="number">0.98</span>;</span><br><span class="line">send();</span><br></pre></td></tr></table></figure><h3 id="Remove-Control-Flag（移除控制标记）"><a href="#Remove-Control-Flag（移除控制标记）" class="headerlink" title="Remove Control Flag（移除控制标记）"></a>Remove Control Flag（移除控制标记）</h3><p>在一系列布尔表达式中，某个变量带有“控制标记（control flag）的作用。<strong>以 break 语句或 return 语句取代控制标记。</strong></p><h3 id="Replace-Nested-Conditional-with-Guard-Classes（以卫语句取代嵌套条件表达式）"><a href="#Replace-Nested-Conditional-with-Guard-Classes（以卫语句取代嵌套条件表达式）" class="headerlink" title="Replace Nested Conditional with Guard Classes（以卫语句取代嵌套条件表达式）"></a>Replace Nested Conditional with Guard Classes（以卫语句取代嵌套条件表达式）</h3><p>函数中的条件逻辑使人难以看清正常的执行路径。<strong>使用卫语句（单独检查语句）</strong>表现所有特殊情况。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">getPayAmount</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> result;</span><br><span class="line">    <span class="keyword">if</span>(isDead) result = deadAmount();</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(isSeparated) result = separatedAmount();</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(isRetired) result = retiredAmount();</span><br><span class="line">            <span class="keyword">else</span> result = normalPayment();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">getPayAmount</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(isDead) <span class="keyword">return</span> deadAmount();</span><br><span class="line">    <span class="keyword">if</span>(isSeparated) <span class="keyword">return</span> separatedAmount();</span><br><span class="line">    <span class="keyword">if</span>(isRetired) <span class="keyword">return</span> retiredAmount();</span><br><span class="line">    <span class="keyword">return</span> normalAmount();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Replace-Conditional-with-Polymorphism（以多态取代条件表达式）"><a href="#Replace-Conditional-with-Polymorphism（以多态取代条件表达式）" class="headerlink" title="Replace Conditional with Polymorphism（以多态取代条件表达式）"></a>Replace Conditional with Polymorphism（以多态取代条件表达式）</h3><p>你手上有个条件表达式，它根据对象类型的不同而选择不同的行为。<strong>将这个条件表达式的每个分支放进一个子类的覆写函数中，然后将原始函数声明为抽象函数。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">getSpeed</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(type)&#123;</span><br><span class="line">        <span class="keyword">case</span> EUROPEAN : <span class="keyword">return</span> getBaseSpeed();</span><br><span class="line">        <span class="keyword">case</span> AFRICAN: <span class="keyword">return</span> getBaseSpeed() - getLoadFactor() * numberOfCoconuts;</span><br><span class="line">        <span class="keyword">case</span> NORWEGIAN_BLUE: <span class="keyword">return</span> isNailed ? <span class="number">0</span> : getBaseSpeed(voltage);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Bird</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">double</span> <span class="title">getSpeed</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">European</span> <span class="keyword">extends</span> <span class="title">Bird</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getSpeed</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getSpeed();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//剩下两个类省略</span></span><br></pre></td></tr></table></figure><h3 id="Introduce-Null-Object（引入-Null-对象）"><a href="#Introduce-Null-Object（引入-Null-对象）" class="headerlink" title="Introduce Null Object（引入 Null 对象）"></a>Introduce Null Object（引入 Null 对象）</h3><p>你需要再三检查某独享是否为 null。<strong>将 null 值替换为 null 对象。</strong></p><h3 id="Introduce-Assertion（引入断言）"><a href="#Introduce-Assertion（引入断言）" class="headerlink" title="Introduce Assertion（引入断言）"></a>Introduce Assertion（引入断言）</h3><p>某一段代码需要对程序状态做出某种假设。<strong>以断言明确表现这种假设。</strong></p><p>断言的失败应该导致一个非受控异常。程序最后的成品往往将断言统统删除。</p><h2 id="简化函数调用"><a href="#简化函数调用" class="headerlink" title="简化函数调用"></a>简化函数调用</h2><h3 id="Remove-Method（函数改名）"><a href="#Remove-Method（函数改名）" class="headerlink" title="Remove Method（函数改名）"></a>Remove Method（函数改名）</h3><p>函数的名称未能揭示函数的用途。<strong>修改函数名称。</strong></p><h3 id="Add-Parameter（添加参数）"><a href="#Add-Parameter（添加参数）" class="headerlink" title="Add Parameter（添加参数）"></a>Add Parameter（添加参数）</h3><p>某个函数需要从调用端得到更多信息。<strong>为此函数添加一个对象参数，让该对象带进函数所需信息。</strong></p><h3 id="Remove-Parameter（移除参数）"><a href="#Remove-Parameter（移除参数）" class="headerlink" title="Remove Parameter（移除参数）"></a>Remove Parameter（移除参数）</h3><p>函数本体不再需要某个参数。<strong>将该参数去除。</strong></p><h3 id="Separate-Query-from-Modifier（将查询函数和修改函数分离）"><a href="#Separate-Query-from-Modifier（将查询函数和修改函数分离）" class="headerlink" title="Separate Query from Modifier（将查询函数和修改函数分离）"></a>Separate Query from Modifier（将查询函数和修改函数分离）</h3><p>某个函数既返回对象状态值，又修改对象状态。<strong>建立两个不同的函数，其中一个负责查询，另一个负责修改。</strong></p><h3 id="Parameterize-Method（令函数携带参数）"><a href="#Parameterize-Method（令函数携带参数）" class="headerlink" title="Parameterize Method（令函数携带参数）"></a>Parameterize Method（令函数携带参数）</h3><p>若干函数做了类似的工作，但在函数本体中却包含了不同的值。<strong>建立单一函数，以参数表达那些不同的值。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fivePercentRaise</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">tenPercentRaise</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">raise</span><span class="params">(<span class="keyword">double</span> percentage)</span></span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Replace-Parameter-with-Explicit-Methods（以明确函数取代参数）"><a href="#Replace-Parameter-with-Explicit-Methods（以明确函数取代参数）" class="headerlink" title="Replace Parameter with Explicit Methods（以明确函数取代参数）"></a>Replace Parameter with Explicit Methods（以明确函数取代参数）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setValue</span><span class="params">(String name, <span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(name.equals(<span class="string">"height"</span>))&#123;</span><br><span class="line">        height = value;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(name.equals(<span class="string">"width"</span>))&#123;</span><br><span class="line">        width = value;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setHeight</span><span class="params">(<span class="keyword">int</span> arg)</span></span>&#123;</span><br><span class="line">    height = arg;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setWidth</span><span class="params">(<span class="keyword">int</span> arg)</span></span>&#123;</span><br><span class="line">    width = arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Preserve-Whole-Object（保持对象完整）"><a href="#Preserve-Whole-Object（保持对象完整）" class="headerlink" title="Preserve Whole Object（保持对象完整）"></a>Preserve Whole Object（保持对象完整）</h3><p>你从某个对象中取出若干值，将它们作为某一次函数调用时的参数。<strong>改为传递整个对象。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> low = daysTempRange().getLow();</span><br><span class="line"><span class="keyword">int</span> high = daysTemoRange().getHigh();</span><br><span class="line">withinPlan = plan.withinRange(low, high);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">withinPlan = plan,withinRange(daysTempRange());</span><br></pre></td></tr></table></figure><h3 id="Replace-Parameter-with-Methods（以函数取代函数）"><a href="#Replace-Parameter-with-Methods（以函数取代函数）" class="headerlink" title="Replace Parameter with Methods（以函数取代函数）"></a>Replace Parameter with Methods（以函数取代函数）</h3><p>对象调用某个函数，并将所得结果作为参数，传递给另一个函数。而接受该参数的函数本身也能调用前一个函数。<strong>让参数接受者去除该项参数，并直接调用前一个函数。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> basePrice = quantity * itemPrice;</span><br><span class="line">discountLevel = getDiscountLevel();</span><br><span class="line"><span class="keyword">double</span> finalPrice = discountedPrice(basePrice, discountLevel);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> basePrice = quantity * itemPrice;</span><br><span class="line"><span class="keyword">double</span> finalPrice = discountedPrice(basePrice);</span><br><span class="line"><span class="comment">// 让 discountedPrice 直接调用 getDiscountLevel 函数</span></span><br></pre></td></tr></table></figure><h3 id="Introduce-Parameter-Object（引入参数对象）"><a href="#Introduce-Parameter-Object（引入参数对象）" class="headerlink" title="Introduce Parameter Object（引入参数对象）"></a>Introduce Parameter Object（引入参数对象）</h3><p>某些参数总是很自然地同时出现。<strong>以一个对象取代这些参数。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Customer</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">amountInvoicedIn</span><span class="params">(Date start, Date end)</span></span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Customer</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">amountInvoicedIn</span><span class="params">(DateRange dateRange)</span></span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Remove-Setting-Method（移除设值函数）"><a href="#Remove-Setting-Method（移除设值函数）" class="headerlink" title="Remove Setting Method（移除设值函数）"></a>Remove Setting Method（移除设值函数）</h3><p>类中的某个字段应该在对象创建时被设值，然后就不再改变。<strong>去掉该字段的所有设值函数。</strong></p><h3 id="Hide-Method（隐藏函数）"><a href="#Hide-Method（隐藏函数）" class="headerlink" title="Hide Method（隐藏函数）"></a>Hide Method（隐藏函数）</h3><p>有一个函数，从来没有被其他任何类用到。<strong>将这个函数修改为 private。</strong></p><h3 id="Replace-Constructor-with-Factory-Method（以工厂函数取代构造函数）"><a href="#Replace-Constructor-with-Factory-Method（以工厂函数取代构造函数）" class="headerlink" title="Replace Constructor with Factory Method（以工厂函数取代构造函数）"></a>Replace Constructor with Factory Method（以工厂函数取代构造函数）</h3><p>你希望在创建对象时不仅仅是做简单的建构动作。<strong>将构造函数替换为工厂函数。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Employee(<span class="keyword">int</span> type)&#123;</span><br><span class="line">    <span class="keyword">this</span>.type = type;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> Employee <span class="title">create</span><span class="params">(<span class="keyword">int</span> type)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Employee(type);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Encapsulate-Downcast（封装向下转型）"><a href="#Encapsulate-Downcast（封装向下转型）" class="headerlink" title="Encapsulate Downcast（封装向下转型）"></a>Encapsulate Downcast（封装向下转型）</h3><p>某个函数返回的对象，需要函数调用者执行向下转型（downcast）。<strong>将向下转型动作移到函数中。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Object <span class="title">lastReading</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> readings.lastElement();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Reading <span class="title">lastReading</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (Reading)readings.lastElement();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Replace-Error-Code-with-Exception（以异常取代错误码）"><a href="#Replace-Error-Code-with-Exception（以异常取代错误码）" class="headerlink" title="Replace Error Code with Exception（以异常取代错误码）"></a>Replace Error Code with Exception（以异常取代错误码）</h3><p>某个函数返回一个特定的代码，用以表示某种特殊情况。<strong>改用异常。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">withdraw</span><span class="params">(<span class="keyword">int</span> amount)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(amount &gt; balance)&#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        balance -= amount;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">withdraw</span><span class="params">(<span class="keyword">int</span> amount)</span> <span class="keyword">throws</span> BalaceException</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(amount &gt; balance) <span class="keyword">throw</span> <span class="keyword">new</span> BalanceException();</span><br><span class="line">    balance -= amount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Replace-Exception-with-Test（以测试取代异常）"><a href="#Replace-Exception-with-Test（以测试取代异常）" class="headerlink" title="Replace Exception with Test（以测试取代异常）"></a>Replace Exception with Test（以测试取代异常）</h3><p>面对一个调用着可以预先检查的条件，你抛出了一个异常。<strong>修改调用者，使它在调用函数之气那先做检查。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">getValueForPeriod</span><span class="params">(<span class="keyword">int</span> periodNumber)</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value[periodNumber];</span><br><span class="line">    &#125; <span class="keyword">catch</span>(ArrayIndexOutOfBoundsException e)&#123; <span class="comment">// 滥用异常</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">getValueForPeriod</span><span class="params">(<span class="keyword">int</span> periodNumber)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(periodNumber &gt;= values.length) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> values[periodNumber];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="处理概括关系（继承关系）"><a href="#处理概括关系（继承关系）" class="headerlink" title="处理概括关系（继承关系）"></a>处理概括关系（继承关系）</h2><h3 id="Pull-Up-Field（字段上移）"><a href="#Pull-Up-Field（字段上移）" class="headerlink" title="Pull Up Field（字段上移）"></a>Pull Up Field（字段上移）</h3><p>两个子类拥有相同的字段。<strong>将该字段移至超类。</strong></p><h3 id="Pull-Up-Method（函数上移）"><a href="#Pull-Up-Method（函数上移）" class="headerlink" title="Pull Up Method（函数上移）"></a>Pull Up Method（函数上移）</h3><p>有些函数，在各个子类中产生完全相同的结果。<strong>将该函数移至超类。</strong></p><h3 id="Pull-Up-Constructor-Body（构造函数本体上移）"><a href="#Pull-Up-Constructor-Body（构造函数本体上移）" class="headerlink" title="Pull Up Constructor Body（构造函数本体上移）"></a>Pull Up Constructor Body（构造函数本体上移）</h3><p>你在各个子类中拥有一些构造函数，它们的本体几乎完全一致。<strong>在超类中新建一个构造函数，并在子类构造函数中调用它。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Manager</span> <span class="keyword">extends</span> <span class="title">Employee</span></span>&#123;</span><br><span class="line">    Manager(String name, String id, <span class="keyword">int</span> grade)&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.grade = grade;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Manager</span> <span class="keyword">extends</span> <span class="title">Employee</span></span>&#123;</span><br><span class="line">    Manager(String name, String id, <span class="keyword">int</span> grade)&#123;</span><br><span class="line">        <span class="keyword">super</span>(name, id);</span><br><span class="line">        <span class="keyword">this</span>.grade = grade;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Push-Down-Method（函数下移）"><a href="#Push-Down-Method（函数下移）" class="headerlink" title="Push Down Method（函数下移）"></a>Push Down Method（函数下移）</h3><p>超类中的某个函数只与部分（而非全部）子类有关。<strong>将这个函数移到相关的那些子类去。</strong></p><h3 id="Push-Down-Field（字段下移）"><a href="#Push-Down-Field（字段下移）" class="headerlink" title="Push Down Field（字段下移）"></a>Push Down Field（字段下移）</h3><p>超类中的某些字段只被部分（而非全部）子类用到。<strong>将这个字段移到需要它的那些子类去。</strong></p><h3 id="Extract-Subclass（提炼子类）"><a href="#Extract-Subclass（提炼子类）" class="headerlink" title="Extract Subclass（提炼子类）"></a>Extract Subclass（提炼子类）</h3><p>类中的某些特性只被某些（而非全部）实例用到。<strong>新建一个子类，将上面所说的那一部分特性移到子类中。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JobItem</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getTotalPrice</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">unitPrice</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">    <span class="function">Employee <span class="title">getEmployee</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JobItem</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getTotalPrice</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">unitPrice</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LaborItem</span> <span class="keyword">extends</span> <span class="title">JobItem</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">unitPrice</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">    <span class="function">Employee <span class="title">getEmployee</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Extract-Superclass（提炼超类）"><a href="#Extract-Superclass（提炼超类）" class="headerlink" title="Extract Superclass（提炼超类）"></a>Extract Superclass（提炼超类）</h3><p>两个类有相似特性。<strong>为这两个类建立一个超类，将相同特性移至超类。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Department</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getTotalAnnualCost</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">    <span class="function">String <span class="title">getName</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getHeadCount</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getAnnualCost</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">    <span class="function">String <span class="title">getName</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">getId</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Party</span></span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">double</span> <span class="title">getAnnualCost</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> String <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">extends</span> <span class="title">Party</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getAnnualCost</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">getId</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Department</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getAnnualCost</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getHeadCount</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Extract-Interface（提炼接口）"><a href="#Extract-Interface（提炼接口）" class="headerlink" title="Extract Interface（提炼接口）"></a>Extract Interface（提炼接口）</h3><p>若干客户使用类接口中的同一子集，或者两个类的接口有部分相同。<strong>将相同的子集提炼到独立接口中。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span></span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">getRate</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">    <span class="function">String <span class="title">hasSpecialSkill</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">    <span class="function">String <span class="title">getName</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">    String getDepartment&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Billable</span></span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">getRate</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">hasSpecialSkill</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">Billable</span></span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">getRate</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">    <span class="function">String <span class="title">hasSpecialSkill</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">    <span class="function">String <span class="title">getName</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">    String getDepartment&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Collapse-Hierarchy（折叠继承体系）"><a href="#Collapse-Hierarchy（折叠继承体系）" class="headerlink" title="Collapse Hierarchy（折叠继承体系）"></a>Collapse Hierarchy（折叠继承体系）</h3><p>超类与子类之间无太大区别。<strong>将它们合为一体。</strong></p><h3 id="Form-Template-Method（塑造模板函数）"><a href="#Form-Template-Method（塑造模板函数）" class="headerlink" title="Form Template Method（塑造模板函数）"></a>Form Template Method（塑造模板函数）</h3><p>你有一些子类，其中相应的某些函数以相同顺序执行类似的操作，但各个操作的细节上有所不同。</p><p><strong>将这些操作分别放金独立函数中，并保持它们都有相同的签名，于是原函数也就变得相同了。然后将原函数上移至超类。</strong></p><h3 id="Replace-Inheritance-with-Delegation（以委托取代继承）"><a href="#Replace-Inheritance-with-Delegation（以委托取代继承）" class="headerlink" title="Replace Inheritance with Delegation（以委托取代继承）"></a>Replace Inheritance with Delegation（以委托取代继承）</h3><p>某个子类只使用超类接口中的一部分，或是根本不需要继承而来得数据。<strong>在子类中新建一个字段用以保存超类；调整子类函数，令它改而委托超类；然后去掉两者之间的继承关系。</strong></p><h3 id="Replace-Delegation-with-Inheritance（以继承取代委托）"><a href="#Replace-Delegation-with-Inheritance（以继承取代委托）" class="headerlink" title="Replace Delegation with Inheritance（以继承取代委托）"></a>Replace Delegation with Inheritance（以继承取代委托）</h3><p>你在两个类之间使用委托关系，并经常为整个接口编写许多极简单的委托函数。<strong>让委托类继承受托类。</strong></p><h2 id="大型重构"><a href="#大型重构" class="headerlink" title="大型重构"></a>大型重构</h2><h3 id="Tease-Apart-Inheritance（梳理并分解继承体系）"><a href="#Tease-Apart-Inheritance（梳理并分解继承体系）" class="headerlink" title="Tease Apart Inheritance（梳理并分解继承体系）"></a>Tease Apart Inheritance（梳理并分解继承体系）</h3><p>某个继承体系同时承担两项责任。<strong>建立两个继承体系，并通过委托关系让其中一个可以调用另一个。</strong></p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20201016150252385.png" alt="image-20201016150252385"></p><h3 id="Convert-Procedural-Design-to-Objects（将过程化设计转换为对象设计）"><a href="#Convert-Procedural-Design-to-Objects（将过程化设计转换为对象设计）" class="headerlink" title="Convert Procedural Design to Objects（将过程化设计转换为对象设计）"></a>Convert Procedural Design to Objects（将过程化设计转换为对象设计）</h3><p>你手上有一些传统过程化风格的代码。<strong>将数据记录变成对象，将大块的行为分成小块，并将行为移入相关对象中。</strong></p><h3 id="Separate-Domain-from-Presentation（将领域和表述-显示分离）"><a href="#Separate-Domain-from-Presentation（将领域和表述-显示分离）" class="headerlink" title="Separate Domain from Presentation（将领域和表述/显示分离）"></a>Separate Domain from Presentation（将领域和表述/显示分离）</h3><p>某些 GUI 类中包含了领域逻辑。<strong>将领域逻辑分离出来，为它们建立独立的领域类。</strong></p><p>MVC 模式最核心的价值在于：它将用户界面代码（即视图；也是“展示层”）和领域逻辑（即模型）分离了。展现类只含用以处理用户界面的逻辑；领域类不含任何与程序外观的代码，只含业务逻辑相关代码。</p><h3 id="Extract-Hierarchy（提炼继承体系）"><a href="#Extract-Hierarchy（提炼继承体系）" class="headerlink" title="Extract Hierarchy（提炼继承体系）"></a>Extract Hierarchy（提炼继承体系）</h3><p>你有某个类做了太多工作，其中一部分工作是以大量条件表达式完成的。<strong>建立继承体系，以一个子类表示一种特殊情况。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;代码的坏味道&quot;&gt;&lt;a href=&quot;#代码的坏味道&quot; class=&quot;headerlink&quot; title=&quot;代码的坏味道&quot;&gt;&lt;/a&gt;代码的坏味道&lt;/h2&gt;&lt;h3 id=&quot;Duplicated-Code（重复代码）&quot;&gt;&lt;a href=&quot;#Duplicated-Code（重复代码）&quot; class=&quot;headerlink&quot; title=&quot;Duplicated Code（重复代码）&quot;&gt;&lt;/a&gt;Duplicated Code（重复代码）&lt;/h3&gt;&lt;p&gt;如果你在一个以上的地方看见相同的程序结构，将它们合二为一。&lt;/p&gt;
&lt;h3 id=&quot;Long-Method（过长函数）&quot;&gt;&lt;a href=&quot;#Long-Method（过长函数）&quot; class=&quot;headerlink&quot; title=&quot;Long Method（过长函数）&quot;&gt;&lt;/a&gt;Long Method（过长函数）&lt;/h3&gt;&lt;p&gt;将过长的函数分解为若干个小函数。&lt;/p&gt;
    
    </summary>
    
    
      <category term="笔记" scheme="https://hoo334.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>丑数II</title>
    <link href="https://hoo334.github.io/2021/04/11/%E4%B8%91%E6%95%B0II/"/>
    <id>https://hoo334.github.io/2021/04/11/%E4%B8%91%E6%95%B0II/</id>
    <published>2021-04-11T02:37:25.000Z</published>
    <updated>2021-04-11T02:58:56.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="264-丑数-II"><a href="#264-丑数-II" class="headerlink" title="264. 丑数 II"></a><a href="https://leetcode-cn.com/problems/ugly-number-ii/" target="_blank" rel="noopener">264. 丑数 II</a></h4><p>给你一个整数 <code>n</code> ，请你找出并返回第 <code>n</code> 个 <strong>丑数</strong> 。</p><p><strong>丑数</strong> 就是只包含质因数 <code>2</code>、<code>3</code> 和/或 <code>5</code> 的正整数。</p> <a id="more"></a><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n &#x3D; 10</span><br><span class="line">输出：12</span><br><span class="line">解释：[1, 2, 3, 4, 5, 6, 8, 9, 10, 12] 是由前 10 个丑数组成的序列。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n &#x3D; 1</span><br><span class="line">输出：1</span><br><span class="line">解释：1 通常被视为丑数。</span><br></pre></td></tr></table></figure><p> <strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 1690</code></li></ul><p><strong>方法一：最小堆</strong></p><p>初始时堆为空，首先将最小的丑数 1 加入堆，每次取出堆顶元素 x，则 x 是堆中最小的丑数，2x，3x，5x也是丑数，因此将 2x，3x，5x，加入堆中，但这会导致出现重复元素，为了避免出现重复元素，我们使用哈希表去重。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nthUglyNumber</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] factors = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        Set&lt;Long&gt; seen = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        PriorityQueue&lt;Long&gt; heap = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line">        seen.add(<span class="number">1L</span>);</span><br><span class="line">        heap.offer(<span class="number">1L</span>);</span><br><span class="line">        <span class="keyword">int</span> ugly = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">long</span> curr = heap.poll();</span><br><span class="line">            ugly = (<span class="keyword">int</span>) curr;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> factor : factors)&#123;</span><br><span class="line">                <span class="keyword">long</span> next = curr * factor;</span><br><span class="line">                <span class="keyword">if</span>(seen.add(next))&#123; </span><br><span class="line">                    heap.offer(next);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ugly;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度O(nlogn)</li><li>空间复杂度O(n)</li></ul><p><strong>方法二：动态规划</strong></p><p>在方法一中，我们存储了较多的丑数，导致空间复杂度较高。我们可以使用三个指针来指向最小的三个丑数。</p><p>定义数组 dp，dp[i] 表示第 i 个丑数，第 n 个丑数为 dp[n]，dp[1] = 1。</p><p>定义三个指针 p2，p3，p5，下一个丑数是当前指针指向的凑数乘以对应的质因数。下一个丑数分别为，2 * p2, 3 * p3, 5 * p5，我们取这三个数的最小值，然后将使用过的指针加一。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nthUglyNumber</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> p2 = <span class="number">1</span>, p3 = <span class="number">1</span>, p5 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> num2 = dp[p2] * <span class="number">2</span>, num3 = dp[p3] * <span class="number">3</span>, num5 = dp[p5] * <span class="number">5</span>;</span><br><span class="line">            <span class="comment">//取三个数中的最小值</span></span><br><span class="line">            dp[i] = Math.min(Math.min(num2, num3), num5);</span><br><span class="line">            <span class="comment">//将使用过的指针加一</span></span><br><span class="line">            <span class="keyword">if</span>(dp[i] == num2)&#123;</span><br><span class="line">                ++p2;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(dp[i] == num3)&#123;</span><br><span class="line">                ++p3;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(dp[i] == num5)&#123;</span><br><span class="line">                ++p5;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度O(n)</li><li>空间复杂度O(n)</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;264-丑数-II&quot;&gt;&lt;a href=&quot;#264-丑数-II&quot; class=&quot;headerlink&quot; title=&quot;264. 丑数 II&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/ugly-number-ii/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;264. 丑数 II&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;给你一个整数 &lt;code&gt;n&lt;/code&gt; ，请你找出并返回第 &lt;code&gt;n&lt;/code&gt; 个 &lt;strong&gt;丑数&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;丑数&lt;/strong&gt; 就是只包含质因数 &lt;code&gt;2&lt;/code&gt;、&lt;code&gt;3&lt;/code&gt; 和/或 &lt;code&gt;5&lt;/code&gt; 的正整数。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode Medium" scheme="https://hoo334.github.io/tags/Leetcode-Medium/"/>
    
      <category term="动态规划" scheme="https://hoo334.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>搜索旋转排序数组II</title>
    <link href="https://hoo334.github.io/2021/04/07/%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84II/"/>
    <id>https://hoo334.github.io/2021/04/07/%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84II/</id>
    <published>2021-04-07T01:29:14.000Z</published>
    <updated>2021-04-09T02:11:20.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="81-搜索旋转排序数组-II"><a href="#81-搜索旋转排序数组-II" class="headerlink" title="81. 搜索旋转排序数组 II"></a><a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array-ii/" target="_blank" rel="noopener">81. 搜索旋转排序数组 II</a></h4><p>已知存在一个按非降序排列的整数数组 <code>nums</code> ，数组中的值不必互不相同。</p><p>在传递给函数之前，<code>nums</code> 在预先未知的某个下标 <code>k</code>（<code>0 &lt;= k &lt; nums.length</code>）上进行了 <strong>旋转</strong> ，使数组变为 <code>[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]</code>（下标 <strong>从 0 开始</strong> 计数）。例如， <code>[0,1,2,4,4,4,5,6,6,7]</code> 在下标 <code>5</code> 处经旋转后可能变为 <code>[4,5,6,6,7,0,1,2,4,4]</code> 。</p><p>给你 <strong>旋转后</strong> 的数组 <code>nums</code> 和一个整数 <code>target</code> ，请你编写一个函数来判断给定的目标值是否存在于数组中。如果 <code>nums</code> 中存在这个目标值 <code>target</code> ，则返回 <code>true</code> ，否则返回 <code>false</code> 。</p> <a id="more"></a><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [2,5,6,0,0,1,2], target &#x3D; 0</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [2,5,6,0,0,1,2], target &#x3D; 3</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p> <strong>提示：</strong></p><ul><li><p><code>1 &lt;= nums.length &lt;= 5000</code></p></li><li><p><code>-104 &lt;= nums[i] &lt;= 104</code></p></li><li><p>题目数据保证 <code>nums</code> 在预先未知的某个下标上进行了旋转</p></li><li><p><code>-104 &lt;= target &lt;= 104</code></p><p><strong>进阶：</strong></p></li><li><p>这是 <a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/description/" target="_blank" rel="noopener">搜索旋转排序数组</a> 的延伸题目，本题中的 <code>nums</code> 可能包含重复元素。</p></li><li><p>这会影响到程序的时间复杂度吗？会有怎样的影响，为什么？</p></li></ul><p><strong>方法一：二分查找</strong></p><p>可以先查看题解<a href="https://hoo334.github.io/2020/04/27/%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/">搜索旋转排序数组</a>，对于数组中有重复元素的情况，二分查找可能会有<code>nums[l] = nums[mid] = nums[r]</code>,此时我们无法判断区间<code>[l, mid]</code>和 <code>[mid + 1, r]</code>哪个是有序的。</p><p>例如 <code>nums =[3,1,2,3,3,3,3]</code> ,target = 2，首次二分时，无法判断区间<code>[0,3]</code>和<code>[4,6]</code></p><p>哪个是有序的。对于这种情况，我们智能将当前二分区间左边界加一，右边界减一，然后在新区间上继续二分查找。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>] == target;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//当三个数都相等时，左边界加一，右边界减一</span></span><br><span class="line">            <span class="keyword">if</span> (nums[l] == nums[mid] &amp;&amp; nums[mid] == nums[r]) &#123;</span><br><span class="line">                ++l;</span><br><span class="line">                --r;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[l] &lt;= nums[mid]) &#123;<span class="comment">//左边界有序</span></span><br><span class="line">                <span class="keyword">if</span> (nums[l] &lt;= target &amp;&amp; target &lt; nums[mid]) &#123;<span class="comment">//mid 在有序部分</span></span><br><span class="line">                    r = mid - <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;<span class="comment">//mid 不在有序部分</span></span><br><span class="line">                    l = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">//右边界有序</span></span><br><span class="line">                <span class="keyword">if</span> (nums[mid] &lt; target &amp;&amp; target &lt;= nums[r]) &#123;</span><br><span class="line">                    l = mid + <span class="number">1</span>;  <span class="comment">//mid 在有序部分</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;  <span class="comment">//mid 不在有序部分</span></span><br><span class="line">                    r = mid - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度O(logN)</li><li>空间复杂度O(1)</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;81-搜索旋转排序数组-II&quot;&gt;&lt;a href=&quot;#81-搜索旋转排序数组-II&quot; class=&quot;headerlink&quot; title=&quot;81. 搜索旋转排序数组 II&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/search-in-rotated-sorted-array-ii/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;81. 搜索旋转排序数组 II&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;已知存在一个按非降序排列的整数数组 &lt;code&gt;nums&lt;/code&gt; ，数组中的值不必互不相同。&lt;/p&gt;
&lt;p&gt;在传递给函数之前，&lt;code&gt;nums&lt;/code&gt; 在预先未知的某个下标 &lt;code&gt;k&lt;/code&gt;（&lt;code&gt;0 &amp;lt;= k &amp;lt; nums.length&lt;/code&gt;）上进行了 &lt;strong&gt;旋转&lt;/strong&gt; ，使数组变为 &lt;code&gt;[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]&lt;/code&gt;（下标 &lt;strong&gt;从 0 开始&lt;/strong&gt; 计数）。例如， &lt;code&gt;[0,1,2,4,4,4,5,6,6,7]&lt;/code&gt; 在下标 &lt;code&gt;5&lt;/code&gt; 处经旋转后可能变为 &lt;code&gt;[4,5,6,6,7,0,1,2,4,4]&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;给你 &lt;strong&gt;旋转后&lt;/strong&gt; 的数组 &lt;code&gt;nums&lt;/code&gt; 和一个整数 &lt;code&gt;target&lt;/code&gt; ，请你编写一个函数来判断给定的目标值是否存在于数组中。如果 &lt;code&gt;nums&lt;/code&gt; 中存在这个目标值 &lt;code&gt;target&lt;/code&gt; ，则返回 &lt;code&gt;true&lt;/code&gt; ，否则返回 &lt;code&gt;false&lt;/code&gt; 。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode Medium" scheme="https://hoo334.github.io/tags/Leetcode-Medium/"/>
    
      <category term="二分查找" scheme="https://hoo334.github.io/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>森林中的兔子</title>
    <link href="https://hoo334.github.io/2021/04/04/%E6%A3%AE%E6%9E%97%E4%B8%AD%E7%9A%84%E5%85%94%E5%AD%90/"/>
    <id>https://hoo334.github.io/2021/04/04/%E6%A3%AE%E6%9E%97%E4%B8%AD%E7%9A%84%E5%85%94%E5%AD%90/</id>
    <published>2021-04-04T01:57:00.000Z</published>
    <updated>2021-04-04T02:11:22.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="781-森林中的兔子"><a href="#781-森林中的兔子" class="headerlink" title="781. 森林中的兔子"></a><a href="https://leetcode-cn.com/problems/rabbits-in-forest/" target="_blank" rel="noopener">781. 森林中的兔子</a></h4><p>森林中，每个兔子都有颜色。其中一些兔子（可能是全部）告诉你还有多少其他的兔子和自己有相同的颜色。我们将这些回答放在 <code>answers</code> 数组里。</p><p>返回森林中兔子的最少数量。</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">示例:</span><br><span class="line">输入: answers &#x3D; [1, 1, 2]</span><br><span class="line">输出: 5</span><br><span class="line">解释:</span><br><span class="line">两只回答了 &quot;1&quot; 的兔子可能有相同的颜色，设为红色。</span><br><span class="line">之后回答了 &quot;2&quot; 的兔子不会是红色，否则他们的回答会相互矛盾。</span><br><span class="line">设回答了 &quot;2&quot; 的兔子为蓝色。</span><br><span class="line">此外，森林中还应有另外 2 只蓝色兔子的回答没有包含在数组中。</span><br><span class="line">因此森林中兔子的最少数量是 5: 3 只回答的和 2 只没有回答的。</span><br><span class="line"></span><br><span class="line">输入: answers &#x3D; [10, 10, 10]</span><br><span class="line">输出: 11</span><br><span class="line"></span><br><span class="line">输入: answers &#x3D; []</span><br><span class="line">输出: 0</span><br></pre></td></tr></table></figure><p><strong>说明:</strong></p><ol><li><code>answers</code> 的长度最大为<code>1000</code>。</li><li><code>answers[i]</code> 是在 <code>[0, 999]</code> 范围内的整数。</li></ol><p><strong>方法一：贪心</strong></p><p>两只相同颜色的兔子看到的其他同色兔子数必然是相同的。反之，若两只兔子看到的其他同色兔子数不同，那么这两只兔子颜色也不同。</p><p>因此，将 answer 中值相同的元素分为一组，对于每一组，计算出兔子的最少数量，然后将所有组的计算结果累加，就是最终的答案。</p><p>例如，现在有 13 只兔子回答 5，可以肯定至少有 3 种颜色的兔子。假设一只蓝色兔子回答 5 ，那么还有 5 只蓝色兔子；假设还有一只红色兔子回答 5 ，那么还有 5 只红色兔子；为了最小化可能的兔子数量，我们假设这 12 只兔子都在这 13 只兔子中。还剩下 1 只其他颜色兔子回答 5 ，那么其他颜色的兔子也为 5 只。最少会有 18 只兔子。</p><p>一般如果有 x 只兔子回答 y，则至少有 ceil(x / (y  + 1))种不同的颜色，且每种颜色有 y  + 1 只兔子，因此兔子数至少为<br>$$<br>\lceil \frac{x}{y + 1}\rceil * (y + 1)<br>$$</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numRabbits</span><span class="params">(<span class="keyword">int</span>[] answers)</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; count = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> y : answers)&#123;</span><br><span class="line">            count.put(y, count.getOrDefault(y, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;Integer, Integer&gt; entry : count.entrySet())&#123;</span><br><span class="line">            <span class="keyword">int</span> y = entry.getKey(), x = entry.getValue();</span><br><span class="line">            ans += (x + y) / (y + <span class="number">1</span>) * (y + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度O(n)</li><li>空间复杂度O(n)</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;781-森林中的兔子&quot;&gt;&lt;a href=&quot;#781-森林中的兔子&quot; class=&quot;headerlink&quot; title=&quot;781. 森林中的兔子&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/rabbits-in-forest/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;781. 森林中的兔子&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;森林中，每个兔子都有颜色。其中一些兔子（可能是全部）告诉你还有多少其他的兔子和自己有相同的颜色。我们将这些回答放在 &lt;code&gt;answers&lt;/code&gt; 数组里。&lt;/p&gt;
&lt;p&gt;返回森林中兔子的最少数量。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode Medium" scheme="https://hoo334.github.io/tags/Leetcode-Medium/"/>
    
      <category term="贪心" scheme="https://hoo334.github.io/tags/%E8%B4%AA%E5%BF%83/"/>
    
  </entry>
  
  <entry>
    <title>最长公共子序列</title>
    <link href="https://hoo334.github.io/2021/04/03/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97/"/>
    <id>https://hoo334.github.io/2021/04/03/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97/</id>
    <published>2021-04-03T12:00:52.000Z</published>
    <updated>2021-04-23T01:28:57.107Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1143-最长公共子序列"><a href="#1143-最长公共子序列" class="headerlink" title="1143. 最长公共子序列"></a><a href="https://leetcode-cn.com/problems/longest-common-subsequence/" target="_blank" rel="noopener">1143. 最长公共子序列</a></h4><p>给定两个字符串 <code>text1</code> 和 <code>text2</code>，返回这两个字符串的最长 <strong>公共子序列</strong> 的长度。如果不存在 <strong>公共子序列</strong> ，返回 <code>0</code> 。</p><p>一个字符串的 <strong>子序列</strong> 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。</p><ul><li>例如，<code>&quot;ace&quot;</code> 是 <code>&quot;abcde&quot;</code> 的子序列，但 <code>&quot;aec&quot;</code> 不是 <code>&quot;abcde&quot;</code> 的子序列。</li></ul><p>两个字符串的 <strong>公共子序列</strong> 是这两个字符串所共同拥有的子序列。</p> <a id="more"></a><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：text1 &#x3D; &quot;abcde&quot;, text2 &#x3D; &quot;ace&quot; </span><br><span class="line">输出：3  </span><br><span class="line">解释：最长公共子序列是 &quot;ace&quot; ，它的长度为 3 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：text1 &#x3D; &quot;abc&quot;, text2 &#x3D; &quot;abc&quot;</span><br><span class="line">输出：3</span><br><span class="line">解释：最长公共子序列是 &quot;abc&quot; ，它的长度为 3 。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：text1 &#x3D; &quot;abc&quot;, text2 &#x3D; &quot;def&quot;</span><br><span class="line">输出：0</span><br><span class="line">解释：两个字符串没有公共子序列，返回 0 。</span><br></pre></td></tr></table></figure><p> <strong>提示：</strong></p><ul><li><code>1 &lt;= text1.length, text2.length &lt;= 1000</code></li><li><code>text1</code> 和 <code>text2</code> 仅由小写英文字符组成。</li></ul><p>我们自顶向下考虑这个问题，以示例 1 为例：</p><ol><li><p>text1 的最后一个字符等于 text2 的最后一个字符，所以它们的最长公共子序列长度为 “abcd” 和 “ac” 的公共子序列长度 + 1。</p></li><li><p>问题转换为求 “abcd” 和 “ac” 的公共子序列长度，此时两个字符串末尾数字不相等，我们也可求 text1 的子串 “abc” 和 text2 “ac” 的公共子序列长度，也可求 text1 “abd” 和 text2的子串 “a”的公共子序列长度，结果为这两个公共子序列长度的最大值。</p></li><li><p>继续这个操作直到两个字符串为空。</p></li></ol><p>我们可以写出 dp：<br>$$<br>dp[i][j] =dp[i - 1][j - 1] + 1, \ text1[i] = text2[j] \<br>$$<br>$$<br>dp[i][j] = Math.max(dp[i - 1][j],\  dp[i][j - 1]), \ text1[i] \neq text2[j] \<br>$$</p><p><code>dp[i][j]</code>代表字符串 text1[0 … i - 1]，和 text2[0 … j - 1]的最长公共子序列，当 i = 0 或 j = 0 时，<code>dp[i][j] = 0</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(String text1, String text2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = text1.length(), n = text2.length();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(text1.charAt(i - <span class="number">1</span>) == text2.charAt(j - <span class="number">1</span>))&#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j] = Math.max(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度O(mn)，m 和 n 分别为两个字符串的长度。</li><li>空间复杂度O(mn)</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1143-最长公共子序列&quot;&gt;&lt;a href=&quot;#1143-最长公共子序列&quot; class=&quot;headerlink&quot; title=&quot;1143. 最长公共子序列&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/longest-common-subsequence/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;1143. 最长公共子序列&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;给定两个字符串 &lt;code&gt;text1&lt;/code&gt; 和 &lt;code&gt;text2&lt;/code&gt;，返回这两个字符串的最长 &lt;strong&gt;公共子序列&lt;/strong&gt; 的长度。如果不存在 &lt;strong&gt;公共子序列&lt;/strong&gt; ，返回 &lt;code&gt;0&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;一个字符串的 &lt;strong&gt;子序列&lt;/strong&gt; 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;例如，&lt;code&gt;&amp;quot;ace&amp;quot;&lt;/code&gt; 是 &lt;code&gt;&amp;quot;abcde&amp;quot;&lt;/code&gt; 的子序列，但 &lt;code&gt;&amp;quot;aec&amp;quot;&lt;/code&gt; 不是 &lt;code&gt;&amp;quot;abcde&amp;quot;&lt;/code&gt; 的子序列。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;两个字符串的 &lt;strong&gt;公共子序列&lt;/strong&gt; 是这两个字符串所共同拥有的子序列。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode Medium" scheme="https://hoo334.github.io/tags/Leetcode-Medium/"/>
    
      <category term="动态规划" scheme="https://hoo334.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
</feed>
