<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>echo</title>
  
  <subtitle>任生命穿梭 时间的角落 </subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://hoo334.github.io/"/>
  <updated>2021-12-14T13:23:23.033Z</updated>
  <id>https://hoo334.github.io/</id>
  
  <author>
    <name>hoo334</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java 八股文</title>
    <link href="https://hoo334.github.io/2021/12/14/%E5%85%AB%E8%82%A1%E6%96%87/"/>
    <id>https://hoo334.github.io/2021/12/14/%E5%85%AB%E8%82%A1%E6%96%87/</id>
    <published>2021-12-14T03:19:38.000Z</published>
    <updated>2021-12-14T13:23:23.033Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h2><h3 id="Mall"><a href="#Mall" class="headerlink" title="Mall"></a>Mall</h3><h4 id="后台用户缓存"><a href="#后台用户缓存" class="headerlink" title="后台用户缓存"></a>后台用户缓存</h4><p>当登录时解析JWT成功之后将<strong>用户信息</strong>以及<strong>用户拥有的资源</strong>缓存起来，方便后续使用。</p><h4 id="验证码"><a href="#验证码" class="headerlink" title="验证码"></a>验证码</h4><p>key 为电话号码，value 为六位随机数，设置过期时间，验证时通过电话来获取。</p><h4 id="MySQL-事务"><a href="#MySQL-事务" class="headerlink" title="MySQL 事务"></a>MySQL 事务</h4><p>@EnableTransactionalManagement</p><p>@Transactional</p><h3 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h3><p>其实死信队列就是一个普通的交换机，有些队列的消息成为死信后，（比如过期了或者队列满了）这些死信一般情况下是会被 RabbitMQ 清理的。但是你可以配置某个交换机为此队列的死信交换机，该队列的消息成为死信后会被重新发送到此 DLX 。至于怎么处理这个DLX中的死信就是看具体的业务场景了，DLX 中的信息可以被路由到新的队列。</p><h4 id="用户下单超时取消订单"><a href="#用户下单超时取消订单" class="headerlink" title="用户下单超时取消订单"></a>用户下单超时取消订单</h4><ul><li>用户进行下单操作（会有锁定商品库存、使用优惠券、积分一系列的操作）；</li><li>生成订单，获取订单的id；</li><li>获取到设置的订单超时时间（假设设置的为60分钟不支付取消订单）；</li><li>按订单超时时间发送一个延迟消息给RabbitMQ，让它在订单超时后触发取消订单的操作；</li><li>如果用户没有支付，进行取消订单操作（释放锁定商品库存、返还优惠券、返回积分一系列操作）。</li></ul><h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><h4 id="说说Redis基本数据类型有哪些吧"><a href="#说说Redis基本数据类型有哪些吧" class="headerlink" title="说说Redis基本数据类型有哪些吧"></a>说说Redis基本数据类型有哪些吧</h4><ol><li><strong>字符串</strong>：redis没有直接使用C语言传统的字符串表示，而是自己实现的叫做简单动态字符串SDS的抽象类型。C语言的字符串不记录自身的长度信息，而SDS则保存了长度信息，这样将获取字符串长度的时间由O(N)降低到了O(1)，同时可以避免缓冲区溢出和减少修改字符串长度时所需的内存重分配次数。</li><li><strong>链表linkedlist</strong>：redis链表是一个双向无环链表结构，很多发布订阅、慢查询、监视器功能都是使用到了链表来实现，每个链表的节点由一个listNode结构来表示，每个节点都有指向前置节点和后置节点的指针，同时表头节点的前置和后置节点都指向NULL。</li><li><strong>字典hashtable</strong>：用于保存键值对的抽象数据结构。redis使用hash表作为底层实现，每个字典带有两个hash表，供平时使用和rehash时使用，hash表使用链地址法来解决键冲突，被分配到同一个索引位置的多个键值对会形成一个单向链表，在对hash表进行扩容或者缩容的时候，为了服务的可用性，rehash的过程不是一次性完成的，而是渐进式的。</li><li><strong>跳跃表skiplist</strong>：跳跃表是有序集合的底层实现之一，redis中在实现有序集合键和集群节点的内部结构中都是用到了跳跃表。redis跳跃表由zskiplist和zskiplistNode组成，zskiplist用于保存跳跃表信息（表头、表尾节点、长度等），zskiplistNode用于表示表跳跃节点，每个跳跃表的层高都是1-32的随机数，在同一个跳跃表中，多个节点可以包含相同的分值，但是每个节点的成员对象必须是唯一的，节点按照分值大小排序，如果分值相同，则按照成员对象的大小排序。</li><li><strong>整数集合intset</strong>：用于保存整数值的集合抽象数据结构，不会出现重复元素，底层实现为数组。</li><li><strong>压缩列表ziplist</strong>：压缩列表是为节约内存而开发的顺序性数据结构，他可以包含多个节点，每个节点可以保存一个字节数组或者整数值。</li></ol><p>基于这些基础的数据结构，redis封装了自己的对象系统，包含字符串对象string、列表对象list、哈希对象hash、集合对象set、有序集合对象zset，每种对象都用到了至少一种基础的数据结构。</p><p>redis通过encoding属性设置对象的编码形式来提升灵活性和效率，基于不同的场景redis会自动做出优化。不同对象的编码如下：</p><ol><li>字符串对象string：int整数、embstr编码的简单动态字符串、raw简单动态字符串</li><li>列表对象list：ziplist、linkedlist</li><li>哈希对象hash：ziplist、hashtable</li><li>集合对象set：intset、hashtable</li><li>有序集合对象zset：ziplist、skiplist</li></ol><h4 id="Redis为什么快呢？"><a href="#Redis为什么快呢？" class="headerlink" title="Redis为什么快呢？"></a>Redis为什么快呢？</h4><p>redis的速度非常的快，单机的redis就可以支撑每秒10几万的并发，相对于mysql来说，性能是mysql的几十倍。速度快的原因主要有几点：</p><ol><li>完全基于内存操作</li><li>C语言实现，优化过的数据结构，基于几种基础的数据结构，redis做了大量的优化，性能极高</li><li>使用单线程，无上下文的切换成本</li><li>基于非阻塞的IO多路复用机制</li></ol><h4 id="那为什么Redis6-0之后又改用多线程呢"><a href="#那为什么Redis6-0之后又改用多线程呢" class="headerlink" title="那为什么Redis6.0之后又改用多线程呢?"></a>那为什么Redis6.0之后又改用多线程呢?</h4><p>redis使用多线程并非是完全摒弃单线程，redis还是使用单线程模型来处理客户端的请求，只是使用多线程来处理数据的读写和协议解析，执行命令还是使用单线程。</p><p>这样做的目的是因为redis的性能瓶颈在于网络IO而非CPU，使用多线程能提升IO读写的效率，从而整体提高redis的性能。</p><h4 id="知道什么是热key吗？热key问题怎么解决？"><a href="#知道什么是热key吗？热key问题怎么解决？" class="headerlink" title="知道什么是热key吗？热key问题怎么解决？"></a>知道什么是热key吗？热key问题怎么解决？</h4><p>所谓热key问题就是，突然有几十万的请求去访问redis上的某个特定key，那么这样会造成流量过于集中，达到物理网卡上限，从而导致这台redis的服务器宕机引发雪崩。</p><img src="https://pic2.zhimg.com/80/v2-dbf60ad2707e0f0f8513c13780c67185_1440w.jpg" alt="img" style="zoom:50%;" /><p>针对热key的解决方案：</p><ol><li>提前把热key打散到不同的服务器，降低压力</li><li>加入二级缓存，提前加载热key数据到内存中，如果redis宕机，走内存查询</li></ol><h4 id="什么是缓存击穿、缓存穿透、缓存雪崩？"><a href="#什么是缓存击穿、缓存穿透、缓存雪崩？" class="headerlink" title="什么是缓存击穿、缓存穿透、缓存雪崩？"></a>什么是缓存击穿、缓存穿透、缓存雪崩？</h4><h5 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a><strong>缓存击穿</strong></h5><p>缓存击穿的概念就是<strong>单个key并发访问过高，过期时导致所有请求直接打到db上</strong>，这个和热key的问题比较类似，只是说的点在于过期导致请求全部打到DB上而已。</p><p>解决方案：</p><ol><li>加锁更新，比如请求查询A，发现缓存中没有，对A这个key加锁，同时去数据库查询数据，写入缓存，再返回给用户，这样后面的请求就可以从缓存中拿到数据了。</li><li>将过期时间组合写在value中，通过异步的方式不断的刷新过期时间，防止此类现象。</li></ol><img src="https://pic3.zhimg.com/80/v2-2c91b29fb027385f045ec915e5f7f056_1440w.jpg" alt="img" style="zoom:50%;" /><h5 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a><strong>缓存穿透</strong></h5><p>缓存穿透是指查询不存在缓存中的数据，每次请求都会打到DB，就像缓存不存在一样。</p><img src="https://pic4.zhimg.com/80/v2-40ca7eb6ddc6f672e0098f43a5743567_1440w.jpg" alt="img" style="zoom:50%;" /><p>针对这个问题，加一层布隆过滤器。布隆过滤器的原理是在你存入数据的时候，会通过散列函数将它映射为一个位数组中的K个点，同时把他们置为1。</p><p>这样当用户再次来查询A，而A在布隆过滤器值为0，直接返回，就不会产生击穿请求打到DB了。</p><p>显然，使用布隆过滤器之后会有一个问题就是误判，因为它本身是一个数组，可能会有多个值落到同一个位置，那么理论上来说只要我们的数组长度够长，误判的概率就会越低，这种问题就根据实际情况来就好了。</p><img src="https://pic4.zhimg.com/80/v2-b71c876d6dea46a6b0138ccd6c4d45db_1440w.jpg" alt="img" style="zoom:50%;" /><h5 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a><strong>缓存雪崩</strong></h5><p>当某一时刻发生大规模的缓存失效的情况，比如你的缓存服务宕机了，会有大量的请求进来直接打到DB上，这样可能导致整个系统的崩溃，称为雪崩。雪崩和击穿、热key的问题不太一样的是，他是指大规模的缓存都过期失效了。</p><img src="https://pic2.zhimg.com/80/v2-6727dc5a64b698dd9a1c176fa218839d_1440w.jpg" alt="img" style="zoom:50%;" /><p>针对雪崩几个解决方案：</p><ol><li>针对不同key设置不同的过期时间，避免同时过期</li><li>限流，如果redis宕机，可以限流，避免同时刻大量请求打崩DB</li><li>二级缓存，同热key的方案。</li></ol><h4 id="Redis的过期策略有哪些？"><a href="#Redis的过期策略有哪些？" class="headerlink" title="Redis的过期策略有哪些？"></a>Redis的过期策略有哪些？</h4><p>redis主要有2种过期删除策略</p><h5 id="惰性删除"><a href="#惰性删除" class="headerlink" title="惰性删除"></a><strong>惰性删除</strong></h5><p>惰性删除指的是当我们查询key的时候才对key进行检测，如果已经达到过期时间，则删除。显然，他有一个缺点就是如果这些过期的key没有被访问，那么他就一直无法被删除，而且一直占用内存。</p><p><img src="https://pic1.zhimg.com/80/v2-b0f1d9737522d1748debb2bf7b77610c_1440w.jpg" alt="img"></p><h5 id="定期删除"><a href="#定期删除" class="headerlink" title="定期删除"></a><strong>定期删除</strong></h5><p>定期删除指的是redis每隔一段时间对数据库做一次检查，删除里面的过期key。由于不可能对所有key去做轮询来删除，所以redis会每次随机取一些key去做检查和删除。</p><h4 id="那么定期-惰性都没有删除过期的key怎么办？"><a href="#那么定期-惰性都没有删除过期的key怎么办？" class="headerlink" title="那么定期+惰性都没有删除过期的key怎么办？"></a>那么定期+惰性都没有删除过期的key怎么办？</h4><p>假设redis每次定期随机查询key的时候没有删掉，这些key也没有做查询的话，就会导致这些key一直保存在redis里面无法被删除，这时候就会走到redis的内存淘汰机制。</p><ol><li>volatile-lru：从已设置过期时间的key中，移除最近最少使用的key进行淘汰</li><li>volatile-ttl：从已设置过期时间的key中，移除将要过期的key</li><li>volatile-random：从已设置过期时间的key中随机选择key淘汰</li><li>allkeys-lru：从key中选择最近最少使用的进行淘汰</li><li>allkeys-random：从key中随机选择key进行淘汰</li><li>noeviction：当内存达到阈值的时候，新写入操作报错</li></ol><h4 id="持久化方式有哪些？有什么区别？"><a href="#持久化方式有哪些？有什么区别？" class="headerlink" title="持久化方式有哪些？有什么区别？"></a>持久化方式有哪些？有什么区别？</h4><p>redis持久化方案分为RDB和AOF两种。</p><h5 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a><strong>RDB</strong></h5><p>RDB持久化可以手动执行也可以根据配置定期执行，它的作用是将某个时间点上的数据库状态保存到RDB文件中，RDB文件是一个压缩的二进制文件，通过它可以还原某个时刻数据库的状态。由于RDB文件是保存在硬盘上的，所以即使redis崩溃或者退出，只要RDB文件存在，就可以用它来恢复还原数据库的状态。</p><p>可以通过SAVE或者BGSAVE来生成RDB文件。</p><p>SAVE命令会阻塞redis进程，直到RDB文件生成完毕，在进程阻塞期间，redis不能处理任何命令请求，这显然是不合适的。</p><p>BGSAVE则是会fork出一个子进程，然后由子进程去负责生成RDB文件，父进程还可以继续处理命令请求，不会阻塞进程。</p><h5 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a><strong>AOF</strong></h5><p>AOF和RDB不同，<strong>AOF是通过保存redis服务器所执行的写命令来记录数据库状态的</strong>。</p><p>AOF通过追加、写入、同步三个步骤来实现持久化机制。</p><ol><li>当AOF持久化处于激活状态，服务器执行完写命令之后，写命令将会被追加append到aof_buf缓冲区的末尾</li><li>在服务器每结束一个事件循环之前，将会调用flushAppendOnlyFile函数决定是否要将aof_buf的内容保存到AOF文件中，可以通过配置appendfsync来决定。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">always ##aof_buf内容写入并同步到AOF文件</span><br><span class="line">everysec ##将aof_buf中内容写入到AOF文件，如果上次同步AOF文件时间距离现在超过1秒，则再次对AOF文件进行同步</span><br><span class="line">no ##将aof_buf内容写入AOF文件，但是并不对AOF文件进行同步，同步时间由操作系统决定</span><br></pre></td></tr></table></figure><p>如果不设置，默认选项将会是everysec，因为always来说虽然最安全（只会丢失一次事件循环的写命令），但是性能较差，而everysec模式只不过会可能丢失1秒钟的数据，而no模式的效率和everysec相仿，但是会丢失上次同步AOF文件之后的所有写命令数据。</p><h4 id="怎么实现Redis的高可用？"><a href="#怎么实现Redis的高可用？" class="headerlink" title="怎么实现Redis的高可用？"></a>怎么实现Redis的高可用？</h4><p>要想实现高可用，一台机器肯定是不够的，而redis要保证高可用，有2个可选方案。</p><h5 id="主从架构"><a href="#主从架构" class="headerlink" title="主从架构"></a><strong>主从架构</strong></h5><p>主从模式是最简单的实现高可用的方案，核心就是主从同步。主从同步的原理如下：</p><ol><li>slave发送sync命令到master</li><li>master收到sync之后，执行bgsave，生成RDB全量文件</li><li>master把slave的写命令记录到缓存</li><li>bgsave执行完毕之后，发送RDB文件到slave，slave执行</li><li>master发送缓存中的写命令到slave，slave执行</li></ol><img src="https://pic3.zhimg.com/80/v2-72d216bf617a3b037f3823f9a57d6bf6_1440w.jpg" alt="img" style="zoom:50%;" /><p>这里我写的这个命令是sync，但是在redis2.8版本之后已经使用psync来替代sync了，原因是sync命令非常消耗系统资源，而psync的效率更高。</p><h5 id="哨兵"><a href="#哨兵" class="headerlink" title="哨兵"></a><strong>哨兵</strong></h5><p>基于主从方案的缺点还是很明显的，假设master宕机，那么就不能写入数据，那么slave也就失去了作用，整个架构就不可用了，除非你手动切换，主要原因就是因为没有自动故障转移机制。而哨兵(sentinel)的功能比单纯的主从架构全面的多了，它具备自动故障转移、集群监控、消息通知等功能。</p><img src="https://pic1.zhimg.com/80/v2-4d5d637bbf883788e35b32fbbd86d0f8_1440w.jpg" alt="img" style="zoom:50%;" /><p>哨兵可以同时监视多个主从服务器，并且在被监视的master下线时，自动将某个slave提升为master，然后由新的master继续接收命令。整个过程如下：</p><ol><li>初始化sentinel，将普通的redis代码替换成sentinel专用代码</li><li>初始化masters字典和服务器信息，服务器信息主要保存ip:port，并记录实例的地址和ID</li><li>创建和master的两个连接，命令连接和订阅连接，并且订阅sentinel:hello频道</li><li>每隔10秒向master发送info命令，获取master和它下面所有slave的当前信息</li><li>当发现master有新的slave之后，sentinel和新的slave同样建立两个连接，同时每个10秒发送info命令，更新master信息</li><li>sentinel每隔1秒向所有服务器发送ping命令，如果某台服务器在配置的响应时间内连续返回无效回复，将会被标记为下线状态</li><li>选举出领头sentinel，领头sentinel需要半数以上的sentinel同意</li><li>领头sentinel从已下线的的master所有slave中挑选一个，将其转换为master</li><li>让所有的slave改为从新的master复制数据</li><li>将原来的master设置为新的master的从服务器，当原来master重新回复连接时，就变成了新master的从服务器</li></ol><p>sentinel会每隔1秒向所有实例（包括主从服务器和其他sentinel）发送ping命令，并且根据回复判断是否已经下线，这种方式叫做主观下线。当判断为主观下线时，就会向其他监视的sentinel询问，如果超过半数的投票认为已经是下线状态，则会标记为客观下线状态，同时触发故障转移。</p><h4 id="能说说redis集群的原理吗？"><a href="#能说说redis集群的原理吗？" class="headerlink" title="能说说redis集群的原理吗？"></a>能说说redis集群的原理吗？</h4><p>如果说依靠哨兵可以实现redis的高可用，如果还想在支持高并发同时容纳海量的数据，那就需要redis集群。redis集群是redis提供的分布式数据存储方案，集群通过数据分片sharding来进行数据的共享，同时提供复制和故障转移的功能。</p><h5 id="节点"><a href="#节点" class="headerlink" title="节点"></a><strong>节点</strong></h5><p>一个redis集群由多个节点node组成，而多个node之间通过cluster meet命令来进行连接，节点的握手过程：</p><ol><li>节点A收到客户端的cluster meet命令</li><li>A根据收到的IP地址和端口号，向B发送一条meet消息</li><li>节点B收到meet消息返回pong</li><li>A知道B收到了meet消息，返回一条ping消息，握手成功</li><li>最后，节点A将会通过gossip协议把节点B的信息传播给集群中的其他节点，其他节点也将和B进行握手</li></ol><img src="https://pic4.zhimg.com/80/v2-3c8e1d99a58f70abffc04c6c8bc80743_1440w.jpg" alt="img" style="zoom:50%;" /><h5 id="槽slot"><a href="#槽slot" class="headerlink" title="槽slot"></a><strong>槽slot</strong></h5><p>redis通过集群分片的形式来保存数据，整个集群数据库被分为16384个slot，集群中的每个节点可以处理0-16383个slot，当数据库16384个slot都有节点在处理时，集群处于上线状态，反之只要有一个slot没有得到处理都会处理下线状态。通过cluster addslots命令可以将slot指派给对应节点处理。</p><p>slot是一个位数组，数组的长度是16384/8=2048，而数组的每一位用1表示被节点处理，0表示不处理，如图所示的话表示A节点处理0-7的slot。</p><img src="https://pic4.zhimg.com/80/v2-0902372ee0c5d5c196a82ad201fc0bfb_1440w.jpg" alt="img" style="zoom:50%;" /><p>当客户端向节点发送命令，如果刚好找到slot属于当前节点，那么节点就执行命令，反之，则会返回一个MOVED命令到客户端指引客户端转向正确的节点。（MOVED过程是自动的）</p><img src="https://pic4.zhimg.com/80/v2-e564d5d1199229fb67ef5b3661cddf9f_1440w.jpg" alt="img" style="zoom:50%;" /><p>如果增加或者移出节点，对于slot的重新分配也是非常方便的，redis提供了工具帮助实现slot的迁移，整个过程是完全在线的，不需要停止服务。</p><h5 id="故障转移"><a href="#故障转移" class="headerlink" title="故障转移"></a><strong>故障转移</strong></h5><p>如果节点A向节点B发送ping消息，节点B没有在规定的时间内响应pong，那么节点A会标记节点B为pfail疑似下线状态，同时把B的状态通过消息的形式发送给其他节点，如果超过半数以上的节点都标记B为pfail状态，B就会被标记为fail下线状态，此时将会发生故障转移，优先从复制数据较多的从节点选择一个成为主节点，并且接管下线节点的slot，整个过程和哨兵非常类似，都是基于Raft协议做选举。</p><h4 id="了解Redis事务机制吗？"><a href="#了解Redis事务机制吗？" class="headerlink" title="了解Redis事务机制吗？"></a>了解Redis事务机制吗？</h4><p>redis通过MULTI、EXEC、WATCH等命令来实现事务机制，事务执行过程将一系列多个命令按照顺序一次性执行，并且在执行期间，事务不会被中断，也不会去执行客户端的其他请求，直到所有命令执行完毕。事务的执行过程如下：</p><ol><li>服务端收到客户端请求，事务以MULTI开始</li><li>如果客户端正处于事务状态，则会把事务放入队列同时返回给客户端QUEUED，反之则直接执行这个命令</li><li>当收到客户端EXEC命令时，WATCH命令监视整个事务中的key是否有被修改，如果有则返回空回复到客户端表示失败，否则redis会遍历整个事务队列，执行队列中保存的所有命令，最后返回结果给客户端</li></ol><p>WATCH的机制本身是一个CAS的机制，被监视的key会被保存到一个链表中，如果某个key被修改，那么REDIS_DIRTY_CAS标志将会被打开，这时服务器会拒绝执行事务。</p><h3 id="RabbitMq消息丢失原因及其解决方案"><a href="#RabbitMq消息丢失原因及其解决方案" class="headerlink" title="RabbitMq消息丢失原因及其解决方案"></a>RabbitMq消息丢失原因及其解决方案</h3><h4 id="一、RabbitMQ消息丢失原因"><a href="#一、RabbitMQ消息丢失原因" class="headerlink" title="一、RabbitMQ消息丢失原因"></a>一、RabbitMQ消息丢失原因</h4><p>我们首先了解下一条消息从生产到消费的整个流程如下：</p><p><img src="https://pic3.zhimg.com/v2-a91ca01f1f069b26f4b582755de57c86_b.jpg" alt="img"></p><p>生产–&gt;MQ Broker –&gt; 消费。所以这三个环节都有丢失消息的可能。</p><h4 id="1-1、生产者丢失消息"><a href="#1-1、生产者丢失消息" class="headerlink" title="1.1、生产者丢失消息"></a>1.1、生产者丢失消息</h4><p>生产者将数据发送到rabbitmq的时候，可能因为网络问题导致数据就在半路给搞丢了。</p><p><strong>1.使用事务（性能差）</strong></p><p>​       RabbitMQ 客户端中与事务机制相关的方法有三个： channel.txSelect 、channel.txCommit 和 channel.txRollback。channel.txSelect 用于将当前的信道设置成事务模式，channel.txCommit 用于提交事务，channel.txRollback 用于事务回滚。在通过 channel.txSelect 方法开启事务之后，我们便可以发布消息给 RabbitMQ 了，如果事务提交成功，则消息一定到达了 RabbitMQ 中，如果在事务提交执行之前由于 RabbitMQ异常崩溃或者其他原因抛出异常，这个时候我们便可以将其捕获，进而通过执行channel.txRollback 方法来实现事务回滚。注意这里的 RabbitMQ 中的事务机制与大多数数据库中的事务概念并不相同，需要注意区分。</p><p>​       事务确实能够解决消息发送方和 RabbitMQ 之间消息确认的问题，只有消息成功被RabbitMQ 接收，事务才能提交成功，否则便可在捕获异常之后进行事务回滚，与此同时可以进行消息重发。但是使用事务机制会“吸干”RabbitMQ 的性能。</p><p><strong>2.发送回执确认（推荐）</strong></p><p>​           生产者将信道设置成 confirm（确认）模式，一旦信道进入 confirm 模式，所有在该信道上面发布的消息都会被指派一个唯一的 ID（从 1 开始），一旦消息被投递到所有匹配的队列之后，RabbitMQ 就会发送一个确认（Basic.Ack）给生产者（包含消息的唯一 ID），这就使得生产者知晓消息已经正确到达了目的地了。如果消息和队列是可持久化的，那么确认消息会在消息写入磁盘之后发出。RabbitMQ 回传给生产者的确认消息中的 deliveryTag 包含了确认消息的序号，此外 RabbitMQ 也可以设置 channel.basicAck 方法中的 multiple 参数，表示到这个序号之前的所有消息都已经得到了处理，注意辨别这里的确认和消费时候的确认之间的异同。</p><p><img src="https://pic3.zhimg.com/v2-70f491ea450976492d8554c6cd91da82_b.jpg" alt="img"></p><p>注意要点:</p><ul><li>事务机制和 publisher confirm 机制两者是互斥的，不能共存。</li><li>事务机制和 publisher confirm 机制确保的是消息能够正确地发送至 RabbitMQ，这里的“发送至 RabbitMQ”的含义是指消息被正确地发往至 RabbitMQ 的交换器，如果此交换器没有匹配的队列，那么消息也会丢失。</li></ul><h4 id="1-2、RabbitMQ弄丢了数据-开启RabbitMQ的数据持久化"><a href="#1-2、RabbitMQ弄丢了数据-开启RabbitMQ的数据持久化" class="headerlink" title="1.2、RabbitMQ弄丢了数据-开启RabbitMQ的数据持久化"></a>1.2、RabbitMQ弄丢了数据-开启RabbitMQ的数据持久化</h4><p>​       为了防止rabbitmq自己弄丢了数据，这个你必须开启rabbitmq的持久化，就是消息写入之后会持久化到磁盘，哪怕是rabbitmq自己挂了，恢复之后会自动读取之前存储的数据，一般数据不会丢。除非极其罕见的是，rabbitmq还没持久化，自己就挂了，可能导致少量数据会丢失的，但是这个概率较小。</p><p>设置持久化有两个步骤，第一个是创建queue的时候将其设置为持久化的，这样就可以保证rabbitmq持久化queue的元数据，但是不会持久化queue里的数据；第二个是发送消息的时候将消息的deliveryMode设置为2，就是将消息设置为持久化的，此时rabbitmq就会将消息持久化到磁盘上去。必须要同时设置这两个持久化才行，rabbitmq哪怕是挂了，再次重启，也会从磁盘上重启恢复queue，恢复这个queue里的数据。</p><p>而且持久化可以跟生产者那边的confirm机制配合起来，只有消息被持久化到磁盘之后，才会通知生产者ack了，所以哪怕是在持久化到磁盘之前，rabbitmq挂了，数据丢了，生产者收不到ack，你也是可以自己重发的。</p><p>若生产者那边的confirm机制未开启的情况下，哪怕是你给rabbitmq开启了持久化机制，也有一种可能，就是这个消息写到了rabbitmq中，但是还没来得及持久化到磁盘上，结果不巧，此时rabbitmq挂了，就会导致内存里的一点点数据会丢失。</p><h4 id="1-3、消费端弄丢了数据"><a href="#1-3、消费端弄丢了数据" class="headerlink" title="1.3、消费端弄丢了数据"></a>1.3、消费端弄丢了数据</h4><p>​       为了保证消息从队列可靠地达到消费者，RabbitMQ 提供了消息确认机制（message acknowledgement）。消费者在订阅队列时，可以指定 autoAck 参数，当 autoAck 等于 false时，RabbitMQ 会等待消费者显式地回复确认信号后才从内存（或者磁盘）中移去消息（实质上是先打上删除标记，之后再删除）。<strong>当 autoAck 等于 true 时</strong>，RabbitMQ 会自动把发送出去的消息置为确认，然后从内存（或者磁盘）中删除，而不管消费者是否真正地消费到了这些消息。</p><p>​       采用消息确认机制后，只要设置 autoAck 参数为 false，消费者就有足够的时间处理消息（任务），不用担心处理消息过程中消费者进程挂掉后消息丢失的问题，因为 RabbitMQ 会一直等待持有消息直到消费者显式调用 Basic.Ack 命令为止。</p><p>​       这里我们可以通过RabbtiMQ 的 Web 管理平台上可以看到当前队列中的“Ready”状态和“Unacknowledged”状态的消息数，分别对应上文中的等待投递给消费者的消息数和已经投递给消费者但是未收到确认信号的消息数。</p><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="Java-基础特性"><a href="#Java-基础特性" class="headerlink" title="Java 基础特性"></a>Java 基础特性</h3><h4 id="Java-语言特点"><a href="#Java-语言特点" class="headerlink" title="Java 语言特点"></a>Java 语言特点</h4><ul><li>面向对象（封装、继承、多态）</li><li>平台无关性（Java 虚拟机实现平台无关性）</li><li>多线程（较好的多线程支持）</li></ul><h4 id="JVM-vs-JDK-vs-JRE"><a href="#JVM-vs-JDK-vs-JRE" class="headerlink" title="JVM vs JDK vs JRE"></a>JVM vs JDK vs JRE</h4><h5 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h5><p>JVM是运行 Java 字节码的虚拟机。JVM 有针对不同系统的特定实现，目的是使用相同的字节码，它们都会给出相同的结果。字节码和不同系统的 JVM 实现是 Java 语言“一次编译，随处可以运行”的关键所在。</p><h5 id="JDK"><a href="#JDK" class="headerlink" title="JDK"></a>JDK</h5><p>DK 是 Java Development Kit 缩写，它是功能齐全的 Java SDK。它拥有 JRE 所拥有的一切，还有编译器（javac）和工具（如 javadoc 和 jdb），能够创建和编译程序。</p><h5 id="JRE"><a href="#JRE" class="headerlink" title="JRE"></a>JRE</h5><p>JRE 是 Java 运行时环境。它是运行已编译 Java 程序所需的所有内容的集合，包括 Java 虚拟机（JVM），Java 类库，java 命令和其他的一些基础构件。但是，它不能用于创建新程序。</p><h5 id="Java-语言“编译与解释并存”"><a href="#Java-语言“编译与解释并存”" class="headerlink" title="Java 语言“编译与解释并存”"></a>Java 语言“编译与解释并存”</h5><p>Java 程序要经过先编译，后解释两个步骤，由 Java 编写的程序需要先经过编译步骤，生成字节码（<code>\*.class</code> 文件），这种字节码必须由 Java 解释器来解释执行。</p><h4 id="Java-与-C-的区别"><a href="#Java-与-C-的区别" class="headerlink" title="Java 与 C++ 的区别"></a>Java 与 C++ 的区别</h4><ul><li>都是面向对象的语言</li><li>Java 不支持通过指针进行内存访问</li><li>Java 类只支持单继承，但可以实现多个接口，C++ 支持多继承</li><li>Java 有 GC 机制，不用手动释放内存</li><li>C++ 同时支持<strong>方法重载</strong>和<strong>运算符重载</strong>，<strong>Java 只支持方法重载</strong></li></ul><h4 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h4><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20210804200000105.png" alt="image-20210804200000105"></p><ul><li><p>strictfp 浮点运算更加精确，不会因为不同的硬件平台所执行的结果不一致</p></li><li><p>transient 修饰字段，用transient关键字标记的成员变量不参与序列化过程。</p></li><li><p>volatile 当把变量声明为volatile类型后，编译器与运行时都会注意到这个变量是共享的，因此不会将该变量上的操作与其他内存操作一起重排序。在访问volatile变量时不会执行加锁操作，因此也就不会使执行线程阻塞，因此volatile变量是一种比 sychronized 关键字更轻量级的同步机制。</p></li></ul><h4 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h4><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20210804205811181.png" alt="image-20210804205811181"></p><p>对于 <code>boolean</code>，官方文档未明确定义，它依赖于 JVM 厂商的具体实现。</p><p><strong>基本数据类型直接存放在 Java 虚拟机栈中栈帧的局部变量表中</strong>，而包装类型属于对象类型，我们知道对象实例都存在于堆中。相比于对象类型， 基本数据类型占用的空间非常小。</p><p>Java 基本类型的包装类的大部分都实现了==常量池==技术。<strong><code>Byte</code>,<code>Short</code>,<code>Integer</code>,<code>Long</code> 这 4 种包装类默认创建了数值 [-128，127] 的相应类型的缓存数据，<code>Character</code> 创建了数值在[0,127]范围的缓存数据，<code>Boolean</code> 直接返回 <code>True</code> Or <code>False</code>。</strong></p><h4 id="StringBuffer-、-StringBuilder-和-String"><a href="#StringBuffer-、-StringBuilder-和-String" class="headerlink" title="==StringBuffer 、 StringBuilder 和 String=="></a>==StringBuffer 、 StringBuilder 和 String==</h4><h5 id="不可变性"><a href="#不可变性" class="headerlink" title="不可变性"></a>不可变性</h5><p>String 类中<strong>使用 final 关键字修饰字符数组来保存字符串</strong>，<code>private final char value[]</code>，所以 <strong>String 对象是不可变的</strong>。</p><blockquote><p>在 Java 9 之后，String、StringBuffer 与 StringBuilder 的实现改为 byte 数组存储字符串 <code>private final byte[] value</code></p></blockquote><p>StringBuilder 和 StringBuffer 都继承自 AbstractStringBuilder 类，在这个类中的字符数组没有用 final 关键字修饰，所以这两种对象都是可变的。</p><h5 id="线程安全性"><a href="#线程安全性" class="headerlink" title="线程安全性"></a>线程安全性</h5><p>String 对象是不可变的，不可变对象都是线程安全的。</p><p>AbstractStringBuilder 定义的一些字符串的基本操作，如 expandCapacity、append、insert、indexOf 等公共方法。StringBuffer 对方法加了同步锁或对调用的方法加了同步锁，所以是线程安全的。StringBuilder 并没有对方法进行加锁，所以是非线程安全的。</p><h5 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h5><p>每次对 String 类型进行改变时，都会生成一个新的 String 对象，然后将引用指向新的 String 对象。StringBuffer 每次都会对StringBuffer 对象本身进行操作。</p><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><ol><li>操作少量的数据，使用 String</li><li>单线程操作字符串缓冲区大量数据：使用 StringBuilder</li><li>多线程操作字符串缓冲区大量数据：使用 StringBuffer</li></ol><h4 id="抽象类与接口"><a href="#抽象类与接口" class="headerlink" title="抽象类与接口"></a>抽象类与接口</h4><p>1.<strong>抽象类和接口都不能够实例化，但可以定义抽象类和接口类型的引用</strong>。一个类如果继承了某个抽象类或者实现了某个接口都需要对其中的抽象方法全部进行实现，否则该类仍然需要被声明为抽象类。</p><p>2.接口比抽象类更加抽象，因为抽象类中可以定义构造器，可以有抽象方法和具体方法，而<strong>接口中不能定义构造器而且其中的方法全部都是抽象方法。</strong></p><p>3.抽象类中的成员可以是 private、默认、protected、public 的，而接口中的成员全都是 public 的。抽象类中可以定义成员变量，而接口中定义的成员变量实际上都是常量。<strong>有抽象方法的类必须被声明为抽象类，而抽象类未必要有抽象方法。</strong></p><p>(抽象类和接口应该如何选择？分别在什么情况下使用呢？</p><p>抽象类：<strong>需要额外的变量或者具体的方法</strong>，抽象类中可以有非抽象方法和变量。</p><p>接口：仅仅需要定义一些抽象方法而不需要其余额外的具体方法或者变量。）</p><h4 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h4><p>泛型的本质是参数化类型。Java的泛型是伪泛型，Java 在编译期间，所有的泛型信息都会被擦除，这通常叫做<strong>类型擦除</strong>。</p><p>泛型通常有三种使用方式：泛型类、泛型接口、泛型方法</p><h5 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Generic</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T key;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实例化一个泛型类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Generic&lt;Integer&gt; genericInteger = <span class="keyword">new</span> Generic&lt;Integer&gt;(<span class="number">123456</span>);</span><br></pre></td></tr></table></figure><h5 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Generator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">method</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现泛型接口，不指定类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GeneratorImpl</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Generator</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现泛型接口，指定类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GeneratorImpl</span> <span class="keyword">implements</span> <span class="title">Generator</span>&lt;<span class="title">String</span>&gt;</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; <span class="function"><span class="keyword">void</span> <span class="title">printArray</span><span class="params">(E[] inputArray)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (E element : inputArray) &#123;</span><br><span class="line">        System.out.printf(<span class="string">"%s "</span>, element);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建不同类型数组： Integer, Double 和 Character</span></span><br><span class="line">Integer[] intArray = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line">String[] stringArray = &#123; <span class="string">"Hello"</span>, <span class="string">"World"</span> &#125;;</span><br><span class="line">printArray(intArray);</span><br><span class="line">printArray(stringArray);</span><br></pre></td></tr></table></figure><p><strong>常用的通配符为： T，E，K，V，？</strong></p><ul><li>？ 表示不确定的 java 类型</li><li>T (type) 表示具体的一个 java 类型</li><li>K V (key value) 分别代表 java 键值中的 Key Value</li><li>E (element) 代表 Element</li></ul><h3 id="Object-类相关"><a href="#Object-类相关" class="headerlink" title="Object 类相关"></a>Object 类相关</h3><h4 id="和-equals-的区别"><a href="#和-equals-的区别" class="headerlink" title="==== 和 equals 的区别=="></a>==== 和 equals 的区别==</h4><p>对于基本数据类型来说，== 比较的是值。对于引用数据类型来说， == 比较的是对象的内存地址（也是值比较）。</p><p>equals 方法只能用来比较两个对象是否相等：</p><ul><li><p>当类没有覆盖 equals 方法时，等价于通过 == 比较这两个对象，调用 Object 类的 equals 方法。</p></li><li><p>当类覆盖了 equals 方法，一般我们都覆盖 equals 方法来比较两个对象中的属性是否相等，若它们的属性相等，则返回true。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String a = <span class="keyword">new</span> String(<span class="string">"ab"</span>); <span class="comment">// a 为一个引用</span></span><br><span class="line">        String b = <span class="keyword">new</span> String(<span class="string">"ab"</span>); <span class="comment">// b为另一个引用,对象的内容一样</span></span><br><span class="line">        String aa = <span class="string">"ab"</span>; <span class="comment">// 放在常量池中</span></span><br><span class="line">        String bb = <span class="string">"ab"</span>; <span class="comment">// 从常量池中查找</span></span><br><span class="line">        <span class="keyword">if</span> (aa == bb) <span class="comment">// true  aa 和 bb 指向常量池中同一个字符串"ab"</span></span><br><span class="line">            System.out.println(<span class="string">"aa==bb"</span>);</span><br><span class="line">        <span class="keyword">if</span> (a == b) <span class="comment">// false，非同一对象</span></span><br><span class="line">            System.out.println(<span class="string">"a==b"</span>);</span><br><span class="line">        <span class="keyword">if</span> (a.equals(b)) <span class="comment">// true</span></span><br><span class="line">            System.out.println(<span class="string">"aEQb"</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">42</span> == <span class="number">42.0</span>) &#123; <span class="comment">// true</span></span><br><span class="line">            System.out.println(<span class="string">"true"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="hashCode-和-equals"><a href="#hashCode-和-equals" class="headerlink" title="==hashCode 和 equals=="></a>==hashCode 和 equals==</h4><p>hashCode 的作用是获取散列码，它的作用是<strong>确定该对象在哈希表中的索引位置</strong>。hashCode 方法在 Object 类中定义，它返回对象的内存地址。</p><p>哈希表存储键值对，它能根据“键”快速找出对应的“值”，存储一个对象时，key 就是这个对象的 hashCode，value 就是这个对象。</p><h4 id="为什么重写-equals-方法时必须重写-hashCode-方法？"><a href="#为什么重写-equals-方法时必须重写-hashCode-方法？" class="headerlink" title="==为什么重写 equals 方法时必须重写 hashCode 方法？=="></a>==为什么重写 equals 方法时必须重写 hashCode 方法？==</h4><p>我们看一下Object类中关于hashCode()方法的注释</p><blockquote><p>1.在 Java 应用程序执行期间，在对同一对象多次调用 hashCode 方法时，必须一致地返回相同的整数，前提是将对象进行 equals 比较时所用的信息没有被修改。从某一应用程序的一次执行到同一应用程序的另一次执行，该整数无需保持一致。</p><p>2.如果根据 equals(Object) 方法，两个对象是相等的，那么对这两个对象中的每个对象调用 hashCode 方法都必须生成相同的整数结果。</p><p>3.如果根据 equals(java.lang.Object) 方法，两个对象不相等，那么对这两个对象中的任一对象上调用 hashCode 方法不要求一定生成不同的整数结果。但是，程序员应该意识到，为不相等的对象生成不同整数结果可以提高哈希表的性能</p></blockquote><p>如果 <code>a.equals(b) == true</code>，那么<code>a.hashCode() == b.hashCode()</code>；如果<code>a.equals(b) == false</code>，对象a 和 b 的哈希值不必相等，但程序员应该知道，为不相等的对象生成不同的哈希值可以提高哈希表的性能（避免哈希冲突）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> code;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">(<span class="keyword">int</span> code)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.code = code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        A a = (A) o;</span><br><span class="line">        <span class="keyword">return</span> code == a.code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    @Override</span></span><br><span class="line"><span class="comment">//    public int hashCode() &#123;</span></span><br><span class="line"><span class="comment">//        return Objects.hash(code);</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"A&#123;"</span> +</span><br><span class="line">                <span class="string">"code="</span> + code +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        A a = <span class="keyword">new</span> A(<span class="number">1</span>);</span><br><span class="line">        A b = <span class="keyword">new</span> A(<span class="number">1</span>);</span><br><span class="line">        HashSet&lt;A&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        set.add(a);</span><br><span class="line">        set.add(b);</span><br><span class="line">        System.out.println(set.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当只重写了 equals 方法时，输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[A&#123;code&#x3D;1&#125;, A&#123;code&#x3D;1&#125;]</span><br></pre></td></tr></table></figure><p>当重写了 equals 和 hashCode 方法时，输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[A&#123;code&#x3D;1&#125;]</span><br></pre></td></tr></table></figure><p>可以看到 equals 相等的两个等价对象因为 hashCode 不同，所以在 hashMap 中的 table 数组下标不同，从而这两个对象就会同时存在于集合中，由于 hashSet 就是 hashMap 实现的，在值不重复的 Set 中出现了两个等价对象，这就会出现逻辑错误，如果需要使用集合类，在重写 equals 方法时必须重写 hashCode 方法。</p><h4 id="Object-类的常见方法总结"><a href="#Object-类的常见方法总结" class="headerlink" title="==Object 类的常见方法总结=="></a>==Object 类的常见方法总结==</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> Class&lt;?&gt; getClass()<span class="comment">//native方法，用于返回当前运行时对象的Class对象，使用了final关键字修饰，故不允许子类重写。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> <span class="comment">//native方法，用于返回对象的哈希码，主要使用在哈希表中，比如JDK中的HashMap。</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span><span class="comment">//用于比较2个对象的内存地址是否相等，String类对该方法进行了重写用户比较字符串的值是否相等。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException<span class="comment">//native方法，用于创建并返回当前对象的一份拷贝。一般情况下，对于任何对象 x，表达式 x.clone() != x 为true，x.clone().getClass() == x.getClass() 为true。Object本身没有实现Cloneable接口，所以不重写clone方法并且进行调用的话会发生CloneNotSupportedException异常。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span><span class="comment">//返回类的名字@实例的哈希码的16进制的字符串。建议Object所有的子类都重写这个方法。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">()</span><span class="comment">//native方法，并且不能重写。唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">notifyAll</span><span class="params">()</span><span class="comment">//native方法，并且不能重写。跟notify一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException<span class="comment">//native方法，并且不能重写。暂停线程的执行。注意：sleep方法没有释放锁，而wait方法释放了锁 。timeout是等待时间。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout, <span class="keyword">int</span> nanos)</span> <span class="keyword">throws</span> InterruptedException<span class="comment">//多了nanos参数，这个参数表示额外时间（以毫微秒为单位，范围是 0-999999）。 所以超时的时间还需要加上nanos毫秒。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException<span class="comment">//跟之前的2个wait方法一样，只不过该方法一直等待，没有超时时间这个概念</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123; &#125;<span class="comment">//实例被垃圾回收器回收的时候触发的操作</span></span><br></pre></td></tr></table></figure><h3 id="Java-面向对象"><a href="#Java-面向对象" class="headerlink" title="Java 面向对象"></a>Java 面向对象</h3><h4 id="面向过程和面向对象"><a href="#面向过程和面向对象" class="headerlink" title="面向过程和面向对象"></a>面向过程和面向对象</h4><ul><li><p><strong>面向过程</strong> ：<strong>面向过程性能比面向对象高。</strong>但是，<strong>面向过程没有面向对象易维护、易复用、易扩展。</strong></p></li><li><p><strong>面向对象</strong> ：<strong>面向对象易维护、易复用、易扩展。</strong> 但是，<strong>面向对象性能比面向过程低</strong>。</p></li></ul><h4 id="成员变量和局部变量的区别"><a href="#成员变量和局部变量的区别" class="headerlink" title="成员变量和局部变量的区别"></a>成员变量和局部变量的区别</h4><ol><li>成员变量是属于类的，局部变量是在方法或代码块中定义的。成员变量可以被 public、static、private 等修饰符修饰，局部变量不能被这些修饰符修饰，成员变量和局部变量都能被 final 关键字修饰。</li><li>成员变量是对象的一部分，随对象的创建而存在，局部变量随着方法的调用而自动消失</li><li>成员变量如果没有赋初值，则会自动以类型的默认值为初值（被 final 修饰的成员变量必须显式地赋值），局部变量不会自动赋初值</li></ol><h4 id="一个类的构造方法的作用是什么？若一个类没有声明构造方法，该程序能正确执行吗？"><a href="#一个类的构造方法的作用是什么？若一个类没有声明构造方法，该程序能正确执行吗？" class="headerlink" title="一个类的构造方法的作用是什么？若一个类没有声明构造方法，该程序能正确执行吗？"></a>一个类的构造方法的作用是什么？若一个类没有声明构造方法，该程序能正确执行吗？</h4><p>构造方法主要完成类对象的初始化工作。</p><p>如果一个类没有声明构造方法，也可以执行！一个类即使没有声明构造方法也会有默认的不带参数的构造方法。（如果自己添加类的构造方法，Java 就不会再添加默认的无参数构造方法了）</p><h4 id="构造方法有哪些特点？是否可被重写？"><a href="#构造方法有哪些特点？是否可被重写？" class="headerlink" title="构造方法有哪些特点？是否可被重写？"></a>构造方法有哪些特点？是否可被重写？</h4><p>特点：</p><ol><li>名字与类名相同</li><li>没有返回值，但不能用 void 声明构造函数</li><li>生成类的对象时自动执行，无需调用</li></ol><p>构造方法不能被重写，但是可以重载，一个类中可以有多个构造函数</p><h4 id="在一个静态方法内调用一个非静态方法为什么是非法的？"><a href="#在一个静态方法内调用一个非静态方法为什么是非法的？" class="headerlink" title="在一个静态方法内调用一个非静态方法为什么是非法的？"></a>在一个静态方法内调用一个非静态方法为什么是非法的？</h4><p>静态方法属于类，在类加载时就会分配内存，可以通过类名直接访问。非静态成员属于实例对象，只有在对象实例化之后才存在。在静态方法中调用内存中还不存在的非静态成员属于非法操作。</p><h4 id="静态方法和实例方法有何不同？"><a href="#静态方法和实例方法有何不同？" class="headerlink" title="静态方法和实例方法有何不同？"></a>静态方法和实例方法有何不同？</h4><p>静态方法可使用 类名.方法名 和 对象名.方法名 这两种方式使用，实例方法只能使用后一种方法，<strong>调用静态方法无需创建对象</strong></p><p>静态方法只能使用类的静态成员变量和方法，不能访问实例成员变量和实例方法，实例方法中无限制。</p><h4 id="为什么-Java-中只有值传递？"><a href="#为什么-Java-中只有值传递？" class="headerlink" title="为什么 Java 中只有值传递？"></a>为什么 Java 中只有值传递？</h4><p>Java 总是采用按值调用，方法得到的所有参数值的一个拷贝。当参数为基本数据类型时，传递的是基本类型的拷贝值，当参数为引用对象时，传递的是对象引用的拷贝（这个拷贝的对象引用和原始对象引用<strong>同时</strong>指向堆中的对象内存）。</p><p>Java 中方法参数的使用情况：</p><ul><li>一个方法不能修改一个基本数据类型的参数（即数值型或布尔型）。</li><li>一个方法可以改变一个对象参数的状态。</li><li>一个方法不能让对象参数引用一个新的对象。</li></ul><h4 id="面向对象三大特征"><a href="#面向对象三大特征" class="headerlink" title="面向对象三大特征"></a>面向对象三大特征</h4><ol><li><p>封装，把一个对象的状态信息隐藏在对象内部，不允许外部对象直接访问对象的内部信息。但是可以提供一些被外界访问的方法来操作属性。</p></li><li><p>继承，使用已存在的类的定义作为基础建立新类，新类的定义可以增加新的数据或新的功能，也可以使用父类的功能，通过继承，可以提高代码的重用性。（子类拥有父类所有对象属性和方法，但父类中的私有属性和方法不能访问，子类可以对父类进行扩展，子类可以重写父类的方法）</p></li><li><p>多态，表示一个对象有多种状态，具体表现为父类的引用指向子类的实例。</p><p>多态的特点：</p><ul><li>对象类型和引用类型之间具有继承（类）/实现（接口）的关系</li><li>引用类型变量调用的方法必须在程序运行期间才能确定</li><li>多态不能调用“只在子类存在但父类不存在”的方法</li><li>如果子类重写了父类的方法，真正执行的是子类覆盖的方法，如果没有重写，执行父类的方法。</li></ul></li></ol><h4 id="继承初始化顺序"><a href="#继承初始化顺序" class="headerlink" title="继承初始化顺序"></a>继承初始化顺序</h4><p>类的初始化顺序：</p><p>初始化父类中的静态成员变量和静态代码块</p><p>初始化子类中的静态成员变量和静态代码块</p><p>初始化父类中的普通成员变量和代码块，再执行父类的构造方法</p><p>初始化子类中的普通成员变量和代码块，再执行子类的构造方法</p><h4 id="实现多态的方法（重载，重写，转型）"><a href="#实现多态的方法（重载，重写，转型）" class="headerlink" title="实现多态的方法（重载，重写，转型）"></a>实现多态的方法（重载，重写，转型）</h4><ul><li><p>方法重载，实现的是编译时的多态性，而方法重写实现的是运行时的多态性。</p><p><strong>方法重载：</strong>发生在同一个类中，方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同。<strong>重载就是同一个类中多个同名方法根据不同的传参来执行不同的逻辑处理。</strong></p></li><li><p><strong>方法重写</strong>：重写发生在运行期，是子类对父类的允许访问的方法的实现过程进行重新编写。</p><p>1.返回值类型、方法名、参数列表必须相同，拋岀的异常范围小于等于父类，访问修饰符范围大于等于父类。2.如果父类方法访问修饰符为 private/final/static则子类就不能重写该方法，但是被 static修饰的方法能够被再次声明。</p><p>3.构造方法无法被重写</p><p>综上:<strong>重写就是子类对父类方法的重新改造，外部样子不能改变，内部逻辑可以改变</strong></p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20210804211851235.png" alt="image-20210804211851235"></p></li><li><p>转型</p><p><strong>向上转型：</strong>把不同的子类对象都当作父类对象来看，可以屏蔽不同子类对象之间的差异，写出通用的代码，以适应需求的不断变化。例如：Father f = new Son（）;</p><p><strong>向下转型：</strong>不丢失子类对象的特性，例如：Son s = (Son) f;</p><p>转型的前提是有继承。在向上转型的时候我们可以直接转，但是在向下转型的时候我们<strong>必须强制类型转换</strong>。以Father f = new Son（）创建父类对象可以直接转型。若以Father f = new Father（）创建父类对象，那么不可以转换向下转换为子类的Son对象，运行会报错，因为其本质还是一个Father对象。</p></li></ul><h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>反射赋予了我们在运行时分析类以及执行类中方法的能力。</p><p>通过反射你可以获取任意一个类的所有属性和方法，并可以调用这些方法和属性。</p><h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><ul><li>优点：让代码更加灵活，为各种框架提供开箱即用功能提供便利</li><li>缺点：让我们在运行时有了分析类和操作类的能力。这同样增加了安全问题。比如可以无视泛型参数的安全检查（泛型参数的安全检查发生在编译时），同时，反射的性能稍差。</li></ul><h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><p>SpringBoot 等框架中大量使用了反射机制，<strong>这些框架中也大量使用了动态代理，而动态代理的实现也依赖反射</strong>。</p><p>另外，Java 中的注解也使用了反射，例如 Spring 中，@Component 注解声明一个类为 Spring Bean。这些都是因为可以基于反射分析类，然后获取到 类/属性/方法/方法参数 上的注解。获取到注解后，就可以进一步处理。</p><h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><h4 id="层次结构图"><a href="#层次结构图" class="headerlink" title="层次结构图"></a>层次结构图</h4><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20210815200456496.png" alt="image-20210815200456496"></p><p><code>Exception</code> 和 <code>Error</code> 二者都是 Java 异常处理的重要子类，各自都包含大量子类。</p><ul><li><strong><code>Exception</code></strong> :程序本身可以处理的异常，可以通过 <code>catch</code> 来进行捕获。<code>Exception</code> 又可以分为 <strong>受检查异常(必须处理) 和 不受检查异常(可以不处理)</strong>。</li><li><strong><code>Error</code></strong> ：<code>Error</code> 属于程序无法处理的错误 ，我们没办法通过 <code>catch</code> 来进行捕获 。例如，Java 虚拟机运行错误（<code>Virtual MachineError</code>）、虚拟机内存不够错误(<code>OutOfMemoryError</code>)、类定义错误（<code>NoClassDefFoundError</code>）等 。这些异常发生时，Java 虚拟机（JVM）一般会选择线程终止。</li></ul><p>==Java 代码在编译过程中 ，我们即使不处理不受检查异常也可以正常通过编译。==</p><h4 id="try-catch-finally"><a href="#try-catch-finally" class="headerlink" title="try-catch-finally"></a>try-catch-finally</h4><p>finally 块不会执行的情况</p><ul><li>在 try 或 finally 块中用了 System.exit(int) 退出程序。</li><li>程序所在线程死亡</li><li>关闭 CPU</li></ul><p>当 try 和 finally 语句中都有 return 语句时，finally 语句的内容将被执行。</p><h4 id="使用-try-with-resource-来代替-try-catch-finally"><a href="#使用-try-with-resource-来代替-try-catch-finally" class="headerlink" title="使用 try-with-resource 来代替 try-catch-finally"></a>使用 try-with-resource 来代替 try-catch-finally</h4><p>适用范围（资源）：任何实现 <code>java.lang.AutoCloseable</code>或者 <code>java.io.Closeable</code> 的类</p><p>在 finally 块中手动关闭资源</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Scanner scanner = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    scanner = <span class="keyword">new</span> Scanner(<span class="keyword">new</span> File(<span class="string">"D://read.txt"</span>)));</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(scanner != <span class="keyword">null</span>)&#123;</span><br><span class="line">        scanner.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 try-with-resource 自动关闭</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>(Scanner scanner = <span class="keyword">new</span> Scanner(<span class="keyword">new</span> File(<span class="string">"D://read.txt"</span>)));)&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="I-O-流"><a href="#I-O-流" class="headerlink" title="I/O 流"></a>I/O 流</h3><h4 id="序列化与反序列化"><a href="#序列化与反序列化" class="headerlink" title="序列化与反序列化"></a>序列化与反序列化</h4><ul><li>序列化：将数据结构或对象转换成二进制字节流的过程</li><li>反序列化：将在序列化过程中所生成的二进制字节流的过程转换为数据结构或对象的过程</li></ul><h4 id="Java-中有些字段不想进行序列化"><a href="#Java-中有些字段不想进行序列化" class="headerlink" title="Java 中有些字段不想进行序列化"></a>Java 中有些字段不想进行序列化</h4><p>使用 transient 关键字修饰，当对象被反序列化时，被 transient 修饰的变量值不会被持久化和恢复。</p><h4 id="关于-transient"><a href="#关于-transient" class="headerlink" title="关于 transient"></a>关于 transient</h4><ul><li>只能修饰变量</li><li>被它修饰的变量，在反序列化后变量值会被置成类型的默认值</li><li>static 变量不属于任何对象，不会被序列化</li></ul><h4 id="获取键盘输入的两种方法"><a href="#获取键盘输入的两种方法" class="headerlink" title="获取键盘输入的两种方法"></a>获取键盘输入的两种方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过 Scanner</span></span><br><span class="line">Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">String s  = input.nextLine();</span><br><span class="line">input.close();</span><br><span class="line"><span class="comment">//通过 BufferReader</span></span><br><span class="line">BufferedReader input = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">String s = input.readLine();</span><br></pre></td></tr></table></figure><h4 id="Java-中-IO-流分几种？"><a href="#Java-中-IO-流分几种？" class="headerlink" title="Java 中 IO 流分几种？"></a>Java 中 IO 流分几种？</h4><ul><li>按流的流向分，可以分为输入流和输出流</li><li>按操作单元划分，可以划分为字节流和字符流</li><li>按流的角色分为节点流和处理流</li></ul><p>Java IO 流的 40 多个类都是从如下 4 个抽象类基类中派生出来的。</p><ul><li>InputStream/Reader: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。</li><li>OutputStream/Writer: 所有输出流的基类，前者是字节输出流，后者是字符输出流。</li></ul><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20210815203343090.png" alt="image-20210815203343090"></p><h4 id="为什么分字节流和字符流"><a href="#为什么分字节流和字符流" class="headerlink" title="为什么分字节流和字符流"></a>为什么分字节流和字符流</h4><p>字符流由虚拟机将字节转化得到的，这个过程非常耗时，并且在编码类型未知时容易出现乱码问题。IO流就直接提供了一个操作字符的接口，方便对字符进行六操作。如果音频、文件、图片等使用字节流比较好。</p><h4 id="BIO、NIO、AIO"><a href="#BIO、NIO、AIO" class="headerlink" title="==BIO、NIO、AIO=="></a>==BIO、NIO、AIO==</h4><p>我们在平常开发过程中接触最多的就是 <strong>磁盘 IO（读写文件）</strong> 和 <strong>网络 IO（网络请求和相应）</strong>。</p><p><strong>从应用程序的视角来看的话，我们的应用程序对操作系统的内核发起 IO 调用（系统调用），操作系统负责的内核执行具体的 IO 操作。也就是说，我们的应用程序实际上只是发起了 IO 操作的调用而已，具体 IO 的执行是由操作系统的内核来完成的。</strong></p><p>当应用程序发起 I/O 调用后，会经历两个步骤：</p><ol><li>内核等待 I/O 设备准备好数据</li><li>内核将数据从内核空间拷贝到用户空间。</li></ol><h5 id="BIO-Blocking-IO"><a href="#BIO-Blocking-IO" class="headerlink" title="BIO(Blocking IO)"></a>BIO(Blocking IO)</h5><p>同步阻塞 IO 模型，应用程序发起 read 调用后会一直阻塞，直到在内核把数据拷贝回用户空间</p><p>在客户端连接数量不高的情况下可以使用。</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/6a9e704af49b4380bb686f0c96d33b81~tplv-k3u1fbpfcp-watermark.image" alt="图源：《深入拆解Tomcat &amp; Jetty》"></p><h5 id="NIO-Non-blocking-New-IO"><a href="#NIO-Non-blocking-New-IO" class="headerlink" title="NIO(Non-blocking/ New IO)"></a>NIO(Non-blocking/ New IO)</h5><p>Java 中的 NIO 于 Java 1.4 中引入，对应 <code>java.nio</code> 包，提供了 <code>Channel</code> , <code>Selector</code>，<code>Buffer</code> 等抽象。NIO 中的 N 可以理解为 Non-blocking，不单纯是 New。它支持面向缓冲的，基于通道的 I/O 操作方法。 对于高负载、高并发的（网络）应用，应使用 NIO 。</p><p>Java 中的 NIO 可以看作是 <strong>I/O 多路复用模型</strong>。也有很多人认为，Java 中的 NIO 属于同步非阻塞 IO 模型。</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/bb174e22dbe04bb79fe3fc126aed0c61~tplv-k3u1fbpfcp-watermark.image" alt="图源：《深入拆解Tomcat &amp; Jetty》"></p><p>同步非阻塞 IO 模型中，应用程序会一直发起 read 调用，等待数据从内核空间拷贝到用户空间的这段时间里，线程依然是阻塞的，直到在内核把数据拷贝到用户空间。</p><p>但是，这种 IO 模型同样存在问题：<strong>应用程序不断进行 I/O 系统调用轮询数据是否已经准备好的过程是十分消耗 CPU 资源的。</strong></p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/88ff862764024c3b8567367df11df6ab~tplv-k3u1fbpfcp-watermark.image" alt="img"></p><p>IO 多路复用模型中，线程首先发起 select 调用，询问内核数据是否准备就绪，等内核把数据准备好了，用户线程再发起 read 调用。read 调用的过程（数据从内核空间-&gt;用户空间）还是阻塞的。</p><p><strong>IO 多路复用模型，通过减少无效的系统调用，减少了对 CPU 资源的消耗。</strong></p><p>Java 中的 NIO ，有一个非常重要的<strong>选择器 ( Selector )</strong> 的概念，也可以被称为 <strong>多路复用器</strong>。通过它，只需要一个线程便可以管理多个客户端连接。当客户端数据到了之后，才会为其服务。</p><h5 id="AIO（Asynchronous-IO）"><a href="#AIO（Asynchronous-IO）" class="headerlink" title="AIO（Asynchronous IO）"></a>AIO（Asynchronous IO）</h5><p>异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/3077e72a1af049559e81d18205b56fd7~tplv-k3u1fbpfcp-watermark.image" alt="img"></p><h5 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h5><h5 id=""><a href="#" class="headerlink" title=""></a><img src="https://gitee.com/hoo334/picgo/raw/master//img/33b193457c928ae02217480f994814b6.png" alt="img"></h5><h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>在 Java 中除了以 <code>Map</code> 结尾的类之外， 其他类都实现了 <code>Collection</code> 接口。以 <code>Map</code> 结尾的类都实现了 <code>Map</code> 接口。</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/java-collection-hierarchy.png" alt="img"></p><h4 id="List，Set，Map-三者的区别"><a href="#List，Set，Map-三者的区别" class="headerlink" title="List，Set，Map 三者的区别"></a>List，Set，Map 三者的区别</h4><ol><li>List，存储的元素是==有序的、可重复==的</li><li>Set，存储的元素是==无序的、不可重复==的</li><li>Map，键值对存储，==key 是无序的、不可重复的，value 是无需的、可重复的==</li></ol><h4 id="集合底层数据结构"><a href="#集合底层数据结构" class="headerlink" title="集合底层数据结构"></a>集合底层数据结构</h4><h6 id="List"><a href="#List" class="headerlink" title="List"></a>List</h6><p>ArrayList、Vector：Object[] 数组，LinkedList：双向链表（JDK1.6 之前为循环链表）</p><h6 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h6><p>HashSet（无序、唯一）：基于 HashMap 实现</p><p>LinkedHashSet：是 HashSet 的子类，其内部是通过 LinkedHashMap 实现的</p><p>TreeSet（有序、唯一）：红黑树</p><h6 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h6><p>HashMap：JDK1.8 之前为数组+链表，之后当链表长度大于阈值（默认为 8 ）将链表转换为红黑树</p><p>LinkedHashMap：继承自 HashMap，在 HashMap 基础上，增加了一条双向链表，可以保持键值对的插入顺序，同时对链表进行相应的操作，实现了访问顺序相关逻辑</p><p>HashTable：数组+链表</p><p>TreeMap：红黑树</p><h3 id="如何选用集合"><a href="#如何选用集合" class="headerlink" title="如何选用集合"></a>如何选用集合</h3><p>当需要键值对存储时使用 Map 接口下的集合，排序用 TreeMap，不需要排序用HashMap，保证线程安全用 ConcurrentHashMap</p><p>当只用存放元素值时使用 Collection 接口下的集合，保证唯一性用 Set接口的集合例如 TreeSet 和 HashSet，不需要则选择实现 List 接口的如 ArrayList，LinkedList</p><h3 id="List-1"><a href="#List-1" class="headerlink" title="List"></a>List</h3><h4 id="ArrayList-和-LinkedList-的区别"><a href="#ArrayList-和-LinkedList-的区别" class="headerlink" title="ArrayList 和 LinkedList 的区别"></a>ArrayList 和 LinkedList 的区别</h4><ol><li><p>线程安全：都是不保证线程安全</p></li><li><p>底层数据结构：ArrayList 底层使用 <strong>Object 数组</strong>，LinkedList 使用<strong>双向链表</strong>数据结构</p></li><li><p>插入和删除是否受元素位置影响：</p><ul><li>ArrayList：操作末尾元素 $O(1)$时间复杂度，操作数组头部和中间元素$O(n)$时间复杂度</li><li>LinkedList：操作头尾元素$O(1)$时间复杂度，操作中间元素$O(n)$时间复杂度</li></ul></li><li><p>是否支持快速随机访问：ArrayList 底层是数组，所以支持，LinkedList 不支持</p></li><li><p>内存空间占用：ArrayList 为数组尾部空余空间浪费，LinkedList 为指针域空间占用</p></li></ol><h4 id="ArrayList-扩容机制"><a href="#ArrayList-扩容机制" class="headerlink" title="ArrayList 扩容机制"></a>ArrayList 扩容机制</h4><ol><li><p>构造方法：<strong>以无参数构造方法创建 <code>ArrayList</code> 时，实际上初始化赋值的是一个空数组。当真正对数组进行添加元素操作时，才真正分配容量。即向数组中添加第一个元素时，数组容量扩为 10</strong></p></li><li><p>扩容（grow 方法）：<strong>int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1),所以 ArrayList 每次扩容之后容量都会变为原来的 1.5 倍左右（oldCapacity 为偶数就是 1.5 倍，否则是 1.5 倍左右）</strong>，在添加大量元素时，显示调用 ensureCapacity 方法可以让ArrayList扩容</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// oldCapacity为旧容量，newCapacity为新容量</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="comment">//将oldCapacity 右移一位，其效果相当于oldCapacity /2，</span></span><br><span class="line">    <span class="comment">//我们知道位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍，</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量，</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="comment">//再检查新容量是否超出了ArrayList所定义的最大容量，</span></span><br><span class="line">    <span class="comment">//若超出了，则调用hugeCapacity()来比较minCapacity和 MAX_ARRAY_SIZE，</span></span><br><span class="line">    <span class="comment">//如果minCapacity大于MAX_ARRAY_SIZE，则新容量则为Interger.MAX_VALUE，否则，新容量大小则为 MAX_ARRAY_SIZE。</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Set-1"><a href="#Set-1" class="headerlink" title="Set"></a>Set</h3><h4 id="Comparable-和-Comparator-的区别"><a href="#Comparable-和-Comparator-的区别" class="headerlink" title="Comparable 和 Comparator 的区别"></a>Comparable 和 Comparator 的区别</h4><ul><li><code>comparable</code> 接口实际上是出自<code>java.lang</code>包 它有一个 <code>compareTo(Object obj)</code>方法用来排序</li><li><code>comparator</code>接口实际上是出自 java.util 包它有一个<code>compare(Object obj1, Object obj2)</code>方法用来排序</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// person对象没有实现Comparable接口，所以必须实现，这样才不会出错，才可以使treemap中的数据按顺序排列</span></span><br><span class="line"><span class="comment">// 前面一个例子的String类已经默认实现了Comparable接口，详细可以查看String类的API文档，另外其他</span></span><br><span class="line"><span class="comment">// 像Integer类等都已经实现了Comparable接口，所以不需要另外实现了</span></span><br><span class="line"><span class="keyword">public</span>  <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Person</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"><span class="comment">//省略 getter、setter、构造方法</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重写compareTo方法实现按年龄来排序</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Person o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.age &gt; o.getAge()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.age &lt; o.getAge()) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定制排序的用法</span></span><br><span class="line">Collections.sort(arrayList, <span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> o2.compareTo(o1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="HashSet、LinkedHashSet-和-TreeSet-三者异同"><a href="#HashSet、LinkedHashSet-和-TreeSet-三者异同" class="headerlink" title="HashSet、LinkedHashSet 和 TreeSet 三者异同"></a>HashSet、LinkedHashSet 和 TreeSet 三者异同</h4><p><code>HashSet</code> 是 <code>Set</code> 接口的主要实现类 ，<code>HashSet</code> 的底层是 <code>HashMap</code>，线程不安全的，可以存储 null 值；</p><p><code>LinkedHashSet</code> 是 <code>HashSet</code> 的子类，<strong>能够按照添加的顺序遍历</strong>；</p><p><code>TreeSet</code> 底层使用红黑树，能够按照添加元素的顺序进行遍历，排序的方式有自然排序和定制排序。</p><h3 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h3><h4 id="Queue-和-Deque-的区别"><a href="#Queue-和-Deque-的区别" class="headerlink" title="Queue 和 Deque 的区别"></a>Queue 和 Deque 的区别</h4><p>Queue 是单端队列，只能从一端插入元素，另一端删除元素，一般遵循先进先出原则。</p><p><code>Queue</code> 扩展了 <code>Collection</code> 的接口，根据 <strong>因为容量问题而导致操作失败后处理方式的不同</strong> 可以分为两类方法: 一种在操作失败后会抛出异常，另一种则会返回特殊值。</p><table><thead><tr><th><code>Queue</code> 接口</th><th>抛出异常</th><th>返回特殊值</th></tr></thead><tbody><tr><td>插入队尾</td><td>add(E e)</td><td>offer(E e)</td></tr><tr><td>删除队首</td><td>remove()</td><td>poll()</td></tr><tr><td>查询队首元素</td><td>element()</td><td>peek()</td></tr></tbody></table><p>Deque 是双端队列，在队列的两端均可插入或删除元素</p><p><code>Deque</code> 扩展了 <code>Queue</code> 的接口, 增加了在队首和队尾进行插入和删除的方法，同样根据失败后处理方式的不同分为两类：</p><table><thead><tr><th><code>Deque</code> 接口</th><th>抛出异常</th><th>返回特殊值</th></tr></thead><tbody><tr><td>插入队首</td><td>addFirst(E e)</td><td>offerFirst(E e)</td></tr><tr><td>插入队尾</td><td>addLast(E e)</td><td>offerLast(E e)</td></tr><tr><td>删除队首</td><td>removeFirst()</td><td>pollFirst()</td></tr><tr><td>删除队尾</td><td>removeLast()</td><td>pollLast()</td></tr><tr><td>查询队首元素</td><td>getFirst()</td><td>peekFirst()</td></tr><tr><td>查询队尾元素</td><td>getLast()</td><td>peekLast()</td></tr></tbody></table><p>事实上，<code>Deque</code> 还提供有 <code>push()</code> 和 <code>pop()</code> 等其他方法，可用于模拟栈。</p><h4 id="ArrayDeque-和-LinkedList-的区别"><a href="#ArrayDeque-和-LinkedList-的区别" class="headerlink" title="ArrayDeque 和 LinkedList 的区别"></a>ArrayDeque 和 LinkedList 的区别</h4><p>它们都实现了 Deque 接口，两者都有队列的功能</p><ul><li>ArrayDeque 基于可变长的数组和双指针实现，LinkedList 通过双向链表实现</li><li>ArrayDeque 不支持 Null 数据，LinkedList 支持</li><li>ArrayDeque 插入时可能存在扩容过程，均摊后的操作时间复杂度$O(1)$，LinkedList 每次插入数据时均需要申请新的堆空间，均摊性能更慢。</li></ul><p>从性能的角度上，选用 <code>ArrayDeque</code> 来实现队列要比 <code>LinkedList</code> 更好。此外，<code>ArrayDeque</code> 也可以用于实现栈。</p><h4 id="PriorityQueue"><a href="#PriorityQueue" class="headerlink" title="PriorityQueue"></a>PriorityQueue</h4><p>优先级队列，总是优先级最高的元素先出队</p><p>它使用二叉堆来实现，底层使用可变长的数组来存储数据，插入元素和删除堆顶元素时间复杂度为$O(log\ n)$，非线程安全，不支持 Null 和 没有实现 Comparable 的对象，默认为小顶堆，可以接受一个 Comparator 自定优先级。</p><h3 id="Map-1"><a href="#Map-1" class="headerlink" title="Map"></a>Map</h3><h4 id="HashMap-和-HashTable"><a href="#HashMap-和-HashTable" class="headerlink" title="HashMap 和 HashTable"></a>HashMap 和 HashTable</h4><ol><li><p>线程安全，HashMap 非线程安全，HashTable 内部的方法基本都使用 synchronized 修饰，是线程安全的</p></li><li><p>效率，由于线程安全的操作，HashTable 比 HashMap 效率低</p></li><li><p>对空键和空值的支持，HashMap 支持一个空键，多个空值；HashTable 不允许有空键和空值，否则抛空指针异常</p></li><li><p>数据结构，HashTable 数组+链表，jdk1.7 HashMap 也是数组+链表，jdk1.8 后当链表长度大于阈值会将链表转换为红黑树</p></li><li><p>初始容量和扩容不同，HashTabl默认大小为 11，每次扩容容量变为原来的 2n + 1 ，HashMap 初始大小为16，每次扩容为原来的 2 倍。如果给定容量大小，HashTable 直接扩容到给定的大小，HashMap 将会把它扩容到 2 的幂次方。</p></li></ol><h4 id="HashMap-和-HashSet"><a href="#HashMap-和-HashSet" class="headerlink" title="HashMap 和 HashSet"></a>HashMap 和 HashSet</h4><p>如果你看过 <code>HashSet</code> 源码的话就应该知道：<code>HashSet</code> 底层就是基于 <code>HashMap</code> 实现的。（<code>HashSet</code> 的源码非常非常少，因为除了 <code>clone()</code>、<code>writeObject()</code>、<code>readObject()</code>是 <code>HashSet</code> 自己不得不实现之外，其他方法都是直接调用 <code>HashMap</code> 中的方法。</p><table><thead><tr><th><code>HashMap</code></th><th><code>HashSet</code></th></tr></thead><tbody><tr><td>实现了 <code>Map</code> 接口</td><td>实现 <code>Set</code> 接口</td></tr><tr><td>存储键值对</td><td>仅存储对象</td></tr><tr><td>调用 <code>put()</code>向 map 中添加元素</td><td>调用 <code>add()</code>方法向 <code>Set</code> 中添加元素</td></tr><tr><td><code>HashMap</code> 使用键（Key）计算 <code>hashcode</code></td><td><code>HashSet</code> 使用成员对象来计算 <code>hashcode</code> 值，对于两个对象来说 <code>hashcode</code> 可能相同，所以<code>equals()</code>方法用来判断对象的相等性</td></tr></tbody></table><h4 id="HashMap-和-TreeMap"><a href="#HashMap-和-TreeMap" class="headerlink" title="HashMap 和 TreeMap"></a>HashMap 和 TreeMap</h4><p><code>TreeMap</code> 和<code>HashMap</code> 都继承自<code>AbstractMap</code> ，但是需要注意的是<code>TreeMap</code>它还实现了<code>NavigableMap</code>接口和<code>SortedMap</code> 接口。</p><p>实现 <code>NavigableMap</code> 接口让 <code>TreeMap</code> 有了对集合内元素的搜索的能力。</p><p>实现<code>SortMap</code>接口让 <code>TreeMap</code> 有了对集合中的元素根据键排序的能力。</p><h4 id="HashSet如何检查重复"><a href="#HashSet如何检查重复" class="headerlink" title="==HashSet如何检查重复=="></a>==HashSet如何检查重复==</h4><p>当你把对象加入<code>HashSet</code>时，<code>HashSet</code> 会先计算对象的<code>hashcode</code>值来判断对象加入的位置，同时也会与其他加入的对象的 <code>hashcode</code> 值作比较，如果没有相符的 <code>hashcode</code>，<code>HashSet</code> 会假设对象没有重复出现。但是如果发现有相同 <code>hashcode</code> 值的对象，这时会调用<code>equals()</code>方法来检查 <code>hashcode</code> 相等的对象是否真的相同。如果两者相同，<code>HashSet</code> 就不会让加入操作成功。</p><h4 id="HashMap-底层实现"><a href="#HashMap-底层实现" class="headerlink" title="HashMap 底层实现"></a>HashMap 底层实现</h4><p>JDK1.8 HashMap 的 hash 方法源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="comment">// key.hashCode()：返回散列值也就是hashcode</span></span><br><span class="line">    <span class="comment">// ^ ：按位异或</span></span><br><span class="line">    <span class="comment">// &gt;&gt;&gt;:无符号右移，忽略符号位，空位都以0补齐</span></span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JDK1.8 之后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。</p><h4 id="HashMap-的长度为什么是-2-的幂次方"><a href="#HashMap-的长度为什么是-2-的幂次方" class="headerlink" title="==HashMap 的长度为什么是 2 的幂次方=="></a>==HashMap 的长度为什么是 2 的幂次方==</h4><p>一般我们使用 hash 值取余数组的长度 n ，得到存放到数组的下标。但取余操作很慢，HashMap 使用的是 <code>(n - 1) &amp; hash</code>快速求下标的方式。但只有当 n 为 2 的幂次时，<code>hash % n == hash &amp; (n - 1)</code>，所以 HashMap 的长度必须为 2 的幂次。</p><h4 id="HashMap-类属性"><a href="#HashMap-类属性" class="headerlink" title="HashMap 类属性"></a>HashMap 类属性</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 序列号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">362498820763181265L</span>;</span><br><span class="line">    <span class="comment">// 默认的初始容量是16</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>;</span><br><span class="line">    <span class="comment">// 最大容量</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line">    <span class="comment">// 默认的填充因子</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line">    <span class="comment">// 当桶(bucket)上的结点数大于这个值时会转成红黑树</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line">    <span class="comment">// 当桶(bucket)上的结点数小于这个值时树转链表</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line">    <span class="comment">// 桶中结构转化为红黑树对应的table的最小大小</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br><span class="line">    <span class="comment">// 存储元素的数组，总是2的幂次倍</span></span><br><span class="line">    <span class="keyword">transient</span> Node&lt;k,v&gt;[] table;</span><br><span class="line">    <span class="comment">// 存放具体元素的集</span></span><br><span class="line">    <span class="keyword">transient</span> Set&lt;map.entry&lt;k,v&gt;&gt; entrySet;</span><br><span class="line">    <span class="comment">// 存放元素的个数，注意这个不等于数组的长度。</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="comment">// 每次扩容和更改map结构的计数器</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br><span class="line">    <span class="comment">// 临界值 当实际大小(容量*填充因子)超过临界值时，会进行扩容</span></span><br><span class="line">    <span class="keyword">int</span> threshold;</span><br><span class="line">    <span class="comment">// 加载因子</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="HashMap-多线程操作死循环问题"><a href="#HashMap-多线程操作死循环问题" class="headerlink" title="HashMap 多线程操作死循环问题"></a>HashMap 多线程操作死循环问题</h4><p>在并发情况下，Rehash 方法会造成元素之间形成一个循环链表</p><p><a href="https://coolshell.cn/articles/9606.html" target="_blank" rel="noopener">详解</a></p><h4 id="ConcurrentHashMap-和-HashTable"><a href="#ConcurrentHashMap-和-HashTable" class="headerlink" title="ConcurrentHashMap 和 HashTable"></a>ConcurrentHashMap 和 HashTable</h4><ol><li>底层数据结构：JDK1.7 之前 ConcurrentHashMap 底层采用分段数组+链表实现，JDK1.8 采用数组 + 链表/红黑树。HashTable 采用数组+链表实现</li><li>实现线程安全的方式：<ul><li>JDK1.7时 ConcurrentHashMap 对整个桶数组进行了分段分割（segment），每一把锁只锁一部分数据。到JDK1.8时，直接使用 Node 数组+链表/红黑树来实现，并发控制使用 synchronzied 和 CAS 来操作</li><li>HashTable 使用全表锁，效率十分低下，一个线程使用 put 添加元素，另一个线程既不能 get 也不能 put。</li></ul></li></ol><h4 id="ConcurrentHashMap底层实现"><a href="#ConcurrentHashMap底层实现" class="headerlink" title="ConcurrentHashMap底层实现"></a>ConcurrentHashMap底层实现</h4><p>JDK1.7</p><p>首先将数据分为一段一段，然后给每段数据配一把锁，当一个线程占用锁访问其中一个段数据时，其他段的数据也能被其他线程访问。</p><p>ConcurrentHashMap 是由 Segment 数组结构和 HashEntry 数组结构组成。</p><p>Segment 实现了 ReentrantLock，Segment 是一种可重入锁，扮演锁的角色。HashEntry 用于存储键值对数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Segment</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">ReentrantLock</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个 ConcurrentHashMap 里包含一个Segment数组，一个 Segment 包含一个 HashEntry 数组，每个 HashEntry 是一个链表结构的元素，当对当前 Segment 内的 HashEntry 进行修改时，必须先获得 Segment 的锁。</p><p>JDK1.8</p><p><code>ConcurrentHashMap</code> 取消了 <code>Segment</code> 分段锁，采用 CAS 和 <code>synchronized</code> 来保证并发安全。数据结构跟 HashMap1.8 的结构类似，数组+链表/红黑二叉树。Java 8 在链表长度超过一定阈值（8）时将链表（寻址时间复杂度为 O(N)）转换为红黑树（寻址时间复杂度为 $O(logN）$</p><h4 id="1-ConcurrentHashMap与HashMap有什么区别？"><a href="#1-ConcurrentHashMap与HashMap有什么区别？" class="headerlink" title="1.ConcurrentHashMap与HashMap有什么区别？"></a>1.ConcurrentHashMap与HashMap有什么区别？</h4><p>数据结构：HashMap的数据结构在HashMap那一篇已经有了很详细的说明，这里就不赘述了。在JDK1.7中ConcurrentHashMap底层采用分段数组+链表的方式实现。在JDK1.8中ConcurrentHashMap与JDK1.8中的HashMap底层数据结构一样，都是采用数组+链表或者数组+红黑树的方式实现。这二者底层数据结构都是以数组为主体的。</p><p>线程安全：HashMap是线程不安全的，ConcurrentHashMap是线程安全的。</p><h4 id="2-说一下ConcurrentHashMap的工作原理，put-和get-的工作流程是怎样的？"><a href="#2-说一下ConcurrentHashMap的工作原理，put-和get-的工作流程是怎样的？" class="headerlink" title="==2.说一下ConcurrentHashMap的工作原理，put()和get()的工作流程是怎样的？=="></a>==2.说一下ConcurrentHashMap的工作原理，put()和get()的工作流程是怎样的？==</h4><p>存储对象时，将key和vaule传给put()方法：</p><ul><li>如果没有初始化，就调用initTable()方法对数组进行初始化；</li><li>如果没有hash冲突则直接通过CAS进行无锁插入；</li><li>如果需要扩容，就先进行扩容，扩容为原来的两倍；</li><li>如果存在hash冲突，就通过加锁的方式进行插入，从而保证线程安全。（如果是链表就按照尾插法插入，如果是红黑树就按照红黑树的数据结构进行插入）；</li><li>如果达到链表转红黑树条件，就将链表转为红黑树；</li><li>如果插入成功就调用addCount()方法进行计数并且检查是否需要扩容；</li></ul><p>注意：在并发情况下ConcurrentHashMap会调用多个工作线程一起帮助扩容，这样效率会更高。</p><p>下面以一个很详细的流程图方式展现一下ConcurrentHashMap的put()过程（由于流程图比较庞大复杂，所以没有将计数和扩容阶段的流程画出，有兴趣的小伙伴可以去看一下addCount()和transfer()这两个方法的源码）：</p><p><img src="https://pic3.zhimg.com/v2-c5d2b7c7c5bd09c5973a0ec64d39eab2_b.jpg" alt="img"></p><p>获取对象时，将key传给get()方法：</p><ul><li>计算hash值，定位table索引位置，如果头节点符合条件则直接返回key对应的value；</li><li>如果遇到正在扩容，则调用标记正在扩容的节点，查找该节点，匹配就返回；</li><li>以上条件都不符合，就继续向下遍历；</li></ul><p>注意：其实get()的流程跟HashMap基本是一样的。put()的流程只是比HashMap多了一些保证线程安全的操作而已</p><h4 id="3-ConcurrentHashMap和HashTable的效率哪个更高？为什么？"><a href="#3-ConcurrentHashMap和HashTable的效率哪个更高？为什么？" class="headerlink" title="3.ConcurrentHashMap和HashTable的效率哪个更高？为什么？"></a>3.ConcurrentHashMap和HashTable的效率哪个更高？为什么？</h4><p>ConcurrentHashMap的效率要高于HashTable，因为HashTable是使用一把锁锁住整个链表结构从而实现线程安全。而ConcurrentHashMap的锁粒度更低，在JDK1.7中采用分段锁实现线程安全，在JDK1.8中采用CAS（无锁算法）+Synchronized实现线程安全。</p><p><strong>追问：那你具体说一下HashTable和ConcurrentHashMap的锁机制（重点）</strong></p><p>HashTable中的锁机制：</p><p>HashTab是使用Synchronized来实现线程安全的，是使用一把锁锁住整个链表结构，效率非常低。当有一个线程访问同步方法的时候，其他线程是访问不了的，其他线程可能会被阻塞或者进入轮询状态。如果有一个线程正在执行put()操作的时候，其他线程是不可以进行put()操作的，也不可以进行get()操作，并发线程越多，竞争越激烈，效率越低下。</p><p><img src="https://pic3.zhimg.com/v2-e0468e9d86cd488bacefbccbd9723396_b.jpg" alt="img"></p><p><strong>ConcurrentHashMap在JDK1.7中的分段锁机制：</strong></p><p>对整个数组进行分段（每段都是由若干个hashEntry对象组成的链表），每个分段都有一个Segment分段锁（继承ReentrantLock分段锁），每个Segment分段锁只会锁住它锁守护的那一段数据，多线程访问不同数据段的数据，就不会存在竞争，从而提高了并发的访问率。</p><p><img src="https://pic2.zhimg.com/v2-199b8bf484a000c52cd43520593a238d_b.jpg" alt="img"></p><p><strong>ConcurrentHashMap在JDK1.8中的锁机制：</strong></p><p>ConcurrentHashMap在JDK1.8中采用Node+CAS+Synchronized实现线程安全，取消了segment分段锁，直接使用Table数组存储键值对（与1.8中的HashMap一样），主要是使用Synchronized+CAS的方法来进行并发控制。在put()的时候如果CAS失败就说明存在竞争，会进行自旋，具体流程上面已有说明，这里就不在赘述。</p><p><img src="https://pic1.zhimg.com/v2-406496261699a413e1a4c836412ef42c_b.jpg" alt="img"></p><h4 id="4-ConcurrentHashMap在JDK1-8中为什么要使用内置锁Synchronized来替换ReentractLock重入锁？"><a href="#4-ConcurrentHashMap在JDK1-8中为什么要使用内置锁Synchronized来替换ReentractLock重入锁？" class="headerlink" title="4.ConcurrentHashMap在JDK1.8中为什么要使用内置锁Synchronized来替换ReentractLock重入锁？"></a>4.ConcurrentHashMap在JDK1.8中为什么要使用内置锁Synchronized来替换ReentractLock重入锁？</h4><ul><li>锁粒度降低了；</li><li>官方对synchronized进行了优化和升级，使得synchronized不那么“重”了；</li><li>在大数据量的操作下，对基于API的ReentractLock进行操作会有更大的内存开销；</li></ul><h4 id="5-ConcurrentHashMap的get-方法需要加锁吗？"><a href="#5-ConcurrentHashMap的get-方法需要加锁吗？" class="headerlink" title="5.ConcurrentHashMap的get()方法需要加锁吗？"></a>5.ConcurrentHashMap的get()方法需要加锁吗？</h4><p>不需要，get操作可以无锁是由于Node的元素val和指针next是用volatile修饰的，在多线程环境下线程A修改结点的val或者新增节点的时候是对线程B可见的。</p><h4 id="6-ConcurrentHashMap中的key和value可以为null吗？为什么？"><a href="#6-ConcurrentHashMap中的key和value可以为null吗？为什么？" class="headerlink" title="6.ConcurrentHashMap中的key和value可以为null吗？为什么？"></a>6.ConcurrentHashMap中的key和value可以为null吗？为什么？</h4><p>不可以，因为源码中是这样判断的，进行put()操作的时候如果key为null或者value为null，会抛出NullPointerException空指针异常。</p><p>追问：那么源码为什么要这么设计呢？</p><p>如果ConcurrentHashMap中存在一个key对应的value是null，那么当调用map.get(key)的时候，必然会返回null，那么这个null就有两个意思：</p><ul><li>这个key从来没有在map中映射过，也就是不存在这个key；</li><li>这个key是真实存在的，只是在设置key的value值的时候，设置为null了；</li></ul><p>这个二义性在非线程安全的HashMap中可以通过map.containsKey(key)方法来判断，如果返回true，说明key存在只是对应的value值为空。如果返回false，说明这个key没有在map中映射过。这样是为什么HashMap可以允许键值为null的原因，但是ConcurrentHashMap只用这个判断是判断不了二义性的。</p><p><strong>追问：说说为什么ConcurrentHashMap判断不了呢？</strong></p><p>此时如果有A、B两个线程，A线程调用ConcurrentHashMap.get(key)方法返回null，但是我们不知道这个null是因为key没有在map中映射还是本身存的value值就是null，此时我们假设有一个key没有在map中映射过，也就是map中不存在这个key，此时我们调用ConcurrentHashMap.containsKey(key)方法去做一个判断，我们期望的返回结果是false。但是恰好在A线程get(key)之后，调用constainsKey(key)方法之前B线程执行了ConcurrentHashMap.put(key,null)，那么当A线程执行完containsKey(key)方法之后我们得到的结果是true，与我们预期的结果就不相符了。</p><p>至于ConcurrentHashMap中的key为什么也不能为null的问题，ConcurrentHashMap的作者Doug Lea认为map中允许键值为null是一种不合理的设计，HashMap虽然可以判断二义性，但是Doug Lea仍然觉得这样设计是不合理的。</p><h4 id="7-ConcurrentHashMap的并发度是什么？"><a href="#7-ConcurrentHashMap的并发度是什么？" class="headerlink" title="7.ConcurrentHashMap的并发度是什么？"></a>7.ConcurrentHashMap的并发度是什么？</h4><p>程序在运行时能够同时更新ConcurrentHashMap且不产生锁竞争的最大线程数默认是16，这个值可以在构造函数中设置。如果自己设置了并发度，ConcurrentHashMap会使用大于等于该值的最小的2的幂指数作为实际并发度，也就是比如你设置的值是17，那么实际并发度是32。</p><h3 id="Collections-工具类"><a href="#Collections-工具类" class="headerlink" title="Collections 工具类"></a>Collections 工具类</h3><h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(List list)</span><span class="comment">//反转</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shuffle</span><span class="params">(List list)</span><span class="comment">//随机排序</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(List list)</span><span class="comment">//按自然排序的升序排序</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(List list, Comparator c)</span><span class="comment">//定制排序，由Comparator控制排序逻辑</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(List list, <span class="keyword">int</span> i , <span class="keyword">int</span> j)</span><span class="comment">//交换两个索引位置的元素</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(List list, <span class="keyword">int</span> distance)</span><span class="comment">//旋转。当distance为正数时，将list后distance个元素整体移到前面。当distance为负数时，将 list的前distance个元素整体移到后面</span></span></span><br></pre></td></tr></table></figure><h4 id="查找、替换操作"><a href="#查找、替换操作" class="headerlink" title="查找、替换操作"></a>查找、替换操作</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(List list, Object key)</span><span class="comment">//对List进行二分查找，返回索引，注意List必须是有序的</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(Collection coll)</span><span class="comment">//根据元素的自然顺序，返回最大的元素。 类比int min(Collection coll)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(Collection coll, Comparator c)</span><span class="comment">//根据定制排序，返回最大元素，排序规则由Comparatator类控制。类比int min(Collection coll, Comparator c)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fill</span><span class="params">(List list, Object obj)</span><span class="comment">//用指定的元素代替指定list中的所有元素</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">frequency</span><span class="params">(Collection c, Object o)</span><span class="comment">//统计元素出现次数</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexOfSubList</span><span class="params">(List list, List target)</span><span class="comment">//统计target在list中第一次出现的索引，找不到则返回-1，类比int lastIndexOfSubList(List source, list target)</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">replaceAll</span><span class="params">(List list, Object oldVal, Object newVal)</span><span class="comment">//用新元素替换旧元素</span></span></span><br></pre></td></tr></table></figure><h4 id="同步（不推荐，建议使用-JUC-包下的并发集合）"><a href="#同步（不推荐，建议使用-JUC-包下的并发集合）" class="headerlink" title="同步（不推荐，建议使用 JUC 包下的并发集合）"></a>同步（不推荐，建议使用 JUC 包下的并发集合）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">synchronizedCollection(Collection&lt;T&gt;  c) <span class="comment">//返回指定 collection 支持的同步（线程安全的）collection。</span></span><br><span class="line">synchronizedList(List&lt;T&gt; list)<span class="comment">//返回指定列表支持的同步（线程安全的）List。</span></span><br><span class="line">synchronizedMap(Map&lt;K,V&gt; m) <span class="comment">//返回由指定映射支持的同步（线程安全的）Map。</span></span><br><span class="line">synchronizedSet(Set&lt;T&gt; s) <span class="comment">//返回指定 set 支持的同步（线程安全的）set。</span></span><br></pre></td></tr></table></figure><h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><h3 id="基础-1"><a href="#基础-1" class="headerlink" title="基础"></a>基础</h3><h4 id="什么是线程安全性"><a href="#什么是线程安全性" class="headerlink" title="什么是线程安全性"></a>什么是线程安全性</h4><p>在线程安全性的定义中最核心的概念就是正确性，正确性的含义是，<strong>某个类的行为与其规范完全一致</strong>。在良好的规范中通常会定义各种不变性条件（Invariant）来约束对象的状态，以及定义各种后验条件（Post condition）来描述对象操作的结果。当多线程访问某个类时，这个类始终都能表现出正确的行为，那么这个类就是线程安全的。</p><h4 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h4><p>进程是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。在 Java 中，当我们启动 main 函数时就是启动了一个 JVM 的进程。</p><p>线程与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是，同类的多个线程共享进程的<strong>堆</strong>和<strong>方法区</strong>资源，但每个线程都有自己的<strong>程序计数器</strong>、<strong>虚拟机栈</strong>和<strong>本地方法栈</strong>。</p><h4 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h4><ol><li>管道</li></ol><p>进程中也可以使用管道进行通信，管道通常会缓存来自一个进程输出的数据，直到另一个进程接收到该数据为止。从图中可以看出，管道是单向的数据通道，类似于键盘流。可以使用两个管道在两个进程之间创建双向数据通道。如果数据没有被拿走，则第一个进程会一直等待，不能做其他事。所以管道这种通信方式很简便，但是效率很低，不能用于其他很复杂的场景</p><ol start="2"><li>消息队列</li></ol><p>管道中第一个进程必须等待数据被读取，这种方法使得进程间通信效率低下。于是消息队列就登场了。A 进程将数据写入消息队列，不用等待，就去做自己的事情了。B 进程来了也不管 A 进程在不在，直接从消息队列里读取数据即可。有时候两个进程会进行频繁地对消息队列进行存取，就会进行大量地拷贝数据操作。还有数据占内存比较大时，拷贝数据操作就更加耗时。</p><ol start="3"><li>共享内存</li></ol><p>针对消息队列拷贝数据耗时，以及存放和读取数据的速度差别大的问题，共享内存又登场了。共享内存就是可以由多个进程同时访问的内存，不同对数据进行拷贝，两个进程约定一个共同空间，直接在该空间对数据进行存取，实现进程间通信。虚拟内存通过分页的方式映射到物理内存，可以让两个进程的虚拟内存映射到相同物理内存中，这就是共享内存。两个或多个进程读写某些共享数据时，遇到会遇到多进程竞争内存的情况，导致读写的数据错误。</p><ol start="4"><li>信号量</li></ol><p>为了解决多进程竞争共享内存的情况，可以使用信号量（Semaphore）信号量可以看做是一个计数器，初始值表示允许同时访问共享内存的最多进程数。当有一个进程访问共享内存，信号量减一。当信号量为零时，锁定共享内存，即不允许其他进程访问共享内存。进程取消访问共享内存，信号量加一。</p><h4 id="程序计数器为什么是线程私有的？"><a href="#程序计数器为什么是线程私有的？" class="headerlink" title="程序计数器为什么是线程私有的？"></a>程序计数器为什么是线程私有的？</h4><ol><li>字节码解释器通过程序计数器来读取指令，从而实现代码的流程控制</li><li>在多线程情况下，程序计数器用于记录当前线程执行的位置</li></ol><p>如果执行的是 native 方法，程序计数器记录的是 undefined 地址，只有执行的是 Java 代码时，程序计数器才指向下一条指令的地址</p><p>程序计数器私有是为了<strong>线程切换后能恢复到正确的执行位置</strong></p><h4 id="虚拟机栈和本地方法栈为什么是私有的？"><a href="#虚拟机栈和本地方法栈为什么是私有的？" class="headerlink" title="虚拟机栈和本地方法栈为什么是私有的？"></a>虚拟机栈和本地方法栈为什么是私有的？</h4><p>虚拟机栈：每个 Java 方法在执行的同时会创建一个栈帧用于存储<strong>局部变量表</strong>，<strong>操作数栈</strong>，<strong>常量池引用</strong>等信息。从方法调用直至执行完成，就对应着一个栈帧在 Java 虚拟机中入栈和出栈的过程</p><p>本地方法栈：和虚拟机栈所发挥的作用非常相似，区别是虚拟机栈为虚拟机执行 Java 方法服务，本地方法为虚拟机使用到的 Native 方法服务</p><p>为了<strong>保证线程中的局部变量不被其他线程访问到</strong>，虚拟机栈和本地方法栈是私有的</p><h4 id="堆和方法区"><a href="#堆和方法区" class="headerlink" title="堆和方法区"></a>堆和方法区</h4><p>堆和方法区是所有线程共享的资源，堆是进程中最大的一块内存，主要用于存放新创建的对象，方法区主要存放已被加载的类信息、常量、静态变量、JIT编译后的数据。</p><h4 id="并行和并发"><a href="#并行和并发" class="headerlink" title="并行和并发"></a>并行和并发</h4><ul><li>并发：同一时间段，多个任务都在执行，同一时刻只执行一个任务</li><li>并发：单位时间内，多个任务同时执行</li></ul><h4 id="为什么使用多线程以及带来的问题"><a href="#为什么使用多线程以及带来的问题" class="headerlink" title="为什么使用多线程以及带来的问题"></a>为什么使用多线程以及带来的问题</h4><p>多核时代，使用多线程主要为了利用多核 CPU 的能力，创建多个线程，这些线程可以被映射到底层多个CPU核心上执行，这会提高任务执行的效率。</p><p>并发编程目的就是提高程序执行效率，但这也不是绝对的，它还会带来内存泄漏，死锁，线程不安全等问题。</p><h4 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h4><p>线程在执行过程中会有自己的运行条件和状态（也称上下文），比如程序计数器，栈信息等，当出现如下情况时，线程会从占用 CPU 状态中退出。</p><ul><li>主动让出 CPU，比如调用 sleep(), wait()等</li><li>时间片用完</li><li>调用了阻塞类型的系统终端，比如请求 IO</li><li>被终止或结束运行</li></ul><p>前三种状态都会发生线程切换，线程切换意味着需要保存当前线程的上下文，并加载下一个要占用 CPU 的线程上下文。频繁的上下文切换会导致效率低下。</p><h4 id="什么是死锁？如何避免死锁"><a href="#什么是死锁？如何避免死锁" class="headerlink" title="什么是死锁？如何避免死锁"></a>什么是死锁？如何避免死锁</h4><p>死锁：多个线程被同时阻塞，它们中的一个或多个都在等待某个资源被释放，由于线程被无限期地阻塞，程序不可能正常终止。</p><h4 id="产生死锁的四个条件"><a href="#产生死锁的四个条件" class="headerlink" title="产生死锁的四个条件"></a>产生死锁的四个条件</h4><ol><li>请求并保持，一个进程因请求资源而阻塞时，对已获得的资源保持不放</li><li>不可剥夺，线程已获得的资源在未使用完之前不能被其他线程强行剥夺</li><li>循环等待，若干进程之间形成一种头尾相接的循环等待资源关系。</li><li>互斥，资源任意一个时刻只由一个线程占用</li></ol><h4 id="预防死锁"><a href="#预防死锁" class="headerlink" title="预防死锁"></a>预防死锁</h4><ol><li>破坏请求与保持条件，一次性申请所有资源</li><li>破坏不可剥夺条件，占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放占有的资源</li><li>破坏循环等待条件，按序申请资源，释放资源则反序释放</li></ol><h4 id="避免死锁"><a href="#避免死锁" class="headerlink" title="避免死锁"></a>避免死锁</h4><p>在资源分配时，借助算法（银行家）对资源分配进行计算评估，使其进入安全状态。</p><h4 id="Thread常用方法"><a href="#Thread常用方法" class="headerlink" title="==Thread常用方法=="></a>==Thread常用方法==</h4><h5 id="sleep-方法和-wait-方法"><a href="#sleep-方法和-wait-方法" class="headerlink" title="sleep() 方法和 wait() 方法"></a>sleep() 方法和 wait() 方法</h5><p>两者最大区别是：sleep() 方法没有释放锁，而 wait() 方法释放了锁</p><p>两者都可以暂停线程的执行。</p><p>wait() 通常被用于线程间交互/通信，sleep() 通常被用于暂停执行</p><p>wait() 方法被调用后，需要其他线程调用同一个对象上的 notify() 方法和 notifyAll() 方法。sleep() 方法执行完成后会自动苏醒</p><h5 id="run-方法和-start-方法"><a href="#run-方法和-start-方法" class="headerlink" title="run() 方法和 start() 方法"></a>run() 方法和 start() 方法</h5><p>新建一个 线程，调用 start() 方法，会启动一个线程并使其进入就绪状态，当分配到时间片后就可以开始运行了。而调用run() 方法会把 run() 方法当成 main 线程下一个普通方法执行，并不会在某个线程中执行它。</p><h5 id="yield-方法"><a href="#yield-方法" class="headerlink" title="yield() 方法"></a>yield() 方法</h5><p>调用 yield 会让当前线程从 <strong>Running</strong> 进入 Runnable 就绪状态（仍然有可能被执行）</p><h5 id="join-方法"><a href="#join-方法" class="headerlink" title="join() 方法"></a>join() 方法</h5><p>用于等待某个线程结束。哪个线程内调用join()方法，就等待哪个线程结束，然后再去执行其他线程。</p><p>如在主线程中调用ti.join()，则是主线程等待t1线程结束。</p><h5 id="interrupt-方法"><a href="#interrupt-方法" class="headerlink" title="interrupt() 方法"></a>interrupt() 方法</h5><p>用于打断阻塞(sleep wait join…)的线程。 处于阻塞状态的线程，CPU不会给其分配时间片。</p><p>如果一个线程在在运行中被打断，打断标记会被置为true。</p><p>如果是打断因sleep wait join方法而被阻塞的线程，会将打断标记置为false</p><h4 id="线程通信"><a href="#线程通信" class="headerlink" title="线程通信"></a>线程通信</h4><h5 id="调用-wait-、notify-以及-notifyAll-时需要注意的细节"><a href="#调用-wait-、notify-以及-notifyAll-时需要注意的细节" class="headerlink" title="调用 wait()、notify()以及 notifyAll()时需要注意的细节"></a>调用 wait()、notify()以及 notifyAll()时需要注意的细节</h5><p>使用 wait()、notify()和 notifyAll()时需要先对调用对象加锁。</p><p>调用 wait()方法后，线程状态由 RUNNING 变为 WAITING，并将当前线程放置到对象的等待队列。</p><p>notify()或 notifyAll()方法调用后，等待线程依旧不会从 wait()返回，需要调用notify()或 notifAll()的线程释放锁之后，等待线程才有机会从 wait()返回。</p><p>notify()方法将等待队列中的一个等待线程从等待队列中移到同步队列中，而notifyAll() 方法则是将等待队列中所有的线程全部移到同步队列，被移动的线程状态由 WAITING 变为 BLOCKED。</p><p>从 wait()方法返回的前提是获得了调用对象的锁。</p><h5 id="Thread-join-的使用"><a href="#Thread-join-的使用" class="headerlink" title="Thread.join()的使用"></a>Thread.join()的使用</h5><p>如果一个线程 A 执行了 thread.join()语句，其含义：当前线程 A 等待 thread 线程终止之后才从 thread.join()返回。</p><h4 id="线程的生命周期和状态"><a href="#线程的生命周期和状态" class="headerlink" title="线程的生命周期和状态"></a>线程的生命周期和状态</h4><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20210827192442845.png" alt="image-20210827192442845"></p><h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20211122152313660.png" alt="image-20211122152313660"></p><h4 id="乐观锁-vs-悲观锁"><a href="#乐观锁-vs-悲观锁" class="headerlink" title="乐观锁 vs 悲观锁"></a>乐观锁 vs 悲观锁</h4><p>对于同一个数据的并发操作，悲观锁认为自己在使用数据的时候一定有别的线程来修改数据，因此在获取数据的时候会先加锁，确保数据不会被别的线程修改。Java中，synchronized关键字和Lock的实现类都是悲观锁。</p><p>而乐观锁认为自己在使用数据时不会有别的线程修改数据，所以不会添加锁，只是在更新数据的时候去判断之前有没有别的线程更新了这个数据。如果这个数据没有被更新，当前线程将自己修改的数据成功写入。如果数据已经被其他线程更新，则根据不同的实现方式执行不同的操作（例如报错或者自动重试）。乐观锁在Java中是通过使用无锁编程来实现，最常采用的是CAS算法，Java原子类中的递增操作就通过CAS自旋实现的。</p><ul><li>悲观锁适合写操作多的场景，先加锁可以保证写操作时数据正确。</li><li>乐观锁适合读操作多的场景，不加锁的特点能够使其读操作的性能大幅提升。</li></ul><h4 id="自旋锁-VS-适应性自旋锁"><a href="#自旋锁-VS-适应性自旋锁" class="headerlink" title="自旋锁 VS 适应性自旋锁"></a>自旋锁 VS 适应性自旋锁</h4><p>自旋锁本身是有缺点的，它不能代替阻塞。自旋等待虽然避免了线程切换的开销，但它要占用处理器时间。如果锁被占用的时间很短，自旋等待的效果就会非常好。反之，如果锁被占用的时间很长，那么自旋的线程只会白浪费处理器资源。所以，自旋等待的时间必须要有一定的限度，如果自旋超过了限定次数（默认是10次，可以使用-XX:PreBlockSpin来更改）没有成功获得锁，就应当挂起线程。</p><p>自旋锁的实现原理同样也是CAS，AtomicInteger中调用unsafe进行自增操作的源码中的do-while循环就是一个自旋操作，如果修改数值失败则通过循环来执行自旋，直至修改成功。</p><p>自适应意味着自旋的时间（次数）不再固定，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。如果自旋刚刚获得过锁，虚拟机会认为这次自旋也很可能成功继续等待更长时间，如果自旋很少获得锁，那么直接阻塞线程。</p><h4 id="无锁-VS-偏向锁-VS-轻量级锁-VS-重量级锁"><a href="#无锁-VS-偏向锁-VS-轻量级锁-VS-重量级锁" class="headerlink" title="无锁 VS 偏向锁 VS 轻量级锁 VS 重量级锁"></a>无锁 VS 偏向锁 VS 轻量级锁 VS 重量级锁</h4><p>无锁没有对资源进行锁定，所有的线程都能访问并修改同一个资源，但同时只有一个线程能修改成功。</p><p>偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁，降低获取锁的代价。</p><p>当锁是偏向锁的时候，被另外的线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，从而提高性能。</p><p>当升级为重量级锁时，等待锁的线程都会进入阻塞状态。</p><p>详见 synchronized 锁升级</p><h4 id="公平锁-VS-非公平锁"><a href="#公平锁-VS-非公平锁" class="headerlink" title="公平锁 VS 非公平锁"></a><strong>公平锁 VS 非公平锁</strong></h4><p>公平锁是指多个线程按照申请锁的顺序来获取锁，线程直接进入队列中排队，<strong>队列中的第一个线程</strong>才能获得锁。公平锁的优点是等待锁的线程不会饿死。缺点是整体吞吐效率相对非公平锁要低，等待队列中除第一个线程以外的所有线程都会阻塞，CPU唤醒阻塞线程的开销比非公平锁大。</p><p>非公平锁是多个线程加锁时直接尝试获取锁，获取不到才会到等待队列的队尾等待。但如果此时锁刚好可用，那么这个线程可以无需阻塞直接获取到锁，所以非公平锁有可能出现后申请锁的线程先获取锁的场景。非公平锁的优点是可以减少唤起线程的开销，整体的吞吐效率高，因为线程有几率不阻塞直接获得锁，CPU不必唤醒所有线程。缺点是处于等待队列中的线程可能会饿死，或者等很久才会获得锁。</p><p>ReentrantLock里面有一个内部类Sync，Sync继承AQS（AbstractQueuedSynchronizer），添加锁和释放锁的大部分操作实际上都是在Sync中实现的。它有公平锁FairSync和非公平锁NonfairSync两个子类。ReentrantLock默认使用非公平锁，也可以通过构造器来显示的指定使用公平锁。公平锁与非公平锁的lock()方法唯一的区别就在于公平锁在获取同步状态时多了一个限制条件：hasQueuedPredecessors()。再进入hasQueuedPredecessors()，可以看到该方法主要做一件事情：主要是判断当前线程是否位于同步队列中的第一个。如果是则返回true，否则返回false。</p><p>公平锁就是通过同步队列来实现多个线程按照申请锁的顺序来获取锁，从而实现公平的特性。非公平锁加锁时不考虑排队等待问题，直接尝试获取锁，所以存在后申请却先获得锁的情况。</p><h4 id="可重入锁-VS-非可重入锁"><a href="#可重入锁-VS-非可重入锁" class="headerlink" title="可重入锁 VS 非可重入锁"></a><strong>可重入锁 VS 非可重入锁</strong></h4><p>可重入锁又名递归锁，是指在同一个线程在外层方法获取锁的时候，再进入该线程的内层方法会自动获取锁（前提锁对象得是同一个对象或者class），不会因为之前已经获取过还没释放而阻塞。Java中ReentrantLock和synchronized都是可重入锁，可重入锁的一个优点是可一定程度避免死锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Widget</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123;</span><br><span class="line">        doOthers();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">doOthers</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//do others</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，类中的两个方法都是被内置锁synchronized修饰的，doSomething()方法中调用doOthers()方法。因为内置锁是可重入的，所以同一个线程在调用doOthers()时可以直接获得当前对象的锁，进入doOthers()进行操作。</p><p>如果是一个不可重入锁，那么当前线程在调用doOthers()之前需要将执行doSomething()时获取当前对象的锁释放掉，实际上该对象锁已被当前线程所持有，且无法释放。所以此时会出现死锁。</p><h4 id="独享锁-VS-共享锁"><a href="#独享锁-VS-共享锁" class="headerlink" title="独享锁 VS 共享锁"></a><strong>独享锁 VS 共享锁</strong></h4><p>独享锁也叫排他锁，是指该锁一次只能被一个线程所持有。如果线程T对数据A加上排它锁后，则其他线程不能再对A加任何类型的锁。获得排它锁的线程即能读数据又能修改数据。JDK中的synchronized和JUC中Lock的实现类就是互斥锁。</p><p>共享锁是指该锁可被多个线程所持有。如果线程T对数据A加上共享锁后，则其他线程只能对A再加共享锁，不能加排它锁。获得共享锁的线程只能读数据，不能修改数据</p><p>我们看到ReentrantReadWriteLock有两把锁：ReadLock和WriteLock，由词知意，一个读锁一个写锁，合称“读写锁”。再进一步观察可以发现ReadLock和WriteLock是靠内部类Sync实现的锁。</p><h3 id="synchronized-关键字"><a href="#synchronized-关键字" class="headerlink" title="==synchronized 关键字=="></a>==synchronized 关键字==</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><p><strong>synchronized 解决多个线程访问资源的同步性，它可以保证被修饰的方法或代码块在任意时刻只能有一个线程执行。</strong></p><p>因为监视器锁（monitor）是依赖于底层的操作系统的 <code>Mutex Lock</code> 来实现的，Java 的线程是映射到操作系统的原生线程之上的。如果要挂起或者唤醒一个线程，都需要操作系统帮忙完成，而操作系统实现线程之间的切换时需要从用户态转换到内核态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高。</p><p>庆幸的是在 Java 6 之后 Java 官方对从 JVM 层面对 <code>synchronized</code> 较大优化，所以现在的 <code>synchronized</code> 锁效率也优化得很不错了。JDK1.6 对锁的实现引入了大量的优化，如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销。</p><h4 id="synchronized-关键字使用方式"><a href="#synchronized-关键字使用方式" class="headerlink" title="synchronized 关键字使用方式"></a>synchronized 关键字使用方式</h4><ol><li>修饰实例方法：作用于当前对象实例加锁，进入同步代码前要获得==当前对象实例的锁==</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//业务代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>修饰静态方法：给当前类加锁，会作用于类的所有对象实例，进入同步代码前要获得==当前 class 的锁==。如果线程 A 调用实例对象的非静态 synchronized 方法，线程 B 调用实例对象所在类的静态 synchronized 方法，不会发生互斥现象。线程 A 占用的实例对象的锁，线程 B 占用的时当前类的锁。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//业务代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>修饰代码块：指定加锁对象，对给对象/类加锁</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;</span><br><span class="line">    <span class="comment">// 业务代码</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">synchronized</span>(A<span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//业务代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="构造方法可用-synchronized-关键字修饰么？"><a href="#构造方法可用-synchronized-关键字修饰么？" class="headerlink" title="构造方法可用 synchronized 关键字修饰么？"></a>构造方法可用 synchronized 关键字修饰么？</h4><p>不能，构造方法本身就是线程安全的</p><h4 id="synchronized-底层原理"><a href="#synchronized-底层原理" class="headerlink" title="==synchronized 底层原理=="></a>==synchronized 底层原理==</h4><ol><li><p>修饰语句块的情况（monitorenter、monitorexit）</p><p>使用 <strong>monitorenter</strong> 和 <strong>monitorexit</strong> 指令，同步代码块指令放在二者中间，当执行 monitorenter指令时，线程尝试获取锁（对象监视器 monitor）的持有权。在执行 monitorenter 之后，锁计数器加一，变为1。执行monitorexit指令后，锁计数器减一，变为0，此时可重新获取锁。</p></li><li><p>修饰方法的情况（ACC_SYNCHRONIZED）</p><p><code>synchronized</code> 修饰的方法并没有 <code>monitorenter</code> 指令和 <code>monitorexit</code> 指令，取得代之的确实是 <code>ACC_SYNCHRONIZED</code> 标识，该标识指明了该方法是一个同步方法。JVM 通过该 <code>ACC_SYNCHRONIZED</code> 访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用。两者的本质都是对象监视器锁 monitor 的获取。</p></li></ol><h4 id="JDK1-6-后-synchronized-关键字的优化"><a href="#JDK1-6-后-synchronized-关键字的优化" class="headerlink" title="JDK1.6 后 synchronized 关键字的优化"></a>JDK1.6 后 synchronized 关键字的优化</h4><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20210830155558454.png" alt="image-20210830155558454"></p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20211210160258131.png" alt="image-20211210160258131"></p><p>锁的级别从低到高分别为：无锁、偏向锁、轻量级锁、重量级锁，锁能升级但不能降级。</p><p>左下角图可以看到，当对象状态为偏向锁时， <strong>Mark Word 存储的是偏向的线程ID</strong>；当状态为 轻量级锁时， Mark Word 存储的是指向<strong>线程栈中 Lock Record 的指针</strong>；当状态为重量级锁时， Mark Word 为指向<strong>堆中的monitor对象的指针</strong>。</p><h5 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h5><p>大多数情况下锁不紧不存在多线程竞争，而且总是由同一线程多次获得。偏向锁会偏向第一个访问锁的线程，如果在接下的运行过程中，该锁没有被其他线程访问，则持有偏向锁的线程将永远不会出发同步。</p><p><strong>加锁</strong>：新线程在进入同步块时，尝试将对象头 MarkWord 中 的线程 ID 改为新线程 ID，如果成功，获得偏向锁，如果失败，开始撤销偏向锁并升级为轻量级锁</p><p><strong>撤销</strong>：当其他线程尝试竞争偏向锁时就会撤销锁并升级。偏向锁在升级成轻量级锁时，会暂停拥有偏向锁的线程，重置偏向锁标识，在一个安全点（这个时间点没有字节码运行）停止锁的线程，遍历线程栈，如果存在锁记录，需修复锁记录和 MarkWord 让它变成无锁状态，唤醒被暂停的线程，将当前锁升级为轻量级锁</p><h5 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a><strong>轻量级锁</strong></h5><p>多个线程在不同时间段获取同一把锁，即不存在锁竞争的情况，也就没有线程阻塞。</p><p><strong>加锁</strong>：JVM会为每个线程在当前线程的栈帧中创建⽤于存储锁记录的空间，我们称为 Displaced Mark Word。如果⼀个线程获得锁的时候发现是轻量级锁，会把锁的Mark Word复制到⾃⼰的Displaced Mark Word⾥⾯。然后线程尝试⽤CAS将锁的Mark Word替换为指向锁记录的指针。如果成功，当前 线程获得锁，如果失败，表示Mark Word已经被替换成了其他线程的锁记录，说明 在与其它线程竞争锁，当前线程就尝试使⽤⾃旋来获取锁。 自旋超过一定次数时，这个锁就会升级成重量级锁。</p><p><strong>撤销</strong>：判断对象头中的锁记录指针是否指向当前线程锁记录，并比较Displaced Mark Word 和锁的 MarkWord 是否相等，如果相等直接释放锁，如果失败则说明锁已经升级成了重量级锁。</p><h5 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h5><p>重量级锁依赖于操作系统的互斥量（mutex） 实现的，⽽操作系统中线程间状态的 转换需要相对⽐较⻓的时间，所以重量级锁效率很低，但被阻塞的线程不会消耗CPU.</p><p>每⼀个对象都可以当做⼀个锁，当多个线程同时请求某个对象锁时，对 象锁会设置⼏种状态⽤来区分请求的线程：</p><blockquote><p>Contention List：所有请求锁的线程将被⾸先放置到该竞争队列</p><p>Entry List：Contention List中那些有资格成为候选⼈的线程被移到Entry List</p><p>Wait Set：那些调⽤wait⽅法被阻塞的线程被放置到Wait Set</p><p>OnDeck：任何时刻最多只能有⼀个线程正在竞争锁，该线程称为OnDeck</p><p>Owner：获得锁的线程称为Owner</p><p>!Owner：释放锁的线程 </p></blockquote><p>当⼀个线程尝试获得锁时，如果该锁已经被占⽤，则会将该线程封装成⼀ 个 ObjectWaiter 对象插⼊到Contention List的队列的队⾸，然后调⽤ park 函数挂 起当前线程。 当线程释放锁时，会从Contention List或EntryList中挑选⼀个线程唤醒，被选中的 线程叫做 Heir presumptive 即假定继承⼈，假定继承⼈被唤醒后会尝试获得锁， 但 synchronized 是⾮公平的，所以假定继承⼈不⼀定能获得锁。这是因为对于重 量级锁，线程先⾃旋尝试获得锁，这样做的⽬的是为了减少执⾏操作系统同步操作 带来的开销。如果⾃旋不成功再进⼊等待队列。</p><h5 id="锁升级的流程"><a href="#锁升级的流程" class="headerlink" title="==锁升级的流程=="></a>==锁升级的流程==</h5><p>每个线程在准备获取共享资源时：</p><ol><li>检查 MarkWord 里放的是不是自己的线程 ID，如果是，代表当前线程有这个偏向锁；如果不是，尝试 CAS 更改共享对象 MarkWord 里的线程 ID，成功的话就获得了偏向锁。失败则代表另一个线程在使用这个共享对象，在等到安全点（这个时间点上没有正在执行的字节码）时如果还有竞争，锁升级</li><li>原本持有偏向锁的线程栈中存储共享对象 MarkWord 的拷贝，<strong>原本持有偏向锁的进程获得轻量级锁</strong>（共享对象 MarkWord 中的地址指向这条拷贝的记录），唤醒原来持有偏向锁的线程，从安全点继续执行。想要抢锁的线程也拷贝一个共享对象的 MarkWord，然后就开始 CAS 抢锁（尝试将共享对象 MarkWord 的锁记录指针指向自己的记录），如果经过一定次数的 CAS 还没抢到，证明竞争激烈，锁升级</li><li>将共享对象中的MarkWord 换为重量级锁，挂起当前线程，等待当前有锁的线程执行完成后唤醒自己。</li></ol><table><thead><tr><th>锁</th><th>优点</th><th>缺点</th><th>适用场景</th></tr></thead><tbody><tr><td>偏向锁</td><td>加锁和解锁不需要额外的消耗，和执行非同步方法仅存在纳秒级的差距</td><td>如果线程间存在锁竞争会带来额外的锁撤销的消耗</td><td>适用于只有一个线程访问同步块的场景</td></tr><tr><td>轻量级锁</td><td>竞争的线程不会阻塞，提高程序的响应速度</td><td>如果始终得不到锁，竞争的线程会使用自旋消耗 CPU</td><td>追求响应时间，同步块执行时间非常快</td></tr><tr><td>重量级锁</td><td>线程竞争不会使用自旋，不消耗 CPU</td><td>线程阻塞，响应时间长</td><td>追求吞吐量，同步块执行时间较长</td></tr></tbody></table><h4 id="synchronized-和-ReentrantLock"><a href="#synchronized-和-ReentrantLock" class="headerlink" title="synchronized 和 ReentrantLock"></a>synchronized 和 ReentrantLock</h4><p>两者都是可重入锁，“可重入”指的是自己可以再次获取自己的内部锁。</p><p>synchronized 依赖 JVM 而 ReentrantLock 依赖于 API，ReentrantLock 需要 lock() 和 unlock() 配合 try/finally 语句块来实现。</p><p>ReentrantLock 比 synchronized 增加了一些高级功能</p><ul><li><p>等待可中断：ReentrantLock 提供了一种能够中断等待锁的机制，通过 lock.lockInterruptibly() 来实现，正在等待的线程可以放弃等待，改为处理其他事情</p></li><li><p>实现公平锁：公平锁就是先等待的线程先获得锁，synchronized 只能是非公平的，ReentrantLock 默认为非公平的。</p></li><li><p>可实现选择性通知（锁可以绑定多个条件）：<code>synchronized</code>关键字与<code>wait()</code>和<code>notify()</code>/<code>notifyAll()</code>方法相结合可以实现等待/通知机制。<code>ReentrantLock</code>类当然也可以实现，但是需要借助于<code>Condition</code>接口与<code>newCondition()</code>方法。</p></li></ul><h3 id="volatile-关键字"><a href="#volatile-关键字" class="headerlink" title="volatile 关键字"></a>volatile 关键字</h3><h4 id="JMM（Java-内存模型）"><a href="#JMM（Java-内存模型）" class="headerlink" title="JMM（Java 内存模型）"></a>JMM（Java 内存模型）</h4><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20210902152656544.png" alt="image-20210902152656544"></p><p>在 JDK1.2 之前，Java 内存模型总是从<strong>主存</strong>读取变量，不用处理一致性问题。根据JMM的规定，<strong>线程对共享变量的所有操作都必须在⾃⼰的本地内存中进行，不能直接从主内存中读取</strong>。在现在的 Java 内存模型下，线程可以<strong>把变量保存到本地内存（寄存器）中</strong>，而不是直接在主存中读写，这就造成了主存数据和寄存器数据不一致的情况。</p><p>要解决这个问题，就需要把变量声明为 volatile，指示 JVM，这个变量是共享且不稳定的，每次使用它都到主存中进行读取。volatile 关键字除了防止 JVM 指令重排，还有一个重要的作用就是保证可见性。</p><h4 id="内存可见性"><a href="#内存可见性" class="headerlink" title="内存可见性"></a>内存可见性</h4><p>内存可⻅性，指的是当⼀个线程对 volatile 修饰的变量进⾏写操作时，<strong>JMM会⽴即把该线程对应的本地内存中的共享变量的值刷新到主内 存</strong>；当⼀个线程对 volatile 修饰的变量进⾏读操作时，JMM会把⽴即该线程对应的本地内存置为⽆效，从主内存中读取共享变量的值。 </p><h4 id="禁止重排序"><a href="#禁止重排序" class="headerlink" title="禁止重排序"></a>禁止重排序</h4><p>JVM 通过内存屏障实现限制处理器的重排序。在硬件层面，内存屏障分为两种：读屏障（Load Barrier）和写屏障（Store Barrier）。它有两个作用：</p><ol><li>阻止屏障两侧的指令重排序</li><li>强制把 CPU 写缓冲区/高速缓存中的脏数据写回主内存，或者让缓存中的响应数据失效</li></ol><p>编译器在⽣成字节码时，会在指令序列中插⼊内存屏障来禁⽌特定类型的处理器重排序。编译器选择了⼀个⽐较保守的<strong>JMM</strong>内存屏障插⼊策略，这样可以保证在任何处理器平台，任何程序中都能得到正确的volatile内存语义。</p><p>这个策略是： </p><ul><li><p>在每个volatile写操作前插⼊⼀个StoreStore屏障； </p></li><li><p>在每个volatile写操作后插⼊⼀个StoreLoad屏障； </p></li><li><p>在每个volatile读操作后插⼊⼀个LoadLoad屏障； </p></li><li><p>在每个volatile读操作后再插⼊⼀个LoadStore屏障。 </p></li></ul><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20210902155135199.png" alt="image-20210902155135199"></p><blockquote><p>LoadLoad 屏障：在第二个 Load 操作开始前，保证第一个 Load 的数据读取完</p><p>StoreStore 屏障：在第二个 Store 操作开始前，保证第一个 Store 的写入操作对其他处理器可见</p><p>LoadStore 屏障：在 Store 操作开始前，保证 Load 的数据读取完毕</p><p>StoreLoad 屏障：在 Load 操作开始前，保证 Store 的写入对所有处理器可见的（写后读最浪费时间）</p></blockquote><h4 id="synchronized-和-volatile-的区别"><a href="#synchronized-和-volatile-的区别" class="headerlink" title="==synchronized 和 volatile 的区别=="></a>==synchronized 和 volatile 的区别==</h4><ul><li>volatile 是线程同步的轻量级实现，性能比 synchronized 稍好。volatile 只能用于变量，synchronized 关键字可以修饰方法或代码块</li><li>volatile 可以保证数据的可见性，但不能保证原子性，synchronized 两者都能保证</li><li>volatile 主要解决变量在多个线程之间的可见性，synchronized 解决的是多个线程之间访问资源的同步性</li></ul><h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h3><p>通常，我们创建的变量可以被任意线程修改，如果香实现每个线程又自己的专属本地变量怎么解决呢？ThreadLocal 类主要解决的就是让每个线程绑定自己的值。</p><p>如果你创建了一个 Thread Local 变量，那么访问这个变量的每个线程都会有这个变量的本地副本，这也是 ThreadLocal 变量名的由来，可以使用 get() 和 set() 方法来获取默认值或将其值改为当前线程所存的副本的值，从而避免了线程安全问题。</p><p>副本值存在<strong>每个线程的</strong> ThreadLocalMap 对象中，ThreadLocalMap 存储的键值对，key 为 ThreadLocal 对象，value 为 Object 对象</p><h4 id="ThreadLocal-内存泄漏"><a href="#ThreadLocal-内存泄漏" class="headerlink" title="ThreadLocal 内存泄漏"></a>ThreadLocal 内存泄漏</h4><p>ThreadLocalMap 中使用的 key 为 ThreadLocal 的弱引用，而 value 是强引用。如果 ThreadLocal 没有被外部强引用的情况下，在垃圾回收时，key 会被清除掉，而 value 不会知恶扬就会出现 key 为 null 的 Entry。我们不做任何措施的话，value 永远不会被 GC 回收，这样就会产生内存泄漏。</p><p>ThreadLocalMap 实现中已经考虑了这种情况，在调用 <code>set()</code>、<code>get()</code>、<code>remove()</code> 方法的时候，会清理掉 key 为 null 的记录。使用完 <code>ThreadLocal</code>方法后 最好手动调用<code>remove()</code>方法，手动删除每个线程的 ThreadLocalMap</p><blockquote><p>如果一个对象只具有弱引用，那就类似于<strong>可有可无的生活用品</strong>。弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它 所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。</p><p>弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java 虚拟机就会把这个弱引用加入到与之关联的引用队列中。</p></blockquote><h4 id="ThreadLocal-示例"><a href="#ThreadLocal-示例" class="headerlink" title="ThreadLocal 示例"></a>ThreadLocal 示例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalExample</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// SimpleDateFormat 不是线程安全的，所以每个线程都要有自己独立的副本</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;SimpleDateFormat&gt; formatter = ThreadLocal.withInitial(() -&gt; <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyyMMdd HHmm"</span>));</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ThreadLocalExample obj = <span class="keyword">new</span> ThreadLocalExample();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span> ; i&lt;<span class="number">5</span>; i++)&#123;</span><br><span class="line">            Thread t = <span class="keyword">new</span> Thread(obj, <span class="string">""</span>+i);</span><br><span class="line">            Thread.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">1000</span>));</span><br><span class="line">            t.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Thread Name= "</span>+Thread.currentThread().getName()+<span class="string">" default Formatter = "</span>+formatter.get().toPattern());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">1000</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//formatter pattern is changed here by thread, but it won't reflect to other threads</span></span><br><span class="line">        formatter.set(<span class="keyword">new</span> SimpleDateFormat());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"Thread Name= "</span>+Thread.currentThread().getName()+<span class="string">" formatter = "</span>+formatter.get().toPattern());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输出</span><br><span class="line">Thread Name&#x3D; 0 default Formatter &#x3D; yyyyMMdd HHmm</span><br><span class="line">Thread Name&#x3D; 0 formatter &#x3D; yy-M-d ah:mm</span><br><span class="line">Thread Name&#x3D; 1 default Formatter &#x3D; yyyyMMdd HHmm</span><br><span class="line">Thread Name&#x3D; 1 formatter &#x3D; yy-M-d ah:mm</span><br><span class="line">Thread Name&#x3D; 2 default Formatter &#x3D; yyyyMMdd HHmm</span><br><span class="line">Thread Name&#x3D; 2 formatter &#x3D; yy-M-d ah:mm</span><br><span class="line">Thread Name&#x3D; 3 default Formatter &#x3D; yyyyMMdd HHmm</span><br><span class="line">Thread Name&#x3D; 3 formatter &#x3D; yy-M-d ah:mm</span><br><span class="line">Thread Name&#x3D; 4 default Formatter &#x3D; yyyyMMdd HHmm</span><br><span class="line">Thread Name&#x3D; 4 formatter &#x3D; yy-M-d ah:mm</span><br></pre></td></tr></table></figure><p>从输出中可以看出，Thread-0 已经改变了 formatter 的值，但仍然是 thread-2 默认格式化程序与初始化值相同，其他线程也一样。</p><h4 id="ThreadLocal-原理"><a href="#ThreadLocal-原理" class="headerlink" title="==ThreadLocal 原理=="></a>==ThreadLocal 原理==</h4><p>我们先看 Thread 类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">     <span class="comment">/* ThreadLocal values pertaining to this thread. This map is maintained</span></span><br><span class="line"><span class="comment">     * by the ThreadLocal class. */</span></span><br><span class="line">    ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * InheritableThreadLocal values pertaining to this thread. This map is</span></span><br><span class="line"><span class="comment">     * maintained by the InheritableThreadLocal class.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ThreadLocal.ThreadLocalMap inheritableThreadLocals = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出 ThreadLocal 副本值存储在线程的 ThreadLocal.ThradLocalMap 中，继续看 ThreadLocalMap </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalMap</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * The entries in this hash map extend WeakReference, using</span></span><br><span class="line"><span class="comment">         * its main ref field as the key (which is always a</span></span><br><span class="line"><span class="comment">         * ThreadLocal object).  Note that null keys (i.e. entry.get()</span></span><br><span class="line"><span class="comment">         * == null) mean that the key is no longer referenced, so the</span></span><br><span class="line"><span class="comment">         * entry can be expunged from table.  Such entries are referred to</span></span><br><span class="line"><span class="comment">         * as "stale entries" in the code that follows.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">        <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">        Object value;</span><br><span class="line"></span><br><span class="line">        Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">            <span class="keyword">super</span>(k);</span><br><span class="line">            value = v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ThreadLocal 的 Entry 键值对，key 是 ThradLocal 对象，value 为 Object 对象。</p><p>再看 ThreadLocal 类中的 get() 和 set() 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 ThreadLocal get() 和 set() 方法都是首先通过 Thread.currentThread() 来获取当前对象 t，进而获取线程的 ThreadLocalMap 对象 t.threadlocals，类似hashmap 操作, get(this) 或者 put(this, value)。</p><p>总结：副本值存在每个线程的 ThreadLocalMap 对象中，ThreadLocalMap 存储的键值对，key 为 ThreadLocal 对象，value 为 Object 对象</p><blockquote></blockquote><h3 id="Atomic-原子类"><a href="#Atomic-原子类" class="headerlink" title="Atomic 原子类"></a>Atomic 原子类</h3><p>Atomic 指一个操作是不可中断的。即使是多个线程一起执行时，一个操作一旦开始，就不会被其他线程干扰。简单来说，原子类就是具有原子/原子操作特征的类。</p><p>java.util.concurrent 的原子类都存放在 java.util.concurrent.atomic 下</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20210831141012291.png" alt="image-20210831141012291"></p><h4 id="JUC-包原子类是哪-4-类？"><a href="#JUC-包原子类是哪-4-类？" class="headerlink" title="JUC 包原子类是哪 4 类？"></a>JUC 包原子类是哪 4 类？</h4><ol><li><p>基本类型，使用原子方式更新基本类型。AtomicInteger、AtomicLong、AtomicBoolean</p></li><li><p>数组类型，使用原子的方式更新数组里的某个元素。AtomicIntegerArray、AtomicLongArray、AtomicReferenceArray</p></li><li><p>引用类型</p><ul><li>AtomicReference：引用类型原子类</li><li>AtomicStampedReference：原子更新带有版本号的引用类型。该类将整数值与引用关联起来，可用于解决原子的更新数据和数据的版本号，可以解决使用 CAS 进行原子更新是可能出现的 ABA 问题</li><li>AtomicMarkableReference：原子更新带有标记位的引用类型</li></ul></li><li><p>对象的属性修改器</p><ul><li>AtomicIntegerFieldUpdater：原子更新整形字段的更新器</li><li>AtomicLongFieldUpdater：原子更新长整型的更新器</li><li>AtomicReferenceFieldUpdator：原子更新引用类型字段的更新器</li></ul></li></ol><h4 id="AtomicInteger-的使用"><a href="#AtomicInteger-的使用" class="headerlink" title="AtomicInteger 的使用"></a>AtomicInteger 的使用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> <span class="comment">//获取当前的值</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndSet</span><span class="params">(<span class="keyword">int</span> newValue)</span><span class="comment">//获取当前的值，并设置新的值</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndIncrement</span><span class="params">()</span><span class="comment">//获取当前的值，并自增</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndDecrement</span><span class="params">()</span> <span class="comment">//获取当前的值，并自减</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAdd</span><span class="params">(<span class="keyword">int</span> delta)</span> <span class="comment">//获取当前的值，并加上预期的值</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> <span class="comment">//如果输入的数值等于预期值，则以原子方式将该值设置为输入值（update）</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lazySet</span><span class="params">(<span class="keyword">int</span> newValue)</span><span class="comment">//最终设置为newValue,使用 lazySet 设置之后可能导致其他线程在之后的一小段时间内还是可以读到旧的值。</span></span></span><br></pre></td></tr></table></figure><p>使用 AtomicInteger 后不对方法加锁也是线程安全的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class AtomicIntegerTest &#123;</span><br><span class="line">    private AtomicInteger count &#x3D; new AtomicInteger();</span><br><span class="line">    &#x2F;&#x2F;使用AtomicInteger之后，不需要对该方法加锁，也可以实现线程安全。</span><br><span class="line">    public void increment() &#123;</span><br><span class="line">        count.incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getCount() &#123;</span><br><span class="line">        return count.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="AtomicInteger-类的原理"><a href="#AtomicInteger-类的原理" class="headerlink" title="==AtomicInteger 类的原理=="></a>==AtomicInteger 类的原理==</h4><p>AtomicInteger 部分源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// setup to use Unsafe.compareAndSwapInt for updates（更新操作时提供“比较并替换”的作用）</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> valueOffset;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        valueOffset = unsafe.objectFieldOffset</span><br><span class="line">            (AtomicInteger.class.getDeclaredField("value"));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> Error(ex); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, valueOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AtomicInteger 主要利用 CAS + volatile 和 native 方法来保证原子操作，避免 synchronized 的高开销。这里的 valueOffset 就是 value 在内存中的地址，直接调用 native 方法 compareAndSwapInt 实现 CAS 操作。</p><blockquote><p>CAS的全称为<code>Compare And Swap</code>，直译就是比较交换。是一条CPU的原子指令，其作用是让<code>CPU</code>先进行比较两个值是否相等，然后原子地更新某个位置的值，其实现方式是给予硬件平台的汇编指令，在<code>intel</code>的<code>CPU</code>中，使用的<code>cmpxchg</code>指令，就是说<code>CAS</code>是靠硬件实现的，从而在硬件层面提升效率。</p></blockquote><h4 id="CAS存在的问题"><a href="#CAS存在的问题" class="headerlink" title="CAS存在的问题"></a>CAS存在的问题</h4><ol><li><strong>ABA 问题</strong><br>所谓ABA问题，就是⼀个值原来是A，变成了B，⼜变回了A。这个时候使⽤CAS是 检查不出变化的，但实际上却被更新了两次。部分乐观锁的实现是通过==<strong>版本号</strong>==（version）的方式来解决ABA问题，<strong>乐观锁每次在执行数据的修改操作时，都会带上一个版本号，一旦版本号和数据的版本号一致就可以执行修改操作并对版本号执行+1操作，否则就执行失败</strong>。因为每次操作的版本号都会随之增加，所以不会出现ABA问题，因为版本号只会增加不会减少。JDK的atomic包⾥提供了⼀个类 AtomicStampedReference 类来解决ABA问题。</li><li><strong>循环时间长开销大</strong>。CAS操作如果长时间不成功，会导致其一直自旋，给CPU带来非常大的开销。</li><li><strong>只能保证一个共享变量的原子操作</strong>。对一个共享变量执行操作时，CAS能够保证原子操作，但是对多个共享变量操作时，CAS是无法保证操作的原子性的。</li></ol><h3 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h3><h4 id="原理概览"><a href="#原理概览" class="headerlink" title="原理概览"></a>原理概览</h4><p>*<em>AbstractQueuedSynchronizer *</em> 这个类在 java.util.concurrent.locks 包下面</p><p><strong>AQS 核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制 AQS 是用 CLH 队列锁实现的，即将暂时获取不到锁的线程加入到队列中。</strong></p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20210831162636969.png" alt="image-20210831162636969"></p><p>AQS 使用一个 int 成员变量来表示同步状态，通过内置的 FIFO 队列来完成获取资源线程的排队工作。AQS 使用 CAS 对该同步状态进行原子操作实现对其值的修改。</p><h4 id="AQS-结构"><a href="#AQS-结构" class="headerlink" title="AQS 结构"></a>AQS 结构</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 头结点，你直接把它当做 当前持有锁的线程 可能是最好理解的</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node head;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 阻塞的尾节点，每个新的节点进来，都插入到最后，也就形成了一个链表</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个是最重要的，代表当前锁的状态，0代表没有被占用，大于 0 代表有线程持有当前锁</span></span><br><span class="line"><span class="comment">// 这个值可以大于 1，是因为锁可以重入，每次重入都加上 1</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代表当前持有独占锁的线程，举个最重要的使用例子，因为锁可以重入</span></span><br><span class="line"><span class="comment">// reentrantLock.lock()可以嵌套调用多次，所以每次用这个来判断当前线程是否已经拥有了锁</span></span><br><span class="line"><span class="comment">// if (currentThread == getExclusiveOwnerThread()) &#123;state++&#125;</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Thread exclusiveOwnerThread; <span class="comment">//继承自AbstractOwnableSynchronizer</span></span><br></pre></td></tr></table></figure><p>状态信息通过 protected 类型的 getState，setState，compareAndSetState 进行操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回同步状态的当前值</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> state;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//设置同步状态的值</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(<span class="keyword">int</span> newState)</span> </span>&#123;</span><br><span class="line">    state = newState;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//原子地（CAS操作）将同步状态值设置为给定值update如果当前同步状态的值等于expect（期望值）</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSetState</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="AQS-对资源的共享方式"><a href="#AQS-对资源的共享方式" class="headerlink" title="AQS 对资源的共享方式"></a>AQS 对资源的共享方式</h4><ul><li><strong>Exclusive</strong>（独占）：只有一个线程执行，如 ReentrantLock，又可分为公平锁和非公平锁</li><li><strong>Share</strong>（共享）：多个线程可同时执行，如CountDownLatch，Semaphore、CyclicBarrier、ReadWriteLock</li></ul><p><code>ReentrantReadWriteLock</code> 可以看成是组合式，因为 <code>ReentrantReadWriteLock</code> 也就是读写锁允许多个线程同时对某一资源进行读。</p><p>AQS中关于这两种资源共享模式的定义源码（均在内部类Node中）。我们来看看Node的结构：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 标记⼀个结点（对应的线程）在共享模式下等待</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Node SHARED = <span class="keyword">new</span> Node();</span><br><span class="line">    <span class="comment">// 标记⼀个结点（对应的线程）在独占模式下等待</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Node EXCLUSIVE = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// waitStatus的值，表示该结点（对应的线程）已被取消</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED =  <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// waitStatus的值，表示后继结点（对应的线程）需要被唤醒</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIGNAL    = -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// waitStatus的值，表示该结点（对应的线程）在等待某⼀条件</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONDITION = -<span class="number">2</span>;</span><br><span class="line">    <span class="comment">/*waitStatus的值，表示有资源可⽤，新head结点需要继续唤醒后继结点*/</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PROPAGATE = -<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待状态，取值范围，-3，-2，-1，0，1</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus;</span><br><span class="line">    <span class="keyword">volatile</span> Node prev; <span class="comment">// 前驱结点</span></span><br><span class="line">    <span class="keyword">volatile</span> Node next; <span class="comment">// 后继结点</span></span><br><span class="line">    <span class="keyword">volatile</span> Thread thread; <span class="comment">// 结点对应的线程</span></span><br><span class="line">    Node nextWaiter; <span class="comment">// 等待队列⾥下⼀个等待条件的结点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断共享模式的⽅法</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nextWaiter == SHARED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node(Thread thread, Node mode) &#123;     <span class="comment">// Used by addWaiter</span></span><br><span class="line">        <span class="keyword">this</span>.nextWaiter = mode;</span><br><span class="line">        <span class="keyword">this</span>.thread = thread;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node(Thread thread, <span class="keyword">int</span> waitStatus) &#123; <span class="comment">// Used by Condition</span></span><br><span class="line">        <span class="keyword">this</span>.waitStatus = waitStatus;</span><br><span class="line">        <span class="keyword">this</span>.thread = thread;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="AQS-底层使用了模板方法模式"><a href="#AQS-底层使用了模板方法模式" class="headerlink" title="AQS 底层使用了模板方法模式"></a>AQS 底层使用了模板方法模式</h4><p>同步器的设计是基于模板方法模式的，如果需要自定义同步器一般步骤有：</p><ol><li><p>使用者继承 <code>AbstractQueuedSynchronizer</code> 并重写指定的方法</p></li><li><p>将 AQS 组合在自定义同步组件的实现中，并调用其模板方法，而这些模板方法会调用使用者重写的方法。</p></li></ol><p>自定义同步器时需要重写下面几个 AQS 提供的模板方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">isHeldExclusively()<span class="comment">//该线程是否正在独占资源。只有用到condition才需要去实现它。</span></span><br><span class="line">tryAcquire(<span class="keyword">int</span>)<span class="comment">//独占方式。尝试获取资源，成功则返回true，失败则返回false。</span></span><br><span class="line">tryRelease(<span class="keyword">int</span>)<span class="comment">//独占方式。尝试释放资源，成功则返回true，失败则返回false。</span></span><br><span class="line">tryAcquireShared(<span class="keyword">int</span>)<span class="comment">//共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</span></span><br><span class="line">tryReleaseShared(<span class="keyword">int</span>)<span class="comment">//共享方式。尝试释放资源，成功则返回true，失败则返回false。</span></span><br></pre></td></tr></table></figure><p>一般来说，自定义同步器要么是独占方法，要么是共享方式，他们也只需实现<code>tryAcquire-tryRelease</code>、<code>tryAcquireShared-tryReleaseShared</code>中的一种即可。但 AQS 也支持自定义同步器同时实现独占和共享两种方式，如<code>ReentrantReadWriteLock</code>。</p><h4 id="获取资源"><a href="#获取资源" class="headerlink" title="获取资源"></a>获取资源</h4><p>⾸先调⽤tryAcquire(arg)尝试去获取资源，这个⽅法是在<strong>⼦类</strong>具体实现的。如果成功 AQS 的 waitStauts 值变化args, exclusiveOwnerThread 值为当前线程；如果获取资源失败，就通过addWaiter(Node.EXCLUSIVE)⽅法把这个线程插⼊到等待队列中。其中传⼊的参数代表要插⼊的Node是独占式的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp; <span class="comment">// 尝试独占获取锁</span></span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg) <span class="comment">//获锁失败，将当前线程挂起并放入阻塞队列中</span></span><br><span class="line">       )</span><br><span class="line">        selfInterrupt();<span class="comment">//线程中断</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来看 addWaiter 方法，将一个独占模式节点放进队列末尾</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">    <span class="comment">//尝试把 node 加入到链表最后</span></span><br><span class="line">    Node pred = tail;</span><br><span class="line">    <span class="comment">//阻塞队列不为空时</span></span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="comment">// 用CAS把自己设置为队尾, 如果成功后，tail == node 了，这个节点成为阻塞队列新的尾巴</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            <span class="comment">//设置成功，将自己与之前的队尾相连</span></span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="comment">// 线程入队了，可以返回了</span></span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 到这里说明 pred==null(队列是空的) 或者 CAS失败(有线程在竞争入队)</span></span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node t = tail;</span><br><span class="line">        <span class="comment">//队列为空，初始时 head 和 tail 都是 null</span></span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// Must initialize</span></span><br><span class="line">            <span class="comment">//可能有多个进程同时设置 head，需要 CAS设置head</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                tail = head; <span class="comment">//设置 tail，马上 t 就不是 null 了，许多线程要抢了。</span></span><br><span class="line">            <span class="comment">//注意这里没有返回，下一次循环就要 else 分支了</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//将当前节点加入到队尾，如果 CAS 抢不到就自旋，一直抢，直到成功加入队尾</span></span><br><span class="line">            node.prev = t;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来回到 acquireQueued 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 下面这个方法，参数node，经过addWaiter(Node.EXCLUSIVE)，此时已经进入阻塞队列</span></span><br><span class="line">    <span class="comment">// 注意一下：如果acquireQueued(addWaiter(Node.EXCLUSIVE), arg))返回true的话，</span></span><br><span class="line">    <span class="comment">// 意味着上面这段代码将进入selfInterrupt()，所以正常情况下，下面应该返回false</span></span><br><span class="line">    <span class="comment">// 这个方法非常重要，应该说真正的线程挂起，然后被唤醒后去获取锁，都在这个方法里了</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// 当前节点的前驱节点为 p</span></span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="comment">// p == head 代表当前节点是阻塞队列第一个，可以尝试抢一下锁</span></span><br><span class="line">            <span class="comment">// 这里我们说一下，为什么可以去试试：</span></span><br><span class="line">            <span class="comment">// 首先，它是队头，这个是第一个条件，其次，当前的head有可能是刚刚初始化的node，</span></span><br><span class="line">            <span class="comment">// enq(node) 方法里面有提到，head是延时初始化的，而且new Node()的时候没有设置任何线程</span></span><br><span class="line">            <span class="comment">// 也就是说，当前的head不属于任何一个线程，所以作为队头，可以去试一试，</span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                <span class="comment">//当前节点成为 head</span></span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 到这里，说明上面的if分支没有成功，要么当前node本来就不是队头，</span></span><br><span class="line">            <span class="comment">// 要么就是tryAcquire(arg)没有抢赢别人，继续往下看</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//failed 为 true 代表 tryAcquire 抛异常了</span></span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 刚刚说过，会到这里就是没有抢到锁呗，这个方法说的是："当前线程没有抢到锁，是否需要挂起当前线程？"</span></span><br><span class="line">        <span class="comment">// 第一个参数是前驱节点，第二个参数才是代表当前线程的节点</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ws = pred.waitStatus;</span><br><span class="line">        <span class="comment">//前驱节点 waitStatus == - 1，说明前驱节点状态正常，当前线程需要挂起，直接可以返回true</span></span><br><span class="line">        <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 前驱节点 waitStatus大于0 ，之前说过，大于0 说明前驱节点取消了排队。</span></span><br><span class="line">            <span class="comment">// 这里需要知道这点：进入阻塞队列排队的线程会被挂起，而唤醒的操作是由前驱节点完成的。</span></span><br><span class="line">            <span class="comment">// 所以下面这块代码说的是将当前节点的prev指向waitStatus&lt;=0的节点，</span></span><br><span class="line">            <span class="comment">// 简单说，就是为了找个好爹，因为你还得依赖它来唤醒呢，如果前驱节点取消了排队，</span></span><br><span class="line">            <span class="comment">// 找前驱节点的前驱节点做爹，往前遍历总能找到一个好爹的</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                node.prev = pred = pred.prev;</span><br><span class="line">            &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">            pred.next = node;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 仔细想想，如果进入到这个分支意味着什么</span></span><br><span class="line">            <span class="comment">// 前驱节点的waitStatus不等于-1和1，那也就是只可能是0，-2，-3</span></span><br><span class="line">            <span class="comment">// 在我们前面的源码中，都没有看到有设置waitStatus的，所以每个新的node入队时，waitStatu都是0</span></span><br><span class="line">            <span class="comment">// 正常情况下，前驱节点是之前的 tail，那么它的 waitStatus 应该是 0</span></span><br><span class="line">            <span class="comment">// 用CAS将前驱节点的waitStatus设置为Node.SIGNAL(也就是-1)</span></span><br><span class="line">            compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果这个方法返回 false，那么会在 acquireQueued 方法中的 for 循环再走一遍，这次队尾元素前驱节点 waitStatus 一定为 -1，然后会从第一个分支返回 true</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//阻塞当前线程</span></span><br><span class="line">        LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20210902203746074.png" alt="image-20210902203746074"></p><h4 id="释放资源"><a href="#释放资源" class="headerlink" title="释放资源"></a>释放资源</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="comment">//到这里代表锁已经释放了，接下来如果有后继节点则唤醒后继节点，h.waitStatus &lt; 0 代表有等待的后继节点</span></span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//唤醒一个后面正在等待的节点</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">    <span class="comment">// 如果head节点当前waitStatus&lt;0, 将其修改为0</span></span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    Node s = node.next;</span><br><span class="line">    <span class="comment">//如果阻塞队列第一个节点为空或者该节点取消等待，就队列后面往前找一个正在等待的节点（waitStatus &lt;= 0）</span></span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        s = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//唤醒节点</span></span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h4><p>ReentrantLock 可实现公平锁和非公平锁，默认为非公平锁，除非在构造函数中传入参数 true。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 默认非公平锁</span></span><br><span class="line">    sync = <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Reentrant Lock 是独占锁，需要实现 tryAcquire 方法和 tryRelease 方法。首先看 FairSync 和 NonFariSync 的基类 Sync，它提供了基本实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line"><span class="comment">//子类需要实现 lock 方法</span></span><br><span class="line">       <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//非公平抢锁</span></span><br><span class="line">       <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">           <span class="keyword">int</span> c = getState();</span><br><span class="line">           <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">               <span class="comment">//非公平抢锁，直接开抢，</span></span><br><span class="line">               <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                   setExclusiveOwnerThread(current);</span><br><span class="line">                   <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">               <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">               <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">                   <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">               setState(nextc);</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line"><span class="comment">//释放锁，非公平锁和公平锁都是通过 AQS 的 release调用此方法</span></span><br><span class="line">       <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">           <span class="comment">//当前进程没有占有锁</span></span><br><span class="line">           <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">           <span class="comment">//是否完全释放锁</span></span><br><span class="line">           <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">           <span class="comment">//完全释放锁之后将占有锁的进程设为空</span></span><br><span class="line">           <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">               free = <span class="keyword">true</span>;</span><br><span class="line">               setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           setState(c);</span><br><span class="line">           <span class="keyword">return</span> free;</span><br><span class="line">       &#125;</span><br><span class="line"><span class="comment">//当前线程是否独占锁</span></span><br><span class="line">       <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> getExclusiveOwnerThread() == Thread.currentThread();</span><br><span class="line">       &#125;</span><br><span class="line"><span class="comment">//省略其他方法</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>接下来看 NonFairSync</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//和公平锁相比，这里会直接先进行一次CAS，成功就返回了</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//直接调用父类方法</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再看 FairSync</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="comment">// state == 0 此时此刻没有线程持有锁</span></span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//虽然锁此时可用，但这是公平锁，先看看有没有别人在队列中等待</span></span><br><span class="line">            <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                <span class="comment">//没有其他线程在队列中，就用 CAS 尝试获取锁，如果不成功，锁就是被别人抢了（刚才还没有线程持有锁）</span></span><br><span class="line">                compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                <span class="comment">//标记获取到锁的线程是当前线程</span></span><br><span class="line">                setExclusiveOwnerThread(current);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果当前线程已经获得了锁，代表重入了，这里没有并发问题（自己已经有锁了，想怎么改 state 就怎么改）</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">            <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">            <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">            setState(nextc);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//尝试获锁失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：公平锁和非公平锁只有两处不同：</p><ol><li>非公平锁在调用 lock 后，首先就会调用 CAS 进行一次抢锁，如果这个时候恰巧锁没有被占用，那么直接就获取到锁返回了。</li><li>非公平锁在 CAS 失败后，和公平锁一样都会进入到 tryAcquire 方法，在 tryAcquire 方法中，如果发现锁这个时候被释放了（state == 0），非公平锁会直接 CAS 抢锁，但是公平锁会判断等待队列是否有线程处于等待状态，如果有则不去抢锁，乖乖排到后面。</li></ol><h4 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h4><p>condition 是依赖于 ReentrantLock 的，不管是调用 await 进入等待还是 signal 唤醒，<strong>都必须获取到锁才能进行操作</strong>。每个 ReentrantLock 实例可以通过调用多次 newCondition 方法产生多个 ConditionObject 实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> ConditionObject <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 实例化一个 ConditionObject</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ConditionObject();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们首先来看下我们关注的 Condition 的实现类 <code>AbstractQueuedSynchronizer</code> 类中的 <code>ConditionObject</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConditionObject</span> <span class="keyword">implements</span> <span class="title">Condition</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 条件队列的第一个节点</span></span><br><span class="line">          <span class="comment">// 不要管这里的关键字 transient，是不参与序列化的意思</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">transient</span> Node firstWaiter;</span><br><span class="line">        <span class="comment">// 条件队列的最后一个节点</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">transient</span> Node lastWaiter;</span><br><span class="line">        ......</span><br></pre></td></tr></table></figure><p>在介绍 AQS 的时候，我们有一个<strong>阻塞队列</strong>，用于保存等待获取锁的线程的队列，这里引用一个新概念，叫条件队列，如下图：</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20210904194159096.png" alt="image-20210904194159096"></p><p>前面 Node 结构中 prev 和 next 域用于实现阻塞队列的双向链表，nextWaiter 用于实现条件队列的单向链表。</p><ul><li>条件队列和阻塞队列的节点都是 Node 节点，因为条件队列的节点是需要转移到阻塞队列中的。</li><li>每个 ReentrantLock 实例可以调用 newCondition 方法来生成多个 Condition 实例，这里对应 condition1 和 condition2，注意 ConditionObject 只有两个属性 firstWaiter 和 lastWaiter。</li><li>每个 condition 有一个关联的<strong>条件队列</strong>，如线程 1 调用 <code>condition1.await()</code> 方法即可将当前线程 1 包装成 Node 后加入到条件队列中，然后阻塞在这里，不继续往下执行，条件队列是一个单向链表；</li><li>调用<code>condition1.signal()</code> 触发一次唤醒，此时唤醒的是队头，会将condition1 对应的<strong>条件队列</strong>的 firstWaiter（队头） 移到<strong>阻塞队列的队尾</strong>，等待获取锁，获取锁后 await 方法才能返回，继续往下执行。</li></ul><p>我们先来看 await 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首先，这个方法是可被中断的，不可被中断的是另一个方法 awaitUninterruptibly()</span></span><br><span class="line"><span class="comment">// 这个方法会阻塞，直到调用 signal 方法（指 signal() 和 signalAll()，下同），或被中断</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">//既然方法要响应中断，那么在最开始就判断中断状态</span></span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="comment">//添加到 condition 的条件队列中</span></span><br><span class="line">    Node node = addConditionWaiter();</span><br><span class="line">    <span class="comment">// 释放锁，返回值是释放锁之前的 state 值</span></span><br><span class="line">    <span class="comment">// await() 之前，当前线程是必须持有锁的，这里肯定要释放掉</span></span><br><span class="line">    <span class="keyword">int</span> savedState = fullyRelease(node);</span><br><span class="line">    <span class="keyword">int</span> interruptMode = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 这里退出循环有两种情况，之后再仔细分析</span></span><br><span class="line">    <span class="comment">// 1. isOnSyncQueue(node) 返回 true，即当前 node 已经转移到阻塞队列了</span></span><br><span class="line">    <span class="comment">// 2. checkInterruptWhileWaiting(node) != 0 会到 break，然后退出循环，代表的是线程中断</span></span><br><span class="line">    <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">        <span class="comment">//线程挂起</span></span><br><span class="line">        LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 被唤醒后，将进入阻塞队列，等待获取锁</span></span><br><span class="line">    <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">        interruptMode = REINTERRUPT;</span><br><span class="line">    <span class="keyword">if</span> (node.nextWaiter != <span class="keyword">null</span>) <span class="comment">// clean up if cancelled</span></span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">    <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">        reportInterruptAfterWait(interruptMode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="将节点加入条件队列"><a href="#将节点加入条件队列" class="headerlink" title="将节点加入条件队列"></a>将节点加入条件队列</h5><p>由于调用  await 和 singnal 方法需要手动先获取独占锁，没有锁的线程无法操作条件队列，所以在条件队列里的操作是线程安全的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将当前线程对应的节点入队，插入队尾</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addConditionWaiter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node t = lastWaiter;</span><br><span class="line">    <span class="comment">// 如果条件队列的最后一个节点取消了，将其清除出去</span></span><br><span class="line">    <span class="comment">// 为什么这里把 waitStatus 不等于 Node.CONDITION，就判定为该节点发生了取消排队？</span></span><br><span class="line">    <span class="keyword">if</span> (t != <span class="keyword">null</span> &amp;&amp; t.waitStatus != Node.CONDITION) &#123;</span><br><span class="line">        <span class="comment">// 这个方法会遍历整个条件队列，然后会将已取消的所有节点清除出队列</span></span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">        t = lastWaiter;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// node 在初始化的时候，指定 waitStatus 为 Node.CONDITION</span></span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), Node.CONDITION);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// t 此时是 lastWaiter，队尾</span></span><br><span class="line">    <span class="comment">// 如果队列为空</span></span><br><span class="line">    <span class="keyword">if</span> (t == <span class="keyword">null</span>)</span><br><span class="line">        firstWaiter = node;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        t.nextWaiter = node;</span><br><span class="line">    lastWaiter = node;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这段代码就是将当前线程 Node 插入到条件队列的队尾。 unlinkCancelledWaiters() 方法用于清除队列中已经取消等待的节点。当 await 的时候如果发生了取消操作（这点之后会说），或者是在节点入队的时候，发现最后一个节点是被取消的，会调用一次这个方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 等待队列是一个单向链表，遍历链表将已经取消等待的节点清除出去</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unlinkCancelledWaiters</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 等待队列是一个单向链表，遍历链表将已经取消等待的节点清除出去</span></span><br><span class="line">    Node t = firstWaiter;</span><br><span class="line">    Node trail = <span class="keyword">null</span>; <span class="comment">// trail 指向为 CONDITION 状态的最后一个节点</span></span><br><span class="line">    <span class="keyword">while</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Node next = t.nextWaiter;</span><br><span class="line">        <span class="comment">// 如果节点的状态不是 Node.CONDITION 的话，这个节点就是被取消的</span></span><br><span class="line">        <span class="keyword">if</span> (t.waitStatus != Node.CONDITION) &#123;</span><br><span class="line">            <span class="comment">//把节点 t 从链表上拿下来</span></span><br><span class="line">            t.nextWaiter = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//目前没有 CONDITION 状态的节点，直接将链表头设置为 next</span></span><br><span class="line">            <span class="keyword">if</span> (trail == <span class="keyword">null</span>)</span><br><span class="line">                firstWaiter = next;</span><br><span class="line">            <span class="keyword">else</span><span class="comment">//否则将 t.next 连到 trail 后面</span></span><br><span class="line">                trail.nextWaiter = next;</span><br><span class="line">            <span class="keyword">if</span> (next == <span class="keyword">null</span>)</span><br><span class="line">                lastWaiter = trail;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span><span class="comment">//当前节点状态是 CONDITION，维护 trail，t 后移</span></span><br><span class="line">            trail = t;</span><br><span class="line">        t = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="完全释放独占锁"><a href="#完全释放独占锁" class="headerlink" title="完全释放独占锁"></a>完全释放独占锁</h5><p>在节点入队后，会执行<code>int savedState = fullyRelease(node)</code>这一行，完全释放独占锁，注意是完全释放，ReentrantLock 是可重入的。</p><blockquote><p>考虑一下这里的 savedState。如果在 condition1.await() 之前，假设线程先执行了 2 次 lock() 操作，那么 state 为 2，我们理解为该线程持有 2 把锁，这里 await() 方法必须将 state 设置为 0，然后再进入挂起状态，这样其他线程才能持有锁。当它被唤醒的时候，它需要重新持有 2 把锁，才能继续下去。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首先，我们要先观察到返回值 savedState 代表 release 之前的 state 值</span></span><br><span class="line"><span class="comment">// 对于最简单的操作：先 lock.lock()，然后 condition1.await()。</span></span><br><span class="line"><span class="comment">//         那么 state 经过这个方法由 1 变为 0，锁释放，此方法返回 1</span></span><br><span class="line"><span class="comment">//         相应的，如果 lock 重入了 n 次，savedState == n</span></span><br><span class="line"><span class="comment">// 如果这个方法失败，会将节点设置为"取消"状态，并抛出异常 IllegalMonitorStateException</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">fullyRelease</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> savedState = getState();</span><br><span class="line">        <span class="comment">// 这里使用了当前的 state 作为 release 的参数，也就是完全释放掉锁，将 state 置为 0</span></span><br><span class="line">        <span class="keyword">if</span> (release(savedState)) &#123;</span><br><span class="line">            failed = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">return</span> savedState;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed) <span class="comment">//释放独占锁失败，直接将节点设为 CANCELLED</span></span><br><span class="line">            node.waitStatus = Node.CANCELLED;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>如果一个线程不在持有独占锁的基础上，调用await 方法，它能进入条件队列（但此时条件队列就不是线程安全了，可能导致条件队列节点丢失，某些线程可能永远不能被唤醒），由于它不持有锁，release 方法肯定返回 false，进入异常分支，然后设置节点为 CANCELLED，这个入队的节点会被后面入队的节点清除。</p></blockquote><h5 id="等待进入阻塞队列"><a href="#等待进入阻塞队列" class="headerlink" title="等待进入阻塞队列"></a>等待进入阻塞队列</h5><p>释放掉锁以后，接下来是这段，这边会自旋，<strong>如果发现自己还没到阻塞队列，那么挂起</strong>，等待被转移到阻塞队列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> interruptMode = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 如果不在阻塞队列中，注意了，是阻塞队列</span></span><br><span class="line"><span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">    <span class="comment">// 线程挂起</span></span><br><span class="line">    LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里可以先不用看了，等看到它什么时候被 unpark 再说</span></span><br><span class="line">    <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>isOnSyncQueue(Node node) 用于判断节点是否已经转移到阻塞队列了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在节点入条件队列的时候，初始化时设置了 waitStatus = Node.CONDITION</span></span><br><span class="line"><span class="comment">// 前面我提到，signal 的时候需要将节点从条件队列移到阻塞队列，</span></span><br><span class="line"><span class="comment">// 这个方法就是判断 node 是否已经移动到阻塞队列了</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isOnSyncQueue</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移动过去的时候，node 的 waitStatus 会置为 0，这个之后在说 signal 方法的时候会说到</span></span><br><span class="line">    <span class="comment">// 如果 waitStatus 还是 Node.CONDITION，也就是 -2，那肯定就是还在条件队列中</span></span><br><span class="line">    <span class="comment">// 如果 node 的前驱 prev 指向还是 null，说明肯定没有在 阻塞队列(prev是阻塞队列链表中使用的)</span></span><br><span class="line">    <span class="keyword">if</span> (node.waitStatus == Node.CONDITION || node.prev == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 如果 node 已经有后继节点 next 的时候，那肯定是在阻塞队列了</span></span><br><span class="line">    <span class="keyword">if</span> (node.next != <span class="keyword">null</span>) </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面这个方法从阻塞队列的队尾开始从后往前遍历找，如果找到相等的，说明在阻塞队列，否则就是不在阻塞队列</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可以通过判断 node.prev() != null 来推断出 node 在阻塞队列吗？答案是：不能。</span></span><br><span class="line">    <span class="comment">// 这个可以看上篇 AQS 的入队方法，首先设置的是 node.prev 指向 tail，</span></span><br><span class="line">    <span class="comment">// 然后是 CAS 操作将自己设置为新的 tail，可是这次的 CAS 是可能失败的。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> findNodeFromTail(node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从阻塞队列的队尾往前遍历，如果找到，返回 true</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">findNodeFromTail</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    Node t = tail;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (t == node)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        t = t.prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回到前面的循环，isOnSyncQueue(node) 返回 false 的话，那么进到 <code>LockSupport.park(this);</code> 这里线程挂起。</p><h5 id="signal-唤醒线程，转移到阻塞队列"><a href="#signal-唤醒线程，转移到阻塞队列" class="headerlink" title="signal 唤醒线程，转移到阻塞队列"></a>signal 唤醒线程，转移到阻塞队列</h5><p>这里我们先看唤醒操作，因为刚刚到 <code>LockSupport.park(this);</code> 把线程挂起了，等待唤醒。</p><p>唤醒操作通常由另一个线程来操作，就像生产者-消费者模式中，如果线程因为等待消费而挂起，那么当生产者生产了一个东西后，会调用 signal 唤醒正在等待的线程来消费。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 唤醒等待了最久的线程</span></span><br><span class="line"><span class="comment">// 其实就是，将这个线程对应的 node 从条件队列转移到阻塞队列</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调用 signal 方法的线程必须持有当前的独占锁</span></span><br><span class="line">    <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    Node first = firstWaiter;</span><br><span class="line">    <span class="keyword">if</span> (first != <span class="keyword">null</span>)</span><br><span class="line">        doSignal(first);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从条件队列队头往后遍历，找出第一个需要转移的 node</span></span><br><span class="line"><span class="comment">// 因为前面我们说过，有些线程会取消排队，但是可能还在队列中</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSignal</span><span class="params">(Node first)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">          <span class="comment">// 将 firstWaiter 指向 first 节点后面的第一个，因为 first 节点马上要离开了</span></span><br><span class="line">        <span class="comment">// 如果将 first 移除后，后面没有节点在等待了，那么需要将 lastWaiter 置为 null</span></span><br><span class="line">        <span class="keyword">if</span> ( (firstWaiter = first.nextWaiter) == <span class="keyword">null</span>)</span><br><span class="line">            lastWaiter = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 因为 first 马上要被移到阻塞队列了，和条件队列的链接关系在这里断掉</span></span><br><span class="line">        first.nextWaiter = <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span> (!transferForSignal(first) &amp;&amp;</span><br><span class="line">             (first = firstWaiter) != <span class="keyword">null</span>);</span><br><span class="line">      <span class="comment">// 这里 while 循环，如果 first 转移不成功，那么选择 first 后面的第一个节点进行转移，依此类推</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将节点从条件队列转移到阻塞队列</span></span><br><span class="line"><span class="comment">// true 代表成功转移</span></span><br><span class="line"><span class="comment">// false 代表在 signal 之前，节点已经取消了</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">transferForSignal</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// CAS 如果失败，说明此 node 的 waitStatus 已不是 Node.CONDITION，说明节点已经取消，</span></span><br><span class="line">    <span class="comment">// 既然已经取消，也就不需要转移了，方法返回，转移后面一个节点</span></span><br><span class="line">    <span class="comment">// 否则，将 waitStatus 置为 0</span></span><br><span class="line">    <span class="keyword">if</span> (!compareAndSetWaitStatus(node, Node.CONDITION, <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// enq(node): 自旋进入阻塞队列的队尾</span></span><br><span class="line">    <span class="comment">// 注意，这里的返回值 p 是 node 在阻塞队列的前驱节点</span></span><br><span class="line">    Node p = enq(node);</span><br><span class="line">    <span class="keyword">int</span> ws = p.waitStatus;</span><br><span class="line">    <span class="comment">// ws &gt; 0 说明 node 在阻塞队列中的前驱节点取消了等待锁，直接唤醒 node 对应的线程。唤醒之后会怎么样，后面再解释</span></span><br><span class="line">    <span class="comment">// 如果 ws &lt;= 0, 那么 compareAndSetWaitStatus 将会被调用，上篇介绍的时候说过，节点入队后，需要把前驱节点的状态设为 Node.SIGNAL(-1)</span></span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span> || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))</span><br><span class="line">        <span class="comment">// 如果前驱节点取消或者 CAS 失败，会进到这里唤醒线程，之后的操作看下一节</span></span><br><span class="line">        LockSupport.unpark(node.thread);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正常情况下，<code>ws &gt; 0 || !compareAndSetWaitStatus(p, ws, Node.SIGNAL)</code> 这句中，ws &lt;= 0，而且 <code>compareAndSetWaitStatus(p, ws, Node.SIGNAL)</code> 会返回 true，所以一般也不会进去 if 语句块中唤醒 node 对应的线程。然后这个方法返回 true，也就意味着 signal 方法结束了，节点进入了阻塞队列。</p><p>假设发生了阻塞队列中的前驱节点取消等待，或者 CAS 失败，只要唤醒线程，让其进到下一步即可。</p><h5 id="唤醒后检查中断"><a href="#唤醒后检查中断" class="headerlink" title="唤醒后检查中断"></a>唤醒后检查中断</h5><p>上一步 signal 之后，我们的线程由条件队列转移到了阻塞队列，之后就准备获取锁了。只要重新获取到锁了以后，继续往下执行。</p><p>等线程从挂起中恢复过来，继续往下看</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> interruptMode = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">    <span class="comment">// 线程挂起</span></span><br><span class="line">    LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先解释下 interruptMode。interruptMode 可以取值为 REINTERRUPT（1），THROW_IE（-1），0</p><ul><li>REINTERRUPT： 代表 await 返回的时候，需要重新设置中断状态</li><li>THROW_IE： 代表 await 返回的时候，需要抛出 InterruptedException 异常</li><li>0 ：说明在 await 期间，没有发生中断</li></ul><p>有以下三种情况会让 LockSupport.park(this); 这句返回继续往下执行：</p><ol><li>常规路径。signal -&gt; 转移节点到阻塞队列 -&gt; 获取了锁（unpark）</li><li>线程中断。在 park 的时候，另外一个线程对这个线程进行了中断</li><li>signal 的时候我们说过，转移以后的前驱节点取消了，或者对前驱节点的CAS操作失败了</li><li>假唤醒。这个也是存在的，和 Object.wait() 类似，都有这个问题</li></ol><p>线程唤醒后第一步是调用 checkInterruptWhileWaiting(node) 这个方法，此方法用于判断是否在线程挂起期间发生了中断，如果发生了中断，是 signal 调用之前中断的，还是 signal 之后发生的中断。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 如果在 signal 之前已经中断，返回 THROW_IE</span></span><br><span class="line"><span class="comment">// 2. 如果是 signal 之后中断，返回 REINTERRUPT</span></span><br><span class="line"><span class="comment">// 3. 没有发生中断，返回 0</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">checkInterruptWhileWaiting</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted() ?</span><br><span class="line">        (transferAfterCancelledWait(node) ? THROW_IE : REINTERRUPT) :</span><br><span class="line">        <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Thread.interrupted()：如果当前线程已经处于中断状态，那么该方法返回 true，同时将中断状态重置为 false，所以，才有后续的 <code>重新中断（REINTERRUPT）</code> 的使用。</p></blockquote><p>看看怎么判断是 signal 之前还是之后发生的中断：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只有线程处于中断状态，才会调用此方法</span></span><br><span class="line"><span class="comment">// 如果需要的话，将这个已经取消等待的节点转移到阻塞队列</span></span><br><span class="line"><span class="comment">// 返回 true：如果此线程在 signal 之前被取消，</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">transferAfterCancelledWait</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 用 CAS 将节点状态设置为 0 </span></span><br><span class="line">    <span class="comment">// 如果这步 CAS 成功，说明是 signal 方法之前发生的中断，因为如果 signal 先发生的话，signal 中会将 waitStatus 设置为 0</span></span><br><span class="line">    <span class="keyword">if</span> (compareAndSetWaitStatus(node, Node.CONDITION, <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="comment">// 将节点放入阻塞队列</span></span><br><span class="line">        <span class="comment">// 这里我们看到，即使中断了，依然会转移到阻塞队列</span></span><br><span class="line">        enq(node);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 到这里是因为 CAS 失败，肯定是因为 signal 方法已经将 waitStatus 设置为了 0</span></span><br><span class="line">    <span class="comment">// signal 方法会将节点转移到阻塞队列，但是可能还没完成，这边自旋等待其完成</span></span><br><span class="line">    <span class="comment">// 当然，这种事情还是比较少的吧：signal 调用之后，没完成转移之前，发生了中断</span></span><br><span class="line">    <span class="keyword">while</span> (!isOnSyncQueue(node))</span><br><span class="line">        Thread.yield();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里再说一遍，即使发生了中断，节点依然会转移到阻塞队列。</p></blockquote><p>到这里，大家应该都知道这个 while 循环怎么退出了吧。要么中断，要么转移成功。</p><p>这里描绘了一个场景，本来有个线程，它是排在条件队列的后面的，但是因为它被中断了，那么它会被唤醒，然后它发现自己不是被 signal 的那个，但是它会自己主动去进入到阻塞队列。</p><h5 id="获取独占锁"><a href="#获取独占锁" class="headerlink" title="获取独占锁"></a>获取独占锁</h5><p>while 循环出来以后，下面是这段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">    interruptMode = REINTERRUPT;</span><br></pre></td></tr></table></figure><p>由于 while 出来后，我们确定节点已经进入了阻塞队列，准备获取锁。</p><p>这里的 acquireQueued(node, savedState) 的第一个参数 node 之前已经经过 enq(node) 进入了队列，参数 savedState 是之前释放锁前的 state，这个方法返回的时候，代表当前线程获取了锁，而且 state == savedState了。</p><p>注意，前面我们说过，不管有没有发生中断，都会进入到阻塞队列，而 acquireQueued(node, savedState) 的返回值就是代表线程是否被中断。如果返回 true，说明被中断了，而且 interruptMode != THROW_IE，说明在 signal 之前就发生中断了，这里将 interruptMode 设置为 REINTERRUPT，用于待会重新中断。</p><p>继续往下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (node.nextWaiter != <span class="keyword">null</span>) <span class="comment">// clean up if cancelled</span></span><br><span class="line">    unlinkCancelledWaiters();</span><br><span class="line"><span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">    reportInterruptAfterWait(interruptMode);</span><br></pre></td></tr></table></figure><p>本着一丝不苟的精神，这边说说 <code>node.nextWaiter != null</code> 怎么满足。我前面也说了 signal 的时候会将节点转移到阻塞队列，有一步是 node.nextWaiter = null，将断开节点和条件队列的联系。</p><p>可是，<code>在判断发生中断的情况下，是 signal 之前还是之后发生的？</code> 这部分的时候，我也介绍了，如果 signal 之前就中断了，也需要将节点进行转移到阻塞队列，这部分转移的时候，是没有设置 node.nextWaiter = null 的。</p><p>之前我们说过，如果有节点取消，也会调用 unlinkCancelledWaiters 这个方法，就是这里了。</p><h5 id="处理中断状态"><a href="#处理中断状态" class="headerlink" title="处理中断状态"></a>处理中断状态</h5><p>到这里，我们终于可以好好说下这个 interruptMode 干嘛用了。</p><ul><li>0：什么都不做，没有被中断过；</li><li>THROW_IE：await 方法抛出 InterruptedException 异常，因为它代表在 await() 期间发生了中断；</li><li>REINTERRUPT：重新中断当前线程，因为它代表 await() 期间没有被中断，而是 signal() 以后发生的中断</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reportInterruptAfterWait</span><span class="params">(<span class="keyword">int</span> interruptMode)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (interruptMode == THROW_IE)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (interruptMode == REINTERRUPT)</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="带超时机制的-await"><a href="#带超时机制的-await" class="headerlink" title="* 带超时机制的 await"></a>* 带超时机制的 await</h5><p>经过前面的 7 步，整个 ConditionObject 类基本上都分析完了，接下来简单分析下带超时机制的 await 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">long</span> <span class="title">awaitNanos</span><span class="params">(<span class="keyword">long</span> nanosTimeout)</span> </span></span><br><span class="line"><span class="function">                  <span class="keyword">throws</span> InterruptedException</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">awaitUntil</span><span class="params">(Date deadline)</span></span></span><br><span class="line"><span class="function">                <span class="keyword">throws</span> InterruptedException</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">await</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">                <span class="keyword">throws</span> InterruptedException</span></span><br></pre></td></tr></table></figure><p>这三个方法都差不多，我们就挑一个出来看看吧：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">await</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 等待这么多纳秒</span></span><br><span class="line">    <span class="keyword">long</span> nanosTimeout = unit.toNanos(time);</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    Node node = addConditionWaiter();</span><br><span class="line">    <span class="keyword">int</span> savedState = fullyRelease(node);</span><br><span class="line">    <span class="comment">// 当前时间 + 等待时长 = 过期时间</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> deadline = System.nanoTime() + nanosTimeout;</span><br><span class="line">    <span class="comment">// 用于返回 await 是否超时</span></span><br><span class="line">    <span class="keyword">boolean</span> timedout = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">int</span> interruptMode = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">        <span class="comment">// 时间到啦</span></span><br><span class="line">        <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">            <span class="comment">// 这里因为要 break 取消等待了。取消等待的话一定要调用 transferAfterCancelledWait(node) 这个方法</span></span><br><span class="line">            <span class="comment">// 如果这个方法返回 true，在这个方法内，将节点转移到阻塞队列成功</span></span><br><span class="line">            <span class="comment">// 返回 false 的话，说明 signal 已经发生，signal 方法将节点转移了。也就是说没有超时嘛</span></span><br><span class="line">            timedout = transferAfterCancelledWait(node);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// spinForTimeoutThreshold 的值是 1000 纳秒，也就是 1 毫秒</span></span><br><span class="line">        <span class="comment">// 也就是说，如果不到 1 毫秒了，那就不要选择 parkNanos 了，自旋的性能反而更好</span></span><br><span class="line">        <span class="keyword">if</span> (nanosTimeout &gt;= spinForTimeoutThreshold)</span><br><span class="line">            LockSupport.parkNanos(<span class="keyword">this</span>, nanosTimeout);</span><br><span class="line">        <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 得到剩余时间</span></span><br><span class="line">        nanosTimeout = deadline - System.nanoTime();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">        interruptMode = REINTERRUPT;</span><br><span class="line">    <span class="keyword">if</span> (node.nextWaiter != <span class="keyword">null</span>)</span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">    <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">        reportInterruptAfterWait(interruptMode);</span><br><span class="line">    <span class="keyword">return</span> !timedout;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>超时的思路还是很简单的，不带超时参数的 await 是 park，然后等待别人唤醒。而现在就是调用 parkNanos 方法来休眠指定的时间，醒来后判断是否 signal 调用了，调用了就是没有超时，否则就是超时了。超时的话，自己来进行转移到阻塞队列，然后抢锁。</p><h5 id="不抛出-InterruptedException-的-await"><a href="#不抛出-InterruptedException-的-await" class="headerlink" title="* 不抛出 InterruptedException 的 await"></a>* 不抛出 InterruptedException 的 await</h5><p>关于 Condition 最后一小节了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">awaitUninterruptibly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node node = addConditionWaiter();</span><br><span class="line">    <span class="keyword">int</span> savedState = fullyRelease(node);</span><br><span class="line">    <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">        LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">            interrupted = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (acquireQueued(node, savedState) || interrupted)</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="AQS-独占锁的取消排队"><a href="#AQS-独占锁的取消排队" class="headerlink" title="AQS 独占锁的取消排队"></a>AQS 独占锁的取消排队</h4><p>接下来，我想说说怎么取消对锁的竞争？</p><p>上篇文章提到过，最重要的方法是这个，我们要在这里面找答案：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，到这个方法的时候，节点一定是入队成功的。</p><p>我把 parkAndCheckInterrupt() 代码贴过来：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这两段代码联系起来看，是不是就清楚了。</p><p>如果我们要取消一个线程的排队，我们需要在另外一个线程中对其进行中断。比如某线程调用 lock() 老久不返回，我想中断它。一旦对其进行中断，此线程会从 <code>LockSupport.park(this);</code> 中唤醒，然后 <code>Thread.interrupted();</code> 返回 true。</p><p>我们发现一个问题，即使是中断唤醒了这个线程，也就只是设置了 <code>interrupted = true</code> 然后继续下一次循环。而且，由于 <code>Thread.interrupted();</code>  会清除中断状态，第二次进 parkAndCheckInterrupt 的时候，返回会是 false。</p><p>所以，我们要看到，在这个方法中，interrupted 只是用来记录是否发生了中断，然后用于方法返回值，其他没有做任何相关事情。</p><p>所以，我们看外层方法怎么处理 acquireQueued 返回 false 的情况。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selfInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread.currentThread().interrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以说，lock() 方法处理中断的方法就是，你中断归中断，我抢锁还是照样抢锁，几乎没关系，只是我抢到锁了以后，设置线程的中断状态而已，也不抛出任何异常出来。调用者获取锁后，可以去检查是否发生过中断，也可以不理会。</p><p>我们来看 ReentrantLock 的另一个 lock 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    sync.acquireInterruptibly(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法上多了个 <code>throws InterruptedException</code> ，经过前面那么多知识的铺垫，这里我就不再啰里啰嗦了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg))</span><br><span class="line">        doAcquireInterruptibly(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续往里：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.EXCLUSIVE);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                <span class="comment">// 就是这里了，一旦异常，马上结束这个方法，抛出异常。</span></span><br><span class="line">                <span class="comment">// 这里不再只是标记这个方法的返回值代表中断状态</span></span><br><span class="line">                <span class="comment">// 而是直接抛出异常，而且外层也不捕获，一直往外抛到 lockInterruptibly</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 如果通过 InterruptedException 异常出去，那么 failed 就是 true 了</span></span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>既然到这里了，顺便说说 cancelAcquire 这个方法吧：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cancelAcquire</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Ignore if node doesn't exist</span></span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    node.thread = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// Skip cancelled predecessors</span></span><br><span class="line">    <span class="comment">// 找一个合适的前驱。其实就是将它前面的队列中已经取消的节点都”请出去“</span></span><br><span class="line">    Node pred = node.prev;</span><br><span class="line">    <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>)</span><br><span class="line">        node.prev = pred = pred.prev;</span><br><span class="line">    <span class="comment">// predNext is the apparent node to unsplice. CASes below will</span></span><br><span class="line">    <span class="comment">// fail if not, in which case, we lost race vs another cancel</span></span><br><span class="line">    <span class="comment">// or signal, so no further action is necessary.</span></span><br><span class="line">    Node predNext = pred.next;</span><br><span class="line">    <span class="comment">// Can use unconditional write instead of CAS here.</span></span><br><span class="line">    <span class="comment">// After this atomic step, other Nodes can skip past us.</span></span><br><span class="line">    <span class="comment">// Before, we are free of interference from other threads.</span></span><br><span class="line">    node.waitStatus = Node.CANCELLED;</span><br><span class="line">    <span class="comment">// If we are the tail, remove ourselves.</span></span><br><span class="line">    <span class="keyword">if</span> (node == tail &amp;&amp; compareAndSetTail(node, pred)) &#123;</span><br><span class="line">        compareAndSetNext(pred, predNext, <span class="keyword">null</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// If successor needs signal, try to set pred's next-link</span></span><br><span class="line">        <span class="comment">// so it will get one. Otherwise wake it up to propagate.</span></span><br><span class="line">        <span class="keyword">int</span> ws;</span><br><span class="line">        <span class="keyword">if</span> (pred != head &amp;&amp;</span><br><span class="line">            ((ws = pred.waitStatus) == Node.SIGNAL ||</span><br><span class="line">             (ws &lt;= <span class="number">0</span> &amp;&amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &amp;&amp;</span><br><span class="line">            pred.thread != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Node next = node.next;</span><br><span class="line">            <span class="keyword">if</span> (next != <span class="keyword">null</span> &amp;&amp; next.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                compareAndSetNext(pred, predNext, next);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            unparkSuccessor(node);</span><br><span class="line">        &#125;</span><br><span class="line">        node.next = node; <span class="comment">// help GC</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实这个方法没什么好说的，一行行看下去就是了，节点取消，只要把 waitStatus 设置为 Node.CANCELLED，会有非常多的情况被从阻塞队列中请出去，主动或被动。</p><h4 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h4><p>CountDownLatch 这个类是比较典型的 AQS 的共享模式的使用，这是一个高频使用的类。latch 的中文意思是<strong>门栓、栅栏</strong>，具体怎么解释我就不废话了，大家随意，看两个例子就知道在哪里用、怎么用了。</p><h5 id="使用例子"><a href="#使用例子" class="headerlink" title="使用例子"></a>使用例子</h5><p>我们看下 Doug Lea 在 java doc 中给出的例子，这个例子非常实用，我经常会写到这个代码。</p><p>假设我们有 N ( N &gt; 0 ) 个任务，那么我们会用 N 来初始化一个 CountDownLatch，然后将这个 latch 的引用传递到各个线程中，在每个线程完成了任务后，调用 latch.countDown() 代表完成了一个任务。</p><p>调用 latch.await() 的方法的线程会阻塞，直到所有的任务完成。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Driver2</span> </span>&#123; <span class="comment">// ...</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        CountDownLatch doneSignal = <span class="keyword">new</span> CountDownLatch(N);</span><br><span class="line">        Executor e = Executors.newFixedThreadPool(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建 N 个任务，提交给线程池来执行</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) <span class="comment">// create and start threads</span></span><br><span class="line">            e.execute(<span class="keyword">new</span> WorkerRunnable(doneSignal, i));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等待所有的任务完成，这个方法才会返回</span></span><br><span class="line">        doneSignal.await();           <span class="comment">// wait for all to finish</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WorkerRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CountDownLatch doneSignal;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    WorkerRunnable(CountDownLatch doneSignal, <span class="keyword">int</span> i) &#123;</span><br><span class="line">        <span class="keyword">this</span>.doneSignal = doneSignal;</span><br><span class="line">        <span class="keyword">this</span>.i = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            doWork(i);</span><br><span class="line">            <span class="comment">// 这个线程的任务完成了，调用 countDown 方法</span></span><br><span class="line">            doneSignal.countDown();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">        &#125; <span class="comment">// return;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doWork</span><span class="params">()</span> </span>&#123; ...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以说 CountDownLatch 非常实用，我们常常会将一个比较大的任务进行拆分，然后开启多个线程来执行，等所有线程都执行完了以后，再往下执行其他操作。这里例子中，<strong>只有 main 线程调用了 await 方法</strong>。</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20210905143440305.png" alt="image-20210905143440305"></p><p>如果始终只有一个线程调用 await 方法等待任务完成，那么 CountDownLatch 就会简单很多，所以之后的源码分析读者一定要在脑海中构建出这么一个场景：有 m 个线程是做任务的，有 n 个线程在某个栅栏上等待这 m 个线程做完任务，直到所有 m 个任务完成后，n 个线程同时通过栅栏。</p><h5 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h5><p>构造方法，需要传入一个不小于 0 的整数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CountDownLatch</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (count &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"count &lt; 0"</span>);</span><br><span class="line">    <span class="keyword">this</span>.sync = <span class="keyword">new</span> Sync(count);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 老套路了，内部封装一个 Sync 类继承自 AQS</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">    Sync(<span class="keyword">int</span> count) &#123;</span><br><span class="line">        <span class="comment">// 这样就 state == count 了</span></span><br><span class="line">        setState(count);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>代码都是套路，先分析套路：AQS 里面的 state 是一个整数值，这边用一个 int count 参数其实初始化就是设置了这个值，所有调用了 await 方法的等待线程会挂起，然后有其他一些线程会做 state = state - 1 操作，当 state 减到 0 的同时，那个将 state 减为 0 的线程会负责唤醒 所有调用了 await 方法的线程。都是套路啊，只是 Doug Lea 的套路很深，代码很巧妙，不然我们也没有要分析源码的必要。</p></blockquote><p>对于 CountDownLatch，我们仅仅需要关心两个方法，一个是 countDown() 方法，另一个是 await() 方法。</p><p>countDown() 方法每次调用都会将 state 减 1，直到 state 的值为 0；而 await 是一个阻塞方法，当 state 减为 0 的时候，await 方法才会返回。await 可以被多个线程调用，读者这个时候脑子里要有个图：所有调用了 await 方法的线程阻塞在 AQS 的阻塞队列中，等待条件满足（state == 0），将线程从队列中一个个唤醒过来。</p><p>我们用以下程序来分析源码，t1 和 t2 负责调用 countDown() 方法，t3 和 t4 调用 await 方法阻塞：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException ignore) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 休息 5 秒后(模拟线程工作了 5 秒)，调用 countDown()</span></span><br><span class="line">                latch.countDown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"t1"</span>);</span><br><span class="line"></span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException ignore) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 休息 10 秒后(模拟线程工作了 10 秒)，调用 countDown()</span></span><br><span class="line">                latch.countDown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"t2"</span>);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line">        Thread t3 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 阻塞，等待 state 减为 0</span></span><br><span class="line">                    latch.await();</span><br><span class="line">                    System.out.println(<span class="string">"线程 t3 从 await 中返回了"</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"线程 t3 await 被中断"</span>);</span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"t3"</span>);</span><br><span class="line">        Thread t4 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 阻塞，等待 state 减为 0</span></span><br><span class="line">                    latch.await();</span><br><span class="line">                    System.out.println(<span class="string">"线程 t4 从 await 中返回了"</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"线程 t4 await 被中断"</span>);</span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"t4"</span>);</span><br><span class="line"></span><br><span class="line">        t3.start();</span><br><span class="line">        t4.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述程序，大概在过了 10 秒左右的时候，会输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">线程 t3 从 await 中返回了</span><br><span class="line">线程 t4 从 await 中返回了</span><br></pre></td></tr></table></figure><blockquote><p>这两条输出，顺序不是绝对的</p><p>后面的分析，我们假设 t3 先进入阻塞队列</p></blockquote><p>接下来，我们按照流程一步一步走：先 await 等待，然后被唤醒，await 方法返回。</p><p>首先，我们来看 await() 方法，它代表线程阻塞，等待 state 的值减为 0。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 这也是老套路了，我在第二篇的中断那一节说过了</span></span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// t3 和 t4 调用 await 的时候，state 都大于 0（state 此时为 2）。</span></span><br><span class="line">    <span class="comment">// 也就是说，这个 if 返回 true，然后往里看</span></span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        doAcquireSharedInterruptibly(arg);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 只有当 state == 0 的时候，这个方法才会返回 1</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (getState() == <span class="number">0</span>) ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从方法名我们就可以看出，这个方法是获取共享锁，并且此方法是可中断的（中断的时候抛出 InterruptedException 退出这个方法）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 入队</span></span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                <span class="comment">// 同上，只要 state 不等于 0，那么这个方法返回 -1</span></span><br><span class="line">                <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 2</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来仔细分析这个方法，线程 t3 经过第 1 步 addWaiter 入队以后，我们应该可以得到这个：</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/2.png" alt="2"></p><p>由于 tryAcquireShared 这个方法会返回 -1，所以 if (r &gt;= 0) 这个分支不会进去。到 shouldParkAfterFailedAcquire 的时候，t3 将 head 的 waitStatus 值设置为 -1，如下：</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/3.png" alt="3"></p><p>然后进入到 parkAndCheckInterrupt 的时候，t3 挂起。</p><p>我们再分析 t4 入队，t4 会将前驱节点 t3 所在节点的 waitStatus 设置为 -1，t4 入队后，应该是这样的：</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/4.png" alt="4"></p><p>然后，t4 也挂起。接下来，t3 和 t4 就等待唤醒了。</p><p>接下来，我们来看唤醒的流程。为了让下面的示意图更丰富些，我们假设用 10 初始化 CountDownLatch。</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/1.png" alt="1"></p><p>当然，我们的例子中，其实没有 10 个线程，只有 2 个线程 t1 和 t2，只是为了让图好看些罢了。</p><p>我们再一步步看具体的流程。首先，我们看 countDown() 方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countDown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 只有当 state 减为 0 的时候，tryReleaseShared 才返回 true</span></span><br><span class="line">    <span class="comment">// 否则只是简单的 state = state - 1 那么 countDown() 方法就结束了</span></span><br><span class="line">    <span class="comment">//    将 state 减到 0 的那个操作才是最复杂的，继续往下吧</span></span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        <span class="comment">// 唤醒 await 的线程</span></span><br><span class="line">        doReleaseShared();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这个方法很简单，用自旋的方法实现 state 减 1</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> nextc = c-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">            <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>countDown 方法就是每次调用都将 state 值减 1，如果 state 减到 0 了，那么就调用下面的方法进行唤醒阻塞队列中的线程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用这个方法的时候，state == 0</span></span><br><span class="line"><span class="comment">// 这个方法先不要看所有的代码，按照思路往下到我写注释的地方，我们先跑通一个流程，其他的之后还会仔细分析</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">            <span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line">            <span class="comment">// t3 入队的时候，已经将头节点的 waitStatus 设置为 Node.SIGNAL（-1） 了</span></span><br><span class="line">            <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                <span class="comment">// 将 head 的 waitStatue 设置为 0</span></span><br><span class="line">                <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                    <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></span><br><span class="line">                <span class="comment">// 就是这里，唤醒 head 的后继节点，也就是阻塞队列中的第一个节点</span></span><br><span class="line">                <span class="comment">// 在这里，也就是唤醒 t3</span></span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                     !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE)) <span class="comment">// todo</span></span><br><span class="line">                <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一旦 t3 被唤醒后，我们继续回到 await 的这段代码，parkAndCheckInterrupt 返回，我们先不考虑中断的情况：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    setHeadAndPropagate(node, r); <span class="comment">// 2. 这里是下一步</span></span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                <span class="comment">// 1. 唤醒后这个方法返回</span></span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，t3 会进到 setHeadAndPropagate(node, r) 这个方法，先把 head 给占了，然后唤醒队列中其他的线程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHeadAndPropagate</span><span class="params">(Node node, <span class="keyword">int</span> propagate)</span> </span>&#123;</span><br><span class="line">    Node h = head; <span class="comment">// Record old head for check below</span></span><br><span class="line">    setHead(node);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面说的是，唤醒当前 node 之后的节点，即 t3 已经醒了，马上唤醒 t4</span></span><br><span class="line">    <span class="comment">// 类似的，如果 t4 后面还有 t5，那么 t4 醒了以后，马上将 t5 给唤醒了</span></span><br><span class="line">    <span class="keyword">if</span> (propagate &gt; <span class="number">0</span> || h == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span> ||</span><br><span class="line">        (h = head) == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        Node s = node.next;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.isShared())</span><br><span class="line">            <span class="comment">// 又是这个方法，只是现在的 head 已经不是原来的空节点了，是 t3 的节点了</span></span><br><span class="line">            doReleaseShared();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>又回到这个方法了，那么接下来，我们好好分析 doReleaseShared 这个方法，我们根据流程，头节点 head 此时是 t3 节点了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用这个方法的时候，state == 0</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="comment">// 1. h == null: 说明阻塞队列为空</span></span><br><span class="line">        <span class="comment">// 2. h == tail: 说明头结点可能是刚刚初始化的头节点，</span></span><br><span class="line">        <span class="comment">//   或者是普通线程节点，但是此节点既然是头节点了，那么代表已经被唤醒了，阻塞队列没有其他节点了</span></span><br><span class="line">        <span class="comment">// 所以这两种情况不需要进行唤醒后继节点</span></span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">            <span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line">            <span class="comment">// t4 将头节点(此时是 t3)的 waitStatus 设置为 Node.SIGNAL（-1） 了</span></span><br><span class="line">            <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                <span class="comment">// 这里 CAS 失败的场景请看下面的解读</span></span><br><span class="line">                <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                    <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></span><br><span class="line">                <span class="comment">// 就是这里，唤醒 head 的后继节点，也就是阻塞队列中的第一个节点</span></span><br><span class="line">                <span class="comment">// 在这里，也就是唤醒 t4</span></span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                     <span class="comment">// 这个 CAS 失败的场景是：执行到这里的时候，刚好有一个节点入队，入队会将这个 ws 设置为 -1</span></span><br><span class="line">                     !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果到这里的时候，前面唤醒的线程已经占领了 head，那么再循环</span></span><br><span class="line">        <span class="comment">// 否则，就是 head 没变，那么退出循环，</span></span><br><span class="line">        <span class="comment">// 退出循环是不是意味着阻塞队列中的其他节点就不唤醒了？当然不是，唤醒的线程之后还是会调用这个方法的</span></span><br><span class="line">        <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们分析下最后一个 if 语句，然后才能解释第一个 CAS 为什么可能会失败：</p><ol><li>h == head：说明头节点还没有被刚刚用 unparkSuccessor 唤醒的线程（这里可以理解为 t4）占有，此时 break 退出循环。</li><li>h != head：头节点被刚刚唤醒的线程（这里可以理解为 t4）占有，那么这里重新进入下一轮循环，唤醒下一个节点（这里是 t4 ）。我们知道，等到 t4 被唤醒后，其实是会主动唤醒 t5、t6、t7…，那为什么这里要进行下一个循环来唤醒 t5 呢？我觉得是出于吞吐量的考虑。</li></ol><p>满足上面的 2 的场景，那么我们就能知道为什么上面的 CAS 操作 compareAndSetWaitStatus(h, Node.SIGNAL, 0) 会失败了？</p><p>因为当前进行 for 循环的线程到这里的时候，可能刚刚唤醒的线程 t4 也刚刚好到这里了，那么就有可能 CAS 失败了。</p><p>for 循环第一轮的时候会唤醒 t4，t4 醒后会将自己设置为头节点，如果在 t4 设置头节点后，for 循环才跑到 if (h == head)，那么此时会返回 false，for 循环会进入下一轮。t4 唤醒后也会进入到这个方法里面，那么 for 循环第二轮和 t4 就有可能在这个 CAS 相遇，那么就只会有一个成功了。</p><h4 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h4><p>字面意思是“可重复使用的栅栏”或“周期性的栅栏”，总之不是用了一次就没用了的，CyclicBarrier 相比 CountDownLatch 来说，要简单很多，其源码没有什么高深的地方，它是 ReentrantLock 和 Condition 的组合使用。看如下示意图，CyclicBarrier 和 CountDownLatch 是不是很像，只是 CyclicBarrier 可以有不止一个栅栏，因为它的栅栏（Barrier）可以重复使用（Cyclic）。</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/cyclicbarrier-2.png" alt="cyclicbarrier-2"></p><p>首先，CyclicBarrier 的源码实现和 CountDownLatch 大相径庭，CountDownLatch 基于 AQS 的共享模式的使用，而 CyclicBarrier 基于 Condition 来实现。</p><p>因为 CyclicBarrier 的源码相对来说简单许多，读者只要熟悉了前面关于 Condition 的分析，那么这里的源码是毫无压力的，就是几个特殊概念罢了。</p><p>先用一张图来描绘下 CyclicBarrier 里面的一些概念，和它的基本使用流程：</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/cyclicbarrier-3.png" alt="cyclicbarrier-3"></p><blockquote><p>看图我们也知道了，CyclicBarrier 的源码最重要的就是 await() 方法了。</p></blockquote><p>大家先把图看完，然后我们开始源码分析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrier</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 我们说了，CyclicBarrier 是可以重复使用的，我们把每次从开始使用到穿过栅栏当做"一代"，或者"一个周期"</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Generation</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> broken = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** The lock for guarding barrier entry */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// CyclicBarrier 是基于 Condition 的</span></span><br><span class="line">    <span class="comment">// Condition 是“条件”的意思，CyclicBarrier 的等待线程通过 barrier 的“条件”是大家都到了栅栏上</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition trip = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 参与的线程数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> parties;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果设置了这个，代表越过栅栏之前，要执行相应的操作</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Runnable barrierCommand;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前所处的“代”</span></span><br><span class="line">    <span class="keyword">private</span> Generation generation = <span class="keyword">new</span> Generation();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 还没有到栅栏的线程数，这个值初始为 parties，然后递减</span></span><br><span class="line">    <span class="comment">// 还没有到栅栏的线程数 = parties - 已经到栅栏的数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties, Runnable barrierAction)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (parties &lt;= <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        <span class="keyword">this</span>.parties = parties;</span><br><span class="line">        <span class="keyword">this</span>.count = parties;</span><br><span class="line">        <span class="keyword">this</span>.barrierCommand = barrierAction;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(parties, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>首先，先看怎么开启新的一代：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 开启新的一代，当最后一个线程到达栅栏上的时候，调用这个方法来唤醒其他线程，同时初始化“下一代”</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">nextGeneration</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 首先，需要唤醒所有的在栅栏上等待的线程</span></span><br><span class="line">    trip.signalAll();</span><br><span class="line">    <span class="comment">// 更新 count 的值</span></span><br><span class="line">    count = parties;</span><br><span class="line">    <span class="comment">// 重新生成“新一代”</span></span><br><span class="line">    generation = <span class="keyword">new</span> Generation();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>开启新的一代，类似于重新实例化一个 CyclicBarrier 实例</p></blockquote><p>看看怎么打破一个栅栏：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">breakBarrier</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 设置状态 broken 为 true</span></span><br><span class="line">    generation.broken = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">// 重置 count 为初始值 parties</span></span><br><span class="line">    count = parties;</span><br><span class="line">    <span class="comment">// 唤醒所有已经在等待的线程</span></span><br><span class="line">    trip.signalAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这两个方法之后用得到，现在开始分析最重要的等待通过栅栏方法 await 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不带超时机制</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, BrokenBarrierException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dowait(<span class="keyword">false</span>, <span class="number">0L</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (TimeoutException toe) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Error(toe); <span class="comment">// cannot happen</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 带超时机制，如果超时抛出 TimeoutException 异常</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">await</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException,</span></span><br><span class="line"><span class="function">           BrokenBarrierException,</span></span><br><span class="line"><span class="function">           TimeoutException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dowait(<span class="keyword">true</span>, unit.toNanos(timeout));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续往里看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dowait</span><span class="params">(<span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, BrokenBarrierException,</span></span><br><span class="line"><span class="function">               TimeoutException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    <span class="comment">// 先要获取到锁，然后在 finally 中要记得释放锁</span></span><br><span class="line">    <span class="comment">// 如果记得 Condition 部分的话，我们知道 condition 的 await() 会释放锁，被 signal() 唤醒的时候需要重新获取锁</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> Generation g = generation;</span><br><span class="line">        <span class="comment">// 检查栅栏是否被打破，如果被打破，抛出 BrokenBarrierException 异常</span></span><br><span class="line">        <span class="keyword">if</span> (g.broken)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BrokenBarrierException();</span><br><span class="line">        <span class="comment">// 检查中断状态，如果中断了，抛出 InterruptedException 异常</span></span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">            breakBarrier();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// index 是这个 await 方法的返回值</span></span><br><span class="line">        <span class="comment">// 注意到这里，这个是从 count 递减后得到的值</span></span><br><span class="line">        <span class="keyword">int</span> index = --count;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果等于 0，说明所有的线程都到栅栏上了，准备通过</span></span><br><span class="line">        <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;  <span class="comment">// tripped</span></span><br><span class="line">            <span class="keyword">boolean</span> ranAction = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 如果在初始化的时候，指定了通过栅栏前需要执行的操作，在这里会得到执行</span></span><br><span class="line">                <span class="keyword">final</span> Runnable command = barrierCommand;</span><br><span class="line">                <span class="keyword">if</span> (command != <span class="keyword">null</span>)</span><br><span class="line">                    command.run();</span><br><span class="line">                <span class="comment">// 如果 ranAction 为 true，说明执行 command.run() 的时候，没有发生异常退出的情况</span></span><br><span class="line">                ranAction = <span class="keyword">true</span>;</span><br><span class="line">                <span class="comment">// 唤醒等待的线程，然后开启新的一代</span></span><br><span class="line">                nextGeneration();</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!ranAction)</span><br><span class="line">                    <span class="comment">// 进到这里，说明执行指定操作的时候，发生了异常，那么需要打破栅栏</span></span><br><span class="line">                    <span class="comment">// 之前我们说了，打破栅栏意味着唤醒所有等待的线程，设置 broken 为 true，重置 count 为 parties</span></span><br><span class="line">                    breakBarrier();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// loop until tripped, broken, interrupted, or timed out</span></span><br><span class="line">        <span class="comment">// 如果是最后一个线程调用 await，那么上面就返回了</span></span><br><span class="line">        <span class="comment">// 下面的操作是给那些不是最后一个到达栅栏的线程执行的</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 如果带有超时机制，调用带超时的 Condition 的 await 方法等待，直到最后一个线程调用 await</span></span><br><span class="line">                <span class="keyword">if</span> (!timed)</span><br><span class="line">                    trip.await();</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (nanos &gt; <span class="number">0L</span>)</span><br><span class="line">                    nanos = trip.awaitNanos(nanos);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">                <span class="comment">// 如果到这里，说明等待的线程在 await（是 Condition 的 await）的时候被中断</span></span><br><span class="line">                <span class="keyword">if</span> (g == generation &amp;&amp; ! g.broken) &#123;</span><br><span class="line">                    <span class="comment">// 打破栅栏</span></span><br><span class="line">                    breakBarrier();</span><br><span class="line">                    <span class="comment">// 打破栅栏后，重新抛出这个 InterruptedException 异常给外层调用的方法</span></span><br><span class="line">                    <span class="keyword">throw</span> ie;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 到这里，说明 g != generation, 说明新的一代已经产生，即最后一个线程 await 执行完成，</span></span><br><span class="line">                    <span class="comment">// 那么此时没有必要再抛出 InterruptedException 异常，记录下来这个中断信息即可</span></span><br><span class="line">                    <span class="comment">// 或者是栅栏已经被打破了，那么也不应该抛出 InterruptedException 异常，</span></span><br><span class="line">                    <span class="comment">// 而是之后抛出 BrokenBarrierException 异常</span></span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">              <span class="comment">// 唤醒后，检查栅栏是否是“破的”</span></span><br><span class="line">            <span class="keyword">if</span> (g.broken)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BrokenBarrierException();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 这个 for 循环除了异常，就是要从这里退出了</span></span><br><span class="line">            <span class="comment">// 我们要清楚，最后一个线程在执行完指定任务(如果有的话)，会调用 nextGeneration 来开启一个新的代</span></span><br><span class="line">            <span class="comment">// 然后释放掉锁，其他线程从 Condition 的 await 方法中得到锁并返回，然后到这里的时候，其实就会满足 g != generation 的</span></span><br><span class="line">            <span class="comment">// 那什么时候不满足呢？barrierCommand 执行过程中抛出了异常，那么会执行打破栅栏操作，</span></span><br><span class="line">            <span class="comment">// 设置 broken 为true，然后唤醒这些线程。这些线程会从上面的 if (g.broken) 这个分支抛 BrokenBarrierException 异常返回</span></span><br><span class="line">            <span class="comment">// 当然，还有最后一种可能，那就是 await 超时，此种情况不会从上面的 if 分支异常返回，也不会从这里返回，会执行后面的代码</span></span><br><span class="line">            <span class="keyword">if</span> (g != generation)</span><br><span class="line">                <span class="keyword">return</span> index;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果醒来发现超时了，打破栅栏，抛出异常</span></span><br><span class="line">            <span class="keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">                breakBarrier();</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> TimeoutException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好了，我想我应该讲清楚了吧，我好像几乎没有漏掉任何一行代码吧？</p><p>下面开始收尾工作。</p><p>首先，我们看看怎么得到有多少个线程到了栅栏上，处于等待状态：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNumberWaiting</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> parties - count;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断一个栅栏是否被打破了，这个很简单，直接看 broken 的值即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBroken</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> generation.broken;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前面我们在说 await 的时候也几乎说清楚了，什么时候栅栏会被打破，总结如下：</p><ol><li>中断，我们说了，如果某个等待的线程发生了中断，那么会打破栅栏，同时抛出 InterruptedException 异常；</li><li>超时，打破栅栏，同时抛出 TimeoutException 异常；</li><li>指定执行的操作抛出了异常，这个我们前面也说过。</li></ol><p>最后，我们来看看怎么重置一个栅栏：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        breakBarrier();   <span class="comment">// break the current generation</span></span><br><span class="line">        nextGeneration(); <span class="comment">// start a new generation</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们设想一下，如果初始化时，指定了线程 parties = 4，前面有 3 个线程调用了 await 等待，在第 4 个线程调用 await 之前，我们调用 reset 方法，那么会发生什么？</p><p>首先，打破栅栏，那意味着所有等待的线程（3个等待的线程）会唤醒，await 方法会通过抛出 BrokenBarrierException 异常返回。然后开启新的一代，重置了 count 和 generation，相当于一切归零了。</p><p>怎么样，CyclicBarrier 源码很简单吧。</p><h4 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h4><p>有了 CountDownLatch 的基础后，分析 Semaphore 会简单很多。Semaphore 是什么呢？它类似一个资源池（读者可以类比线程池），每个线程需要调用 acquire() 方法获取资源，然后才能执行，执行完后，需要 release 资源，让给其他的线程用。</p><p>大概大家也可以猜到，Semaphore 其实也是 AQS 中共享锁的使用，因为每个线程共享一个池嘛。</p><p>套路解读：创建 Semaphore 实例的时候，需要一个参数 permits，这个基本上可以确定是设置给 AQS 的 state 的，然后每个线程调用 acquire 的时候，执行 state = state - 1，release 的时候执行 state = state + 1，当然，acquire  的时候，如果 state = 0，说明没有资源了，需要等待其他线程 release。</p><p>构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits)</span> </span>&#123;</span><br><span class="line">    sync = <span class="keyword">new</span> NonfairSync(permits);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits, <span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> FairSync(permits) : <span class="keyword">new</span> NonfairSync(permits);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里和 ReentrantLock 类似，用了公平策略和非公平策略。</p><p>看 acquire 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquireUninterruptibly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.acquireShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> permits)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (permits &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    sync.acquireSharedInterruptibly(permits);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquireUninterruptibly</span><span class="params">(<span class="keyword">int</span> permits)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (permits &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    sync.acquireShared(permits);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这几个方法也是老套路了，大家基本都懂了吧，这边多了两个可以传参的 acquire 方法，不过大家也都懂的吧，如果我们需要一次获取超过一个的资源，会用得着这个的。</p><p>我们接下来看不抛出 InterruptedException 异常的 acquireUninterruptibly() 方法吧：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquireUninterruptibly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.acquireShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        doAcquireShared(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前面说了，Semaphore 分公平策略和非公平策略，我们对比一下两个 tryAcquireShared 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 公平策略：</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 区别就在于是不是会先判断是否有线程在排队，然后才进行 CAS 减操作</span></span><br><span class="line">        <span class="keyword">if</span> (hasQueuedPredecessors())</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> available = getState();</span><br><span class="line">        <span class="keyword">int</span> remaining = available - acquires;</span><br><span class="line">        <span class="keyword">if</span> (remaining &lt; <span class="number">0</span> ||</span><br><span class="line">            compareAndSetState(available, remaining))</span><br><span class="line">            <span class="keyword">return</span> remaining;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 非公平策略：</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nonfairTryAcquireShared(acquires);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">nonfairTryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> available = getState();</span><br><span class="line">        <span class="keyword">int</span> remaining = available - acquires;</span><br><span class="line">        <span class="keyword">if</span> (remaining &lt; <span class="number">0</span> ||</span><br><span class="line">            compareAndSetState(available, remaining))</span><br><span class="line">            <span class="keyword">return</span> remaining;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也是老套路了，所以从源码分析角度的话，我们其实不太需要关心是不是公平策略还是非公平策略，它们的区别往往就那么一两行。</p><p>我们再回到 acquireShared 方法，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        doAcquireShared(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于 tryAcquireShared(arg) 返回小于 0 的时候，说明 state 已经小于 0 了（没资源了），此时 acquire 不能立马拿到资源，需要进入到阻塞队列等待，虽然贴了很多代码，不在乎多这点了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    <span class="keyword">if</span> (interrupted)</span><br><span class="line">                        selfInterrupt();</span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法我就不介绍了，线程挂起后等待有资源被 release 出来。接下来，我们就要看 release 的方法了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 任务介绍，释放一个资源</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> current = getState();</span><br><span class="line">        <span class="keyword">int</span> next = current + releases;</span><br><span class="line">        <span class="comment">// 溢出，当然，我们一般也不会用这么大的数</span></span><br><span class="line">        <span class="keyword">if</span> (next &lt; current) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum permit count exceeded"</span>);</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(current, next))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>tryReleaseShared 方法总是会返回 true，然后是 doReleaseShared，这个也是我们熟悉的方法了，我就贴下代码，不分析了，这个方法用于唤醒所有的等待线程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">            <span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line">            <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                    <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                     !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Semphore 的源码确实很简单，基本上都是分析过的老代码的组合使用了。</p><h4 id="AQS-组件总结"><a href="#AQS-组件总结" class="headerlink" title="AQS 组件总结"></a>AQS 组件总结</h4><ul><li><strong><code>Semaphore</code>(信号量)-允许多个线程同时访问：</strong> <code>synchronized</code> 和 <code>ReentrantLock</code> 都是一次只允许一个线程访问某个资源，<code>Semaphore</code>(信号量)可以指定多个线程同时访问某个资源。</li><li><strong><code>CountDownLatch</code>（倒计时器）：</strong> <code>CountDownLatch</code> 是一个同步工具类，用来协调多个线程之间的同步。这个工具通常用来控制线程等待，它可以让某一个线程等待直到倒计时结束，再开始执行。</li><li><strong><code>CyclicBarrier</code>(循环栅栏)：</strong> <code>CyclicBarrier</code> 和 <code>CountDownLatch</code> 非常类似，它也可以实现线程间的技术等待，但是它的功能比 <code>CountDownLatch</code> 更加复杂和强大。让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程继续执行。</li></ul><h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><h4 id="为什么要用线程池？"><a href="#为什么要用线程池？" class="headerlink" title="为什么要用线程池？"></a>为什么要用线程池？</h4><ol><li>降低资源消耗。通知重复利用已创建的线程降低线程创建和销毁造成的消耗</li><li>提高响应速度。当任务到达时，任务可以不需要等待线程创建</li><li>提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一分配、调优和监控</li></ol><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20210831164907239.png" alt="image-20210831164907239"></p><h4 id="实现-Runnable-和-Callable-接口的区别"><a href="#实现-Runnable-和-Callable-接口的区别" class="headerlink" title="实现 Runnable 和 Callable 接口的区别"></a>实现 Runnable 和 Callable 接口的区别</h4><p>Callable 接口引入是为了处理 Runnable 不支持的用例。Runnable 接口不会返回结果或抛出异常，Callable 接口可以。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 被线程执行，没有返回值也无法抛出异常</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callable</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 计算结果，或在无法这样做时抛出异常。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 计算得出的结果</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> 如果无法计算结果，则抛出异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">V <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="执行-execute-方法和-submit-方法的区别是什么？"><a href="#执行-execute-方法和-submit-方法的区别是什么？" class="headerlink" title="执行 execute() 方法和 submit() 方法的区别是什么？"></a>执行 execute() 方法和 submit() 方法的区别是什么？</h4><ol><li>execute() 方法用于提交不需要返回值的任务，无法判断任务是否被线程池成功执行与否</li><li>submit() 方法用于提交需要返回值的任务，线程池会返回一个 Future 对象，通过这个 Future 对象可以判断任务是否执行成功，并且可以通过 Future 的 get() 方法来获取返回值，get() 方法会阻塞当前线程直到任务完成。</li></ol><p>我们以 <strong><code>AbstractExecutorService</code> 接口</strong> 中的一个 <code>submit</code> 方法为例子来看看源代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, <span class="keyword">null</span>);</span><br><span class="line">    execute(ftask);</span><br><span class="line">    <span class="keyword">return</span> ftask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面方法调用的 <code>newTaskFor</code> 方法返回了一个 <code>FutureTask</code> 对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">RunnableFuture&lt;T&gt; <span class="title">newTaskFor</span><span class="params">(Runnable runnable, T value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FutureTask&lt;T&gt;(runnable, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="如何创建线程池"><a href="#如何创建线程池" class="headerlink" title="如何创建线程池"></a>如何创建线程池</h4><p>通常不建议使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式。</p><blockquote><p>Executors 返回线程池对象的弊端如下：</p><ul><li><strong>FixedThreadPool 和 SingleThreadExecutor</strong> ： 允许请求的队列长度为 Integer.MAX_VALUE ，可能堆积大量的请求，从而导致 OOM。</li><li><strong>CachedThreadPool 和 ScheduledThreadPool</strong> ： 允许创建的线程数量为 Integer.MAX_VALUE ，可能会创建大量线程，从而导致 OOM。</li></ul></blockquote><p>通过构造方法实现</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20210830203732695.png" alt="image-20210830203732695"></p><h4 id="ThreadPoolExecutors-类分析"><a href="#ThreadPoolExecutors-类分析" class="headerlink" title="ThreadPoolExecutors 类分析"></a>ThreadPoolExecutors 类分析</h4><p>这里分析最后一个最长的构造函数，其余三个都是在这个构造方法基础上产生。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用给定的初始参数创建一个新的ThreadPoolExecutor。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                      TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                      BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                      ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                      RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">        keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || handler == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">    <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">    <span class="keyword">this</span>.workQueue = workQueue;</span><br><span class="line">    <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">    <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">    <span class="keyword">this</span>.handler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ThreadPoolExecutor 3 个最重要的参数：</p><ul><li>corePoolSize：核心线程数定义了最小可以同时运行的线程数量</li><li>maximumPoolSize：当队列中存放的任务达到队列容量时，当前可以同时运行的线程数量变为最大线程数。</li><li>workQueue：当新任务来时，会判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被放到队列中</li></ul><p>其他常见参数</p><ol><li>keepAliveTime，当线程池中的线程数量大于 corePoolSize 时，如果没有新的任务提交，<strong>核心线程外的线程不会立即销毁而是等待时间超过了 keepAliveTime 后被回收销毁</strong></li><li>unit，keepAliveTime 参数的时间单位</li><li>threadFactory，executor 创建新线程会用到</li><li>handler，饱和策略</li></ol><h4 id="ThreadPoolExecutor-饱和策略"><a href="#ThreadPoolExecutor-饱和策略" class="headerlink" title="ThreadPoolExecutor 饱和策略"></a>ThreadPoolExecutor 饱和策略</h4><p>当同时运行的线程数量达到 maximumPoolSize 时，且队列也满时，ThreadPoolTaskExecutor 定义一些策略：</p><ul><li><p>ThreadPoolExecutor.AbortPolicy：抛出 RejectExecutionException 来拒绝新任务的处理</p></li><li><p>ThreadPoolExecutor.CallerRunsPolicy： 调用执行自己的线程运行任务，也就是直接在调用<code>execute</code>方法的线程中运行(<code>run</code>)被拒绝的任务，如果执行程序已关闭，则会丢弃该任务。因此这种策略会降低对于新任务提交速度，影响程序的整体性能。</p></li><li><p>ThreadPoolExecutor.DiscardPolicy：不处理新任务，直接丢弃掉</p></li><li><p>ThreadPoolExecutor.DiscardOldestPolicy：丢弃最早未处理的任务请求</p></li></ul><h4 id="线程池Demo"><a href="#线程池Demo" class="headerlink" title="线程池Demo"></a>线程池Demo</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Runnable r = () -&gt; &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" Start. Time = "</span> + <span class="keyword">new</span> Date());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" End. Time = "</span> + <span class="keyword">new</span> Date());</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    ThreadPoolExecutor executor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">5</span>, <span class="number">10</span>, <span class="number">1L</span>, TimeUnit.SECONDS,</span><br><span class="line">            <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">100</span>), <span class="keyword">new</span> ThreadPoolExecutor.CallerRunsPolicy());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        executor.execute(r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//终止线程池</span></span><br><span class="line">    executor.shutdown();</span><br><span class="line">    <span class="keyword">while</span> (!executor.isTerminated()) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"Finished all threads"</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">输出：</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span> Start. Time = Mon Aug <span class="number">30</span> <span class="number">21</span>:<span class="number">13</span>:<span class="number">45</span> CST <span class="number">2021</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span> Start. Time = Mon Aug <span class="number">30</span> <span class="number">21</span>:<span class="number">13</span>:<span class="number">45</span> CST <span class="number">2021</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">4</span> Start. Time = Mon Aug <span class="number">30</span> <span class="number">21</span>:<span class="number">13</span>:<span class="number">45</span> CST <span class="number">2021</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">3</span> Start. Time = Mon Aug <span class="number">30</span> <span class="number">21</span>:<span class="number">13</span>:<span class="number">45</span> CST <span class="number">2021</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">5</span> Start. Time = Mon Aug <span class="number">30</span> <span class="number">21</span>:<span class="number">13</span>:<span class="number">45</span> CST <span class="number">2021</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">3</span> End. Time = Mon Aug <span class="number">30</span> <span class="number">21</span>:<span class="number">13</span>:<span class="number">50</span> CST <span class="number">2021</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span> End. Time = Mon Aug <span class="number">30</span> <span class="number">21</span>:<span class="number">13</span>:<span class="number">50</span> CST <span class="number">2021</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">4</span> End. Time = Mon Aug <span class="number">30</span> <span class="number">21</span>:<span class="number">13</span>:<span class="number">50</span> CST <span class="number">2021</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">3</span> Start. Time = Mon Aug <span class="number">30</span> <span class="number">21</span>:<span class="number">13</span>:<span class="number">50</span> CST <span class="number">2021</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">4</span> Start. Time = Mon Aug <span class="number">30</span> <span class="number">21</span>:<span class="number">13</span>:<span class="number">50</span> CST <span class="number">2021</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span> End. Time = Mon Aug <span class="number">30</span> <span class="number">21</span>:<span class="number">13</span>:<span class="number">50</span> CST <span class="number">2021</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">5</span> End. Time = Mon Aug <span class="number">30</span> <span class="number">21</span>:<span class="number">13</span>:<span class="number">50</span> CST <span class="number">2021</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span> Start. Time = Mon Aug <span class="number">30</span> <span class="number">21</span>:<span class="number">13</span>:<span class="number">50</span> CST <span class="number">2021</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span> Start. Time = Mon Aug <span class="number">30</span> <span class="number">21</span>:<span class="number">13</span>:<span class="number">50</span> CST <span class="number">2021</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">5</span> Start. Time = Mon Aug <span class="number">30</span> <span class="number">21</span>:<span class="number">13</span>:<span class="number">50</span> CST <span class="number">2021</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">4</span> End. Time = Mon Aug <span class="number">30</span> <span class="number">21</span>:<span class="number">13</span>:<span class="number">55</span> CST <span class="number">2021</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span> End. Time = Mon Aug <span class="number">30</span> <span class="number">21</span>:<span class="number">13</span>:<span class="number">55</span> CST <span class="number">2021</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span> End. Time = Mon Aug <span class="number">30</span> <span class="number">21</span>:<span class="number">13</span>:<span class="number">55</span> CST <span class="number">2021</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">3</span> End. Time = Mon Aug <span class="number">30</span> <span class="number">21</span>:<span class="number">13</span>:<span class="number">55</span> CST <span class="number">2021</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">5</span> End. Time = Mon Aug <span class="number">30</span> <span class="number">21</span>:<span class="number">13</span>:<span class="number">55</span> CST <span class="number">2021</span></span><br><span class="line">Finished all threads</span><br><span class="line">Finished all threads</span><br></pre></td></tr></table></figure><h4 id="线程池原理分析"><a href="#线程池原理分析" class="headerlink" title="==线程池原理分析=="></a>==线程池原理分析==</h4><p>上面 Demo 可以看出，共 10 个任务，线程池先执行 5 个，等待这些任务结束后，继续执行剩下的 5 个任务。</p><p>我们看看 execute(worker) 源码 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 存放线程池的运行状态 (runState) 和线程池内有效线程的数量 (workerCount)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">workerCountOf</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c &amp; CAPACITY;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;Runnable&gt; workQueue;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果任务为null，则抛出异常。</span></span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">// ctl 中保存的线程池当前的一些状态信息</span></span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  下面会涉及到 3 步 操作</span></span><br><span class="line">    <span class="comment">// 1.首先判断当前线程池中执行的任务数量是否小于 corePoolSize</span></span><br><span class="line">    <span class="comment">// 如果小于的话，通过addWorker(command, true)新建一个线程，并将任务(command)添加到该线程中；然后，启动该线程从而执行任务。</span></span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2.如果当前执行的任务数量大于等于 corePoolSize 的时候就会走到这里</span></span><br><span class="line">    <span class="comment">// 通过 isRunning 方法判断线程池状态，线程池处于 RUNNING 状态才会被并且队列可以加入任务，该任务才会被加入进去</span></span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">        <span class="comment">// 再次获取线程池状态，如果线程池状态不是 RUNNING 状态就需要从任务队列中移除任务，并尝试判断线程是否全部执行完毕。同时执行拒绝策略。</span></span><br><span class="line">        <span class="keyword">if</span> (!isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            reject(command);</span><br><span class="line">            <span class="comment">// 如果当前线程池为空就新创建一个线程并执行。</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">            addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3. 通过addWorker(command, false)新建一个线程，并将任务(command)添加到该线程中；然后，启动该线程从而执行任务。</span></span><br><span class="line">    <span class="comment">//如果addWorker(command, false)执行失败，则通过reject()执行相应的拒绝策略的内容。</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20210830211740198.png" alt="image-20210830211740198"></p><h4 id="线程池大小确定"><a href="#线程池大小确定" class="headerlink" title="==线程池大小确定=="></a>==线程池大小确定==</h4><p>有一个简单并且适用面比较广的公式：</p><ul><li><strong>CPU 密集型任务(N+1)：</strong> 这种任务消耗的主要是 CPU 资源，可以将线程数设置为 N（CPU 核心数）+1，<strong>比 CPU 核心数多出来的一个线程是为了防止线程偶发的缺页中断，或者其它原因导致的任务暂停而带来的影响</strong>。一旦任务暂停，CPU 就会处于空闲状态，而在这种情况下多出来的一个线程就可以充分利用 CPU 的空闲时间。</li><li><strong>I/O 密集型任务(2N)：</strong> 这种任务应用起来，系统会用大部分的时间来处理 I/O 交互，<strong>而线程在处理 I/O 的时间段内不会占用 CPU 来处理，这时就可以将 CPU 交出给其它线程使用</strong>。因此在 I/O 密集型任务的应用中，我们可以多配置一些线程，具体的计算方法是 2N。</li></ul><p><strong>如何判断是 CPU 密集任务还是 IO 密集任务？</strong></p><p>CPU 密集型简单理解就是利用 CPU 计算能力的任务比如你在内存中对大量数据进行排序。单凡涉及到网络读取，文件读取这类都是 IO 密集型，这类任务的特点是 CPU 计算耗费时间相比于等待 IO 操作完成的时间来说很少，大部分时间都花在了等待 IO 操作完成上。</p><h4 id="四种常见的线程池"><a href="#四种常见的线程池" class="headerlink" title="四种常见的线程池"></a>四种常见的线程池</h4><h5 id="newCachedThreadPool"><a href="#newCachedThreadPool" class="headerlink" title="newCachedThreadPool"></a>newCachedThreadPool</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,  <span class="comment">//核心池大小 0，最大池大小为整型最大可能导致 OOM</span></span><br><span class="line"> <span class="number">60L</span>, TimeUnit.SECONDS, <span class="comment">// keepAliveTime 60s</span></span><br><span class="line"> <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;()); <span class="comment">//SynchronousQueue队列</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="newFixedThreadPool"><a href="#newFixedThreadPool" class="headerlink" title="newFixedThreadPool"></a>newFixedThreadPool</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads, <span class="comment">//核心池和最大池大小都是传入的参数，只能创建核心线程</span></span><br><span class="line"> <span class="number">0L</span>, TimeUnit.MILLISECONDS,<span class="comment">//只能创建核心线程 keepAliveTime 也没啥用</span></span><br><span class="line"> <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()); <span class="comment">//LinkedBlockingQueue的默认⼤⼩Integer.MAX_VALUE</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="newSingleThreadExecutor"><a href="#newSingleThreadExecutor" class="headerlink" title="newSingleThreadExecutor"></a><strong>newSingleThreadExecutor</strong></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService(<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,<span class="comment">//核心池和最大池大小都是1</span></span><br><span class="line"> <span class="number">0L</span>, TimeUnit.MILLISECONDS,<span class="comment">//只能创建核心线程 keepAliveTime 也没啥用</span></span><br><span class="line"> <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;())); <span class="comment">//所有任务按照FIFO执行，任务队列大小默认为Integer.MAX_VALUE</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="newScheduledThreadPool"><a href="#newScheduledThreadPool" class="headerlink" title="newScheduledThreadPool"></a><strong>newScheduledThreadPool</strong></h5><p>创建⼀个定⻓线程池，⽀持定时及周期性任务执⾏。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize</span></span></span><br><span class="line"><span class="function"><span class="params"> return new ScheduledThreadPoolExecutor(corePoolSize)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//ScheduledThreadPoolExecutor():</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ScheduledThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">super</span>(corePoolSize, Integer.MAX_VALUE,   <span class="comment">//核心池大小 corePoolSize，最大池大小为整型最大可能导致 OOM</span></span><br><span class="line"> DEFAULT_KEEPALIVE_MILLIS, MILLISECONDS,</span><br><span class="line"> <span class="keyword">new</span> DelayedWorkQueue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h3><p>BlockingQueue⼀般⽤于⽣产者-消费者模式，⽣产者是往队列⾥添加元素的线程， 消费者是从队列⾥拿元素的线程。<strong>BlockingQueue</strong>就是存放元素的容器。 </p><h4 id="BlockingQueue-的操作方法"><a href="#BlockingQueue-的操作方法" class="headerlink" title="BlockingQueue 的操作方法"></a>BlockingQueue 的操作方法</h4><p>阻塞队列提供了四组不同的方法用于插入、移除、检查元素：</p><table><thead><tr><th>方法/处理方式</th><th>抛出异常</th><th>返回特殊值</th><th>一直阻塞</th><th>超时退出</th></tr></thead><tbody><tr><td>插入方法</td><td>add(e)</td><td>offer(e)</td><td>put(e)</td><td>offer(e, time, unit)</td></tr><tr><td>移除方法</td><td>remove</td><td>poll()</td><td>take()</td><td>poll(time, unit)</td></tr><tr><td>检查方法</td><td>element()</td><td>peek()</td><td>-</td><td>-</td></tr></tbody></table><ul><li>抛出异常：当队列满时插入元素，抛出IllegalStateException(“Queue full”)异常，当队列为空取元素，抛出NoSuchElementException异常</li><li>返回特殊值：一般为 true/false</li><li>一直阻塞：试图的操作无法立即执行，一直阻塞</li><li>超时退出，阻塞超过一定时间后，返回一个特定值告知该操作是否完成</li></ul><p>注意：不能往阻塞队列中插入 null</p><h4 id="BlockingQueue-的实现类"><a href="#BlockingQueue-的实现类" class="headerlink" title="BlockingQueue 的实现类"></a>BlockingQueue 的实现类</h4><h5 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h5><p>由数组结构组成的有界阻塞队列。内部结构是数组，故具有数组的特性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity, <span class="keyword">boolean</span> fair)</span></span>&#123;</span><br><span class="line"> <span class="comment">//..省略代码 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以初始化队列⼤⼩， 且⼀旦初始化不能改变。构造⽅法中的fair表示控制对象的 内部锁是否采⽤公平锁，默认是⾮公平锁。</p><h5 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a><strong>LinkedBlockingQueue</strong></h5><p>由链表结构组成的有界阻塞队列。内部结构是链表，具有链表的特性。默认队列的 ⼤⼩是 Integer.MAX_VALUE ，也可以指定⼤⼩。此队列按照先进先出的原则对元素 进⾏排序。</p><h5 id="DelayQueue"><a href="#DelayQueue" class="headerlink" title="DelayQueue"></a><strong>DelayQueue</strong></h5><p>该队列中的元素只有当其指定的延迟时间到了，才能够从队列中获取到该元素 。注⼊其中的元素必须实现 Delayed 接口。DelayQueue是⼀个没有⼤⼩限制的队列，因此往队列中插⼊数据的操作（⽣产者）永远不会被阻塞。</p><h5 id="PriorityBlockingQueue"><a href="#PriorityBlockingQueue" class="headerlink" title="PriorityBlockingQueue"></a><strong>PriorityBlockingQueue</strong></h5><p>基于优先级的⽆界阻塞队列（优先级的判断通过构造函数传⼊的Compator对象来决定）</p><h5 id="SynchronousQueue"><a href="#SynchronousQueue" class="headerlink" title="SynchronousQueue"></a><strong>SynchronousQueue</strong></h5><p>这个队列⽐较特殊，没有任何内部容量，甚⾄连⼀个队列的容量都没有。并且每个put 必须等待⼀个 take，反之亦然。 </p><p><strong>==注意==</strong></p><p><strong>PriorityBlockingQueue</strong>不会阻塞数据⽣产者（因为队列是⽆界的），⽽只会在没 有可消费的数据时，阻塞数据的消费者。因此使⽤的时候要特别注意，⽣产者⽣产数据的速度绝对不能快于消费者消费数据的速度，否则时间⼀⻓，会最终耗尽所有 的可⽤堆内存空间。对于使⽤默认⼤⼩的<strong>LinkedBlockingQueue</strong>也是⼀样的。 </p><h4 id="阻塞队列原理"><a href="#阻塞队列原理" class="headerlink" title="阻塞队列原理"></a>阻塞队列原理</h4><p>阻塞队列的原理很简单，利⽤了Lock锁的多条件（Condition）阻塞控制。接下来我们分析ArrayBlockingQueue JDK 1.8 的源码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数据元素数组</span></span><br><span class="line"><span class="keyword">final</span> Object[] items;</span><br><span class="line"><span class="comment">//下⼀个待取出元素索引</span></span><br><span class="line"><span class="keyword">int</span> takeIndex;</span><br><span class="line"><span class="comment">//下⼀个待添加元素索引</span></span><br><span class="line"><span class="keyword">int</span> putIndex;</span><br><span class="line"><span class="comment">//元素个数</span></span><br><span class="line"><span class="keyword">int</span> count;</span><br><span class="line"><span class="comment">//内部锁</span></span><br><span class="line"><span class="keyword">final</span> ReentrantLock lock;</span><br><span class="line"><span class="comment">//消费者监视器</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty;</span><br><span class="line"><span class="comment">//⽣产者监视器</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notFull; </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity, <span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line"> <span class="comment">//..省略其他代码</span></span><br><span class="line"> lock = <span class="keyword">new</span> ReentrantLock(fair);</span><br><span class="line"> notEmpty = lock.newCondition();</span><br><span class="line"> notFull = lock.newCondition();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="put-方法"><a href="#put-方法" class="headerlink" title="put 方法"></a>put 方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">     checkNotNull(e);</span><br><span class="line">     <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">     <span class="comment">// 1.⾃旋拿锁</span></span><br><span class="line">     lock.lockInterruptibly();</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">// 2.判断队列是否满了</span></span><br><span class="line">         <span class="keyword">while</span> (count == items.length)</span><br><span class="line">             <span class="comment">// 2.1如果满了，阻塞该线程，并标记为notFull线程，</span></span><br><span class="line">             <span class="comment">// 等待notFull的唤醒，唤醒之后继续执⾏while循环。</span></span><br><span class="line">             notFull.await();</span><br><span class="line">         <span class="comment">// 3.如果没有满，则进⼊队列</span></span><br><span class="line">         enqueue(e);</span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">         lock.unlock();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(E x)</span> </span>&#123;</span><br><span class="line">     <span class="comment">// assert lock.getHoldCount() == 1;</span></span><br><span class="line">     <span class="comment">// assert items[putIndex] == null;</span></span><br><span class="line">     <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line">     items[putIndex] = x;</span><br><span class="line">     <span class="keyword">if</span> (++putIndex == items.length)</span><br><span class="line">         putIndex = <span class="number">0</span>;</span><br><span class="line">     count++;</span><br><span class="line">     <span class="comment">// 4 唤醒⼀个等待的线程</span></span><br><span class="line">     notEmpty.signal();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="take-方法"><a href="#take-方法" class="headerlink" title="take 方法"></a>take 方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">     <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    <span class="comment">//自旋拿锁</span></span><br><span class="line">     lock.lockInterruptibly();</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="keyword">while</span> (count == <span class="number">0</span>)</span><br><span class="line">             notEmpty.await(); <span class="comment">//队列为空，阻塞该线程，直到队列不为空</span></span><br><span class="line">         <span class="keyword">return</span> dequeue();</span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">         lock.unlock();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="comment">// assert lock.getHoldCount() == 1;</span></span><br><span class="line"> <span class="comment">// assert items[takeIndex] != null;</span></span><br><span class="line">     <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line">     <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">     E x = (E) items[takeIndex];</span><br><span class="line">     items[takeIndex] = <span class="keyword">null</span>;</span><br><span class="line">     <span class="keyword">if</span> (++takeIndex == items.length)</span><br><span class="line">         takeIndex = <span class="number">0</span>;</span><br><span class="line">     count--;</span><br><span class="line">     <span class="keyword">if</span> (itrs != <span class="keyword">null</span>)</span><br><span class="line">         itrs.elementDequeued();</span><br><span class="line">     notFull.signal();<span class="comment">//唤醒一个等待的线程</span></span><br><span class="line">     <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用场景：生产者消费者"><a href="#使用场景：生产者消费者" class="headerlink" title="使用场景：生产者消费者"></a>使用场景：生产者消费者</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ArrayBlockingQueue&lt;Integer&gt; q = <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">10</span>);</span><br><span class="line">    Thread consumer = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">"取走："</span> + q.take() + <span class="string">" 剩余："</span> + q.size());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    Thread producer = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Integer num = (<span class="keyword">int</span>) (Math.random() * <span class="number">100</span>);</span><br><span class="line">                q.put(num);</span><br><span class="line">                System.out.println(<span class="string">"装入："</span> + num + <span class="string">" 剩余："</span> + q.size());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    producer.start();</span><br><span class="line">    consumer.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="锁接口和类"><a href="#锁接口和类" class="headerlink" title="锁接口和类"></a>锁接口和类</h3><h4 id="synchronized-不足之处"><a href="#synchronized-不足之处" class="headerlink" title="synchronized 不足之处"></a>synchronized 不足之处</h4><ul><li>如果临界区是只读的，synchronized 排他锁效率较低</li><li>synchronized 不知道线程有没有成功获得锁</li><li>使用 synchronized ，如果临界区阻塞，当前线程又没有释放锁，就会导致所有线程等待。</li></ul><h4 id="锁分类"><a href="#锁分类" class="headerlink" title="锁分类"></a>锁分类</h4><h5 id="可重入和非重入锁"><a href="#可重入和非重入锁" class="headerlink" title="可重入和非重入锁"></a>可重入和非重入锁</h5><p>支持线程对资源重复加锁，成为可重入锁。synchronized 也是可重入锁、ReentrantLock 也是可重入锁。</p><h5 id="公平锁和非公平锁"><a href="#公平锁和非公平锁" class="headerlink" title="公平锁和非公平锁"></a>公平锁和非公平锁</h5><p>按请求锁的顺序拥有锁，反之锁就是不公平的。非公平锁能提升一定的效率，但可能导致线程饥饿。ReentrantLock 支持公平和非公平锁。</p><h5 id="读写锁和排他锁"><a href="#读写锁和排他锁" class="headerlink" title="读写锁和排他锁"></a>读写锁和排他锁</h5><p>synchronized 和 ReentrantLock 都是排他锁，这些锁只允许一个线程进行访问。 Java 提供 ReentrantReadWriteLock 作为读写锁，内部维护了一个读锁和一个写锁，在读多写少的环境下，提高了性能。</p><h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><h4 id="什么是数据库-数据库管理系统-数据库系统-数据库管理员"><a href="#什么是数据库-数据库管理系统-数据库系统-数据库管理员" class="headerlink" title="什么是数据库,数据库管理系统,数据库系统,数据库管理员?"></a>什么是数据库,数据库管理系统,数据库系统,数据库管理员?</h4><ul><li><strong>数据库</strong> :数据库(DataBase 简称 DB)就是信息的集合或者说数据库是由数据库管理系统管理的数据的集合。</li><li><strong>数据库管理系统</strong> : 数据库管理系统(Database Management System 简称 DBMS)是一种操纵和管理数据库的大型软件，通常用语用于建立、使用和维护数据库。</li><li><strong>数据库系统</strong> : 数据库系统(Data Base System，简称 DBS)通常由软件、数据库和数据管理员(DBA)组成。</li><li><strong>数据库管理员</strong> : 数据库管理员(Database Administrator,简称 DBA)负责全面管理和控制数据库系统。</li></ul><h4 id="什么是元组-码-候选码-主码-外码-主属性-非主属性"><a href="#什么是元组-码-候选码-主码-外码-主属性-非主属性" class="headerlink" title="什么是元组,码,候选码,主码,外码,主属性,非主属性"></a>什么是元组,码,候选码,主码,外码,主属性,非主属性</h4><ul><li><strong>元组</strong> ： 元组（tuple）是关系数据库中的基本概念，关系是一张表，表中的每行就是一个元组，每列就是一个属性。</li><li><strong>码</strong> ：码就是能唯一标识实体的属性，对应表中的列。</li><li><strong>候选码</strong> ： 若关系中的某一属性或属性组的值能<strong>唯一的标识一个元组，而其任何、子集都不能再标识</strong>，则称该属性组为候选码。</li><li><strong>主码</strong> : 主码也叫主键。主码是从候选码中选出来的。 <strong>一个实体集中只能有一个主码，但可以有多个候选码</strong>。</li><li><strong>外码</strong> : 外码也叫外键。如果一个关系中的一个属性是另外一个关系中的主码则这个属性为外码。</li><li><strong>主属性</strong> ： <strong>候选码中出现过的属性称为主属性</strong>。</li><li><strong>非主属性：</strong> 不包含在任何一个候选码中的属性称为非主属性。</li></ul><h4 id="主键和外键有什么区别"><a href="#主键和外键有什么区别" class="headerlink" title="主键和外键有什么区别"></a>主键和外键有什么区别</h4><ul><li><strong>主键(主码)</strong> ：主键用于唯一标识一个元组，不能有重复，不允许为空。一个表只能有一个主键。</li><li><strong>外键(外码)</strong> ：外键用来和其他表建立联系用，外键是另一表的主键，外键是可以有重复的，可以是空值。一个表可以有多个外键。</li></ul><h4 id="什么是-ER-图"><a href="#什么是-ER-图" class="headerlink" title="什么是 ER 图"></a>什么是 ER 图</h4><p><strong>E-R 图</strong>也称实体-联系图(Entity Relationship Diagram)，提供了表示实体类型、属性和联系的方法，用来描述现实世界的概念模型。 它是描述现实世界关系概念模型的有效方法。 是表示概念关系模型的一种方式。</p><h4 id="数据库范式了解吗"><a href="#数据库范式了解吗" class="headerlink" title="数据库范式了解吗"></a>数据库范式了解吗</h4><p><strong>1NF(第一范式)</strong></p><p><strong>属性（对应于表中的字段）不能再被分割</strong>，也就是这个字段只能是一个值，不能再分为多个其他的字段了。<strong>1NF 是所有关系型数据库的最基本要求</strong> ，也就是说关系型数据库中创建的表一定满足第一范式。</p><p><strong>2NF(第二范式)</strong></p><p>2NF 在 1NF 的基础之上，<strong>消除了非主属性对于码的部分函数依赖</strong>。如下图所示，展示了第一范式到第二范式的过渡。第二范式在第一范式的基础上增加了一个列，这个列称为主键，非主属性都依赖于主键。</p><p>一些重要的概念：</p><ul><li><strong>函数依赖（functional dependency）</strong> ：若在一张表中，在属性（或属性组）X 的值确定的情况下，必定能确定属性 Y 的值，那么就可以说 Y 函数依赖于 X，写作 X → Y。</li><li><strong>部分函数依赖（partial functional dependency）</strong> ：如果 X→Y，并且存在 X 的一个真子集 X0，使得 X0→Y，则称 Y 对 X 部分函数依赖。比如学生基本信息表 R 中（学号，身份证号，姓名）当然学号属性取值是唯一的，在 R 关系中，（学号，身份证号）-&gt;（姓名），（学号）-&gt;（姓名），（身份证号）-&gt;（姓名）；所以姓名部分函数依赖与（学号，身份证号）；</li><li><strong>完全函数依赖(Full functional dependency)</strong> ：在一个关系中，若某个非主属性数据项依赖于全部关键字称之为完全函数依赖。比如学生基本信息表 R（学号，班级，姓名）假设不同的班级学号有相同的，班级内学号不能相同，在 R 关系中，（学号，班级）-&gt;（姓名），但是（学号）-&gt;(姓名)不成立，（班级）-&gt;(姓名)不成立，所以姓名完全函数依赖与（学号，班级）；</li><li><strong>传递函数依赖</strong> ： 在关系模式 R(U)中，设 X，Y，Z 是 U 的不同的属性子集，如果 X 确定 Y、Y 确定 Z，且有 X 不包含 Y，Y 不确定 X，（X∪Y）∩Z=空集合，则称 Z 传递函数依赖(transitive functional dependency) 于 X。传递函数依赖会导致数据冗余和异常。传递函数依赖的 Y 和 Z 子集往往同属于某一个事物，因此可将其合并放到一个表中。比如在关系 R(学号 ,姓名, 系名，系主任)中，学号 → 系名，系名 → 系主任，所以存在非主属性系主任对于学号的传递函数依赖。。</li></ul><p><strong>3NF(第三范式)</strong></p><p>3NF 在 2NF 的基础之上，消除了<strong>非主属性对于码的传递函数依赖</strong> 。符合 3NF 要求的数据库设计，<strong>基本</strong>上解决了数据冗余过大，插入异常，修改异常，删除异常的问题。比如在关系 R(学号 ,姓名, 系名，系主任)中，学号 → 系名，系名 → 系主任，所以存在非主属性系主任对于学号的传递函数依赖，所以该表的设计，不符合 3NF 的要求。</p><p><strong>总结</strong></p><ul><li>1NF：属性不可再分。</li><li>2NF：1NF 的基础之上，消除了非主属性对于码的部分函数依赖。</li><li>3NF：3NF 在 2NF 的基础之上，消除了非主属性对于码的传递函数依赖 。</li></ul><h4 id="什么是存储过程"><a href="#什么是存储过程" class="headerlink" title="什么是存储过程"></a>什么是存储过程</h4><p>我们可以把存储过程看成是一些 SQL 语句的集合，中间加了点逻辑控制语句。存储过程在业务比较复杂的时候是非常实用的，比如很多时候我们完成一个操作可能需要写一大串 SQL 语句，这时候我们就可以写有一个存储过程，这样也方便了我们下一次的调用。存储过程一旦调试完成通过后就能稳定运行，另外，使用存储过程比单纯 SQL 语句执行要快，因为存储过程是预编译过的。</p><p><strong>存储过程在互联网公司应用不多，因为存储过程难以调试和扩展，而且没有移植性，还会消耗数据库资源。</strong></p><h4 id="drop、delete-与-truncate-trvŋˈkeɪt-区别"><a href="#drop、delete-与-truncate-trvŋˈkeɪt-区别" class="headerlink" title="drop、delete 与 truncate ([trʌŋˈkeɪt]) 区别"></a>drop、delete 与 truncate ([trʌŋˈkeɪt]) 区别</h4><ul><li>drop(删除表结构及数据): <code>drop table 表名</code> ，直接将表都删除掉，在删除表的时候使用。</li><li>truncate (清空数据) : <code>truncate table 表名</code> ，<strong>只删除表中的数据，再插入数据的时候自增长 id 又从 1 开始</strong>。</li><li>delete（删除数据） : <code>delete from 表名 where 列名=值</code>，删除某一列的数据</li></ul><h4 id="数据库设计通常分为哪几步"><a href="#数据库设计通常分为哪几步" class="headerlink" title="数据库设计通常分为哪几步"></a>数据库设计通常分为哪几步</h4><ol><li><strong>需求分析</strong> : 分析用户的需求，包括数据、功能和性能需求。</li><li><strong>概念结构设计</strong> : 主要采用 E-R 模型进行设计，包括画 E-R 图。</li><li><strong>逻辑结构设计</strong> : 通过将 E-R 图转换成表，实现从 E-R 模型到关系模型的转换。</li><li><strong>物理结构设计</strong> : 主要是为所设计的数据库选择合适的存储结构和存取路径。</li><li><strong>数据库实施</strong> : 包括编程、测试和试运行</li><li><strong>数据库的运行和维护</strong> : 系统的运行与数据库的日常维护。</li></ol><h3 id="InnoDB-体系架构"><a href="#InnoDB-体系架构" class="headerlink" title="InnoDB 体系架构"></a>InnoDB 体系架构</h3><p>InnoDB 存储引擎有多个内存块，这些内存块组成了一个大的内存池，负责如下工作：</p><ul><li>维护所有进程/线程需要访问的多个内部数据结构。</li><li>缓存磁盘上的数据，方便快速读取，同时在对磁盘文件数据修改之前在这里缓存</li><li>重做日志（redo log）缓冲</li><li>…</li></ul><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20211213195303634.png" style="zoom:50%;" /><p>后台线程的主要作用是负责刷新内存池中的数据，保证缓冲池中的内存缓存的是最近的数据。此外将已修改的数据文件刷新到磁盘文件，同时保证在数据库发生异常的情况下InnoDB能恢复到正常运行状态。</p><h4 id="后台线程"><a href="#后台线程" class="headerlink" title="后台线程"></a>后台线程</h4><p>Master Thread，主要负责将缓冲池中的数据异步刷新到磁盘，保证数据的一致性，包括脏页的刷新、合并插入缓冲（INSERTBUFFER）、UNDO页的回收等</p><p>IO Thread，使用了AIO（Async IO）来处理写IO请求，这样可以极大提高数据库的性能。InnoDB 1.0版本之前共有4个IO Thread，分别是write、read、insert buffer和log IO thread。</p><p>Purge Thread，事务被提交后，其所使用的undolog可能不再需要，因此需要PurgeThread来回收已经使用并分配的undo页。在InnoDB 1.1版本之前，purge操作仅在InnoDB存储引擎的Master Thread中完成。而从InnoDB 1.1版本开始，purge操作可以独立到单独的线程中进行，以此来减轻Master Thread的工作。</p><p>Page Cleaner Thread，其作用是将之前版本中脏页的刷新操作都放入到单独的线程中来完成。</p><h4 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h4><h5 id="缓冲池"><a href="#缓冲池" class="headerlink" title="缓冲池"></a>缓冲池</h5><p>缓冲池中缓存的数据页类型有：索引页、数据页、undo页、插入缓冲（insert buffer）、自适应哈希索引（adaptive hash index）、InnoDB存储的锁信息（lock info）、数据字典信息（data dictionary）等</p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20211214143027208.png" alt="image-20211214143027208" style="zoom: 25%;" /><h5 id="LRU-List、Free-List和Flush-List"><a href="#LRU-List、Free-List和Flush-List" class="headerlink" title="LRU List、Free List和Flush List"></a>LRU List、Free List和Flush List</h5><p>通常来说，数据库中的缓冲池是通过LRU（Latest Recent Used，最近最少使用）算法来进行管理的。</p><p>在InnoDB的存储引擎中，LRU列表中还加入了midpoint位置。新读取到的页，虽然是最新访问的页，但并不是直接放入到LRU列表的首部，而是放入到LRU列表的midpoint位置。在默认配置下，该位置在LRU列表长度的5/8处。若直接将读取到的页放入到LRU的首部，那么某些SQL操作（索引或数据的扫描操作）可能会使缓冲池中的页被刷新出，从而影响缓冲池的效率。</p><h5 id="重做日志缓冲"><a href="#重做日志缓冲" class="headerlink" title="重做日志缓冲"></a>重做日志缓冲</h5><p>InnoDB存储引擎首先将重做日志信息先放入到这个缓冲区，然后按一定频率将其刷新到重做日志文件。</p><p>重做日志在下列三种情况下会将重做日志缓冲中的内容刷新到外部磁盘的重做日志文件中。</p><ul><li><p>Master Thread每一秒将重做日志缓冲刷新到重做日志文件；</p></li><li><p>每个事务提交时会将重做日志缓冲刷新到重做日志文件；</p></li><li><p>当重做日志缓冲池剩余空间小于1/2时，重做日志缓冲刷新到重做日志文件。</p></li></ul><h5 id="额外的内存池"><a href="#额外的内存池" class="headerlink" title="额外的内存池"></a>额外的内存池</h5><p>在对一些数据结构本身的内存进行分配时，需要从额外的内存池中进行申请，当该区域的内存不够时，会从缓冲池中进行申请。</p><h4 id="Master-Thread工作方式"><a href="#Master-Thread工作方式" class="headerlink" title="Master Thread工作方式"></a>Master Thread工作方式</h4><p>Master Thread具有最高的线程优先级别。其内部由多个循环（loop）组成：主循环（loop）、后台循环（backgroup loop）、刷新循环（flush loop）、暂停循环（suspend loop）。Master Thread会根据数据库运行的状态在loop、background loop、flush loop和suspend loop中进行切换。</p><p>Loop被称为主循环，因为大多数的操作是在这个循环中，其中有两大部分的操作——每秒钟的操作和每10秒的操作。</p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20211214144359014.png" alt="image-20211214144359014" style="zoom:50%;" /><p>每秒一次的操作包括：</p><ul><li><p>日志缓冲刷新到磁盘，即使这个事务还没有提交（总是）；</p></li><li><p>合并插入缓冲（可能）。InnoDB存储引擎会判断当前一秒内发生的IO次数是否小于5次，如果小于5次，InnoDB认为当前的IO压力很小，可以执行合并插入缓冲的操作。</p></li><li><p>至多刷新100个InnoDB的缓冲池中的脏页到磁盘（可能）。InnoDB存储引擎通过判断当前缓冲池中脏页的比例（buf_get_modified_ratio_pct）是否超过了配置文件中innodb_max_dirty_pages_pct这个参数（默认为90，代表90%）如果超过了这个阈值，InnoDB存储引擎认为需要做磁盘同步的操作，将100个脏页写入磁盘中。</p></li><li><p>如果当前没有用户活动，则切换到background loop（可能）。</p></li></ul><p>接着来看每10秒的操作，包括如下内容：</p><ul><li><p>刷新100个脏页到磁盘（可能的情况下）。InnoDB存储引擎会先判断过去10秒之内磁盘的IO操作是否小于200次，如果是，InnoDB存储引擎认为当前有足够的磁盘IO操作能力，因此将100个脏页刷新到磁盘</p></li><li><p>合并至多5个插入缓冲（总是）</p></li><li><p>将日志缓冲刷新到磁盘（总是）</p></li><li><p>删除无用的Undo页（总是）InnoDB存储引擎会判断当前事务系统中已被删除的行是否可以删除，比如有时候可能还有查询操作需要读取之前版本的undo信息，如果可以删除，InnoDB会立即将其删除。</p></li><li><p>刷新100个或者10个脏页到磁盘（总是）。如果有超过70%的脏页，则刷新100个脏页到磁盘，如果脏页的比例小于70%，则只需刷新10%的脏页到磁盘。</p></li></ul><h4 id="InnoDB关键特性"><a href="#InnoDB关键特性" class="headerlink" title="InnoDB关键特性"></a>InnoDB关键特性</h4><h5 id="插入缓冲"><a href="#插入缓冲" class="headerlink" title="插入缓冲"></a>插入缓冲</h5><p>Insert Buffer</p><p>InnoDB存储引擎开创性地设计了Insert Buffer，<strong>对于非聚集索引的插入或更新操作</strong>，不是每一次直接插入到索引页中，而是先判断插入的非聚集索引页是否在缓冲池中，若在，则直接插入；若不在，则先放入到一个Insert Buffer对象中，好似欺骗。再以<strong>一定的频率和情况进行Insert Buffer和辅助索引页子节点的merge（合并）操作</strong>，这时通常能将多个插入合并到一个操作中（因为在一个索引页中），这就大大提高了对于非聚集索引插入的性能。</p><p>Insert Buffer的使用需要同时满足以下两个条件：</p><ul><li>索引是辅助索引（secondary index）；</li><li>索引不是唯一（unique）的。</li></ul><p>辅助索引不能是唯一的，<strong>因为在插入缓冲时，数据库并不去查找索引页来判断插入的记录的唯一性</strong>。如果去查找肯定又会有离散读取的情况发生，从而导致InsertBuffer失去了意义。</p><p>Change Buffer</p><p>InnoDB从1.0.x版本开始引入了Change Buffer，可将其视为Insert Buffer的升级。从这个版本开始，InnoDB存储引擎可以对DML操作——INSERT、DELETE、UPDATE都进行缓冲，他们分别是：Insert Buffer、Delete Buffer、Purgebuffer。<strong>Change Buffer适用的对象依然是非唯一的辅助索引。</strong></p><p>对一条记录进行UPDATE操作可能分为两个过程：□ 将记录标记为已删除；□ 真正将记录删除。因此Delete Buffer对应UPDATE操作的第一个过程，即将记录标记为删除。PurgeBuffer对应UPDATE操作的第二个过程，即将记录真正的删除。</p><p>Merge Insert Buffer</p><p>Insert/Change Buffer是一棵B+树。若需要实现插入记录的辅助索引页不在缓冲池中，那么需要将辅助索引记录首先插入到这棵B+树中。Merge Insert Buffer的操作可能发生在以下几种情况下：</p><ul><li><p>辅助索引页被读取到缓冲池时；</p></li><li><p>Insert Buffer Bitmap页追踪到该辅助索引页已无可用空间时；</p></li><li><p>Master Thread。</p></li></ul><h5 id="两次写"><a href="#两次写" class="headerlink" title="两次写"></a>两次写</h5><p>当发生数据库宕机时，可能InnoDB存储引擎正在写入某个页到表中，而这个页只写了一部分，比如16KB的页，只写了前4KB，之后就发生了宕机，这种情况被称为部分写失效（partial page write）</p><img src="C:\Users\ming hoo\AppData\Roaming\Typora\typora-user-images\image-20211214150703963.png" alt="image-20211214150703963" style="zoom:33%;" /><p>如果发生写失效，可以通过重做日志进行恢复。这是一个办法。但是必须清楚地认识到，重做日志中记录的是对页的物理操作，如偏移量800，写’aaaa’记录。如果这个页本身已经发生了损坏，再对其进行重做是没有意义的。这就是说，在应用（apply）重做日志前，用户需要一个页的副本，当写入失效发生时，先通过页的副本来还原该页，再进行重做，这就是doublewrite。</p><h5 id="自适应哈希索引"><a href="#自适应哈希索引" class="headerlink" title="自适应哈希索引"></a>自适应哈希索引</h5><p>InnoDB存储引擎会监控对表上各索引页的查询。如果观察到建立哈希索引可以带来速度提升，则建立哈希索引，称之为自适应哈希索引（Adaptive Hash Index，AHI）。AHI是通过缓冲池的B+树页构造而来，因此建立的速度很快，而且不需要对整张表构建哈希索引。InnoDB存储引擎会自动根据访问的频率和模式来自动地为某些热点页建立哈希索引。</p><h5 id="异步IO"><a href="#异步IO" class="headerlink" title="异步IO"></a>异步IO</h5><p>为了提高磁盘操作性能，当前的数据库系统都采用异步IO（Asynchronous IO，AIO）的方式来处理磁盘操作。用户可以在发出一个IO请求后立即再发出另一个IO请求，当全部IO请求发送完毕后，等待所有IO操作的完成，这就是AIO。AIO的另一个优势是可以进行IO Merge操作，也就是将多个IO合并为1个IO，这样可以提高IOPS的性能。</p><h5 id="刷新邻接页"><a href="#刷新邻接页" class="headerlink" title="刷新邻接页"></a>刷新邻接页</h5><p>当刷新一个脏页时，InnoDB存储引擎会检测该页所在区（extent）的所有页，如果是脏页，那么一起进行刷新。</p><h5 id="启动、关闭与恢复"><a href="#启动、关闭与恢复" class="headerlink" title="启动、关闭与恢复"></a>启动、关闭与恢复</h5><p>在关闭时，参数innodb_fast_shutdown影响着表的存储引擎为InnoDB的行为。该参数可取值为0、1、2，默认值为1。</p><ul><li><p>0表示在MySQL数据库关闭时，InnoDB需要完成所有的full purge和mergeinsert buffer，并且将所有的脏页刷新回磁盘。这需要一些时间，有时甚至需要几个小时来完成。如果在进行InnoDB升级时，必须将这个参数调为0，然后再关闭数据库。</p></li><li><p>1是参数innodb_fast_shutdown的默认值，表示不需要完成上述的fullpurge和merge insert buffer操作，但是在缓冲池中的一些数据脏页还是会刷新回磁盘。</p></li><li><p>2表示不完成full purge和merge insert buffer操作，也不将缓冲池中的数据脏页写回磁盘，而是将日志都写入日志文件。这样不会有任何事务的丢失，但是下次MySQL数据库启动时，会进行恢复操作（recovery）。</p></li></ul><p>参数innodb_force_recovery影响了整个InnoDB存储引擎恢复的状况。该参数值默认为0，代表<strong>当发生需要恢复时，进行所有的恢复操作，当不能进行有效恢复时</strong>，如数据页发生了corruption，MySQL数据库可能发生宕机（crash），并<strong>把错误写入错误日志中去。</strong></p><h4 id="MyISAM-和-InnoDB-的区别"><a href="#MyISAM-和-InnoDB-的区别" class="headerlink" title="==MyISAM 和 InnoDB 的区别=="></a>==MyISAM 和 InnoDB 的区别==</h4><p>MySQL 5.5 之前，MyISAM 是默认的存储引擎，MyISAM 的性能还行，但它不支持事务和行级锁，而且最大的缺陷是崩溃后无法安全恢复。5.5 版本之后，MySQL 引入了 InnoDB。</p><ul><li><p>MyISAM 只有表级锁，InnoDB 支持行级锁，和表级锁，默认为行级锁。</p></li><li><p>MyISAM 不支持事务，InnoDB 支持，具有提交和回滚的能力</p></li><li><p>MyISAM 不支持外键，InnoDB 支持。一般不建议再数据库层使用外键，通常在应用层进行处理，不过这会对数据一致性造成威胁</p></li><li><p>MyISAM 不支持崩溃后安全恢复，InnoDB 支持。使用 InnoDB 的数据库在异常崩溃后，数据库重新启动时会恢复到崩溃前的状态，这个恢复过程基于 redo log</p></li></ul><p><strong>表级锁和行级锁对比：</strong></p><ul><li><strong>表级锁：</strong> MySQL 中锁定 <strong>粒度最大</strong> 的一种锁，对当前操作的整张表加锁，实现简单，资源消耗也比较少，加锁快，不会出现死锁。其锁定粒度最大，触发锁冲突的概率最高，并发度最低，MyISAM 和 InnoDB 引擎都支持表级锁。</li><li><strong>行级锁：</strong> MySQL 中锁定 <strong>粒度最小</strong> 的一种锁，只针对当前操作的行进行加锁。 行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。</li></ul><p>缓存不命中的情况：</p><ul><li>任何两个查询任何字符上的不同</li><li>查询中包含任何用户自定义函数、存储函数、用户变量、临时表、MySQL 中的系统表</li><li>缓存建立后，表（数据和结构）发生改变，与此表关联的所有缓存将失效</li></ul><p><strong>缓存虽然能够提升数据库的查询性能，但是缓存同时也带来了额外的开销，每次查询后都要做一次缓存操作，失效后还要销毁。</strong> 因此，开启查询缓存要谨慎，尤其对于写密集的应用来说更是如此。</p><p><strong>还可以通过 sql_cache 和 sql_no_cache 来控制某个查询语句是否需要缓存：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> sql_no_cache <span class="keyword">count</span>(*) <span class="keyword">from</span> usr;</span><br></pre></td></tr></table></figure><h3 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h3><h4 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h4><p>重做日志用来实现事务的持久性，即 ACID 中的 D。其由两部分组成：内存中的<strong>重做日志缓冲（redo log buffer）</strong>，其是易失的；重做文件日志（redo log file），其是持久的。</p><p>InnoDB 是事务的存储引擎，其通过 Force Log at Commit 机制实现事务的持久化，即当事务提交（Commit）时，必须先将事务的所有日志写入到 redo log file 中持久化，待事务的 Commit 操作完成才算完成。redo log 基本上都是顺序写的，在数据库运行时不需要对 redo log 文件进行读取操作。</p><p>为了确保重做日志写入磁盘，必须进行一次 fsync 操作，清空 redo log buffer，刷盘到 redo log file 中。</p><p><strong>InnoDB 引擎刷盘策略</strong></p><p>参数 <code>innodb_flush_log_at_trx_commit</code>用来控制重做日志刷新到磁盘的策略，它支持 3 种策略：</p><ul><li>0 ，事务提交时不进行写入重做日志操作，这个操作仅在 master thread 完成，master thread 中每 1 秒会进行一次重做日志文件的 fsync 操作，还有一种情况，当 <code>redo log buffer</code> 占用的空间即将达到 <code>innodb_log_buffer_size</code> 一半的时候，后台线程会主动刷盘。<strong>如果 MySQL 挂了或宕机会有 1 秒的数据丢失</strong>。</li><li>1，为默认值。事务提交时必须调用一次 fsync 操作，只要事务提交成功 ，redo log 就一定在磁盘里，不会有任何数据丢失。如果事务执行期间 MySQL 挂了或宕机，这部分日志丢了，但事务没有提交，所以日志丢了也不会有损失</li><li>2，事务只要提交成功， redo log buffer 中的内容值写入文件系统缓存（page cache），<strong>如果仅仅只是 MySQL 挂了不会有任何损失，宕机可能会有 1 秒的数据损失。</strong></li></ul><p>虽然可以通过设置为 0 和 2 来提高事务提交的性能，但这种设置方法丧失了事务的 ACID 特性。</p><p><strong>为什么不直接把修改的数据刷回磁盘，而是采用 redo log 方式？</strong></p><p>数据页较大，把修改的数据也刷回磁盘时随机写，时间效率较低；如果写 redo log，一行记录占用空间较小，而且是顺序写，性能更好。</p><h4 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h4><p>事务有时需要进行回滚操作，这就需要 undo。在对数据库进行修改时，InnoDB 引擎不仅会产生 redo，还会产生一定量的 undo。如果用户执行的事务或语句由于某种原因失败了，又或者用户用一条 rollback 语句请求回滚，就可以利用这些 undo 信息将数据回滚到修改前的样子。</p><p>与 redo 不同，undo 存放在数据库内部的一个特殊段中，这个段称为 undo 段。许多用户常常有这样的误解：undo 用于将数据库物理地恢复到执行语句或事务之前的样子，但事实并非如此。比如一个事务在修改一个页中的某几条数据，但另一个事务在修改同一个页中的另外几条数据，<strong>不能将一个页回滚到事务开始的样子，这会影响到其他事务正在进行的任务</strong>。当用户 rollback 时，会将插入的事务进行回滚，但表空间的大小并不会因此收缩。对于每个 INSERT，InnoDB 会完成一个 DELETE；对于每个 DELETE，InnoDB 会执行一个 INSERT；对于每个 UPDATE，InnoDB 会执行一个相反的 UPDATE，将修改之前的行放回去。</p><p>除了回滚操作，undo 的另一个作用是 MVCC，当用户读取一行记录时，若该记录已经被其他事务占用，当前事务可以通过 undo 读取之前的行版本信息，以实现非锁定读取。</p><h4 id="binlog"><a href="#binlog" class="headerlink" title="binlog"></a>binlog</h4><p>==<strong>二进制日志（bin log）记录了对 MySQL 数据库执行更改的所有操作</strong>==，不包括 SELECT 和 SHOW 这类操作。若操作本身并没有导致数据库发生变化，那么该操作可能也会写入二进制日志。例如 <code>update t set a = 1 where a = 2</code>，没有 a = 2 的记录，也会写入 bin log。</p><p><code>binlog</code> 日志有三种格式，可以通过<code>binlog_format</code>参数指定。</p><ul><li><strong>statement</strong>，保存原始的 sql 语句，但对于<code>update T set update_time=now() where id=1</code>这条语句来说，直接执行会获取当前时间，这是不对的。</li><li><strong>row</strong>，包含操作的具体数据，<code>update_time=now()</code>变成了具体的时间<code>update_time=1627112756247</code>，@1 表示数据第一个字段的原始值</li><li><strong>mixed</strong>，当数据会产生不一致时使用 row，否则使用 statement</li></ul><h6 id="写入"><a href="#写入" class="headerlink" title="写入"></a>写入</h6><p><code>binlog</code>的写入时机也非常简单，事务执行过程中，先把日志写到<code>binlog cache</code>，事务提交的时候，再把<code>binlog cache</code>写到<code>binlog</code>文件中。因为一个事务的<code>binlog</code>不能被拆开，无论这个事务多大，也要确保一次性写入，所以系统会给每个线程分配一个块内存作为<code>binlog cache</code>。我们可以通过<code>binlog_cache_size</code>参数控制单个线程 binlog cache 大小，如果存储内容超过了这个参数，就要暂存到磁盘（<code>Swap</code>）。</p><p>和 redo log 一样也有 fsync 写入磁盘的策略：</p><p><code>write</code>和<code>fsync</code>的时机，可以由参数<code>sync_binlog</code>控制，默认是<code>0</code>。</p><ul><li><p>为<code>0</code>的时候，表示每次提交事务都只<code>write</code>，由系统自行判断什么时候执行<code>fsync</code>。虽然性能得到提升，但是机器宕机，<code>page cache</code>里面的 binglog 会丢失。</p></li><li><p>可以设置为<code>1</code>，表示每次提交事务都会执行<code>fsync</code>，就如同<strong>redo log 日志刷盘流程</strong>一样。</p></li><li><p>最后还有一种折中方式，可以设置为<code>N(N&gt;1)</code>，表示每次提交事务都<code>write</code>，但累积<code>N</code>个事务后才<code>fsync</code>。</p></li></ul><h6 id="redo-log-两阶段提交"><a href="#redo-log-两阶段提交" class="headerlink" title="redo log 两阶段提交"></a>redo log 两阶段提交</h6><p><code>redo log</code>（重做日志）让<code>InnoDB</code>存储引擎拥有了崩溃恢复能力。<code>binlog</code>（归档日志）保证了<code>MySQL</code>集群架构的数据一致性。</p><p>虽然它们都属于持久化的保证，但是则重点不同。在执行更新语句过程，会记录<code>redo log</code>与<code>binlog</code>两块日志，以基本的事务为单位，<code>redo log</code>在事务执行过程中可以不断写入，而<code>binlog</code>只有在提交事务时才写入，所以<code>redo log</code>与<code>binlog</code>的写入时机不一样。</p><p>假设执行过程中写完<code>redo log</code>日志后，<code>binlog</code>日志写期间发生了异常，这会导致两个日志之间逻辑不一致，为了解决这个问题，InnoDB 使用两阶段提交方案，将 redo log 的写入拆成了两个步骤 prepare 和 commit</p><img src="https://gitee.com/hoo334/picgo/raw/master//img/04.png" alt="img" style="zoom:50%;" /><p>使用<strong>两阶段提交</strong>后，写入<code>binlog</code>时发生异常也不会有影响，因为<code>MySQL</code>根据<code>redo log</code>日志恢复数据时，发现<code>redo log</code>还处于<code>prepare</code>阶段，并且没有对应<code>binlog</code>日志，就会回滚该事务。</p><p>再看一个场景，<code>redo log</code>设置<code>commit</code>阶段发生异常，那会不会回滚事务呢？并不会回滚事务，它会执行上图框住的逻辑，虽然<code>redo log</code>是处于<code>prepare</code>阶段，但是能通过事务<code>id</code>找到对应的<code>binlog</code>日志，所以<code>MySQL</code>认为是完整的，就会提交事务恢复数据。</p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20210907113348007.png" alt="image-20210907113348007" style="zoom:50%;" /><h3 id="锁-1"><a href="#锁-1" class="headerlink" title="锁"></a>锁</h3><p>锁机制用于管理对共享资源的并发访问。</p><h4 id="InnoDB-的锁"><a href="#InnoDB-的锁" class="headerlink" title="InnoDB 的锁"></a>InnoDB 的锁</h4><p>InnoDB存储引擎实现了如下两种标准的行级锁：</p><ul><li>共享锁（S Lock），允许事务读一行数据</li><li>排他锁（X Lock），允许事务删除或更新一行数据</li></ul><p>InnoDB 存储引擎支持多粒度锁定，这种锁定允许事务在行级锁和表级锁上同时存在。为了<strong>支持在不同粒度上进行加锁操作</strong>，InnoDB 支持了一种额外的锁方式，称为意向锁。如果将上锁的对象看成一棵树，对最下层的对象（最细粒度的对象）上锁，那么首先需要对粗粒度的对象上锁。例如如果需要对页上的记录 r 进行上 X 锁，那么分别需要对数据库 A、表、页上意向锁 IX，最后对记录 r 上 X 锁。</p><p>意向锁即表级别的锁。设计的目的主要是为了在同一个事务揭示下一行将被请求的锁类型。其支持两种意向锁：</p><ul><li>意向共享锁（IS Lock），事务想要获得一张表中某几行的共享锁</li><li>意向排他锁（IX Lock），事务想要获得一张表中某几行的排他锁</li></ul><p>由于InnoDB支持的是行级锁，意向锁不会阻止除全表扫意外的任何请求。</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20211214195846259.png" alt="image-20211214195846259"></p><h4 id="一致性非锁定读和锁定读"><a href="#一致性非锁定读和锁定读" class="headerlink" title="一致性非锁定读和锁定读"></a>一致性非锁定读和锁定读</h4><h5 id="一致性非锁定读"><a href="#一致性非锁定读" class="headerlink" title="一致性非锁定读"></a>一致性非锁定读</h5><p>指 InnoDB 存储引擎通过行多版本控制的方式来读取当前执行时间数据库中行的数据。如果去读的行正在执行 DELETE 或 UPDATE 操作，这时读取操作不会因此等待行上锁的释放。相反地，InnoDB 存储引擎<strong>会读取行的一个快照数据</strong>。快照数据指该行之前版本的数据，该实现是通过 undo 段来完成。</p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20211214200306404.png" alt="image-20211214200306404" style="zoom:50%;" /><p>在事务隔离级别 READ COMMITTED 和 REPEATABLE READ下，InnoDB 使用非锁定的一致性读。在 READ COMMITTED 事务隔离级别下，对于快照数据，非一致读总是读取<strong>被锁定行的最新一份快照数</strong>据。而在 REPEATABLE READ 事务隔离级别下，对于快照数据，总是<strong>读取事务开始时的行数据版本</strong>。</p><p>在 <code>Repeatable Read</code> 和 <code>Read Committed</code> 两个隔离级别下，如果是执行普通的 <code>select</code> 语句（不包括 <code>select ... lock in share mode</code> ,<code>select ... for update</code>）则会使用 <code>一致性非锁定读（MVCC）</code>。并且在 <code>Repeatable Read</code> 下 <code>MVCC</code> 实现了可重复读和==<strong>防止部分幻读</strong>==</p><h5 id="一致性锁定读"><a href="#一致性锁定读" class="headerlink" title="一致性锁定读"></a>一致性锁定读</h5><p>在某些情况下，用户需要<strong>显式地对数据库读取操作进行加锁以保证数据的逻辑一致性。</strong></p><p>如果执行的是下列语句，就是 锁定读（Locking Reads）</p><ul><li><code>select ... lock in share mode</code></li><li><code>select ... for update</code></li><li><code>insert</code>、<code>update</code>、<code>delete</code> 操作</li></ul><p>在锁定读下，读取的是数据的最新版本，这种读也被称为 <code>当前读（current read）</code>。锁定读会对读取到的记录加锁：</p><ul><li><code>select ... lock in share mode</code>：对记录加 <code>S</code> 锁，其它事务也可以加<code>S</code>锁，如果加 <code>x</code> 锁则会被阻塞</li><li><code>select ... for update</code>、<code>insert</code>、<code>update</code>、<code>delete</code>：对记录加 <code>X</code> 锁，且其它事务不能加任何锁</li></ul><h4 id="自增长与锁"><a href="#自增长与锁" class="headerlink" title="自增长与锁"></a>自增长与锁</h4><p>在 InnoDB  存储引擎的内存结构中，对每个含有自增长值得表都有一个自增长计数器。插入操作会依据这个自增长计数器值加 1 赋予自增长列。这个实现方式称作 AUTO-INC Locking。这种锁其实采用一种特殊得表锁机制，为了提高插入的性能，锁不是在一个事务完成后释放，而是在完成对自增长值插入的 SQL 语句后立即释放。MyISAM 存储引擎是表锁设计，自增长不会考虑并发插入的问题。</p><h4 id="外键和锁"><a href="#外键和锁" class="headerlink" title="外键和锁"></a>外键和锁</h4><p>外键主要用于引用完整性的约束检查。在 InnoDB 存储引擎中，<strong>对于一个外键列，如果没有显式地对这个列加索引，InnoDB 存储引擎自动对其加一个索引，这样可以避免表锁。</strong></p><p>对于外键值的插入或更新，首先需要查询父表中的记录。但是对父表的 SELECT 操作，不是使用一致性非锁定读的方式，因为这样会发生数据不一致的问题，因此这时使用的是 SELECT … LOCK IN SHARE MODE 方式，主动对父表加一个 S 锁。如果此时父表上已经这样加 X 锁，子表上的操作会被阻塞。</p><h4 id="Record-lock、Gap-lock、Next-key-lock"><a href="#Record-lock、Gap-lock、Next-key-lock" class="headerlink" title="Record lock、Gap lock、Next-key lock"></a>Record lock、Gap lock、Next-key lock</h4><ul><li>Record lock：记录锁，单个行记录上的锁</li><li>Gap lock：间隙锁，锁定一个范围，不包括记录本身</li><li>Next-key lock：record+gap 临键锁，锁定一个范围，包含记录本身</li></ul><p>当查询的索引含有唯一属性时，InnoDB 存储引擎会对 Next-key Lock 进行优化，将其降级为 Record Lock，仅锁住索引本身，而不是范围。若唯一索引由多个列组成，而查询仅是查询唯一索引列中的一个，查询其实是 range 类型查询，而不是 point 类型查询，仍会使用 Next-key Lock。</p><h4 id="锁问题"><a href="#锁问题" class="headerlink" title="锁问题"></a>锁问题</h4><h5 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h5><p>在不同的事务下，当前事务可以读到另外事务未提交的数据。</p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20211214202329498.png" alt="image-20211214202329498" style="zoom: 67%;" /><p>会话 A 事务没有提交的情况下，会话 B 读到了它未提交的数据。</p><p>在一些特殊的情况下可以将事务隔离级别设置为 READ UNCOMMITED。例如 replication 环境中的 slave 节点，并在该slave 上的查询并不需要特别精确的值。</p><h5 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h5><p>在一次事务内两次读到的数据不一样，这种情况称为不可重复读。不可重复读和脏读的区别是：脏读读到的是未提交的数据，不可重复读读到的是已提交的数据。</p><img src="C:\Users\ming hoo\AppData\Roaming\Typora\typora-user-images\image-20211214202905107.png" alt="image-20211214202905107" style="zoom:67%;" /><p>会话 A 事务没有提交的情况下，会话 A 读到了会话B事务提交的数据。不可重复读的问题是可以接受的，其读到的是已经提交的数据。 </p><p>在 InnoDB 存储引擎中，通过使用 Next-Key Lock 算法来避免不可重复读的问题。它对于索引的扫描不仅锁住扫描到的索引，还锁住这些索引覆盖的范围（gap）。在这个范围内的插入都是不被允许的，这样就避免的另外的事务在这个范围内插入数据导致的不可重复读问题。</p><h5 id="丢失更新"><a href="#丢失更新" class="headerlink" title="丢失更新"></a>丢失更新</h5><p>一个事务的更新操作会被另一个事务覆盖，从而导致数据的不一致。</p><p>即使在 READ UNCOMMITED 事务隔离级别下，对于行的 DML 操作需要对行或其他粗粒度的对象加锁，都不会导致丢失更新问题，但在逻辑上存在丢失更新的问题。</p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20211214203616398.png" alt="image-20211214203616398" style="zoom:67%;" /><p>经典银行转账例子，一个账户有 10000 元，他用两个网上银行客户端转账，第一次转账 9000 元，因为网络原因需要等待，第二次用另一个客户端转账 1 元操作成功，此时账户余额 9999 元，第一次的转账并没有更新（丢失更新），对方却收到了 9000元。要避免这个问题出现，需要让事务在这种情况下的操作变成串行化，而不是并行操作。<strong>在步骤 2，3 中对需要读取的数据加 X 锁。</strong></p><h5 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h5><p>因为不同锁之间的兼容性关系，在有些时刻一个事务中的锁需要等待另一个事务中的锁释放它所占用的资源，这就是阻塞。阻塞并不是一件坏事，其是为了确保事务可以并发且正常地运行。</p><p>在默认情况下，InnoDB 引擎不会回滚超时引发地错误异常。</p><h5 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h5><p>两个或两个以上的事务在执行过程中因争夺锁资源而造成的互相等待的现象。解决死锁最简单的方法是超时，即等待时间超过设定的阈值时其中一个事务回滚。如果超时的事务所占的权重比较大，已经执行了比较多的操作，占用了较多的 undo log 回滚它是不划算的。</p><p>除了超时机制，当前数据库普遍采用等待图的方式来进行死锁检测。</p><p>等待图要求数据库保存一下两种信息：</p><ul><li>锁的信息链表</li><li>事务等待链表</li></ul><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20211214204854958.png" alt="image-20211214204854958"></p><p>根据这两个信息生成等待图</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20211214204915896.png" alt="image-20211214204915896"></p><p>如果存在回路则存在死锁。通常来说 InnoDB 选择回滚 undo 量最小的事务。</p><h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>事务是逻辑上的一组操作，要么都执行，要么都不执行。</p><h4 id="数据库事务"><a href="#数据库事务" class="headerlink" title="数据库事务"></a>数据库事务</h4><p>数据库事务可以保证多个对数据库的操作（也就是 SQL 语句）构成一个逻辑上的整体。构成这个逻辑上的整体的这些数据库操作遵循：<strong>要么全部执行成功,要么全部不执行</strong> 。</p><h4 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h4><p>关系型数据库（例如：<code>MySQL</code>、<code>SQL Server</code>、<code>Oracle</code> 等）事务都有 <strong>ACID</strong> 特性</p><ol><li><strong>原子性</strong>（<code>Atomicity</code>） ： <strong>事务是最小的执行单位</strong>，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；</li><li><strong>一致性</strong>（<code>Consistency</code>）： <strong>执行事务前后，数据保持一致</strong>，例如转账业务中，无论事务是否成功，转账者和收款人的总额应该是不变的；</li><li><strong>隔离性</strong>（<code>Isolation</code>）： 并发访问数据库时，<strong>一个用户的事务不被其他事务所干扰</strong>，各并发事务之间数据库是独立的；</li><li><strong>持久性</strong>（<code>Durability</code>）： <strong>一个事务被提交之后。它对数据库中数据的改变是持久的</strong>，即使数据库发生故障也不应该对其有任何影响。</li></ol><p>undo log 来保证原子性，redo log 保证持久性，隔离性通过锁和 MVCC 来保证，通过回滚，以及恢复，和在并发环境下的隔离做到一致性。</p><h4 id="事务分类"><a href="#事务分类" class="headerlink" title="事务分类"></a>事务分类</h4><h5 id="扁平事务"><a href="#扁平事务" class="headerlink" title="扁平事务"></a>扁平事务</h5><p>所有操作都处于同一层次，有 BEGIN WORK 开始，COMMIT WORK 或 ROLLBACK WORK 结束，其间的操作都是原子的。主要限制是不能提交或回滚事务的某一部分，或分几个步骤提交。</p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20211214205336561.png" alt="image-20211214205336561" style="zoom:50%;" /><h5 id="带保存点的事务"><a href="#带保存点的事务" class="headerlink" title="带保存点的事务"></a>带保存点的事务</h5><p>允许事务执行过程中回滚到同一事务中较早的状态</p><img src="C:\Users\ming hoo\AppData\Roaming\Typora\typora-user-images\image-20211214205442992.png" alt="image-20211214205442992" style="zoom:50%;" /><h5 id="链事务"><a href="#链事务" class="headerlink" title="链事务"></a>链事务</h5><p>带保存点的扁平事务在系统崩溃时所有保存点消失，链事务思想是，在提交事务时将必要的上下文隐式地传到下一个要开始的事务。</p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20211214205810980.png" alt="image-20211214205810980" style="zoom:50%;" /><h5 id="嵌套事务"><a href="#嵌套事务" class="headerlink" title="嵌套事务"></a>嵌套事务</h5><p>由一个顶层事务控制着各个层次的事务，处在叶节点的事务是扁平事务。</p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20211214205914684.png" alt="image-20211214205914684" style="zoom:50%;" /><h5 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h5><p>一个在分布式环境下运行的扁平事务，因此需要根据数据所在位置访问网络中的不同节点。任何一个步骤失败都会导致整个分布式事务回滚。</p><h4 id="事务的实现"><a href="#事务的实现" class="headerlink" title="事务的实现"></a>事务的实现</h4><p> <strong>redo log(重做日志)</strong> 保证事务的<strong>原子性和持久性</strong>，使用 <strong>undo log(回滚日志)</strong> 来保证事务的<strong>一致性</strong>。</p><p>MySQL InnoDB 引擎通过 <strong>锁机制</strong>、<strong>MVCC</strong> 等手段来保证事务的隔离性（ 默认支持的隔离级别是 <strong><code>REPEATABLE-READ</code></strong> ）。</p><h4 id="并发事务带来的问题"><a href="#并发事务带来的问题" class="headerlink" title="并发事务带来的问题"></a>并发事务带来的问题</h4><p>在典型应用程序中，多个事务并发运行，经常会操作相同的数据来完成各自的任务（多个用户对同一数据进行操作）。并发是必须的，但这会导致以下问题：</p><ul><li>脏读：当一个事务正在访问数据并对数据进行了修改，这种修改还没提交，另一个事务就读到了未提交的数据</li><li>丢失数据：当一个事务修改了数据后，修改还未提交，此时第二个事务也修改了数据，此时第一个事务的修改丢失</li><li>不可重复读：一个事务多次读同一数据，在多次读的过程中，另一个事务<strong>对数据进行了修改</strong>，这就发生了多次读数据不一样的情况</li><li>幻读：一个事务多次读同一数据，在多次读的过程中，另一个事务<strong>插入了一些数据</strong>，在随后的查询中，第一个事务就发现了一些原本不存在的数据</li></ul><h4 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h4><p>SQL 标准定义了四个隔离级别：</p><ul><li><strong>READ-UNCOMMITTED(读取未提交)：</strong> 最低的隔离级别，允许读取尚未提交的数据变更，<strong>可能会导致脏读、幻读或不可重复读</strong>。</li><li><strong>READ-COMMITTED(读取已提交)：</strong> 允许读取并发事务已经提交的数据，<strong>可以阻止脏读，但是幻读或不可重复读仍有可能发生</strong>。</li><li><strong>REPEATABLE-READ(可重复读)：</strong> 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，<strong>可以阻止脏读和不可重复读，但幻读仍有可能发生</strong>。</li><li><strong>SERIALIZABLE(可串行化)：</strong> 最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，<strong>该级别可以防止脏读、不可重复读以及幻读</strong>。</li></ul><hr><table><thead><tr><th>隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>READ-UNCOMMITTED</td><td>√</td><td>√</td><td>√</td></tr><tr><td>READ-COMMITTED</td><td>×</td><td>√</td><td>√</td></tr><tr><td>REPEATABLE-READ</td><td>×</td><td>×</td><td>√</td></tr><tr><td>SERIALIZABLE</td><td>×</td><td>×</td><td>×</td></tr></tbody></table><h4 id="MySQL-默认隔离级别"><a href="#MySQL-默认隔离级别" class="headerlink" title="MySQL 默认隔离级别"></a>MySQL 默认隔离级别</h4><p>MySQL InnoDB 存储引擎的默认支持的隔离级别是 <strong>REPEATABLE-READ（可重读）</strong>。</p><p><strong>MySQL InnoDB 的 REPEATABLE-READ（可重读）并不保证避免幻读，需要应用使用加锁读来保证。而这个加锁度使用到的机制就是 Next-Key Locks。</strong></p><p>因为隔离级别越低，事务请求的锁越少，所以大部分数据库系统的隔离级别都是 <strong>READ-COMMITTED(读取提交内容)</strong> ，但是你要知道的是 InnoDB 存储引擎默认使用 <strong>REPEATABLE-READ（可重读）</strong> 并不会有任何性能损失。</p><p>InnoDB 存储引擎在 <strong>分布式事务</strong> 的情况下一般会用到 <strong>SERIALIZABLE(可串行化)</strong> 隔离级别。</p><blockquote><p>InnoDB 存储引擎提供了对 XA 事务的支持，并通过 XA 事务来支持分布式事务的实现。分布式事务指的是允许多个独立的事务资源（transactional resources）参与到一个全局的事务中。事务资源通常是关系型数据库系统，但也可以是其他类型的资源。全局事务要求在其中的所有参与的事务要么都提交，要么都回滚，这对于事务原有的 ACID 要求又有了提高。另外，在使用分布式事务时，InnoDB 存储引擎的事务隔离级别必须设置为 SERIALIZABLE。</p></blockquote><h4 id="InnoDB-对-MVVC-实现"><a href="#InnoDB-对-MVVC-实现" class="headerlink" title="InnoDB 对 MVVC 实现"></a>InnoDB 对 MVVC 实现</h4><p>MVVC 的实现依赖于：==隐藏字段==、Read View、undo log。在内部实现中，InnoDB 通过数据行的 <code>DB_TRX_ID</code>和<code>Read View</code> 来判断数据的可见性；如不可见，则通过数据行的 <code>DB_ROLL_PTR</code>找到 <code>undo log</code> 中的历史版本。每个事务读到的数据版本可能是不一样的，在同一个事务中，用户只能看到该事务<strong>创建 <code>Read View</code> 之前已经提交的修改</strong>和该<strong>事务本身做的修改</strong>。</p><h5 id="隐藏字段"><a href="#隐藏字段" class="headerlink" title="隐藏字段"></a>隐藏字段</h5><p>InnoDB 存储引擎为每行数据添加了三个隐藏字段：</p><ul><li>DB_TRX_ID(6 字节)：<strong>最后一次插入或更新该行的事务 ID</strong>。此外 delete 操作在内部被视为更新，只不过会在记录头 Record header 中的 delete_flag 标记为已删除</li><li>DB_ROLL_PTR(7 字节)：回滚指针，指向该行的 undo log。如果该行未被更新，则为空</li><li>DB_ROW_ID(6 字节)：如果没有设置主键且该表没有唯一非空索引时，InnoDB 会使用该 id 生成聚簇索引。</li></ul><h5 id="Read-View"><a href="#Read-View" class="headerlink" title="Read View"></a>Read View</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReadView</span> &#123;</span></span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">trx_id_t</span> m_low_limit_id;      <span class="comment">/* 大于等于这个 ID 的事务均不可见 */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">trx_id_t</span> m_up_limit_id;       <span class="comment">/* 小于这个 ID 的事务均可见 */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">trx_id_t</span> m_creator_trx_id;    <span class="comment">/* 创建该 Read View 的事务ID */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">trx_id_t</span> m_low_limit_no;      <span class="comment">/* 事务 Number, 小于该 Number 的 Undo Logs 均可以被 Purge */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">ids_t</span> m_ids;                  <span class="comment">/* 创建 Read View 时的活跃事务列表 */</span></span><br><span class="line"></span><br><span class="line">  m_closed;                     <span class="comment">/* 标记 Read View 是否 close */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Read View</code>主要用来做可见性判断，里面保存了”当前对本事务不可见的其他活跃事务“</p><ul><li><code>m_low_limit_id</code>：<strong>下一个将被分配的事务 ID</strong>。大于等于这个 ID 的数据版本均不可见</li><li><code>m_up_limit_id</code>：活跃事务列表 <code>m_ids</code> 中最小的事务 ID，如果 <code>m_ids</code> 为空，则 <code>m_up_limit_id</code> 为 <code>m_low_limit_id</code>。<strong>小于这个 ID 的数据版本均可见</strong></li><li><code>m_ids</code>：<strong><code>Read View</code></strong> <strong>创建时其他未提交的活跃事务 ID 列表</strong>。创建 <code>Read View</code>时，将当前未提交事务 ID 记录下来，后续即使它们修改了记录行的值，对于当前事务也是不可见的。<code>m_ids</code> 不包括当前事务自己和已提交的事务（正在内存中）</li><li><code>m_creator_trx_id</code>：<strong>创建该 <code>Read View</code> 的事务 ID</strong></li></ul><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20211017194203661.png" alt="image-20211017194203661" style="zoom:50%;" /><h5 id="Undo-log"><a href="#Undo-log" class="headerlink" title="Undo-log"></a>Undo-log</h5><p>undo log 主要有两个作用：</p><ul><li>用于数据恢复</li><li>MVVC，当读取记录时，若该记录被其他事务占用或当前版本对事务不可见，可以通过 undo log 读取之前的版本数据，实现非锁定读。</li></ul><p>在 InnoDB 中 undo log 分为两种：<code>insert undo log</code>和<code>update undo log</code></p><ol><li><code>insert undo log</code>：在 insert 操作中产生的 undo log。insert undo log 只对事务本身可见，对其他事务不可见，在事务提交后直接删除。</li><li><code>update undo log</code>：update 或 delete 操作中产生的 undo log。<strong>该 undo log 可能需要提供 MVCC 机制，因此不能再事务提交时删除。</strong>提交时放入 <code>undo log</code>链表，等待 <code>purge</code>线程进行最后的删除。</li></ol><p>例子</p><ol><li><p>插入时数据初始状态：</p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20211017201459515.png" alt="image-20211017201459515" style="zoom:50%;" /></li><li><p>数据第一次被修改：</p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20211017201533180.png" alt="image-20211017201533180" style="zoom:50%;" /></li><li><p>数据第二次被修改：</p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20211017201719433.png" alt="image-20211017201719433" style="zoom:50%;" /></li></ol><p>不同事务或者相同事务对同一记录行的修改，会使该记录行的 undo log 成为一条链表。</p><h4 id="数据可见性算法"><a href="#数据可见性算法" class="headerlink" title="数据可见性算法"></a>数据可见性算法</h4><p>在 <code>InnoDB</code> 存储引擎中，创建一个新事务后，执行每个 <code>select</code> 语句前，都会创建一个快照（Read View），<strong>快照中保存了当前数据库系统中正处于活跃（没有 commit）的事务的 ID 号</strong>。</p><p>其实简单的说保存的是系统中当前不应该被本事务看到的其他事务 ID 列表（即 m_ids）。当用户在这个事务中要读取某个记录行的时候，<code>InnoDB</code> 会将该记录行的 <code>DB_TRX_ID</code> 与 <code>Read View</code> 中的一些变量及当前事务 ID 进行比较，判断是否满足可见性条件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">changes_visible</span><span class="params">( <span class="keyword">trx_id_t</span> id, <span class="keyword">const</span> <span class="keyword">table_name_t</span>&amp; name)</span> <span class="keyword">const</span> <span class="title">MY_ATTRIBUTE</span><span class="params">((warn_unused_result))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ut_ad(id &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//最新修改该行的事务 id 在当前事务创建之前就提交了，该记录行对当前事务可见</span></span><br><span class="line">    <span class="keyword">if</span> (id &lt; m_up_limit_id || id == m_creator_trx_id) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 检查 id 是否有效</span></span><br><span class="line">    check_trx_id_sanity(id, name);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (id &gt;= m_low_limit_id) &#123;</span><br><span class="line"><span class="comment">// id 大于最大活跃的事务 id，即不可见</span></span><br><span class="line">        <span class="keyword">return</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (m_ids.empty()) &#123;</span><br><span class="line"><span class="comment">// 目前不存在活跃的事务</span></span><br><span class="line">        <span class="keyword">return</span>(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">ids_t</span>::value_type*p = m_ids.data();</span><br><span class="line"><span class="comment">// 利用二分查找搜索 活跃事务列表,如果 id 在 m_up_limit_id 和 m_low_limit_id 之间，且在 m_ids 数组中，代表创建 Read View 时，事务处于活跃状态，因此记录不可见</span></span><br><span class="line">    <span class="keyword">return</span>(!<span class="built_in">std</span>::binary_search(p, p + m_ids.size(), id));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="RC-和-RR-隔离级别下-MVCC-的差异"><a href="#RC-和-RR-隔离级别下-MVCC-的差异" class="headerlink" title="RC 和 RR 隔离级别下 MVCC 的差异"></a>RC 和 RR 隔离级别下 MVCC 的差异</h4><p>在事务隔离级别 RC 和 RR 下，InnoDB 存储引擎使用 MVVC，但它们生成 Read View 的时机却不同。</p><ul><li>在 RC 隔离级别下的 每次 select 查询前都生成一个 Read View（m_ids 列表）</li><li>在 RR 隔离级别下只在 第一次 select 数据前生成一个  Read View（m_ids 列表）</li></ul><blockquote><p><strong>在 RC 隔离级别下，事务在每次查询开始时都会生成并设置新的 Read View，所以导致不可重复读</strong></p></blockquote><h4 id="MVCC-Next-Key-Lock-防止幻读"><a href="#MVCC-Next-Key-Lock-防止幻读" class="headerlink" title="==MVCC + Next-Key-Lock 防止幻读=="></a>==MVCC + Next-Key-Lock 防止幻读==</h4><ol><li><p><strong>执行普通 select，此时会以 MVCC 快照读的方式读取数据</strong></p><p>在快照读的情况下，RR 隔离级别只会在事务开启后的第一次查询生成 <code>Read View</code> ，并使用至事务提交。所以在生成 <code>Read View</code> 之后其它事务所做的更新、插入记录版本对当前事务并不可见，实现了可重复读和防止快照读下的 “幻读”</p></li><li><p><strong>执行 select…for update/lock in share mode、insert、update、delete 等当前读</strong></p><p>在当前读下，读取的都是最新的数据，如果其它事务有插入新的记录，并且刚好在当前事务查询范围内，就会产生幻读！<code>InnoDB</code> 使用 <a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-locking.html#innodb-next-key-locks" target="_blank" rel="noopener">Next-key Lock</a> 来防止这种情况。当执行当前读时，会锁定读取到的记录的同时，锁定它们的间隙，防止其它事务在查询范围内插入数据。只要我不让你插入，就不会发生幻读（间隙锁）。</p></li></ol><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><p>索引是一种用于快速查询和检索数据的数据结构。常见的索引结构有：B 树、B+树和 Hash。</p><h4 id="索引的优缺点"><a href="#索引的优缺点" class="headerlink" title="索引的优缺点"></a>索引的优缺点</h4><p>优点：可以大大加快数据的检索速度（大大减少检索的数据量），通过创建唯一索引，可以保证数据库表中每一行数据的唯一性。</p><p>缺点：创建索引和维护索引需要耗费许多时间，当对表中的数据增删改时，如果有索引，也需要动态的修改索引，影响执行效率。索引需要使用物理文件存储，也会消耗一定空间。</p><p>大多数情况下，索引查询都是全表扫描快，如果数据量不大，索引也不一定带来很大提升。</p><h4 id="B-树、B-树、Hash"><a href="#B-树、B-树、Hash" class="headerlink" title="B+树、B 树、Hash"></a>B+树、B 树、Hash</h4><h5 id="Hash-表"><a href="#Hash-表" class="headerlink" title="Hash 表"></a>Hash 表</h5><p>哈希表是键值对的集合，通过键（key）可以快速取出对应的值（value），因此哈希表可以快速检索数据。处理 Hash 冲突的方法有链地址法和红黑树。</p><p>为什么 MySQL 没有使用其作为索引的数据结构？</p><ol><li>Hash 冲突问题</li><li>Hash 索引不支持顺序和范围查询，这是它最大的缺点</li></ol><p>例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> tb1 <span class="keyword">WHERE</span> <span class="keyword">id</span> &lt; <span class="number">500</span></span><br></pre></td></tr></table></figure><p>在这种情况下，Hash 索引只能把 1- 500 都进行一次hash计算来找到每一行记录，时间复杂度太高。</p><h5 id="B-树-amp-B-树"><a href="#B-树-amp-B-树" class="headerlink" title="B 树 &amp; B+ 树"></a>B 树 &amp; B+ 树</h5><p><strong>B 树&amp; B+树两者有何异同呢？</strong></p><ul><li>B 树的<strong>所有节点既存放键(key) 也存放 数据(data)</strong>，而 <strong>B+树只有叶子节点存放 key 和 data，其他内节点只存放 key</strong>。</li><li>B 树的叶子节点都是独立的;B+树的叶子节点有一条引用链指向与它相邻的叶子节点。</li><li>B 树的检索的过程相当于对范围内的每个节点的关键字做二分查找，可能还没有到达叶子节点，检索就结束了。而 B+树的检索效率就很稳定了，任何查找都是从根节点到叶子节点的过程，叶子节点的顺序检索很明显。</li></ul><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20210906145735073.png" alt="image-20210906145735073"></p><p>B+树插入删除过程</p><p>B 树也称为 B- 树，全称为多路平衡树，B+ 树是 B 树的一种变体，B 树和 B+ 树中的 B 是 Balanced（平衡）的意思。</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20211214162618141.png" alt="image-20211214162618141"></p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20211214162642282.png" alt="image-20211214162642282"></p><h4 id="主键索引与辅助索引"><a href="#主键索引与辅助索引" class="headerlink" title="主键索引与辅助索引"></a>主键索引与辅助索引</h4><h5 id="主键索引（primary-key）"><a href="#主键索引（primary-key）" class="headerlink" title="主键索引（primary key）"></a>主键索引（primary key）</h5><p>数据库的主键列使用的就是主键索引，一张数据表只能由一个主键，并且主键不能为 null，不能重复。</p><p>在 MySQL 的 InnoDB 中，当没有显示地指定表地主键时，InnoDB会自动先检查表中是否有唯一索引的字段，如果有，则选择该字段为默认的主键，否则 InnoDB 会自动创建一个 6B 的自增主键。</p><h5 id="二级索引（辅助索引）"><a href="#二级索引（辅助索引）" class="headerlink" title="二级索引（辅助索引）"></a>二级索引（辅助索引）</h5><p>二级索引又称为辅助索引，是因为<strong>二级索引的叶子节点存储的数据是主键</strong>。也就是说，通过二级索引，可以定位主键的位置。</p><p>唯一索引，普通索引，前缀索引等属于二级索引。</p><ol><li><strong>唯一索引(Unique Key)</strong> ：唯一索引也是一种约束。<strong>唯一索引的属性列不能出现重复的数据，但是允许数据为 NULL，一张表允许创建多个唯一索引。</strong> 建立唯一索引的目的大部分时候都是为了该属性列的数据的唯一性，而不是为了查询效率。</li><li><strong>普通索引(Index)</strong> ：<strong>普通索引的唯一作用就是为了快速查询数据，一张表允许创建多个普通索引，并允许数据重复和 NULL。</strong></li><li><strong>前缀索引(Prefix)</strong> ：前缀索引只适用于字符串类型的数据。前缀索引是对文本的前几个字符创建索引，相比普通索引建立的数据更小， 因为只取前几个字符。</li><li><strong>全文索引(Full Text)</strong> ：全文索引主要是为了检索大文本数据中的关键字的信息，是目前搜索引擎数据库使用的一种技术。Mysql5.6 之前只有 MYISAM 引擎支持全文索引，5.6 之后 InnoDB 也支持了全文索引。</li></ol><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20210906150839294.png" alt="image-20210906150839294"></p><h4 id="聚集索引与非聚集索引"><a href="#聚集索引与非聚集索引" class="headerlink" title="聚集索引与非聚集索引"></a>聚集索引与非聚集索引</h4><h5 id="聚集索引"><a href="#聚集索引" class="headerlink" title="聚集索引"></a><strong>聚集索引</strong></h5><p><strong>结构和数据一起存放的索引，主键索引属于聚集索引。</strong></p><blockquote><p>在 Mysql 中，InnoDB 引擎的表的 <code>.ibd</code>文件就包含了该表的索引和数据，对于 InnoDB 引擎表来说，该表的索引(B+树)的每个非叶子节点存储索引，叶子节点存储索引和索引对应的数据。</p></blockquote><p>聚集索引优点：查询速度快，因为整个 B+ 树本身就是一颗多叉平衡树，叶子节点也是有序的，定位到索引的节点，就相当于定位到了数据。</p><p>聚集索引的缺点：</p><ol><li><strong>依赖于有序的数据</strong>：因为 B+ 树是多路平衡树，如果索引的数据不是有序的，就需要在插入时排序，当数据是字符串或者 UUID 这种又长又没有顺序的数据，插入或查找的速度肯定比较慢。</li><li><strong>更新代价大</strong>：如果对索引列的数据被修改时，那么对应的索引也将会被修改，所以对于主键索引来说，主键一般是不可以修改的。</li></ol><h5 id="非聚集索引"><a href="#非聚集索引" class="headerlink" title="非聚集索引"></a><strong>非聚集索引</strong></h5><p><strong>结构和数据分开的索引</strong></p><p><strong>二级索引属于非聚集索引。</strong></p><blockquote><p>MYISAM 引擎的表的.MYI 文件包含了表的索引， 该表的索引(B+树)的每个叶子非叶子节点存储索引， 叶子节点存储索引和索引对应数据的指针，指向.MYD 文件的数据。</p><p><strong>非聚集索引的叶子节点并不一定存放数据的指针， 因为二级索引的叶子节点就存放的是主键，根据主键再回表查数据。</strong></p></blockquote><p>非聚集索引的优点</p><p><strong>更新代价比聚集索引要小</strong> 。非聚集索引的更新代价就没有聚集索引那么大了，非聚集索引的叶子节点是不存放数据的</p><p>非聚集索引的缺点</p><ol><li>跟聚集索引一样，非聚集索引也依赖于有序的数据</li><li>==<strong>可能会二次查询(回表)</strong>== :这应该是非聚集索引最大的缺点了。 <strong>当查到索引对应的指针或主键后，可能还需要根据指针或主键再到数据文件或表中查询</strong>。</li></ol><p>这是 MySQL 的表的文件截图:</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/20210420165311654.png" alt="img"></p><p>聚集索引和非聚集索引:</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/20210420165326946.png" alt="img"></p><p>非聚集索引一定回表查询吗？（覆盖索引）</p><p>非聚集索引不一定回表查询。</p><p>如果仅仅查询索引本身的信息，那么无需回表查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">name</span> <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> <span class="keyword">name</span>=<span class="string">'guang19'</span>;</span><br></pre></td></tr></table></figure><h4 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h4><p>如果一个索引包含（或者说覆盖）所有要查询的字段的值，我们就称之为“覆盖索引“。</p><p>在 InnoDB 存储引擎中，如果不是主键索引，叶子节点存储的是主键+列值。最终还是要通过主键查询一次，这样就会比较慢。覆盖索引就是把要查询的列和索引对应，不做回表操作。</p><p>覆盖索引，即要查询的字段正好是索引的字段，那么直接根据该索引，就可查到数据了，无需回表查询。</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20211017161206969.png" alt="image-20211017161206969"></p><h4 id="创建索引的注意事项"><a href="#创建索引的注意事项" class="headerlink" title="创建索引的注意事项"></a>创建索引的注意事项</h4><ol><li><p><strong>选择合适的字段创建索引</strong></p><ul><li><strong>不为 Null 的字段</strong>，索引字段的数据应该尽量不为 Null，对于数据为Null 的字段，数据库较难优化。</li><li><strong>频繁查询的字段</strong></li><li><strong>条件查询的字段</strong>，被作为 WHERE 条件查询的字段，应该被考虑建立索引 </li><li><strong>频繁需要排序的字段</strong>，索引已经排序，可以利用这个特性加快排序查询时间</li><li><strong>频繁用于连接的字段</strong>，提高多表连接查询的效率</li></ul></li><li><p><strong>被频繁更新的字段应该慎重建立索引</strong></p><p>索引能提高查询的性能，但同时维护索引的成本也不小，如果字段少查询、多修改，这个字段就不适合建立索引</p></li><li><p><strong>尽可能建立联合索引而不是单列索引</strong></p><p>每个索引都对应一颗 B+ 树，如果一个表的字段过多，索引过多，那么占用的磁盘空间也很多。如果是联合索引（多列索引），多个字段在一个索引上，那么会节约很多磁盘空间。</p></li><li><p><strong>避免冗余索引</strong></p><p>冗余索引指的是索引的功能相同，能够命中索引(a, b)就肯定能命中索引(a) ，那么索引(a)就是冗余索引。如（name,city ）和（name ）这两个索引就是冗余索引</p></li><li><p><strong>考虑在字符串类型的字段上使用前缀索引代替普通索引</strong></p><p>前缀索引仅限于字符串类型，较普通索引会占用更小的空间。</p></li></ol><h4 id="使用索引的一些建议"><a href="#使用索引的一些建议" class="headerlink" title="使用索引的一些建议"></a>使用索引的一些建议</h4><ul><li>特大型表不适合建索引，维护开销会很大</li><li>避免 where 子句中对字段施加函数，这会造成无法命中索引</li><li>在使用 InnoDB 时，使用与业务无关的自增主键作为主键</li><li>删除长时间未使用的索引</li><li>在使用 limit 查询缓慢时，可借助索引来提高性能</li></ul><h4 id="MySQL-为表字段添加索引"><a href="#MySQL-为表字段添加索引" class="headerlink" title="MySQL 为表字段添加索引"></a>MySQL 为表字段添加索引</h4><ol><li><p>主键索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="string">`table_name`</span> <span class="keyword">ADD</span> PRIMARY <span class="keyword">KEY</span> ( <span class="string">`column`</span> )</span><br></pre></td></tr></table></figure></li><li><p>唯一索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="string">`table_name`</span> <span class="keyword">ADD</span> <span class="keyword">UNIQUE</span> ( <span class="string">`column`</span> )</span><br></pre></td></tr></table></figure></li><li><p>普通索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="string">`table_name`</span> <span class="keyword">ADD</span> <span class="keyword">INDEX</span> index_name ( <span class="string">`column`</span> )</span><br></pre></td></tr></table></figure></li><li><p>全文索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="string">`table_name`</span> <span class="keyword">ADD</span> FULLTEXT ( <span class="string">`column`</span>)</span><br></pre></td></tr></table></figure></li><li><p>多列索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="string">`table_name`</span> <span class="keyword">ADD</span> <span class="keyword">INDEX</span> index_name ( <span class="string">`column1`</span>, <span class="string">`column2`</span>, <span class="string">`column3`</span> )</span><br></pre></td></tr></table></figure></li></ol><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><h3 id="排序-1"><a href="#排序-1" class="headerlink" title="排序"></a>排序</h3><h5 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertionSort</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">    <span class="comment">//将第 i 个元素与 前面的 0 ~ i-1 个元素比较, 若比其中的元素小则依次交换</span></span><br><span class="line">    <span class="keyword">int</span> n = nums.length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &gt; <span class="number">0</span> &amp;&amp; nums[j] &lt; nums[j - <span class="number">1</span>]; j--)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = nums[j];</span><br><span class="line">            nums[j] = nums[j - <span class="number">1</span>];</span><br><span class="line">            nums[j - <span class="number">1</span>] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.length;</span><br><span class="line">    <span class="comment">//将数组变为 h 有序，即相隔 h 个元素 的元素构成一组，组内有序，将 h 的值逐渐缩小则数组有序。</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> h = n / <span class="number">2</span>; h &gt; <span class="number">0</span>; h /= <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = h; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &gt;= h &amp;&amp; nums[j] &lt; nums[j - h]; j -= h)&#123;</span><br><span class="line">                <span class="keyword">int</span> temp = nums[j];</span><br><span class="line">                nums[j] = nums[j - h];</span><br><span class="line">                nums[j - h] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.length;</span><br><span class="line">    <span class="comment">// 数组尾部的 i 个元素是递增有序的，依次把最大的数放入数组尾部，只用把最大的 n - 1 个数放入数组尾部就排序好了</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++)&#123;</span><br><span class="line">        <span class="comment">//第 i 趟排序需要比较 n - 1 - i 次</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n - <span class="number">1</span> - i; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[j + <span class="number">1</span>] &lt; nums[j])&#123;</span><br><span class="line">                <span class="keyword">int</span> temp = nums[j];</span><br><span class="line">                nums[j] = nums[j + <span class="number">1</span>];</span><br><span class="line">                nums[j + <span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectionSort</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.length;</span><br><span class="line">    <span class="comment">// 数组的前 i 个元素是有序的</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="comment">//依次找出最小的元素与 nums[i] 交换</span></span><br><span class="line">        <span class="keyword">int</span> minIdx = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[j] &lt; nums[minIdx])&#123;</span><br><span class="line">                minIdx = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">        nums[i] = nums[minIdx];</span><br><span class="line">        nums[minIdx] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">    mergeSort(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(hi &lt;= lo)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">    mergeSort(nums, lo, mid);</span><br><span class="line">    mergeSort(nums, mid + <span class="number">1</span>, hi);</span><br><span class="line">    merge(nums, lo, mid, hi);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> lo, <span class="keyword">int</span> mid, <span class="keyword">int</span> hi)</span></span>&#123;</span><br><span class="line">    <span class="comment">//将nums[lo..mid] 和nums[mid+1..hi]归并</span></span><br><span class="line">    <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">    <span class="keyword">int</span> k = lo, i = lo, j = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= mid &amp;&amp; j &lt;= hi)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] &lt; nums[j])&#123;</span><br><span class="line">            result[k++] = nums[i++];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            result[k++] = nums[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= mid)&#123;</span><br><span class="line">        result[k++] = nums[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(j &lt;= hi)&#123;</span><br><span class="line">        result[k++] = nums[j++];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(k = lo; k &lt;= hi; k++)&#123;</span><br><span class="line">        nums[k] = result[k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">    quickSort(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(hi &lt;= lo)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> j = partition(nums, lo, hi);</span><br><span class="line">    quickSort(nums, lo, j - <span class="number">1</span>);</span><br><span class="line">    quickSort(nums, j + <span class="number">1</span>, hi);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span>&#123;</span><br><span class="line">    <span class="comment">//将数组切分为nums[lo..i-1], nums[i], nums[i+1..hi]</span></span><br><span class="line">    <span class="keyword">int</span> i = lo, j = hi;</span><br><span class="line">    <span class="comment">//选取第一个元素为基准点</span></span><br><span class="line">    <span class="keyword">int</span> pivot = nums[lo];</span><br><span class="line">    <span class="keyword">while</span>(i != j)&#123;</span><br><span class="line">        <span class="comment">//从左边开始，不能保证你最后交换的那个数，是小于等于左边的。例如 2，1，4，9</span></span><br><span class="line">        <span class="keyword">while</span>(i &lt; j &amp;&amp; nums[j] &gt;= pivot)&#123;</span><br><span class="line">            --j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j &amp;&amp; nums[i] &lt;= pivot)&#123;</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; j)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">            nums[i] = nums[j];</span><br><span class="line">            nums[j] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    nums[lo] = nums[j];</span><br><span class="line">    nums[j] = pivot;</span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.length;</span><br><span class="line">    <span class="comment">//从第一个非叶子结点开始，从下至上，从右至左调整结构</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">        adjustDown(nums, i, n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//交换堆顶元素与最后一个元素，最大的元素归位。由于破坏了大根堆的特性需要重新调整堆顶元素。</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = n - <span class="number">1</span>; j &gt; <span class="number">0</span>; j--) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[<span class="number">0</span>];</span><br><span class="line">        nums[<span class="number">0</span>] = nums[j];</span><br><span class="line">        nums[j] = temp;</span><br><span class="line">        <span class="comment">//向下调整大根堆</span></span><br><span class="line">        adjustDown(nums, <span class="number">0</span>, j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">adjustDown</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">2</span> * i + <span class="number">1</span>; k &lt; n; k = <span class="number">2</span> * k + <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">//找到两个子结点中较大的一个结点</span></span><br><span class="line">        <span class="keyword">if</span>(k + <span class="number">1</span> &lt; n &amp;&amp; nums[k + <span class="number">1</span>] &gt; nums[k])&#123;</span><br><span class="line">            ++k;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果子结点的值大于父结点的值, 将子节点的值赋给父节点，继续向下调整</span></span><br><span class="line">        <span class="keyword">if</span>(nums[k] &gt; nums[i])&#123;</span><br><span class="line">            <span class="comment">//父结点的值设置为子结点的值</span></span><br><span class="line">            nums[i] = nums[k];</span><br><span class="line">            <span class="comment">//对当前结点继续向下调整</span></span><br><span class="line">            i = k;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        nums[i] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20211121171037450.png" alt="image-20211121171037450"></p><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><h4 id="股票"><a href="#股票" class="headerlink" title="股票"></a>股票</h4><h5 id="121-买卖股票的最佳时机"><a href="#121-买卖股票的最佳时机" class="headerlink" title="121. 买卖股票的最佳时机"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/" target="_blank" rel="noopener">121. 买卖股票的最佳时机</a></h5><p>难度：简单</p><p>给定一个数组 <code>prices</code> ，它的第 <code>i</code> 个元素 <code>prices[i]</code> 表示一支给定股票第 <code>i</code> 天的价格。</p><p>你只能选择 <strong>某一天</strong> 买入这只股票，并选择在 <strong>未来的某一个不同的日子</strong> 卖出该股票。设计一个算法来计算你所能获取的最大利润。</p><p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 <code>0</code> 。</p><!--more--><p> <strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：[7,1,5,3,6,4]</span><br><span class="line">输出：5</span><br><span class="line">解释：在第 2 天（股票价格 &#x3D; 1）的时候买入，在第 5 天（股票价格 &#x3D; 6）的时候卖出，最大利润 &#x3D; 6-1 &#x3D; 5 。</span><br><span class="line">     注意利润不能是 7-1 &#x3D; 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：prices &#x3D; [7,6,4,3,1]</span><br><span class="line">输出：0</span><br><span class="line">解释：在这种情况下, 没有交易完成, 所以最大利润为 0。</span><br></pre></td></tr></table></figure><p> <strong>提示：</strong></p><ul><li><code>1 &lt;= prices.length &lt;= 105</code></li><li><code>0 &lt;= prices[i] &lt;= 104</code></li></ul><p><strong>题解：</strong></p><p>对于只能买卖一次的股票交易，对于 prices 数组中的数对 （<code>prices[i]</code>，<code>prices[j]</code> 且<code>i &lt; j</code>，求 <code>prices[j] - prices[i]</code> 的最大值 。</p><p><strong>方法一：暴力枚举（代码略）</strong></p><p>直接枚举右边界 j，然后向左枚举左边界 i, 维护最大值。</p><ul><li><p>时间：$O(n^2)$</p></li><li><p>空间：$O(1)$ </p></li></ul><p><strong>方法二：一次遍历</strong></p><p>在遍历过程中维护最小值 minStock，省略内层循环。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.length &lt; <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// minStock 为 prices[0 ... i] 中最小值</span></span><br><span class="line">        <span class="keyword">int</span> minStock = prices[<span class="number">0</span>], profit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(prices[i] &gt; minStock)&#123;</span><br><span class="line">                profit = Math.max(profit, prices[i] - minStock);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                minStock = prices[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> profit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>时间：$O(n)$</p></li><li><p>空间：$O(1)$ </p></li></ul><h5 id="122-买卖股票的最佳时机-II"><a href="#122-买卖股票的最佳时机-II" class="headerlink" title="122. 买卖股票的最佳时机 II"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/" target="_blank" rel="noopener">122. 买卖股票的最佳时机 II</a></h5><p>难度：中等</p><p>给定一个数组 <code>prices</code> ，其中 <code>prices[i]</code> 是一支给定股票第 <code>i</code> 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p><p><strong>注意：</strong>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p> <strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: prices &#x3D; [7,1,5,3,6,4]</span><br><span class="line">输出: 7</span><br><span class="line">解释: 在第 2 天（股票价格 &#x3D; 1）的时候买入，在第 3 天（股票价格 &#x3D; 5）的时候卖出, 这笔交易所能获得利润 &#x3D; 5-1 &#x3D; 4 。</span><br><span class="line">     随后，在第 4 天（股票价格 &#x3D; 3）的时候买入，在第 5 天（股票价格 &#x3D; 6）的时候卖出, 这笔交易所能获得利润 &#x3D; 6-3 &#x3D; 3 。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: prices &#x3D; [1,2,3,4,5]</span><br><span class="line">输出: 4</span><br><span class="line">解释: 在第 1 天（股票价格 &#x3D; 1）的时候买入，在第 5 天 （股票价格 &#x3D; 5）的时候卖出, 这笔交易所能获得利润 &#x3D; 5-1 &#x3D; 4 。</span><br><span class="line">     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: prices &#x3D; [7,6,4,3,1]</span><br><span class="line">输出: 0</span><br><span class="line">解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</span><br></pre></td></tr></table></figure><p> <strong>提示：</strong></p><ul><li><code>1 &lt;= prices.length &lt;= 3 * 104</code></li><li><code>0 &lt;= prices[i] &lt;= 104</code></li></ul><p><strong>题解：</strong></p><p><strong>方法一：动态规划</strong></p><p>这次我们可以买卖多次股票，选择第 i - 1天和 第 i 天分析：</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20211022165325957.png" alt="image-20211022165325957"></p><p>第 i 天<strong>有股票</strong>的情况分两种：前一天就有股票；前一天没股票，第 i 天买了股票。</p><p>有股票时的最大利润为两者中的最大值</p><p>类似的，第 i 天<strong>没股票</strong>的情况分两种：前一天没有有股票；前一天有股票，第 i 天买了股票。</p><p>有股票时的最大利润为两者中的最大值</p><p>令 $ f[i][0]$ 为第 i 天<strong>有股票</strong>时的最大利润，令 $ f[i][1]$ 为第 i 天<strong>没股票</strong>时的最大利润，可以得到如下转移方程：<br>$$<br>f[i][0] = max(f[i - 1][0], f[i - 1][1] - prices[i])<br>$$</p><p>$$<br>f[i][1] = max(f[i - 1][1], f[i - 1][0] + prices[i])<br>$$</p><p>初始条件：$ f[i][0] = -prices[0]$，$ f[i][1] = 0$</p><p>第 0 天就持有股票的最大利润为负（利润为 0 时就买了第 0 天的股票），没有持有股票的最大利润为 0 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = prices.length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][<span class="number">2</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">            dp[i][<span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>时间：$O(n)$</p></li><li><p>空间：$O(n)$ </p></li></ul><p>可以看到 第 i 天的状态只与第 i - 1天有关，可以进行空间优化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = prices.length;</span><br><span class="line">        <span class="keyword">int</span> dp0 = <span class="number">0</span>, dp1 = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> newdp0 = Math.max(dp0, dp1 + prices[i]);</span><br><span class="line">            <span class="keyword">int</span> newdp1 = Math.max(dp1, dp0 - prices[i]);</span><br><span class="line">            dp0 = newdp0;</span><br><span class="line">            dp1 = newdp1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>时间：$O(n)$</p></li><li><p>空间：$O(1)$ </p></li></ul><p><strong>方法二：贪心</strong></p><p>由于不限制交易次数，只要今天股价比昨天高，就交易。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> profit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(prices[i] &gt; prices[i - <span class="number">1</span>])&#123;</span><br><span class="line">                profit += prices[i] - prices[i - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> profit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>时间：$O(n)$</p></li><li><p>空间：$O(1)$ </p></li></ul><h5 id="123-买卖股票的最佳时机-III"><a href="#123-买卖股票的最佳时机-III" class="headerlink" title="123. 买卖股票的最佳时机 III"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/" target="_blank" rel="noopener">123. 买卖股票的最佳时机 III</a></h5><p>难度：困难</p><p>给定一个数组，它的第 <code>i</code> 个元素是一支给定的股票在第 <code>i</code> 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 <strong>两笔</strong> 交易。</p><p><strong>注意：</strong>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p> <strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：prices &#x3D; [3,3,5,0,0,3,1,4]</span><br><span class="line">输出：6</span><br><span class="line">解释：在第 4 天（股票价格 &#x3D; 0）的时候买入，在第 6 天（股票价格 &#x3D; 3）的时候卖出，这笔交易所能获得利润 &#x3D; 3-0 &#x3D; 3 。</span><br><span class="line">     随后，在第 7 天（股票价格 &#x3D; 1）的时候买入，在第 8 天 （股票价格 &#x3D; 4）的时候卖出，这笔交易所能获得利润 &#x3D; 4-1 &#x3D; 3 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：prices &#x3D; [1,2,3,4,5]</span><br><span class="line">输出：4</span><br><span class="line">解释：在第 1 天（股票价格 &#x3D; 1）的时候买入，在第 5 天 （股票价格 &#x3D; 5）的时候卖出, 这笔交易所能获得利润 &#x3D; 5-1 &#x3D; 4 。   </span><br><span class="line">     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。   </span><br><span class="line">     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：prices &#x3D; [7,6,4,3,1] </span><br><span class="line">输出：0 </span><br><span class="line">解释：在这个情况下, 没有交易完成, 所以最大利润为 0。</span><br></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：prices &#x3D; [1]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure><p> <strong>提示：</strong></p><ul><li><code>1 &lt;= prices.length &lt;= 105</code></li><li><code>0 &lt;= prices[i] &lt;= 105</code></li></ul><p>此题与 122 不同的是，限制了交易次数，只能交易两次。</p><p>类似的，我们分析一下第 <code>i</code>天有几个状态，第<code>i - 1</code> 天到第<code>i</code> 天的转移关系是什么样的。</p><p>我们可以将每天分为 5 个状态：没有任何买卖操作，第一次持有股票，第一次卖完股票，第二次持有股票，第二次卖完股票。由于没有任何买卖操作，利润总是 0 ，我们需要计算的只有 4 个状态。</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20211022172452534.png" alt="image-20211022172452534"></p><p>令 $ f[i][0]$ 为第 i 天<strong>第一次持有股票</strong>时的最大利润，令 $ f[i][1]$ 为第 i 天<strong>第一次没有股票</strong>时的最大利润，令 $ f[i][2]$ 为第 i 天<strong>第二次持有股票</strong>时的最大利润，令 $ f[i][3]$ 为第 i 天<strong>第二次没有股票</strong>时的最大利润，可以得到如下转移方程：<br>$$<br>f[i][0] = max(f[i - 1][0],  - prices[i])<br>$$</p><p>$$<br>f[i][1] = max(f[i - 1][1], f[i - 1][0] + prices[i])<br>$$</p><p>$$<br>f[i][2] = max(f[i - 1][2], f[i - 1][1] - prices[i])<br>$$</p><p>$$<br>f[i][3] = max(f[i - 1][3], f[i - 1][2] + prices[i])<br>$$</p><p>初始条件：$ f[i][0] = f[i][2] = -prices[0]$，$ f[i][1] = f[i][3] = 0$</p><p>$f[i][2] = -prices[0]$ 可以理解为买了 prices[0]，然后立马卖了 prices[0]，再次买入 prices[0]，这样就是第二次有股票。</p><p>在考虑边界条件时我们注意到以下事实：</p><blockquote><p>==<strong>无论题目中是否允许同一天买入卖出，这一操作都不会对最终结果造成影响，因为这一操作收益为零</strong>==</p></blockquote><p>我们可以进一步优化上述转移方程：<br>$$<br>f[0] = max(f[0],  - prices[i])<br>$$</p><p>$$<br>f[1] = max(f[1], f[0] + prices[i])<br>$$</p><p>$$<br>f[2] = max(f[2], f[1] - prices[i])<br>$$</p><p>$$<br>f[3] = max(f[3], f[2] + prices[i])<br>$$</p><p>对于$f[0] = max(f[0],  - prices[i])$来说，这是滚动数组常用技巧，左边的 $f[0]$代表<strong>今天</strong>第一次持有股票的最大利润，右边的 $f[0]$代表昨天第一次持有股票的最大利润；</p><p>对于$f[1] = max(f[1], f[0] + prices[i])$来说，左边的 $f[1]$代表<strong>今天</strong>第一次没有股票的最大利润，右边的 $f[1]$代表昨天第一次没有股票的最大利润，此时 $f[0]$应该是代表<strong>昨天</strong>第一次持有股票的最大利润，但由于我们刚才已经把值更新为<strong>今天</strong>第一次持有股票的最大利润。为什么这样转移方程依然正确？</p><blockquote><p>将今天的 <code>f[0]</code>带入 <code>f[1]</code> 计算公式中，得到$f[1] = max(f[1], max(f[0], -prices[i])+ prices[i] \ )$，此时 $f[0]$是代表<strong>昨天</strong>第一次持有股票的最大利润。<strong>我们多考虑了第 i 天买入股票的情况，但同时计算 $f[1]$时，又将股票卖出，这样的利润为 0</strong> ,这一操作收益为零，对结果没有影响。所以我们将新的 $f[0]$值用于计算不会导致错误结果。</p></blockquote><p>后面的依此类推。</p><p>最后，我们手中肯定没有股票，结果在  0, $f[1]$，$f[3]$中选择最大的，由于在状态转移中我们维护的是最大值，且$f[1]$，$f[3]$初始值为 0，0不可能为结果。如果最优解为交易一次，即$f[1]$，那么它也会因为我们在转移时允许在同一天买入并且卖出这一宽松的条件，从$f[1]$转移到$f[3]$，因此最后答案为 $f[3]$。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = prices.length;</span><br><span class="line">        <span class="keyword">int</span>[] f = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>];</span><br><span class="line">        <span class="comment">// 分为 5 个阶段：没买也没卖，买了一次，卖了一次，买了两次且卖了一次，卖了两次</span></span><br><span class="line">        f[<span class="number">0</span>] = f[<span class="number">2</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        f[<span class="number">1</span>] = f[<span class="number">3</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">            f[<span class="number">0</span>] = Math.max(f[<span class="number">0</span>], -prices[i]);</span><br><span class="line">            f[<span class="number">1</span>] = Math.max(f[<span class="number">1</span>], f[<span class="number">0</span>] + prices[i]);</span><br><span class="line">            f[<span class="number">2</span>] = Math.max(f[<span class="number">2</span>], f[<span class="number">1</span>] - prices[i]);</span><br><span class="line">            f[<span class="number">3</span>] = Math.max(f[<span class="number">3</span>], f[<span class="number">2</span>] + prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[<span class="number">3</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>时间：$O(n)$</p></li><li><p>空间：$O(1)$ </p></li></ul><h5 id="188-买卖股票的最佳时机-IV"><a href="#188-买卖股票的最佳时机-IV" class="headerlink" title="188. 买卖股票的最佳时机 IV"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/" target="_blank" rel="noopener">188. 买卖股票的最佳时机 IV</a></h5><p>难度：困难</p><p>给定一个整数数组 <code>prices</code> ，它的第 <code>i</code> 个元素 <code>prices[i]</code> 是一支给定的股票在第 <code>i</code> 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 <strong>k</strong> 笔交易。</p><p><strong>注意：</strong>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p> <strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：k &#x3D; 2, prices &#x3D; [2,4,1]</span><br><span class="line">输出：2</span><br><span class="line">解释：在第 1 天 (股票价格 &#x3D; 2) 的时候买入，在第 2 天 (股票价格 &#x3D; 4) 的时候卖出，这笔交易所能获得利润 &#x3D; 4-2 &#x3D; 2 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：k &#x3D; 2, prices &#x3D; [3,2,6,5,0,3]</span><br><span class="line">输出：7</span><br><span class="line">解释：在第 2 天 (股票价格 &#x3D; 2) 的时候买入，在第 3 天 (股票价格 &#x3D; 6) 的时候卖出, 这笔交易所能获得利润 &#x3D; 6-2 &#x3D; 4 。</span><br><span class="line">     随后，在第 5 天 (股票价格 &#x3D; 0) 的时候买入，在第 6 天 (股票价格 &#x3D; 3) 的时候卖出, 这笔交易所能获得利润 &#x3D; 3-0 &#x3D; 3 。</span><br></pre></td></tr></table></figure><p> <strong>提示：</strong></p><ul><li><code>0 &lt;= k &lt;= 100</code></li><li><code>0 &lt;= prices.length &lt;= 1000</code></li><li><code>0 &lt;= prices[i] &lt;= 1000</code></li></ul><p>此题与 123 类似，但可交易 k 次，由之前的经验可以推导，每天应该有 <code>2 * k + 1</code>个状态。</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20211022200055327.png" alt="image-20211022200055327"></p><p>初始化数组 $f$ ，长度为 $2k + 1$，$f[0] = 0$ 表示没有参与任何交易的利润。$f[2<em>j - 1]$表示第 <code>j</code>次*</em>持有股票<strong>的最大利润，$f[2 * j ]$表示第<code>j</code>次</strong>没有股票**的最大利润，其中$1 &lt;= j &lt;= k$。</p><p>令 $j$ 为 数组 $f$  下标，我们可以写出转移方程：<br>$$<br>f[j] = max(f[j], f[j - 1] - prices[i]), j 为奇数<br>$$</p><p>$$<br>f[j] = max(f[j], f[j - 1] + prices[i]), j 为偶数<br>$$</p><p>同样的，最后的结果为第 k 次没有股票的最大利润$f[2 * k]$。</p><p>初始条件：所有奇数下标位置为 $ -prices[0]$, 所有偶数下标位置为 0，分析过程同 123 题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> n = prices.length;</span><br><span class="line">        <span class="keyword">int</span>[] f = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span> * k + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">2</span> * k; j += <span class="number">2</span>)&#123;</span><br><span class="line">            f[j] = -prices[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">2</span> * k; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>((j &amp; <span class="number">1</span>) == <span class="number">1</span>)&#123; <span class="comment">// 买</span></span><br><span class="line">                    f[j] = Math.max(f[j], f[j - <span class="number">1</span>] - prices[i]);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123; <span class="comment">//卖</span></span><br><span class="line">                    f[j] = Math.max(f[j], f[j - <span class="number">1</span>] + prices[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> f[<span class="number">2</span> * k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>时间：$O(nk)$</p></li><li><p>空间：$O(k)$ </p></li></ul><h5 id="309-最佳买卖股票时机含冷冻期"><a href="#309-最佳买卖股票时机含冷冻期" class="headerlink" title="309. 最佳买卖股票时机含冷冻期"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/" target="_blank" rel="noopener">309. 最佳买卖股票时机含冷冻期</a></h5><p>难度：中等</p><p>给定一个整数数组，其中第 <em>i</em> 个元素代表了第 <em>i</em> 天的股票价格 。</p><p>设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:</p><ul><li>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</li><li>卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。</li></ul><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,0,2]</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]</span><br></pre></td></tr></table></figure><p>显然，每天的状态有：持有股票，没有股票，冷冻期。我们画出今天和昨天的关系图：</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20211022213057682.png" alt="image-20211022213057682"></p><p>定义 $f[i][0]$ 第 <code>i</code> 天有股票， $f[i][1]$ 第 <code>i</code> 天无股票冷冻期， $f[i][2]$ 第 <code>i</code> 天无股票非冷冻期。可得到如下转移方程：<br>$$<br>f[i][0] = max(f[i - 1][0], f[i - 1][2] - prices[i])<br>$$</p><p>$$<br>f[i][1] = f[i - 1][0] + prices[i]<br>$$</p><p>$$<br>f[i][2] = max(f[i - 1][1], f[i - 1][2])<br>$$</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.length &lt; <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> n = prices.length;</span><br><span class="line">        <span class="keyword">int</span>[][] f = <span class="keyword">new</span> <span class="keyword">int</span>[n][<span class="number">3</span>];</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">            f[i][<span class="number">0</span>] = Math.max(f[i - <span class="number">1</span>][<span class="number">0</span>], f[i - <span class="number">1</span>][<span class="number">2</span>] - prices[i]);</span><br><span class="line">            f[i][<span class="number">1</span>] = f[i - <span class="number">1</span>][<span class="number">0</span>] + prices[i];</span><br><span class="line">            f[i][<span class="number">2</span>] = Math.max(f[i - <span class="number">1</span>][<span class="number">2</span>], f[i - <span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(f[n - <span class="number">1</span>][<span class="number">1</span>], f[n - <span class="number">1</span>][<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>时间：$O(n)$</p></li><li><p>空间：$O(n)$ </p></li></ul><p>我们可以只保存最近两天的数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.length &lt; <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> n = prices.length;</span><br><span class="line">        <span class="comment">// f[0] 表示第 i 天持有股票时的最大利润，f[1] 表示无股票冷冻期，f[2] 表示无股票非冷冻期</span></span><br><span class="line">        <span class="keyword">int</span>[] f = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line">        f[<span class="number">0</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span>[] newF = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line">            newF[<span class="number">0</span>] = Math.max(f[<span class="number">0</span>], f[<span class="number">2</span>] - prices[i]);</span><br><span class="line">            newF[<span class="number">1</span>] = f[<span class="number">0</span>] + prices[i];</span><br><span class="line">            newF[<span class="number">2</span>] = Math.max(f[<span class="number">2</span>], f[<span class="number">1</span>]);</span><br><span class="line">            f = newF;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(f[<span class="number">1</span>], f[<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间：$O(n)$</li><li>空间：$O(1)$ </li></ul><h5 id="714-买卖股票的最佳时机含手续费"><a href="#714-买卖股票的最佳时机含手续费" class="headerlink" title="714. 买卖股票的最佳时机含手续费"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/" target="_blank" rel="noopener">714. 买卖股票的最佳时机含手续费</a></h5><p>难度：中等</p><p>给定一个整数数组 <code>prices</code>，其中第 <code>i</code> 个元素代表了第 <code>i</code> 天的股票价格 ；整数 <code>fee</code> 代表了交易股票的手续费用。</p><p>你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。</p><p>返回获得利润的最大值。</p><p><strong>注意：</strong>这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：prices &#x3D; [1, 3, 2, 8, 4, 9], fee &#x3D; 2</span><br><span class="line">输出：8</span><br><span class="line">解释：能够达到的最大利润:  </span><br><span class="line">在此处买入 prices[0] &#x3D; 1</span><br><span class="line">在此处卖出 prices[3] &#x3D; 8</span><br><span class="line">在此处买入 prices[4] &#x3D; 4</span><br><span class="line">在此处卖出 prices[5] &#x3D; 9</span><br><span class="line">总利润: ((8 - 1) - 2) + ((9 - 4) - 2) &#x3D; 8</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：prices &#x3D; [1,3,7,5,10,3], fee &#x3D; 3</span><br><span class="line">输出：6</span><br></pre></td></tr></table></figure><p> <strong>提示：</strong></p><ul><li><code>1 &lt;= prices.length &lt;= 5 * 104</code></li><li><code>1 &lt;= prices[i] &lt; 5 * 104</code></li><li><code>0 &lt;= fee &lt; 5 * 104</code></li></ul><p>此题就是 121 加上卖出手续费。关系图如下：</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20211022214139191.png" alt="image-20211022214139191"></p><p>令 $ f[i][0]$ 为第 i 天<strong>有股票</strong>时的最大利润，令 $ f[i][1]$ 为第 i 天<strong>没股票</strong>时的最大利润，可以得到如下转移方程：<br>$$<br>f[i][0] = max(f[i - 1][0], f[i - 1][1] - prices[i])<br>$$</p><p>$$<br>f[i][1] = max(f[i - 1][1], f[i - 1][0] + prices[i] -fee)<br>$$</p><p>初始条件：$ f[i][0] = -prices[0]$，$ f[i][1] = 0$</p><p>只保存最近两天的数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices, <span class="keyword">int</span> fee)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.length &lt; <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> n = prices.length;</span><br><span class="line">        <span class="keyword">int</span>[] f = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        f[<span class="number">0</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// f[0] 代表持有股票，f[1]代表没有股票</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span>[] newF = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">            newF[<span class="number">0</span>] = Math.max(f[<span class="number">0</span>], f[<span class="number">1</span>] - prices[i]);</span><br><span class="line">            <span class="comment">// 卖出收手续费</span></span><br><span class="line">            newF[<span class="number">1</span>] = Math.max(f[<span class="number">1</span>], f[<span class="number">0</span>] + prices[i] - fee);</span><br><span class="line">            f = newF;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>时间：$O(n)$</p></li><li><p>空间：$O(1)$ </p></li></ul><h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><h3 id="OSI七层协议模型"><a href="#OSI七层协议模型" class="headerlink" title="OSI七层协议模型"></a>OSI七层协议模型</h3><ul><li><p>应用层：由用户自己规定，规定各个应用之间消息传递的形式等，包括各机互访协议，分布式数据库协议等。常见的应用层协议有HTTP协议和FTP等。</p></li><li><p>表示层：在满足用户需求的基础上，尽可能的节省传输费用而设置的，比如传输压缩文件，jpeg或者加密文件等格式。</p></li><li><p>会话层：用于建立和拆除会话。</p></li><li><p>传输层：负责将来自会话层的消息传递给网络层，常见的传输层协议有TCP和UDP等协议。</p></li><li><p>网络层：规定通信网内的路由选择等方式，建立用户间的信息报传输设施。常见的网络层协议有IP，ICMP以及ARP等协议。</p></li><li><p>数据链路层：与建立数据传输链路相关。</p></li><li><p>物理层：规定一些机电性能，也包括工作方式如双工、单工或半双工，建立通信的启动和终止等。</p></li></ul><p>应用层负责的事情，规定各个应用之间消息传递的形式；接下来是不是需要规定传输格式？这就是表示层；然后需要会话层来建立会话；由传输层将数据包传输到网络层，然后通过数据链路来传输；最底层还需要物理层来规定一些物理硬件层面的东西</p><p>常见的传输层协议有TCP和UDP等协议。</p><h3 id="TCP-IP协议有了解吗？"><a href="#TCP-IP协议有了解吗？" class="headerlink" title="TCP/IP协议有了解吗？"></a>TCP/IP协议有了解吗？</h3><p>TCP/IP协议是一系列网络协议的总称，是网络通信的基本骨架。TCP/IP协议模型在OSI七层模型的基础上，通过合并的方式，简化为四层，分别为应用层，传输层，网络层以及链路层。</p><p>我们通常的应用程序都工作在应用层，当各个应用之间通信时，传输层的TCP模块负责给HTTP数据添加TCP头部等信息；网络层的IP模块负责给HTTP数据添加IP头部等信息；链路层添加以太网首部等信息，并且通过电信号来传输数据包；然后数据包会依次经过对方的链路层，网络层，传输层以及应用层，实现数据的通信。</p><h3 id="三次握手以及四次挥手"><a href="#三次握手以及四次挥手" class="headerlink" title="三次握手以及四次挥手"></a>三次握手以及四次挥手</h3><h4 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h4><p>TCP协议是一种可靠的协议，在正式传输数据之前必须通过三次握手建立连接并且互相交换窗口大小。在传输结束之后，通过四次挥手来确认双方都结束数据交互。</p><p>刚开始客户端处于 closed 的状态，服务端处于 listen 状态。然后</p><p>1、 第一次握手：客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号 ISN（c）。此时客户端处于 SYN_Send 状态。</p><p>2、 第二次握手：服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，并且也是指定了自己的初始化序列号 ISN(s)，同时会把客户端的 ISN + 1 作为 ACK 的值，即SYN+ACK包。表示自己已经收到了客户端的 SYN，此时服务器处于 SYN_REVD 的状态。</p><p>3、 第三次握手：客户端收到 SYN 报文之后，会发送一个 ACK 报文，当然，也是一样把服务器的 ISN + 1 作为 ACK 的值，表示已经收到了服务端的 SYN 报文，此时客户端处于 establised 状态。</p><p>4、服务器收到 ACK 报文之后，也处于 establised 状态，此时，双方以建立起了链接</p><p> 作用是为了确认双方的接收与发送能力是否正常。</p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20211209192346891.png" alt="image-20211209192346891" style="zoom:50%;" /><h4 id="为什么需要三次握手？两次可以吗"><a href="#为什么需要三次握手？两次可以吗" class="headerlink" title="为什么需要三次握手？两次可以吗"></a>为什么需要三次握手？两次可以吗</h4><p>第一次握手：客户端发送网络包，服务端收到了。这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。</p><p>第二次握手：服务端发包，客户端收到了。这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时服务器并不能确认客户端的接收能力是否正常。</p><p>第三次握手：客户端发包，服务端收到了。这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常。</p><h4 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a><strong>四次挥手</strong></h4><p>1）客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。</p><p>2）服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。</p><p>3）客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。</p><p>4）服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。</p><p>5）客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2∗∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。</p><p>6）服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20211209192306140.png" alt="image-20211209192306140"></p><h3 id="TIME-WAIT-过多怎么解决？"><a href="#TIME-WAIT-过多怎么解决？" class="headerlink" title="TIME_WAIT 过多怎么解决？"></a>TIME_WAIT 过多怎么解决？</h3><p>开启重用，允许将TIME_WAIT重用与新的连接</p><p>增大最多允许TIME_WAIT的数量</p><p>调整TIME_WAIT_2到TIME_WAIT的超时时间，默认是60s，优化到30s：</p><h3 id="CLOSE-WAIT-状态的原因与解决方法"><a href="#CLOSE-WAIT-状态的原因与解决方法" class="headerlink" title="CLOSE_WAIT 状态的原因与解决方法"></a>CLOSE_WAIT 状态的原因与解决方法</h3><p>CLOSE_WAIT状态的一端都是被动关闭连接的，如果该端的socket程序没有正确关闭从而发送不了FIN信号，将会导致长时间CLOSE_WAIT状态。如果服务器端不执行socket的close()操作，状态就不能由close_wait迁移到last_ack</p><p> 为什么断开连接需要四次？ </p><p>其ACK和FIN包并不是一起发送给客户端的，因为第一次由客户端-&gt;服务端的FIN信号表示的是客户端想要断开连接。服务端先给出ACK确认信号，表示已经收到FIN请求，然后当自己也可以结束的时候，再次发送FIN信号，所以需要挥手交互需要四次</p><h3 id="四次挥手主动方为什么需要等待-2MSL-？"><a href="#四次挥手主动方为什么需要等待-2MSL-？" class="headerlink" title="四次挥手主动方为什么需要等待 2MSL  ？"></a>四次挥手主动方为什么需要等待 2MSL  ？</h3><p>主动关闭方在收到被动一方发出的FIN信号，会立马发送ACK确认信号，之后状态转变为TIME_WAIT，等待2MSL后才会进入CLOSE状态。</p><p>1、为了保证客户端发送的最后一个ACK报文段能够到达服务器。因为这个ACK有可能丢失，从而导致处在LAST-ACK状态的服务器收不到对FIN-ACK的确认报文。服务器会超时重传这个FIN-ACK，接着客户端再重传一次确认，重新启动时间等待计时器。最后客户端和服务器都能正常的关闭。假设客户端不等待2MSL，而是在发送完ACK之后直接释放关闭，一但这个ACK丢失的话，服务器就无法正常的进入关闭连接状态。</p><p>2、还可以防止已失效的报文段。客户端在发送最后一个ACK之后，再经过经过2MSL，就可以使本链接持续时间内所产生的所有报文段都从网络中消失。从保证在关闭连接后不会有还在网络中滞留的报文段去骚扰服务器。</p><p>注意：在服务器发送了FIN-ACK之后，会立即启动超时重传计时器。客户端在发送最后一个ACK之后会立即启动时间等待计时器。</p><h3 id="TCP和UDP区别"><a href="#TCP和UDP区别" class="headerlink" title="TCP和UDP区别"></a>TCP和UDP区别</h3><p>TCP协议进行数据通信之前需要三次握手建立连接，UDP协议不需要建立连接即可发送数据。</p><p>TCP有确认机制，丢包可以重发，保证数据的正确性；UDP不保证正确性，只是单纯的负责发送数据包。</p><p>TCP协议可能会对大数据包进行拆分，并且在接收方进行重组数据包操作；UDP协议是面向报文的，不会进行分片和重组，所以需要注意传输的报文大小。</p><p>网络包中的TCP头部为20个字节；UDP头部只有8个字节。</p><p>TCP利用滑动窗口来实现流量控制。流量控制是为了控制发送方发送速率，保证接收方来得及接受</p><h3 id="TCP协议如何保证传输可靠性"><a href="#TCP协议如何保证传输可靠性" class="headerlink" title="TCP协议如何保证传输可靠性"></a>TCP协议如何保证传输可靠性</h3><p>校验和</p><p>序列号</p><p>确认应答</p><p>超时重传</p><p>连接管理</p><p>流量控制</p><p>拥塞控制</p><p>TCP传输的过程中，发送端开始发送数据的时候，如果刚开始就发送大量的数据，那么就可能造成一些问题。网络可能在开始的时候就很拥堵，如果给网络中在扔出大量数据，那么这个拥堵就会加剧。拥堵的加剧就会产生大量的丢包，就对大量的超时重传，严重影响传输。</p><p>所以TCP引入了慢启动的机制，在开始发送数据时，先发送少量的数据探路。探清当前的网络状态如何，再决定多大的速度进行传输。这时候就引入一个叫做拥塞窗口的概念。发送刚开始定义拥塞窗口为 1，每次收到ACK应答，拥塞窗口加 1。在发送数据之前，首先将拥塞窗口与接收端反馈的窗口大小比对，取较小的值作为实际发送的窗口。</p><p>拥塞窗口的增长是指数级别的。慢启动的机制只是说明在开始的时候发送的少，发送的慢，但是增长的速度是非常快的。为了控制拥塞窗口的增长，不能使拥塞窗口单纯的加倍，设置一个拥塞窗口的阈值，当拥塞窗口大小超过阈值时，不能再按照指数来增长，而是线性的增长。在慢启动开始的时候，慢启动的阈值等于窗口的最大值，一旦造成网络拥塞，发生超时重传时，慢启动的阈值会为原来的一半（这里的原来指的是发生网络拥塞时拥塞窗口的大小），同时拥塞窗口重置为 1。</p><h4 id="IPv4头部"><a href="#IPv4头部" class="headerlink" title="IPv4头部"></a>IPv4头部</h4> <img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20211209192235433.png" alt="image-20211209192235433" style="zoom:50%;" /><p>(1) 16位的源端口号/目的端口号</p><p>  告知目的机器报文段来自哪里(源端口号)以及传给传递给哪个上层协议或者应用程序(目的端口号)。进行TCP通讯时，客户端通常使用系统自动选择的临时端口号，而服务器则使用知名端口号。在Linux系统中，一些知名服务使用的端口号定义在/etc/services中。</p><p>(2) 32位序号</p><p>  一次TCP通讯(从TCP连接的建立到断开)整个过程中，一个传输方向上的字节流的每一个报文的编号。例如主机A和主机B进行TCP通讯，A发送给B的第一个TCP报文中，序号值就被系统设置为某个随机值(ISN, Initial Sequence Number)，在该传输方向(A-&gt;B)的后续TCP报文的序号子将被系统设置为ISN加上该报文所携带的第一个字节在整个字节流的偏移。假设某个TCP报文段传输的数据是整个字节流中的第1024~2048字节，那么该报文的序号值为ISN+1025，下一个报文为ISN+2049。</p><p>(3) 32位的确认号</p><p>  用于对对方发来的TCP报文段的响应，其值为收到的TCP报文段的序号值加1。</p><p>(4) 4位头部长度</p><p>  标志该TCP头部具有多长，单位为字(4字节)，可见TCP头部最长为60字节。</p><p>(5) 6位保留</p><p>(6) 6个标志位</p><p>  ① URG: 表示紧急指针是否有效</p><p>  ② ACK: 表示确认号是否有效(携带ACK标志的TCP报文段称为确认报文段)</p><p>  ③ PSH: 提示接收端应用程序要立即从TCP接收缓冲区读走数据，以腾出空间接收后续的数据。(若应用程序不读走数据，数据会一直留在TCP模块的接收缓冲区)</p><p>  ④ RST: 表示要求对方重新建立连接(携带RST标志的TCP报文段为复位报文段)</p><p>  ⑤ SYN: 表示请求建立一个连接(携带SYN标志的TCP报文段称为同步报文段)</p><p>  ⑥ FIN: 表示通知对方要关闭连接(携带FIN标志的TCP报文段为结束报文段)</p><p>(7) 16位窗口大小</p><p>  这是TCP流量控制的一个手段。此处的窗口指的是接收通告窗口，用于告诉对方本端的TCP接收缓冲区还能容纳多少字节的数据，这样对方就可以控制发送数据的速度。</p><p>(8) 16位校验和</p><p>  由发送端填充，接收端对TCP报文段执行CRC算法以检验TCP报文段在传输过程中是否损坏。作为TCP可靠传输的重要保障，这个校验不仅包括TCP头部，也包括数据部分。</p><p>(9) 16位紧急指针</p><p>存放着一个正的偏移值，该值加上当前报文的序号将得到紧急指针，紧急指针处存放的是紧急数据，是发送端向接收端发送紧急数据的方法。</p><h3 id="TCP协议的拥塞避免算法"><a href="#TCP协议的拥塞避免算法" class="headerlink" title="TCP协议的拥塞避免算法"></a>TCP协议的拥塞避免算法</h3><p>当网络中的资源供应不足，网络的性能就要明显变坏，整个网络的吞吐量随之负荷的增大而下降。也就是说对资源的需求超过了可用的资源，因为传输数据是需要资源的。</p><p>拥塞控制：防止过多的数据注入到网络中，使得网络中的路由器或链路不致过载。</p><p>拥塞避免算法主要有如下两种：</p><p>(1)慢开始  当主机开始发送数据时，如果立即把大量数据字节注入到网络，那么可能会引起网络阻塞，最好的方法是先探测一下，由小到大的逐渐增大发送窗口，也就是由小到大的增大拥塞窗口数值。Cwnd初始值为1，每经过一个传播轮次，cwnd加倍</p><p>(2)拥塞避免  让拥塞窗口cwnd缓慢增大，每经过一个往返时间RTT就把发送放的cwnd+1</p><p>为了防止cwnd增长过大引起网络拥塞，还需设置一个慢开始门限ssthresh状态变量。ssthresh的用法如下：</p><p>当cwnd&lt;ssthresh时，使用慢开始算法。</p><p>当cwnd&gt;ssthresh时，改用拥塞避免算法。</p><p>当cwnd=ssthresh时，慢开始与拥塞避免算法任意。</p><p>快重传  要求接收方在收到一个失序的报文段后就立即发出重复确认（为的是使发送方及早知道有报文段没有到达对方）而不要等到自己发送数据时捎带确认。快重传算法规定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期</p><p>快恢复算法，有以下两个要点:</p><p>①当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把ssthresh门限减半。但是接下去并不执行慢开始算法。</p><p>②考虑到如果网络出现拥塞的话就不会收到好几个重复的确认，所以发送方现在认为网络可能没有出现拥塞。所以此时不执行慢开始算法，而是将cwnd设置为ssthresh的大小，然后执行拥塞避免算法</p><h3 id="HTTP和HTTPS的区别"><a href="#HTTP和HTTPS的区别" class="headerlink" title="HTTP和HTTPS的区别"></a>HTTP和HTTPS的区别</h3><p>HTTP是超文本传输协议，数据明文传输；HTTPS在HTTP的基础上加入了SSL协议，实现数据的加密传输；</p><p>HTTPS需要区申请证书，一般是收费的；</p><p>HTTP默认使用80端口，HTTPS默认使用443端口</p><p>HTTP是超文本传输协议，是一种无状态的协议，是常见的一种应用层协议。HTTP是一个通信规则，规定了客户端发送给服务器的内容格式，也规定了服务器发送给客户端的内容格式。HTTP请求信息：HTTP请求头中可以看到当前请求支持的语言，压缩格式，编码格式以及何种类型的返回文件，Connection以及Cookie，Content-Type等信息。</p><p>HTTP返回信息：HTTP返回信息中包括响应协议，HTTP Code以及Content-Type，时间和Cookie等信息。</p><p>HTTPS 的流程：</p><p>HTTPS在传输的过程中会涉及到三个密钥：</p><p>服务器端的公钥和私钥，用来进行非对称加密</p><p>客户端生成的随机密钥，用来进行对称加密</p><p>一个HTTPS请求实际上包含了两次HTTP传输，可以细分为8步。</p><p>1）客户端发起一个http请求，连接到服务器的443端口。</p><p>2）服务端把自己的信息以数字证书的形式返回给客户端（证书内容有密钥公钥，网站地址，证书颁发机构，失效日期等）。证书中有一个公钥来加密信息，私钥由服务器持有。</p><p>3）验证证书的合法性  客户端收到服务器的响应后会先验证证书的合法性（证书中包含的地址与正在访问的地址是否一致，证书是否过期）。</p><p>4）生成随机密码（RSA签名）如果验证通过，或用户接受了不受信任的证书，浏览器就会生成一个随机的对称密钥（session key），然后用服务器的公钥对客户端密钥进行加密，这样客户端密钥就变成密文了，至此，HTTPS中的第一次HTTP请求结束。</p><p>5）客户端会发起HTTPS中的第二个HTTP请求，将加密之后的客户端密钥发送给服务器。</p><p>6）.服务器接收到客户端发来的密文之后，会用自己的私钥对其进行非对称解密，解密之后的明文就是客户端密钥，然后用客户端密钥对数据进行对称加密，这样数据就变成了密文</p><p>7）然后服务器将加密后的密文发送给客户端</p><p>8）客户端收到服务器发送来的密文，用客户端密钥对其进行对称解密，得到服务器发送的数据。这样HTTPS中的第二个HTTP请求结束，整个HTTPS传输完成。</p> <img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20211209192059065.png" alt="image-20211209192059065" style="zoom:50%;" /><h4 id="常见HTTP协议的状态码"><a href="#常见HTTP协议的状态码" class="headerlink" title="常见HTTP协议的状态码"></a>常见HTTP协议的状态码</h4><p>200（成功）</p><p>300 （多种选择） 针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。</p><p>302 （重定向）：请求重定向到指定网页</p><p>304（未修改）：自从上次请求后，请求的网页未修改过。服务器返回此响应时，不会返回网页内容</p><p>401（未授权）：请求要求身份验证</p><p>403（禁止）：服务器拒绝请求（比如死循环了，一直访问）</p><p>404（未找到）：服务器找不到请求的网页</p><p>405 （方法禁用）:Post请求当成了Get请求直接访问</p><p>500 （服务器内部错误）：服务器遇到一个错误，使其无法为请求提供服务</p><p>502 （错误网关）：服务器从上游接到了无效响应</p><p>504 （ 网关超时）：nginx请求超时，请求一直没有返回</p><h3 id="cookie-和-session"><a href="#cookie-和-session" class="headerlink" title="cookie 和 session"></a>cookie 和 session</h3><p>Cookie ⼀般⽤来保存⽤户信息 Session 的主要作⽤是通过服务端记录⽤户的状态</p><p>HTTP协议是一种无状态的协议，我们可以使用cookie和session来保持会话状态。用户发起请求，服务端收到请求处理后可以生成一个sessionId，并且将sessionId存入cookie中返回给客户端，将session的内容存储在服务器上。在下一次的请求中，客户端带着cookie来请求服务器，服务端从cookie中取出sessionId，实现了用户会话状态的保持。</p><p>这样做有一个缺点是将一些东西存在了服务器上，在用户量较大的情况下，服务器容量会不足。实际情况中，经常是将所需要的会话状态，比如说登录态直接存入cookie并且返回给客户端，下次请求时，服务端直接取出cookie中的信息和参数信息进行比较，保持HTTP会话状态。</p><p>总结：session保存在服务端。cookie保存在客户端,并且cookie有大小限制。</p><p>Session对象：服务端机制将用户请求的信息放在服务器端来保存，服务器采用一种类似散列表的结果来保存信息。当程序需要为某个客户的请求创建一个session时，服务器首先检查这个客户端的请求里是否包含了一个seesion标识，称为session id，若没有则创建。每一个Session对象都是不一样的。他保存的是每一个用户的专有信息。应用范围为单个用户。生存期默认情况下为20分钟，可以自行设置。过了生存期，则自动清空。</p><p>Cookie对象：保存用户登录信息。当用户访问站点时，web服务器发送给用户的不仅仅是一个页面，还有一个包含日期和时间的cookie。用户的浏览器在获得页面的同时，还得到了这个cookie，并且将它保存在用户硬盘上的某个文件夹中。我们可以用其存取非敏感的用户信息，保存时间可以根据需要设定。如果没有设定失效日期，则他的生命周期保存到关闭浏览器为止。Cookie存放的数据量受限制，大多数浏览器为4k，不要存放大数据。</p><p>创建购物车。购物网站通常把已选物品保存在cookie中，这样可以实现不同页面之间数据的同步(同一个域名下是可以共享cookie的)，同时在提交订单的时候又会把这些cookie传到后台。</p><p>跟踪用户行为。例如百度联盟会通过cookie记录用户的偏好信息</p><h3 id="HTTP1-0，HTTP1-1以及HTTP2-0协议的区别"><a href="#HTTP1-0，HTTP1-1以及HTTP2-0协议的区别" class="headerlink" title="HTTP1.0，HTTP1.1以及HTTP2.0协议的区别"></a>HTTP1.0，HTTP1.1以及HTTP2.0协议的区别</h3><p>HTTP1.0是一种无状态，无连接的协议。浏览器的每次请求都需要与服务器建立一个TCP连接，服务器处理完成后立即断开TCP连接（无连接），服务器不跟踪每个客户端也不记录过去的请求（无状态）。也就是默认使用Connection: close</p><p>HTTP/1.1中默认使用Connection: keep-alive，避免了连接建立和释放的开销。但服务器必须按照客户端请求的先后顺序依次回送相应的结果，以保证客户端能够区分出每次请求的响应内容。通过Content-Length字段来判断当前请求的数据是否已经全部接收。不允许同时存在两个并行的响应。</p><p>HTTP2.0协议新增了二进制分帧，多路复用，头部压缩和服务器推送等功能，进一步提高了传输效率。</p><p>而从HTTP/1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头加入这行代码：</p><p>Connection:keep-alive</p><p>在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。HTTP协议的长连接和短连接，实质上是TCP协议的长连接和短连接。</p><h3 id="在浏览器中输⼊url地址-gt-gt-显示主⻚的过程"><a href="#在浏览器中输⼊url地址-gt-gt-显示主⻚的过程" class="headerlink" title="在浏览器中输⼊url地址 -&gt;&gt; 显示主⻚的过程"></a>在浏览器中输⼊url地址 -&gt;&gt; 显示主⻚的过程</h3><p>DNS解析：将域名解析成对应的服务器IP地址。</p><p>TCP连接：拿到域名对应的IP地址之后，浏览器会以一个随机端口（1024&lt;端口&lt;65535）向服务器的WEB程序（常用的有httpd,nginx等）80端口发起TCP的连接请求。这个连接请求到达服务器端后（这中间通过各种路由设备，局域网内除外），进入到网卡，然后是进入到内核的TCP/IP协议栈（用于识别该连接请求，解封包，一层一层的剥开），还有可能要经过Netfilter防火墙（属于内核的模块）的过滤，最终到达WEB程序，最终建立了TCP/IP的连接。</p><p>发送HTTP请求：建立了TCP连接之后，发起一个http请求。一个典型的 http request header 一般需要包括请求的方法，例如 GET 或者 POST 等，不常用的还有 PUT 和 DELETE 、HEAD、OPTION以及 TRACE 方法，一般的浏览器只能发起 GET 或者 POST 请求。</p><p>客户端向服务器发起http请求的时候，会有一些请求信息，请求信息包含三个部分：</p><p>请求方法URI协议/版本</p><p>请求头(Request Header)</p><p>请求正文：</p><p>服务器处理请求并返回HTTP报文：后端从在固定的端口接收到TCP报文开始，它会对TCP连接进行处理，对HTTP协议进行解析，并按照报文格式进一步封装成HTTP Request对象，供上层使用。HTTP报文；就是返回一个HTPP响应。 HTTP响应与HTTP请求相似，HTTP响应也由3个部分构成，分别是：</p><p>状态行</p><p>响应头(Response Header)</p><p>空行</p><p>响应正文</p><p>浏览器解析渲染页面：WebKit渲染的过程：构建dom树 -&gt; 构建render树 -&gt; 布局render树 -&gt; 绘制render树</p><p>连接结束：现在的页面为了优化请求的耗时，默认都会开启持久连接（keep-alive），那么一个TCP连接确切关闭的时机，是这个tab标签页关闭的时候。这个关闭的过程就是著名的四次挥手。关闭是一个全双工的过程，发包的顺序的不一定的</p><h3 id="GET和POST请求的区别和使用场景"><a href="#GET和POST请求的区别和使用场景" class="headerlink" title="GET和POST请求的区别和使用场景"></a>GET和POST请求的区别和使用场景</h3><p>本质上的区别： GET请求、处理、响应过程中只是产生一个TCP数据包，而POST请求会产生两个TCP数据包。 更具体地说，GET请求过程中头和请求正文数据一起到服务器端，而POST请求过程中，先发一个请求头，服务器会先响应一次，然后浏览器再发送一次请求过程中会将正文数据带到服务器端，然后被服务器处理，然后再产生一个状态码，返回对应的状态描述。 (GET相当于一次请求，POST相当于两次请求。所以，显然GET方式请求更加快。</p><p>   另外，GET请求过程中它的主要作用是访问服务器，并从服务器上查询和获取数据，而POST除了查询和获取数据外，它是可以向服务器发送修改的请求的。（GET用于数据的查询和获取，而POST用于查询和获取外，还可用于数据的修改）</p><p>  GET请求的长度限制为4k，而POST没有这方面的限制，另外，GET会将请求参数等相关信息暴露出来，所以相比之下不安全</p><p>   一般对于登录、注册等表单请求，不建议用GET方式请求，一般用POST，因为一些参数信息暴露出来会不安全。另外，对于博客、论坛、数据的上传下载等也最好用POST，因为论坛或者上传下载等前后都可能会产生数据的变化，故用POST。 而一般对于有响应速度要求，并且对信息相对不敏感的，比如查询、搜索等，可以使用GET。</p><h3 id="HTTP请求中的Get和Post方法有哪些区别？"><a href="#HTTP请求中的Get和Post方法有哪些区别？" class="headerlink" title="HTTP请求中的Get和Post方法有哪些区别？"></a>HTTP请求中的Get和Post方法有哪些区别？</h3><p>Get一般用来从服务器上查询获取资源；Post一般用来更新服务器上的资源；</p><p>Get方法将参数直接拼接在了URL后边，明文显示，可以通过浏览器地址栏直接访问；</p><p>Post请求用于提交表单，数据不是明文的，安全性更高；</p><p>Get请求有长度限制，Post请求没有</p><h2 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h2><h3 id="常用注解"><a href="#常用注解" class="headerlink" title="常用注解"></a>常用注解</h3><h4 id="启动注解-SpringBootApplication"><a href="#启动注解-SpringBootApplication" class="headerlink" title="启动注解 @SpringBootApplication"></a>启动注解 @SpringBootApplication</h4><p>@SpringBootApplication是一个复合注解，包含了@SpringBootConfiguration，@EnableAutoConfiguration，@ComponentScan这三个注解</p><p><strong>(1)</strong>  <strong>@SpringBootConfiguration</strong> 注解，继承@Configuration注解，主要用于加载配置文件</p><p>@SpringBootConfiguration继承自@Configuration，二者功能也一致，标注当前类是配置类， 并会将当前类内声明的一个或多个以@Bean注解标记的方法的实例纳入到spring容器中，并且实例名就是方法名。</p><p><strong>(2) @EnableAutoConfiguration</strong> 注解，开启自动配置功能</p><p>@EnableAutoConfiguration可以帮助SpringBoot应用将所有符合条件的@Configuration配置都加载到当前SpringBoot创建并使用的IoC容器。借助于Spring框架原有的一个工具类：SpringFactoriesLoader的支持，@EnableAutoConfiguration可以智能的自动配置功效才得以大功告成</p><p><strong>(3) @ComponentScan</strong> 注解，主要用于组件扫描和自动装配</p><p>@ComponentScan的功能其实就是自动扫描并加载符合条件的组件或bean定义，最终将这些bean定义加载到容器中。我们可以通过basePackages等属性指定@ComponentScan自动扫描的范围，如果不指定，则默认Spring框架实现从声明@ComponentScan所在类的package进行扫描，默认情况下是不指定的，所以SpringBoot的启动类最好放在root package下。</p><h4 id="Controller-相关注解"><a href="#Controller-相关注解" class="headerlink" title="Controller 相关注解"></a>Controller 相关注解</h4><p>1.@Controller控制器，处理http请求。</p><p>2.@RestController 复合注解</p><p>@RestController注解相当于@ResponseBody+@Controller合在一起的作用,RestController使用的效果是将方法返回的对象直接在浏览器上展示成json格式.</p><p>3.@RequestBody:通过HttpMessageConverter读取Request Body并反序列化为Object（泛指）对象</p><p>4.@RequestMapping 是 Spring Web 应用程序中最常被用到的注解之一。这个注解会将 HTTP 请求映射到 MVC 和REST 控制器的处理方法上</p><p>5.@GetMapping用于将HTTP get请求映射到特定处理程序的方法注解</p><p>注解简写：@RequestMapping(value = “/say”,method = RequestMethod.GET)等价于：@GetMapping(value = “/say”)</p><p>6.@PostMapping用于将HTTP post请求映射到特定处理程序的方法注解</p><h4 id="取请求参数值"><a href="#取请求参数值" class="headerlink" title="取请求参数值"></a>取请求参数值</h4><p>@PathVariable:获取url中的数据</p><p>@RequestParam:获取请求参数的值</p><p>@RequestHeader 把Request请求header部分的值绑定到方法的参数上</p><p>@CookieValue 把Request header中关于cookie的值绑定到方法的参数上</p><h4 id="导入配置文件"><a href="#导入配置文件" class="headerlink" title="导入配置文件"></a>导入配置文件</h4><ol><li>@PropertySource注解</li></ol><p>引入单个properties文件：</p><p>@PropertySource(value = {“classpath : xxxx/xxx.properties”})</p><p>引入多个properties文件：</p><p>@PropertySource(value = {“classpath : xxxx/xxx.properties”，”classpath : xxxx.properties”})</p><ol start="2"><li>@ImportResource导入xml配置文件</li></ol><p>可以额外分为两种模式 相对路径classpath，绝对路径（真实路径）file</p><p>注意：单文件可以不写value或locations，value和locations都可用</p><h4 id="相对路径（classpath）"><a href="#相对路径（classpath）" class="headerlink" title="相对路径（classpath）"></a>相对路径（classpath）</h4><p>引入单个xml配置文件：@ImportSource(“classpath : xxx/xxxx.xml”)</p><p>引入多个xml配置文件：@ImportSource(locations={“classpath : xxxx.xml” , “classpath : yyyy.xml”})</p><h4 id="绝对路径（file）"><a href="#绝对路径（file）" class="headerlink" title="绝对路径（file）"></a>绝对路径（file）</h4><p>引入单个xml配置文件：@ImportSource(locations= {“file : d:/hellxz/dubbo.xml”})</p><p>引入多个xml配置文件：@ImportSource(locations= {“file : d:/hellxz/application.xml” , “file : d:/hellxz/dubbo.xml”})</p><p>取值：使用@Value注解取配置文件中的值</p><p>@Value(“${properties中的键}”)</p><p>private String xxx;</p><p>@Import 导入额外的配置信息</p><p>功能类似XML配置的，用来导入配置类，可以导入带有@Configuration注解的配置类或实现了ImportSelector/ImportBeanDefinitionRegistrar。</p><h4 id="全局异常处理"><a href="#全局异常处理" class="headerlink" title="全局异常处理"></a>全局异常处理</h4><p>1.@ControllerAdvice 统一处理异常</p><p>@ControllerAdvice 注解定义全局异常处理类</p><p>2.@ExceptionHandler 注解声明异常处理方法</p><h3 id="Spring-IoC-容器"><a href="#Spring-IoC-容器" class="headerlink" title="Spring IoC 容器"></a>Spring IoC 容器</h3><p>Spring 容器是 Spring 框架的核心。</p><p><strong>IoC</strong>：通常new一个实例，控制权由程序员控制，而”控制反转”是指new实例工作交给Spring容器来做。在Spring中BeanFactory是IOC容器的实际代表者。</p><p>IoC容器：IOC 容器是一个有依赖注入功能的容器，它可以创建对象，IOC 容器负责实例化、定位、配置应用程序中的对象及建立这些对象间的依赖。并管理他们的整个生命周期从创建到销毁。Spring 容器使用依赖注入（DI）来管理组成一个应用程序的组件。这些对象被称为 Spring Beans。</p><p>配置元数据可以通过 XML，Java 注释或 Java 代码来表示。下图是 Spring 如何工作的高级视图。 Spring IoC容器利用 Java 的 POJO 类和配置元数据来生成完全配置和可执行的系统或应用程序。    </p><p>![image-20211209200100083](C:\Users\ming hoo\AppData\Roaming\Typora\typora-user-images\image-20211209200100083.png)</p><p>Spring 提供了以下两种不同类型的容器:</p><p>1.Spring BeanFactory容器</p><p>2.Spring ApplicationContext容器</p><h4 id="Spring-BeanFactory-容器"><a href="#Spring-BeanFactory-容器" class="headerlink" title="Spring BeanFactory 容器"></a>Spring BeanFactory 容器</h4><p>这是一个最简单的容器，它主要的功能是为依赖注入（DI）提供支持，这个容器接口在 org.springframework.beans.factory.BeanFactory中被定义。</p><p>在 Spring 中，有大量对 BeanFactory 接口的实现。其中，最常被使用的是 XmlBeanFactory 类。这个容器从一个 XML 文件中读取配置元数据，由这些元数据来生成一个被配置化的系统或者应用。</p><h4 id="Spring-ApplicationContext-容器"><a href="#Spring-ApplicationContext-容器" class="headerlink" title="Spring ApplicationContext 容器"></a>Spring ApplicationContext 容器</h4><p>Application Context 是 BeanFactory 的子接口，也被称为 Spring 上下文。ApplicationContext 包含 BeanFactory 所有的功能，一般情况下，相对于 BeanFactory，ApplicationContext 会更加优秀。</p><p>Application Context 是 spring 中较高级的容器。和 BeanFactory 类似，它可以加载配置文件中定义的 bean，将所有的 bean 集中在一起，当有请求的时候分配 bean。这个容器在 org.springframework.context.ApplicationContext interface 接口中定义。</p><h4 id="Bean-定义"><a href="#Bean-定义" class="headerlink" title="Bean 定义"></a>Bean 定义</h4><p>被称作 bean 的对象是构成应用程序的支柱也是由 Spring IoC 容器管理的。bean 是一个被实例化，组装，并通过 Spring IoC 容器所管理的对象。这些 bean 是由用容器提供的配置元数据创建的。 </p><p>bean 定义包含称为配置元数据的信息，下述容器也需要知道配置元数据：</p><p>·  如何创建一个 bean</p><p>·  bean 的生命周期的详细信息</p><p>·  bean 的依赖关系</p><p><strong>Bean</strong> <strong>与 Spring</strong> <strong>容器的关系</strong></p><p>下图表达了Bean 与 Spring 容器之间的关系：</p><p> <img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20211209200111996.png" alt="image-20211209200111996"></p><p><strong>Spring</strong> <strong>配置元数据</strong></p><p>Spring IoC 容器完全由实际编写的配置元数据的格式解耦。有下面三个重要的方法把配置元数据提供给 Spring 容器：</p><p>·  基于 XML 的配置文件</p><p>·  基于注解的配置</p><p>·  基于 Java 的配置</p><h4 id="Spring-Bean-作用域"><a href="#Spring-Bean-作用域" class="headerlink" title="Spring Bean 作用域"></a>Spring Bean 作用域</h4><p>singleton 作用域：（默认作用域配置）当一个bean的作用域为 Singleton，那么 Spring IoC 容器会创建该bean的<strong>唯一的共享实例</strong>。</p><p>Singleton 是单例类型，就是在创建起容器时就同时自动创建了一个 bean 的对象，不管你是否使用，他都存在了，每次获取到的对象都是同一个对象。</p><p>prototype 作用域：</p><p>Prototype 作用域的 bean 会导致在每次对该 bean 请求（将其注入到另一个 bean 中，或者以程序的方式调用容器的 getBean() 方法）时都会创建一个新的 bean 实例。Prototype 是原型类型，它在我们创建容器的时候并没有实例化，而是当我们获取bean的时候才会去创建一个对象，而且我们<strong>每次获取到的对象都不是同一个对象</strong>。</p><h4 id="Spring-Bean-生命周期"><a href="#Spring-Bean-生命周期" class="headerlink" title="Spring Bean 生命周期"></a>Spring Bean 生命周期</h4><p>Beand定义、实例化 Instantiation、属性赋值 Populate、初始化 Initialization、销毁 Destruction</p><p>1.Bean的定义过程：</p><p>·  第一步，资源定位，就是Spring根据我们定义的注解(@Component)，找到相应的类。</p><p>·  找到了资源就开始解析，并将定义的信息保存起来，此时，并没有初始化bean,这点需要注意。</p><p>·  然后将bean的定义发布到SpringIoc的容器中，此时,SpringIoc的容器中还是没有Bean的生成。只是定义的信息。</p><p>2.Bean的初始化</p><p>经过Bean的定义，初始化，SPring会继续完成Bean的实例和化和依赖注入，这样从IoC容器中就可以得到一个依赖注入完成的Bean。下图是初始化图的示例：</p><p> <img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20211209200143427.png" alt="image-20211209200143427"></p><p>Bean的生命周期:</p><p> <img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20211209200150953.png" alt="image-20211209200150953"></p><p>ApplicationContext容器中，Bean的生命周期流程如上图所示，流程大致如下：</p><p>1.首先容器启动后，会对scope为singleton且非懒加载的bean进行实例化，</p><p>2.按照Bean定义信息配置信息，注入所有的属性，</p><p>·  如果Bean实现了BeanNameAware接口，会回调该接口的setBeanName()方法，传入该Bean的id，此时该Bean就获得了自己在配置文件中的id，</p><p>·  如果Bean实现了BeanFactoryAware接口,会回调该接口的setBeanFactory()方法，传入该Bean的BeanFactory，这样该Bean就获得了自己所在的BeanFactory，</p><p>·  如果Bean实现了ApplicationContextAware接口,会回调该接口的setApplicationContext()方法，传入该Bean的ApplicationContext，这样该Bean就获得了自己所在的ApplicationContext</p><p>3.初始化</p><p>·  如果有Bean实现了BeanPostProcessor接口，则会回调该接口的postProcessBeforeInitialzation()方法，</p><p>·  如果Bean实现了InitializingBean接口，则会回调该接口的afterPropertiesSet()方法，</p><p>·  如果Bean配置了init-method方法，则会执行init-method配置的方法，</p><p>·  如果有Bean实现了BeanPostProcessor接口，则会回调该接口的postProcessAfterInitialization()方法，</p><p>4.经过流程上述流程之后，就可以正式使用该Bean了,对于scope为singleton的Bean,Spring的ioc容器中会缓存一份该bean的实例，而对于scope为prototype的Bean,每次被调用都会new一个新的对象，期生命周期就交给调用方管理了，不再是Spring容器进行管理了</p><p>5.容器关闭后，如果Bean实现了DisposableBean接口，则会回调该接口的destroy()方法，</p><p>6.如果Bean配置了destroy-method方法，则会执行destroy-method配置的方法，至此，整个Bean的生命周期结束</p><h3 id="Spring-依赖注入"><a href="#Spring-依赖注入" class="headerlink" title="Spring 依赖注入"></a>Spring 依赖注入</h3><ol><li><p>@Repository：DAO层注解，DAO层中接口继承JpaRepository&lt;T,ID extends Serializable&gt;,需要在build.gradle中引入相关jpa的一个jar自动加载。</p></li><li><p>@Service是@Component注解的一个特例，作用在类上</p><p>@Service注解作用域默认为单例</p><p>使用注解配置和类路径扫描时，被@Service注解标注的类会被Spring扫描并注册为Bean</p><p>@Service用于标注服务层组件,表示定义一个bean</p><p>@Service使用时没有传参数，Bean名称默认为当前类的类名，首字母小写</p><p>@Service(“serviceBeanId”)或@Service(value=”serviceBeanId”)使用时传参数，使用value作为Bean名字</p></li><li><p>@Scope作用域注解</p><p>@Scope作用在类上和方法上，用来配置 spring bean 的作用域，它标识 bean 的作用域</p></li><li><p>@Entity实体类注解</p><p>@Table(name =”数据库表名”)，这个注解也注释在实体类上，对应数据库中相应的表。</p><p>@Id、@Column注解用于标注实体类中的字段，pk字段标注为@Id，其余@Column。</p></li><li><p>@Bean产生一个bean的方法</p><p>@Bean明确地指示了一种方法，产生一个bean的方法，并且交给Spring容器管理。支持别名@Bean(“xx-name”)</p></li><li><p>@Component</p><p>把普通pojo实例化到spring容器中，相当于配置文件中的</p><p>泛指各种组件，就是说当我们的类不属于各种归类的时候（不属于@Controller、@Services等的时候），我们就可以使用@Component来标注这个类。</p><p>虽然有了@Autowired,但是我们还是要写一堆bean的配置文件,相当麻烦,而@Component就是告诉spring,我是pojo类,把我注册到容器中吧,spring会自动提取相关信息。那么我们就不用写麻烦的xml配置文件了</p></li><li><p>@Autowired 自动导入</p><p>@Autowired注解作用在构造函数、方法、方法参数、类字段以及注解上</p><p>@Autowired注解可以实现Bean的自动注入</p></li><li><p>@Resource</p><p>其作用与 Autowired 一样。其区别在于 @Autowired 默认按照 Bean 类型装配，而 @Resource 默认按照 Bean 实例名称进行装配。@Resource 中有两个重要属性：name 和 type。</p><p>Spring 将 name 属性解析为 Bean 实例名称，type 属性解析为 Bean 实例类型。如果指定 name 属性，则按实例名称进行装配；如果指定 type 属性，则按 Bean 类型进行装配。</p></li></ol><h3 id="Spring-AOP"><a href="#Spring-AOP" class="headerlink" title="Spring AOP"></a>Spring AOP</h3><p>AOP 采取横向抽取机制，取代了传统纵向继承体系的重复性代码，其应用主要体现在事务处理、日志管理、权限控制、异常处理等方面。</p><p>AOP 提供了对横切的处理思路，它的主要思想是，<strong>将横切逻辑分离出来，封装成切面，通过某种机制将其织入到指定的各个功能模块中去，而不再是同核心业务代码交织在一起</strong>。AOP 使得我们可以暂时忽略掉系统中的横切逻辑，专注于核心业务逻辑的开发，实现横切逻辑与核心业务逻辑的解耦，允许我们对横切代码进行集中管理，消除代码重复。</p><h4 id="AOP-的基本术语"><a href="#AOP-的基本术语" class="headerlink" title="AOP 的基本术语"></a>AOP 的基本术语</h4><p>切面（Aspect）：是对横切逻辑的抽象与封装，一个切面由通知和切点两部分组成。在实际应用中，切面通常用一个类来表示，称其为切面类。</p><p>通知（Advice）：是横切逻辑的具体实现。在实际应用中，通知被定义成切面类中的一个方法，该方法就是用来放横切代码的地方。通知的分类：以目标方法为参照点，根据切入方位的不同，可分为前置通知（Before）、后置通知（AfterReturning）、异常通知（AfterThrowing）、最终通知（After）与环绕通知（Around）5种。</p><p>切点（Pointcut）：用于说明将通知织入到哪个方法上，它是由切点表达式来定义的。</p><p>目标对象（Target）：是指那些即将织入切面的对象。这些对象中已经只剩下干干净净的核心业务逻辑的代码了，所有的横切逻辑的代码都等待 AOP 框架的织入。</p><p>代理对象（Proxy）：是指将切面应用到目标对象之后由 AOP 框架创建的对象。可以简单地理解为，代理对象的功能等于目标对象的核心业务逻辑功能加上横切业务功能。</p><p>织入（Weaving）：是指将切面应用到目标对象从而创建一个新的代理对象的过程。</p><h3 id="spring-AOP-通知流程"><a href="#spring-AOP-通知流程" class="headerlink" title="spring AOP 通知流程"></a>spring AOP 通知流程</h3><p> <img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20211209200210654.png" alt="image-20211209200210654"></p><h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><p>Spring AOP 是通过动态代理技术实现的，默认为JDK，而动态代理是基于反射设计的。</p><ol><li><p>JDK动态代理: 代理的类必须实现一个接口</p><p>JDK动态代理通过反射来接收被代理的类，并且要求被代理的类必须实现一个<strong>接口</strong>，核心是InvocationHandler接口和Proxy类</p></li><li><p>CGLIB动态代理: 动态生成被代理类的子类</p><p>CGLIB（Code Generation Library），是一个代码生成的类库，可以在运行时动态的生成某个类的子类，注意，CGLIB是通过继承的方式做的动态代理，因此如果某个类被标记为final，那么它是无法使用CGLIB做动态代理的</p></li></ol><h3 id="Spring事务"><a href="#Spring事务" class="headerlink" title="Spring事务"></a>Spring事务</h3><p> Spring 为事务管理提供了丰富的功能支持。Spring 事务管理分为<strong>编码式和声明式</strong>的两种方式:</p><p>·  编程式事务:允许用户在代码中精确定义事务的边界。编程式事务管理使用TransactionTemplate或者直接使用底层的PlatformTransactionManager。对于编程式事务管理，spring推荐使用TransactionTemplate。</p><p>·  声明式事务: 基于AOP,有助于用户将操作与事务规则进行解耦。其本质是对方法前后进行拦截，然后在目标方法开始之前创建或者加入一个事务，在执行完目标方法之后根据执行情况提交或者回滚事务。声明式事务管理也有两种常用的方式，一种是在配置文件(xml)中做相关的事务规则声明，另一种是基于@Transactional注解的方式。显然基于注解的方式更简单易用，更清爽。@Transactional注解的使用也是我们本文着重要理解的部分。</p><p>显然声明式事务管理要优于编程式事务管理，这正是spring倡导的非侵入式的开发方式。声明式事务管理使业务代码不受污染，一个普通的POJO对象，只要加上注解就可以获得完全的事务支持。和编程式事务相比，声明式事务唯一不足地方是，后者的最细粒度只能作用到方法级别，无法做到像编程式事务那样可以作用到代码块级别。但是即便有这样的需求，也存在很多变通的方法，比如，可以将需要进行事务管理的代码块独立为方法等等。</p><h4 id="Transactional"><a href="#Transactional" class="headerlink" title="@Transactional"></a>@Transactional</h4><p>​    @Transactional注解 可以作用于接口、接口方法、类以及类方法上。当作用于类上时，该类的所有 public 方法将都具有该类型的事务属性，同时，我们也可以在方法级别使用该标注来覆盖类级别的定义。</p><h2 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h2><h3 id="运行时数据区"><a href="#运行时数据区" class="headerlink" title="运行时数据区"></a>运行时数据区</h3><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20211127201215005.png" alt="image-20211127201215005" style="zoom: 50%;" /><h4 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h4><p>线程私有，当前线程所执行的字节码行号指示器，它是唯一一个不会出现 OOM 的区域。字节码解释器工作时通过改变这个技术器的值来选取下一条需要执行的字节码指令，是程序控制流的指示器，<strong>分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖它来实现</strong>。如果执行的是 Java 方法，它记录的是正在执行的字节码指令的地址，如果执行的是 Native 方法，它应为空（undefined）。</p><h4 id="Java-虚拟机栈"><a href="#Java-虚拟机栈" class="headerlink" title="Java 虚拟机栈"></a>Java 虚拟机栈</h4><p>线程私有，生命周期与线程相同，当程序请求栈深度大于虚拟机所允许的深度（一直递归）或栈扩展（一直分配局部变量）无法申请到足够的内存会抛出 OOM 异常。每个方法被执行的时候，Java 虚拟机栈都会同步创建要给栈帧（Stack Frame）用于存储<strong>局部变量表、操作数栈、动态连接、方法出口</strong>等信息。每个方法被调用直到执行完毕的过程对应一个栈帧在虚拟机栈中从入栈到出栈的过程。</p><p>局部变量表存放了编译器可知的各种 Java 虚拟机基本数据类型、对象引用（指向对象地址或指向对象的句柄）和 returnAddress 类型（返回地址）。这些数据类型在局部变量表以局部变量槽（Slot）来表示，long 和  double 类型的数据会占用两个变量槽，其他的数据类型只占一个。局部变量表所需的内存空间在编译期间完成分配，在方法运行时不会改变局部变量表的大小。</p><h4 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h4><p>线程私有，与Java虚拟机栈类似，在栈深度溢出或栈扩展失败时抛出 OOM，为虚拟机所用到的本地方法服务。</p><h4 id="Java-堆"><a href="#Java-堆" class="headerlink" title="Java 堆"></a>Java 堆</h4><p>线程共享，没有内存完成对象分配时抛出 OOM。Java 世界里几乎所有对象实例都在这里分配。所有线程共享的 Java 堆中可以分出多个<strong>线程私有</strong>的分配缓冲区（Thread Local Allocation Buffer，TLAB），以提升对象分配的效率。Java 堆可以处在物理上不连续的内存空间中，但在逻辑上应被视为连续的。</p><h4 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h4><p>线程共享，无法满足新的内存分配需求时抛出 OOM。用于存储被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。 <strong>JDK 7 的 Hotspot 已经把原本放在永久代的字符串常量池、静态变量等移至 Java 堆中</strong>。这部分内存区域的回收主要针对常量池的回收和对类型的卸载。</p><p>运行时常量池是方法区的一部分。Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是<strong>常量池表，用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法去的运行时常量池中</strong>。除了保存 Class 文件中描述的符号引用外，还会把由符号引用翻译出来的直接引用也存储在运行时常量池中。</p><p>运行时常量池相比 Class 文件常量池的另一个重要特性是具备<strong>动态性</strong>。在运行时也能将新的常量放入池中，例如 <strong>String.intern()</strong> 方法。</p><h4 id="直接内存（不属于运行时数据区）"><a href="#直接内存（不属于运行时数据区）" class="headerlink" title="直接内存（不属于运行时数据区）"></a>直接内存（不属于运行时数据区）</h4><p>受本机总内存大小限制，这部分区域也可能出现 OOM，在 JDK1.4 中加入了 NIO 类，引入了一种基于通道（Channel）与缓冲区（Buffer）的 I/O 方式，它可以<strong>直接使用 Native 函数直接分配堆外内存</strong>，然后通过一个存储在 Java 堆里面的 DirectByteBuffer 对象作为这块内存的引用进行操作，<strong>避免了在 Java 堆和 Native 堆中来回复制数据</strong>。</p><h3 id="对象创建、内存布局与访问定位"><a href="#对象创建、内存布局与访问定位" class="headerlink" title="对象创建、内存布局与访问定位"></a>对象创建、内存布局与访问定位</h3><h4 id="对象创建"><a href="#对象创建" class="headerlink" title="对象创建"></a>对象创建</h4><ol><li><p><strong>检查类加载</strong>。当遇到 new 指令时，首先检查这个指令的参数是否能在常量池中找到一个类的符号引用，并检查这个类是否已经被加载、解析和初始化过。如果没有执行相应的类加载过程。</p></li><li><p><strong>分配内存</strong>。在类加载完成后，对象所需内存就可完全确定。分配内存主要由<strong>指针碰撞</strong>和<strong>空闲列表</strong>两种方法。指针碰撞指向使用的内存与空闲内存的分界点，分配内存仅仅是把指针往空闲内存方向挪动一段与对象大小相等的距离。如果内存不是规整的，已使用的和空闲的内存交错在一起就没法用指针碰撞了。虚拟机维护一个列表，记录哪些内存块可用，分配给对象实例，并更新空闲列表上的记录。当使用 Serial、ParNew 等带压缩整理的收集器时，采用指针碰撞。当使用 CMS 这种基于清除（Sweep）算法的收集器时，理论上只能使用空闲列表来分配内存。</p><p>分配内存线程安全问题，例如指针碰撞，两个线程同时拿到了相同的指针，分别创建对象。虚拟机采用 CAS 和失败重试的方式保证更新操作的原子性。另一种内存分配的动作是，现在线程私有的 TLAB 中分配内存，只有本地缓冲用完了需要同步锁定。</p><p>分配完内存后，将分配到的内存空间（不包括对象头）都初始化为零值。</p></li><li><p><strong>设置对象信息</strong>。例如对象是哪个类的实例、如何能找到类的元数据信息、对象的哈希码（调用 hashCode() 方法时才计算）、对象的 GC 年龄等信息。这些信息存放到对象的对象头中（Object Head）。</p></li><li><p><strong>执行构造函数</strong>。执行Class 文件中的 &lt;init&gt;() 方法，构造对象需要的其他资源和状态信息。</p></li></ol><h4 id="对象内存布局"><a href="#对象内存布局" class="headerlink" title="对象内存布局"></a>对象内存布局</h4><p>对象在堆内存中可以分为三部分：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）。</p><h5 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h5><p>包括两类信息，第一类用于<strong>存储对象自身的运行时数据</strong>，如哈希码、GC 分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向锁时间戳等，这部分数据在 32 位 和 64 位虚拟机（未开启压缩指针）中分别为 32 bit 和 64 bit，官方称其为 Mark Word。</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20211127211726151.png" alt="image-20211127211726151"></p><p>对象头的另一部分是<strong>类型指针</strong>，即对象指向它的类型元数据的指针，Java 虚拟机通过这个指针来确定该对象是哪个类的实例。并不是所有虚拟机的实现都必须在对象数据上保留类型指针。<strong>如果对象是一个 Java 数组，对象头中还必须有一块用于记录数组长度的数据。</strong></p><h5 id="实例数据"><a href="#实例数据" class="headerlink" title="实例数据"></a>实例数据</h5><p>对象真正存储的有效信息，即程序代码里定义的各种类型的字段内容，无论是从父类继承下来的，还是在子类中定义的字段都必须记录起来。字段的存储顺序受虚拟机分配策略参数（-XX:FieldsAllocationStyle）和字段在 Java 源码中定义顺序影响。HotSpot 虚拟机默认分配顺序为 longs/doubles、ints、shorts、chars、bytes/booleans、oops（Ordinary Object Pointers，OOPs）,相同宽度的字段总是被分配到一起存放。父类中定义的变量会出现在子类之前。设置 <code>-XX:CompactFields</code> 参数还可以将子类中较窄的变量插入到父类变量的空隙中。</p><h5 id="对齐填充"><a href="#对齐填充" class="headerlink" title="对齐填充"></a>对齐填充</h5><p>起占位符的作用，HotSpot 虚拟机自动内存管理系统要求对象起始地址必须是 8 字节的整数倍，换句话说，<strong>任何对象的大小必须是 8 字节的整数倍。</strong></p><h4 id="对象访问定位"><a href="#对象访问定位" class="headerlink" title="对象访问定位"></a>对象访问定位</h4><p>Java 程序会通过<strong>栈</strong>上的 reference 数据来操作堆上的具体对象。访问方式分两种：</p><ul><li>句柄访问，堆中有一块内存为句柄池，reference 存储对象的<strong>句柄地址</strong>，句柄中包含了<strong>对象实例数据</strong>与<strong>类型数据</strong>各自具体的地址信息</li><li>直接指针，reference 中存储的直接就是对象地址，少了一次间接访问的开销。对象投中必须包含对象类型的指针。</li></ul><p>使用句柄的好处是在对象移动时只用改动句柄的地址，不用改动栈中 reference 地址；使用直接指针来访问的好处就是速度快。</p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20211127213355991.png" alt="image-20211127213355991" style="zoom:50%;" /><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20211127213434271.png" alt="image-20211127213434271" style="zoom:50%;" /><p>程序计数器、虚拟机栈、本地方法栈3个区域随线程而生，随线程而灭。当方法结束或者线程结束时，内存自然就跟随着回收了。而Java堆和方法区这两个区域内存的分配和回收是动态的，垃圾收集器所关注的是这部分内存该如何管理。</p><h3 id="判断对象死亡"><a href="#判断对象死亡" class="headerlink" title="判断对象死亡"></a>判断对象死亡</h3><h4 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h4><p>在对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加一；当引用失效时，计数器值就减一；任何时刻计数器为零的对象就是不可能再被使用的。</p><p>单纯的引用计数很难解决对象间<strong>相互循环引用</strong>的问题</p><h4 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h4><p>通过 一系列称为“GC Roots”的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过的路径称为引用链，如果某个对象没有没有跟 GC Roots 之间有引用链连接，则该对象是不可能被使用的。</p><h4 id="GC-Roots"><a href="#GC-Roots" class="headerlink" title="==GC Roots=="></a>==GC Roots==</h4><ul><li>虚拟机栈（<strong>栈帧本地变量表</strong>）中引用的对象。例如线程调用方法堆栈中使用到的参数、局部变量、临时变量</li><li>方法区中<strong>类静态引用</strong>的对象，例如 Java 类的引用类型静态变量</li><li>方法区中<strong>常量引用</strong>的对象，例如字符串常量池中的引用</li><li>本地方法栈中引用的对象</li><li>Java 虚拟机内部引用，基本数据类型对应的Class对象，一些常驻的异常对象（比如 NullPointExcepiton、OutOfMemoryError）等，还有系统类加载器。</li><li>所有被同步锁（synchronized关键字）持有的对象。 </li></ul><p>除了这些固定的GC Roots集合以外，根据用户所选用的垃圾收集器以及当前回收的内存区域不同，还可以有其他对象“临时性”地加入，共同构成完整GC Roots集合。<strong>某个区域里的对象完全有可能被位于堆中其他区域的对象所引用</strong>，这时候就需要将这些关联区域的对象也一并加入GC Roots集合中去，才能保证可达性分析的正确性。（局部回收，跨代引用）</p><h4 id="四种引用"><a href="#四种引用" class="headerlink" title="四种引用"></a>四种引用</h4><p>Java里面的引用是很传统的定义： 如果reference类型的数据中存储的数值代表的是另外一块内存的起始地址，就称该reference数据是代表某块内存、某个对象的引用。</p><ul><li><p>强引用，指在程序代码之中普遍存在的引用赋值，即类似“Object obj=new Object()”这种引用关系。无论任何情况下，<strong>只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象</strong>。 </p></li><li><p>软引用，来描述一些还有用，但非必须的对象。只被软引用关联着的对象，在系统将要发生<strong>内存溢出异常</strong>前，会把这些对象列进回收范围之中进行第<strong>二次回收</strong>，如果这次回收还没有足够的内存，才会<strong>抛出内存溢出异常</strong>。在JDK 1.2版之后提供了SoftReference类来实现软引用。 </p></li><li><p>弱引用，用来描述那些非必须对象，但是它的强度比软引用更弱一些，被弱引用关联的对象<strong>只能生存到下一次垃圾收集发生为止</strong>。在JDK 1.2版之后提供了WeakReference类来实现弱引用。 </p></li><li><p>虚引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。<strong>为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知</strong>。在JDK 1.2版之后提供了PhantomReference类来实现虚引用。</p></li></ul><h3 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h3><h4 id="分代收集理论"><a href="#分代收集理论" class="headerlink" title="分代收集理论"></a>分代收集理论</h4><ul><li>弱分代假说：绝大多数对象都是朝生夕灭的。</li><li>强分代假说：熬过越多次垃圾收集过程的对象就越难以消亡。</li></ul><p>这两个分代假说共同奠定了多款常用的垃圾收集器的一致的设计原则：收集器应该将Java堆划分出不同的区域，然后将回收对象依据其年龄（年龄即对象熬过垃圾收集过程的次数）分配到不同的区域之中存储。在Java堆划分出不同的区域之后，垃圾收集器才可以每次只回收其中某一个或者某些部分的区域。</p><ul><li>跨代引用假说：跨代引用相对于同代引用来说仅占极少数。</li></ul><p>这其实是可根据前两条假说逻辑推理得出的隐含推论：存在互相引用关系的两个对象，是应该倾向于同时生存或者同时消亡的。</p><p>依据这条假说，我们就<strong>不应再为了少量的跨代引用去扫描整个老年代</strong>，也不必浪费空间专门记录每一个对象是否存在及存在哪些跨代引用，只需<strong>在新生代上建立一个全局的数据结构</strong>（“<strong>记忆集</strong>”，Remembered Set），它<strong>把老年代划分成若干小块</strong>，<strong>标识出老年代的哪一块内存会存在跨代引用</strong>。此后当发生Minor GC时，只有包含了跨代引用的小块内存里的对象才会被加入到GC Roots进行扫描。虽然这种方法需要在对象改变引用关系（如将自己或者某个属性赋值）时维护记录数据的正确性，会增加一些运行时的开销，但比起收集时扫描整个老年代来说仍然是划算的。</p><h4 id="标记-清除算法（Mark-Sweep）"><a href="#标记-清除算法（Mark-Sweep）" class="headerlink" title="标记-清除算法（Mark-Sweep）"></a>标记-清除算法（Mark-Sweep）</h4><p>首先标记出所有需要回收的对象，在标记完成后，统一回收掉所有被标记的对象，也可以反过来，标记存活的对象，统一回收所有未被标记的对象。</p><p>缺点：</p><ul><li>执行效率不稳定，如果需要回收大量的对象，标记和清除的效率都会随着对象数量增长而降低</li><li>空间碎片化，清除之后会产生大量不连续碎片，后续分配大对象时可能造成额外的垃圾收集操作</li></ul><h4 id="标记-复制算法"><a href="#标记-复制算法" class="headerlink" title="标记-复制算法"></a>标记-复制算法</h4><p>“半区复制”（Semispace Copying）的垃圾收集算法，它将可用 内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。<strong>现在的商用Java虚拟机大多都优先采用了这种收集算法去回收新生代</strong></p><p>Appel式回收的具体做法是把新生代分为一块较大的Eden空间和两块较小的 Survivor空间，每次分配内存只使用Eden和其中一块Survivor。发生垃圾搜集时，将Eden和Survivor中仍 然存活的对象一次性复制到另外一块Survivor空间上，然后直接清理掉Eden和已用过的那块Survivor空间。HotSpot虚拟机默认Eden和Survivor的大小比例是8∶1，也即每次新生代中可用内存空间为整个新生代容量的90%（Eden的80%加上一个Survivor的10%），只有一个Survivor空间，<strong>即10%的新生代是会被“浪费”的。</strong></p><p>当Survivor空间不足以容纳一次Minor GC之后存活的对象时，就需要依赖其他内存区域（实际上大多就是老年代）进行==分配担保==（Handle Promotion）</p><h4 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h4><p>标记-复制算法在对象存活率较高时就要进行较多的复制操作，效率将会降低。更关键的是，如果不想浪费50%的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都100%存活的极端情况，所以在老年代一般不能直接选用这种算法。</p><p><strong>标记-清除算法与标记-整理算法的本质差异在于前者是一种非移动式的回收算法，而后者是移动式的。</strong>是否移动回收后的存活对象是一项优缺点并存的风险决策： </p><ul><li>移动对象，负重极大的操作，必须全部暂停全部用户程序才能进行，称为“Stop the world”</li><li>不移动对象，弥散于堆中的存活对象导致的 空间碎片化问题就只能依赖更为复杂的内存分配器和内存访问器来解决。譬如通过“<strong>分区空闲分配链表</strong>”来解决内存分配问题</li></ul><p>从垃圾收集的停顿时间来看，不移动对象停顿时间会更短，甚至可以不需要停顿，但是从整个程序的吞吐量来看，移动对象会更划算。即使不移动对象会使得收集器的效率提升一些，但因内存分配和访问相比垃圾收集频率要高得多，这部分的耗时增加，总吞吐量仍然是下降的。</p><p><strong>HotSpot虚拟机里面关注吞吐量的Parallel Scavenge收集器是基于标记-整理算法的，而关注延迟的CMS收集器则是基于标记-清除算法的</strong>，CMS 在碎片化严重时会采用标记-整理算法收集一次。</p><h3 id="HotSpot-算法细节实现"><a href="#HotSpot-算法细节实现" class="headerlink" title="HotSpot 算法细节实现"></a>HotSpot 算法细节实现</h3><h4 id="根节点枚举"><a href="#根节点枚举" class="headerlink" title="根节点枚举"></a>根节点枚举</h4><p>迄今为止，所有收集器在根节点枚举这一步骤时都是必须暂停用户线程的，现在可达性分析算法<strong>耗时最长的查找引用链的过程</strong>已经<strong>可以</strong>做到<strong>与用户线程一起并发</strong>，但根节点枚举始终还是必须在一个能<strong>保障一致性的快照中才得以进行</strong>——这里“一致性”的意思是整个枚举期间执行子系统看起来就像被冻结在某个时间点上，不<strong>会出现分析过程中，根节点集合的对象引用关系还在不断变化的情况</strong>，若这点不能满足的话，分析结果准确性也就无法保证。</p><p>在HotSpot 的解决方案里，是使用一组称为==OopMap==的数据结构来达到这个目的。一旦类加载动作完成的时候， HotSpot就会把对象内什么偏移量上是什么类型的数据计算出来，在即时编译（见第11章）过程中，也会在特定的位置记录下栈里和寄存器里哪些位置是引用。这样收集器在扫描时就可以直接得知这些信息了，并不需要真正一个不漏地从方法区等GC Roots开始查找。</p><h4 id="安全点"><a href="#安全点" class="headerlink" title="安全点"></a>安全点</h4><p>在OopMap的协助下，HotSpot可以快速准确地完成GC Roots枚举，但一个很现实的问题随之而来：可能导致引用关系变化，或者说导致OopMap内容变化的指令非常多，如果为每一条指令都生成对应的OopMap，那将会需要大量的额外存储空间，这样垃圾收集伴随而来的空间成本就会变得无法忍受的高昂。 </p><p>实际上HotSpot也的确没有为每条指令都生成OopMap，前面已经提到，只是在“特定的位置”记录了这些信息，这些位置被称为安全点（Safepoint）用户程序执行时 并非在代码指令流的任意位置都能够停顿下来开始垃圾收集，而是强制要求必须执行到达安全点后才 能够暂停。因此，安全点的选定既不能太少以至于让收集器等待时间过长，也不能太过频繁以至于过分增大运行时的内存负荷。</p><p>如何在垃圾收集发生时让所有线程（这里其实不包括执行JNI调用的线程）都<strong>跑到最近的安全点，然后停顿下来</strong>。这里有两种方案可供选择：</p><ul><li><p>抢先式中断不需要线程的执行代码主动去配合，在垃圾收集发生时，系统<strong>首先把所有用户线程全部中断</strong>，如果发现有用户线程中断的地方不在安全点上，就恢复这条线程执行，让它一会再重新中断，直到跑到安全点上。现在几乎没有虚拟机实现采用抢先式中断来暂停线程响应GC事件。 </p></li><li><p>主动式中断的思想是当垃圾收集需要中断线程的时候，不直接对线程操作，仅仅简单地设置一个标志位，各个线程执行过程时会不停地主动去轮询这个标志，一旦发现中断标志为真时就自己在最近的安全点上主动中断挂起。</p></li></ul><h4 id="安全区域"><a href="#安全区域" class="headerlink" title="安全区域"></a>安全区域</h4><p>安全点机制保证了程序执行时，在不太长的时间内就会遇到可进入垃圾收集过程的安全点。但是，程序“不执行”的时候呢？所谓的程序不执行就是没有分配处理器时间，典型的场景便是用户线程处于Sleep状态或者Blocked状态，这时候线程无法响应虚拟机的中断请求，不能再走到安全的地方去中断挂起自己。</p><p>安全区域是指能够确保在某一段代码片段之中，引用关系不会发生变化，因此，<strong>在这个区域中任意地方开始垃圾收集都是安全的</strong>。我们也可以把安全区域看作被扩展拉伸了的安全点。</p><p>当用户线程执行到安全区域里面的代码时，首先会<strong>标识自己已经进入了安全区域</strong>，那样当这段时间里虚拟机要发起垃圾收集时就不必去管这些已声明自己在安全区域内的线程了。当<strong>线程要离开安全区域时，它要检查虚拟机是否已经完成了根节点枚举</strong>（或者垃圾收集过程中其他需要暂停用户线程的阶段），如果完成了，那线程就当作没事发生过，继续执行；否则它就必须一直等待，直到收到可以离开安全区域的信号为止。</p><h4 id="记忆集与卡表"><a href="#记忆集与卡表" class="headerlink" title="记忆集与卡表"></a>记忆集与卡表</h4><p>为解决对象跨代引用所带来的问题，垃圾收集器在新生代中建 立了名为记忆集（Remembered Set）的数据结构，用以避免把整个老年代加进GC Roots扫描范围。</p><p>记忆集是一种用于记录从<strong>非收集区域指向收集区域的指针集合的抽象数据结构</strong>。在垃圾收集的场景中，收集器只需要<strong>通过记忆集判断出某一块非收集区域是否存在有指向了收集区域的指针</strong>就可以了，并不需要了解这些跨代指针的全部细节。</p><p>下面列举了一些可供选择（当然也可以选择这个范围以外的）的记录精度：</p><ul><li>字长精度，每个记录精确到一个机器字长，该字包含跨代指针</li><li>对象精度，每个记录精确到一个对象，该对象里有字段包含跨代指针</li><li>卡精度，每个记录精确到一块内存区域，该区域内有对象包含跨代指针</li></ul><p><strong>卡表是记忆集卡精度的一种实现</strong>，最简单的形式可以只是一个字节数组，字节数组CARD_TABLE的每一个元素都对应着其标识的内存区域中一块特定大小的内存块，这个内存块被称作“卡页”（Card Page）。</p><p>一个卡页的内存中通常包含不止一个对象，只要卡页内有一个（或更多）对象的字段存在着跨代指针，那就将对应卡表的数组元素的值标识为1，称为这个元素变脏（Dirty），没有则标识为0。在垃圾收集发生时，只要<strong>筛选出卡表中变脏的元素，就能轻易得出哪些卡页内存块中包含跨代指针，把它们加入GC Roots中一并扫描</strong>。 </p><h4 id="写屏障"><a href="#写屏障" class="headerlink" title="写屏障"></a>写屏障</h4><p>我们已经解决了如何使用记忆集来缩减GC Roots扫描范围的问题，但还没有解决卡表元素如何维护的问题，例如它们何时变脏、谁来把它们变脏等。卡表元素何时变脏的答案是很明确的——<strong>有其他分代区域中对象引用了本区域对象时，其对应的卡表元素就应该变脏</strong>，变脏时间点原则上<strong>应该发生在引用类型字段赋值的那一刻</strong>。</p><p>写屏障可以看作在虚拟机层面<strong>对“引用类型字段赋值”这个动作的AOP切面</strong>，应用写屏障后，虚拟机就会<strong>为所有赋值操作生成相应的指令</strong>，一旦收集器在写屏障中增加了更新卡表操作，无论更新的是不是老年代对新生代对象的引用，每次只要对引用进行更新，就会产生额外的开销，不过这个开销与Minor GC时扫描整个老年代的代价相比还是低得多的。</p><p>当多线程修改互相独立的变量时，如果这些变量恰好共享同一个缓存行，就会彼此影响（写回、无效化或者同步）而导致性能降低，这就是伪共享问题。 为了避免伪共享问题，一种简单的解决方案是不采用无条件的写屏障，而是先检查卡表标记，只有当该卡表元素未被标记过时才将其标记为变脏（避免多个线程修改卡表）。</p><h4 id="并发的可达性分析"><a href="#并发的可达性分析" class="headerlink" title="并发的可达性分析"></a>并发的可达性分析</h4><h5 id="三色标记"><a href="#三色标记" class="headerlink" title="三色标记"></a>三色标记</h5><p>把遍历对象图过程中遇到的对象，按照“是否访问过”这个条件标记成以下三种颜色：</p><ul><li><p>白色：表示对象尚<strong>未被垃圾收集器访问过</strong>。显然在可达性分析刚刚开始的阶段，所有的对象都是白色的，<strong>若在分析结束的阶段，仍然是白色的对象，即代表不可达。</strong></p></li><li><p>黑色：表示对象已经被垃圾收集器访问过，且这个<strong>对象的所有引用都已经扫描过</strong>。黑色的对象代表已经扫描过，它是安全存活的，如果有其他对象引用指向了黑色对象，无须重新扫描一遍。黑色对象不可能直接（不经过灰色对象）指向某个白色对象。 </p></li><li><p>灰色：表示对象已经被垃圾收集器访问过，但这个<strong>对象上至少存在一个引用还没有被扫描过</strong>。 </p></li></ul><p>用户线程与收集器是并发工作时，收集器在对象图上标记颜色，同时用户线程在修改引用关系——即修改对象图的结构，这样可能出现两种后果：</p><ol><li><p>一种是<strong>把原本消亡的对象错误标记为存活</strong>， 这不是好事，但其实是可以容忍的，只不过产生了一点逃过本次收集的浮动垃圾而已，下次收集清理掉就好。（收集器线程先标记为黑，用户线程又将该对象的所有引用断开）</p></li><li><p>另一种是把<strong>原本存活的对象错误标记为已消亡</strong>，这就是非常致命的后果了，程序肯定会因此发生错误。（用户线程先将灰色对象所连的白色对象的所有引用断开，在收集器线程扫过之后，用户线程<strong>又将黑色对象引用白色对象</strong>（这个对象此时应该是黑色，但收集器扫不到它了，所以它还是白色））</p></li></ol><h5 id="对象消失"><a href="#对象消失" class="headerlink" title="对象消失"></a>对象消失</h5><p>对象消失的问题当且仅当以下两个条件同时满足时成立：</p><ul><li>赋值器插入了一条或多条从黑色对象到白色对象的新引用</li><li>赋值器删除了全部从灰色对象到该白色对象的直接或间接引用。</li></ul><p>解决并发扫描时的对象消失问题，只需破坏这两个条件的任意一个即可。由此分别产生了两种解决方案：==增量更新==和==原始快照==</p><p>增量更新要破坏的是第一个条件，当黑色对象插入新的指向白色对象的引用关系时，就<strong>将这个新插入的引用记录下来</strong>，等并发扫描结束之后，再将这些记录过的引用关系中的黑色对象为根，重新扫描一次。</p><p>原始快照要破坏的是第二个条件，当灰色对象要删除指向白色对象的引用关系时，就<strong>将这个要删除的引用记录下来</strong>，在并发扫描结束之后，再将这些记录过的引用关系中的灰色对象为根，重新扫描一次。可以简化理解为，无论引用关系删除与否，都会按照刚<strong>刚开始扫描那一刻的对象图快照</strong>来进行搜索。 </p><p><strong>CMS是基于增量更新来做并发标记的，G1、Shenandoah则是用原始快照来实现</strong></p><h3 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h3><img src="C:\Users\ming hoo\AppData\Roaming\Typora\typora-user-images\image-20211203162201113.png" alt="image-20211203162201113" style="zoom: 33%;" /><h4 id="Serial-收集器"><a href="#Serial-收集器" class="headerlink" title="Serial 收集器"></a>Serial 收集器</h4><p>单线程，<strong>只会使用一个处理器或一条收集线程去完成垃圾收集工作</strong>，在<strong>它进行垃圾收集时，必须暂停其他所有工作线程，直到它收集结束。</strong>对于内存资源受限的环境，它是所有收集器里额外内存消耗（Memory Footprint）最小的。</p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20211203162627009.png" alt="image-20211203162627009" style="zoom: 50%;" /><h4 id="ParNew-收集器"><a href="#ParNew-收集器" class="headerlink" title="ParNew 收集器"></a>ParNew 收集器</h4><p>Serial收集器的多线程并行版本，除了同时使用多条线程进行垃圾收集之 外，其余的行为包括Serial收集器可用的所有控制参数（例如：-XX：SurvivorRatio、-XX： PretenureSizeThreshold、-XX：HandlePromotionFailure等）、收集算法、Stop The World、对象分配规则、回收策略等都与Serial收集器完全一致。<strong>除了Serial收集器外，目前只有它能与CMS 收集器配合工作。</strong></p><img src="C:\Users\ming hoo\AppData\Roaming\Typora\typora-user-images\image-20211203163233593.png" alt="image-20211203163233593" style="zoom:50%;" /><h4 id="Parallel-Scavenge收集器"><a href="#Parallel-Scavenge收集器" class="headerlink" title="Parallel Scavenge收集器"></a>Parallel Scavenge收集器</h4><p>Parallel Scavenge收集器也是一款新生代收集器，它同样是基于<strong>标记-复制算法实现的收集器</strong>，也是能够并行收集的多线程收集器。CMS等收集器的关注点是尽可能地缩短垃圾收集时用户线程的停顿时间，而Parallel Scavenge收集器的目标则是达到一个可控制的吞吐量（Throughput）。吞吐量就是处理器用于运行用户代码的时间与处理器总消耗时间的比值。</p><p>Parallel Scavenge收集器提供了两个参数用于精确控制吞吐量，分别是控制<strong>最大垃圾收集停顿时间</strong>的<strong>-XX：MaxGCPauseMillis</strong>参数以及直接设置吞吐量大小的-XX：GCTimeRatio参数。垃圾收集停顿时间缩短是以牺牲吞吐量和新生代空间为代价换取的，停顿时间短就对应着新生代空间小和更频繁的 GC，这会导致吞吐量降低。</p><p>Parallel Scavenge收集器还有一个参数<strong>-XX：+UseAdaptiveSizePolicy</strong>值得我们关注。这是一个开关参数，当这个参数被激活之后，就不需要人工指定新生代的大小（-Xmn）、Eden与Survivor区的比例（-XX：SurvivorRatio）、晋升老年代对象大小（-XX：PretenureSizeThreshold）等细节参数了，<strong>虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量</strong>。这种调节方式称为垃圾收集的<strong>自适应的调节策略</strong>。</p><h4 id="Serial-Old-收集器"><a href="#Serial-Old-收集器" class="headerlink" title="Serial Old 收集器"></a>Serial Old 收集器</h4><p>Serial Old是Serial收集器的老年代版本，它同样是一个单线程收集器，<strong>使用标记-整理算法</strong>。这个收集器的主要意义也是供客户端模式下的HotSpot虚拟机使用。如果在服务端模式下，它也可能有两种用途：一种是在JDK 5以及之前的版本中与Parallel Scavenge收集器搭配使用，另外一种就是<strong>作为CMS 收集器发生失败时的后备预案，在并发收集发生Concurrent Mode Failure时使用。</strong></p><h4 id="Parallel-Old-收集器"><a href="#Parallel-Old-收集器" class="headerlink" title="Parallel Old 收集器"></a>Parallel Old 收集器</h4><p>Parallel Scavenge收集器的老年代版本，支持多线程并发收集，基于<strong>标记-整理算法</strong>实现。在注重吞吐量或者处理器资源较为稀缺的场合，都可以优先考虑Parallel Scavenge加Parallel Old收集器这个组合。</p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20211206193620348.png" alt="image-20211206193620348" style="zoom:50%;" /><h4 id="CMS（Concurrent-Mark-Sweep）收集器"><a href="#CMS（Concurrent-Mark-Sweep）收集器" class="headerlink" title="CMS（Concurrent Mark Sweep）收集器"></a>CMS（Concurrent Mark Sweep）收集器</h4><p>基于标记-清除算法实现，是一种以获取最短回收停顿时间为目标的收集器。</p><p>整个过程分为四个步骤，包括： </p><ul><li>初始标记，需要暂停用户线程，标记 GC Roots 能<strong>直接</strong>关联到的对象</li><li>并发标记，从GC Roots的直接关联对象开始遍历整个对象图</li><li>重新标记，需要暂停用户线程，修正并发标记期间，用户线程变动的那一部分对象的标记（增量更新，对新加的引用再扫一次）</li><li>并发清除，清理删除掉标记阶段判断的已经死亡的对象</li></ul><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20211206201031510.png" alt="image-20211206201031510" style="zoom:50%;" /><p>==CMS 缺点==：</p><ol><li><p><strong>对处理器资源非常敏感</strong>。在并发阶段占用一部分线程，导致应用程序变慢。CMS默认启动的回收线程数是（处理器核心数量 </p><p>+3）/4，核越少，CMS 对用户程序影响越大。</p></li><li><p><strong>无法处理浮动垃圾</strong>。有可能出现“Con-current Mode Failure”失败进而导致另一次完全“Stop The World”的Full GC的产生。CMS 无法清理在并发阶段用户程序产生的垃圾。在垃圾收集阶段还需要保留空间给用户线程使用，不能等老年代几乎完全被填满了收集。JDK 5 时，老年代使用了 68% 以上 CMS 就会被激活，这偏保守，可以适当提高参数-XX：CMSInitiatingOccu-pancyFraction的值降低回收频率。JDK6 时这个参数被设置为 92%，要是<strong>CMS运行期间预留的内存无法满足程序分配新对象的需要</strong>，就会出现一次“并发失败”（Concurrent Mode Failure），临时使用 Serial Old 收集器（STW）来重新进行老年代垃圾收集。</p></li><li><p><strong>内存碎片化</strong>。可以在碎片化严重时进行一次合并整理。</p></li></ol><p><strong>CMS 处理跨代引用</strong></p><p>CMS的卡表相当简单， 只有唯一一份，而且<strong>只需要处理老年代到新生代的引用</strong>，反过来则不需要，由于新生代的对象具有朝生夕灭的不稳定性，引用变化频繁，能省下这个区域的维护开销是很划算的。代价就是当CMS发生Old GC时（所有收集器中只有CMS有针对老年代的Old GC），要把<strong>整个新生代作为GC Roots来进行扫描</strong>，避免出现新生代引用老年代，而老年代被清理。</p><h4 id="Garbage-First-收集器"><a href="#Garbage-First-收集器" class="headerlink" title="Garbage First 收集器"></a>Garbage First 收集器</h4><p>把连续的Java堆划分为<strong>多个大小相等的独立区域</strong>（Region），每一个Region都可以根据需要，扮演新生代的Eden空间、Survivor空间，或者老年代空间，对扮演不同角色的 Region 采用不同的策略去处理。</p><p>Region中还有一类特殊的Humongous区域，专门用来存储大对象。G1认为只要大小<strong>超过了一个Region容量一半的对象即可判定为大对象</strong>。每个Region的大小可以通过参数-XX：G1HeapRegionSize设定，取值范围为1MB～32MB，且应为2的N次幂。对于那些超过了整个Region容量的超级大对象， 将会被存放在N个连续的Humongous Region之中。</p><p>将Region作 为单次回收的最小单元，每次收集到的内存空间都是Region大小的整数倍。更具体的处理思路是让G1收集器去跟踪各个Region里面的垃 圾堆积的“价值”大小，价值即<strong>回收所获得的空间大小以及回收所需时间的经验值</strong>，然后在后台维护一 个优先级列表，每次根据用户设定允许的收集停顿时间（使用参数-XX：MaxGCPauseMillis指定，默认值是200毫秒），优先处理回收价值收益最大的那些Region。</p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20211206202809276.png" alt="image-20211206202809276" style="zoom: 25%;" /><p><strong>G1 解决跨代引用</strong></p><p>每个 Region 都有自己的记忆集，这些记忆集会<strong>记录下别的Region 指向自己的指针</strong>，并标记这些指针分别在哪些卡页的范围之内。G1的记忆集在存储结构的本质上是一 种哈希表，Key是<strong>别的Region的起始地址</strong>，Value是一个集合，里面存储的元素是卡表的索引号。这 种“双向”的卡表结构（卡表是“我指向谁”，这种结构还记录了“谁指向我”）比原来的卡表实现起来更复杂，同时由于Region数量比传统收集器的分代数量明显要多得多，因此G1收集器要比其他的传统垃圾收集器有着更高的内存占用负担。根据经验，G1至少要耗费大约相当于Java堆容量10%至20%的额外内存来维持收集器工作。 </p><p><strong>G1 解决浮动垃圾</strong></p><p>使用原始快照实现，将并发标记阶段时删除的引用记录下来，根据这些引用再扫一次。G1为每一个Region设计了两个名为TAMS（Top at Mark Start）的指针，把Region中的一部分空间划分出来用于<strong>并发回收过程中的新对象分配</strong>，并发回收时新分配的对象地址都必须要在这两个指针位置以上。G1收集器默认在这个地址以上的对象是被隐式标记过的，即默认它们是存活的，不纳入回收范围。如果回收的速度赶不上内存分配的速度，G1 也会 STW，执行 Full GC。</p><p><strong>G1 停顿预测模型</strong></p><p>在垃圾收集过程中，G1收集器会记录每个Region的回收耗时、每个Region记忆集里的脏卡数量等各个可测量的步骤花费的成本，并分析得 出平均值、标准偏差、置信度等统计信息。</p><p><strong>运行过程：</strong></p><ul><li>初始标记。暂停用户线程，标记一下GC Roots能直接关联到的对象，并且修改 TAMS 指针的值，让下一阶段用户线程能正确地在可用的Region中分配新对象</li><li>并发标记。从GC Root开始对堆中对象进行可达性分析</li><li>最终标记。暂停用户线程，处理并发阶段结束后仍遗留下来的最后那少量的SATB记录</li><li>筛选回收。暂停用户线程，负责更新Region的统计数据，对各个Region的回收价值和成本进行排序，根据用户所期望的停顿时间来制定回收计划，可以自由选择任意多个Region 构成回收集，然后<strong>把决定回收的那一部分Region的存活对象复制到空的Region中</strong>，再清理掉整个旧 Region的全部空间。这里的操作<strong>涉及存活对象的移动，是必须暂停用户线程，由多条收集器线程并行完成的。</strong></li></ul><p>它并非纯粹地追求低延迟，官方给它设定的目标是在延迟可控的情况下获得尽可能高的吞吐量。</p><img src="C:\Users\ming hoo\AppData\Roaming\Typora\typora-user-images\image-20211206205201025.png" alt="image-20211206205201025" style="zoom:50%;" /><h4 id="CMS-vs-G1"><a href="#CMS-vs-G1" class="headerlink" title="CMS vs G1"></a>CMS vs G1</h4><table><thead><tr><th></th><th>CMS</th><th>G1</th></tr></thead><tbody><tr><td>清除算法</td><td>标记-清除，碎片化</td><td>整体上看，标记-整理，局部来看标记复制，不会产生碎片，能提供规整的可用内存</td></tr><tr><td>内存占用</td><td>只有一份卡表，处理老年代到新生代的引用</td><td>堆中每个Region，无论扮演的是新生代还是老年代角色，都必须有一份卡表，这导致G1的记忆集（和 其他内存消耗）可能会占整个堆容量的20%乃至更多的内存空间</td></tr><tr><td>执行负载</td><td>CMS用写后屏障来更新维护卡表，使用增量更新来处理对象消失问题，重新标记耗时较长</td><td>G1除了使用写后屏障来进行（更繁琐的）卡表维护操作，为了实现原始快照，还要使用写前屏障来跟踪并发时指针变化情况，搜索能够减少并发标记和重新标记阶段的消耗。</td></tr></tbody></table><h4 id="Shenandoah-收集器"><a href="#Shenandoah-收集器" class="headerlink" title="Shenandoah 收集器"></a>Shenandoah 收集器</h4><p>基于Region的堆内存布局，同样有着用于存放大对象的Humongous Region，默认的回收策略也同样是优先处理回收价值最大的Region。</p><p>与G1至少有三个明显的不同之处</p><ul><li><p>支持并发的整理算法</p></li><li><p>默认不使用分代收集 </p></li><li><p>摒弃了在G1中耗费大量内存和计算资源去维护的记忆集，改用名为“连接矩阵”（Connection Matrix）的全局数据结构来记录跨Region的引用关系。</p></li></ul><img src="C:\Users\ming hoo\AppData\Roaming\Typora\typora-user-images\image-20211206211031018.png" alt="image-20211206211031018" style="zoom:25%;" /><p>连接矩阵可以简单理解为一张二维表格，如果Region N有对象指向Region M，就在表格的N行M列中打上一个标记，如图所示，如果Region 5中的对象Baz引用了Region 3的Foo，Foo又引用了Region 1的Bar，那连接矩阵中的5行3列、3行1列就应该被打上标记。在回收时通过这张表格就可以得出哪些Region之间产生了跨代引用。</p><p><strong>工作过程：</strong></p><ol><li>初始标记：STW，标记与GC Roots直接关联的对象。</li><li>并发标记：遍历对象图，标记出全部可达的对象</li><li>最终标记：STW，处理剩余的SATB扫描，并在这个阶段统计出回收价值最高的Region，将这些Region构成一组回收集（Collection Set）。最终标记阶段也会有一小段短暂的停顿。 </li><li>并发清理：这个阶段用于<strong>清理那些整个区域内连一个存活对象都没有找到的Region</strong>。 </li><li>并发回收：并发回收阶段是Shenandoah与之前HotSpot中其他收集器的核心差异。在这个阶段，Shenandoah要把回收集里面的存活对象先复制一份到其他未被使用的Region之中。<strong>Shenandoah将会通过读屏障和被称为“Brooks Pointers”的转发指针来解决并发移动对象的问题</strong>。并发回收阶段运行的时间长短取决于回收集的大小。 </li><li>初始引用更新：STW，并发回收阶段复制对象结束后，还需要<strong>把堆中所有指向旧对象的引用修正到复制后的新地址</strong>，这个操作称为引用更新。初始引用更新仅仅建立一个线程集合点，确保所有并发回收阶段中进行的收集器线程都已完成分配给它们的对象移动任务。</li><li>并发引用更新：真正开始进行引用更新操作，这个阶段是与用户线程一起并发的，时间长短取决于内存中涉及的引用数量的多少。并发引用更新与并发标记不同，它不再需要沿着对象图来搜索，<strong>只需要按照内存物理地址的顺序，线性地搜索出引用类型，把旧值改为新值即可。</strong> </li><li>最终引用更新：解决了堆中的引用更新后，还要<strong>修正存在于GC Roots中的引用</strong>。这个阶段是Shenandoah的最后一次停顿，停顿时间只与GC Roots的数量相关。 </li><li>并发清理：经过并发回收和引用更新之后，<strong>整个回收集中所有的Region已再无存活对象</strong>，最后再调用一次并发清理过程来回收这些Region的内存空间，供以后新对象分配使用。</li></ol><p>读者只要抓住其中 三个最重要的并发阶段（并发标记、并发回收、并发引用更新），就能比较容易理清Shenandoah是如 何运作的了。图中黄色的区域代表的是被选入回收集的Region，绿色部分就代表还存活的对 象，蓝色就是用户线程可以用来分配对象的内存Region了。图3-16中不仅展示了Shenandoah三个并发阶段的工作过程，还能形象地表示出并发标记阶段如何找出回收对象确定回收集，并发回收阶段如何移 动回收集中的存活对象，并发引用更新阶段如何将指向回收集中存活对象的所有引用全部修正，此后回收集便不存在任何引用可达的存活对象了。 </p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20211206211443587.png" alt="image-20211206211443587"></p><p><strong>Shenandoah 并发复制对象</strong></p><p><strong>在移动对象的同时，用户线程仍然可能不停对被移动的对象进行读写访问，移动对象是一次性的行为，但移动之后整个内存中所有指向该对象的引用都还是旧对象的地址，这是很难一瞬间全部改变过来的</strong>。</p><p>此前，要做类似的并发操作，通常是在<strong>被移动对象原有的内存上设置保护陷阱（Memory Protection Trap），一旦用户程序访问到归属于旧对象的内存空间就会产生自陷中段，进入预设好的异常处理器中，再由其中的代码逻辑把访问转发到复制后的新对象上</strong>。如果没有操作系统层面的直接支持，这种方案将导致用户态频繁切换到核心态，代价是非常大。</p><p>Brooks提出的新方案不需要用到内存保护陷阱，而是在原有对象布局结构的最前面统一增加一个新的引用字段，<strong>在正常不处于并发移动的情况下，该引用指向对象自己</strong>。当对象拥有了一份新的副本时，只需要修改一处指针的值，即旧对象上转发指针的引用位置，使其指向新对象，便可将所有对该对象的访问转发到新的副本上（在引用更新后就可清除旧对象）。</p><img src="C:\Users\ming hoo\AppData\Roaming\Typora\typora-user-images\image-20211206212950578.png" alt="image-20211206212950578" style="zoom:50%;" /><p>转发指针在设计上决定了它是必然会出现多线程竞争问题：</p><p>1）收集器线程复制了新的对象副本； </p><p>2）用户线程更新对象的某个字段； </p><p>3）收集器线程更新转发指针的引用值为新副本地址。</p><p>如果不做任何保护措施，让事件2在事件1、事件3之间发生的话，将导致的结果就是<strong>用户线程对对象的变更发生在旧对象上</strong>，所以这里必须针对转发指针的访问操作采取同步措施，让收集器线程或者用户线程对转发指针的访问只有其中之一能够成功，另外一个必须等待，避免两者交替进行。实际上 Shenandoah收集器是通过比较并交换（Compare And Swap，CAS）操作[8]来保证并发时对象的访问正确性的。</p><h4 id="ZGC-收集器"><a href="#ZGC-收集器" class="headerlink" title="ZGC 收集器"></a>ZGC 收集器</h4><p>ZGC收集器是一款基于Region内存布局的，（暂时）不设分代的，使用了读屏障、染色指针和内存多重映射等技术来实现可并发的标记-整理算法的，以低延迟为首要目标的一款垃圾收集器。</p><p>内存布局：与Shenandoah和G1一样，ZGC也采用基于Region的堆内存布局，但与它们不同的是，ZGC的 Region 具有动态性——<strong>动态创建和销毁，以及动态的区域容量大小</strong>。</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20211206214500139.png" alt="image-20211206214500139"></p><p>工作流程：</p><ol><li>并发标记：STW，ZGC的标记是在指针上而不是在对象上进行的，标记阶段会更新染色指针中的Marked 0、Marked 1标志位。 </li><li>并发预备重分配：这个阶段需要根据特定的查询条件统计得出本次收集过程要清理哪些Region，将这些Region组成重分配集（Relocation Set）。ZGC每次回收都会扫描所有的Region，用范围更大的扫描成本换取省去G1中记忆集的维护成本。因为标记过程是针对全堆的。</li><li>并发重分配：重分配是ZGC执行过程中的核心阶段，这个过程要把重分配集中的存活对象复制到新的Region上，并为重分配集中的每个Region维护一个转发表（ForwardTable），<strong>记录从旧对象到新对象的转向关系</strong>。<strong>得益于染色指针的支持，ZGC收集器能仅从引用上就明确得知一个对象是否处于重分配集之中</strong>，<strong>如果用户线程此时并发访问了位于重分配集中的对象，这次访问将会被预置的内存屏障所截获，然后立即根据Region上的转发表记录将访问转发到新复制的对象上，并同时修正更新该引用的值，使其直接指向新对象</strong>。</li><li>并发重映射：重映射所做的就是<strong>修正整个堆中指向重分配集中旧对象的所有引用</strong>。ZGC的并发重映射并不是一个必须要“迫切”去完成的任务，因为前面说过，即使是旧引用，它也是可以自愈的，最多只是第一次使用时多一次转发和修正操作。ZGC很巧妙地把并发重映射阶段要做的工作，合并到了下一次垃圾收集循环中的并发标记阶段里去完成。一旦所有指针都被修正之后，原来记录新旧对象关系的转发表就可以释放掉了。 </li></ol><p>相比G1、Shenandoah等先进的垃圾收集器，G1需要通过写屏障来维护记忆集，才能处理跨代指针，得以实现Region的增量回收。记忆集要占用大量的内存空间，写屏障也对正常程序运行造成额外负担，这些都是权衡选择的代价。<strong>ZGC就完全没有使用记忆集，它甚至连分代都没有，连像CMS中那样只记录新生代和老年代间引用的卡表也不需要，因而完全没有用到写屏障，所以给用户线程带来的运行负担也要小得多</strong>。</p><h3 id="内存分配与回收策略"><a href="#内存分配与回收策略" class="headerlink" title="内存分配与回收策略"></a>内存分配与回收策略</h3><h4 id="对象优先在Eden分配"><a href="#对象优先在Eden分配" class="headerlink" title="对象优先在Eden分配"></a>对象优先在Eden分配</h4><p>-Xms20M、-Xmx20M、-Xmn10M 、-XX：Survivor-Ratio=8 最小堆最大堆都是 20M，新生代 10M，Eden：Survivor = 8：1</p><p>大多数情况下，对象在新生代Eden区中分配。当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC</p><h4 id="大对象直接进入老年代"><a href="#大对象直接进入老年代" class="headerlink" title="大对象直接进入老年代"></a>大对象直接进入老年代</h4><p>-XX：PretenureSizeThreshold=3145728  大于 3MB 的直接进老年代</p><p>在Java虚拟机中要避免大对象的原因是，在分配空间时，它容易导致内存明明还有不少空间时就提前触发垃圾收集，以获取足够的连续空间才能安置好它们，而当复 制对象时，大对象就意味着高额的内存复制开销。HotSpot虚拟机提供了-XX：PretenureSizeThreshold 参数，指定大于该设置值的对象直接在老年代分配，这样做的目的就是<strong>避免在Eden区及两个Survivor区之间来回复制</strong>，产生大量的内存复制操作</p><h4 id="长期存活的对象将进入老年代"><a href="#长期存活的对象将进入老年代" class="headerlink" title="长期存活的对象将进入老年代"></a>长期存活的对象将进入老年代</h4><p>虚拟机给每个对象定义了一个对 象年龄（Age）计数器，存储在对象头中。对象通常在Eden区里诞生，如果经过第一次 Minor GC后仍然存活，并且能被Survivor容纳的话，该对象会被移动到Survivor空间中，并且将其对象 年龄设为1岁。对象在Survivor区中每熬过一次Minor GC，年龄就增加1岁，当它的年龄增加到一定程度（默认为15），就会被晋升到老年代中。对象晋升老年代的年龄阈值，可以通过参数-XX： MaxTenuringThreshold设置</p><h4 id="动态对象年龄判定"><a href="#动态对象年龄判定" class="headerlink" title="动态对象年龄判定"></a>动态对象年龄判定</h4><p>为了能更好地适应不同程序的内存状况，HotSpot虚拟机并不是永远要求对象的年龄必须达到- XX：MaxTenuringThreshold才能晋升老年代，如果在Survivor空间中相同年龄所有对象大小的总和大于 Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到-XX： MaxTenuringThreshold中要求的年龄。</p><h4 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a>空间分配担保</h4><p>在发生Minor GC之前，虚拟机必须先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那这一次Minor GC可以确保是安全的。如果不成立，则虚拟机会先查看- XX：HandlePromotionFailure参数的设置值是否允许担保失败（Handle Promotion Failure）；如果允许，那会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试进行一次Minor GC，尽管这次Minor GC是有风险的（老年代放不下）；如果小于，或者-XX：HandlePromotionFailure设置不允许冒险，那这时就要改为进行一次Full GC。</p><h3 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h3><p>Java虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这个过程被称作虚拟机的类加载机制。</p><p>一个类型从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期将会经历加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）和卸载（Unloading）七个阶段，其中<strong>验证、准备、解析三个部分统称为连接（Linking）。</strong></p><img src="C:\Users\ming hoo\AppData\Roaming\Typora\typora-user-images\image-20211208192639471.png" alt="image-20211208192639471" style="zoom:50%;" /><p>加载、验证、准备、初始化和卸载这五个阶段的顺序是确定的，类型的加载过程必须按照这种顺序<strong>按部就班地开始</strong>，而解析阶段则不一定：它在某些情况下可以在初始化阶段之后再开始。这些阶段通常都是互相交叉地混合进行的，会在一个阶段执行的过程中调用、激活另一个阶段。</p><h4 id="必须立即类初始化的情况"><a href="#必须立即类初始化的情况" class="headerlink" title="必须立即类初始化的情况"></a>必须立即类初始化的情况</h4><p>对于初始化阶段，《Java虚拟机规范》 则是严格规定了有且只有六种情况必须立即对类进行“初始化”（而加载、验证、准备自然需要在此之 前开始）： </p><ol><li><p>遇到new、getstatic、putstatic或invokestatic这四条字节码指令时，如果类型没有进行过初始化，则需要先触发其初始化阶段。能够生成这四条指令的典型Java代码场景有： </p><ul><li>使用new关键字实例化对象的时候。</li><li>读取或设置一个类型的静态字段（被final修饰、已在编译期把结果放入常量池的静态字段除外）的时候。</li><li>调用一个类型的静态方法的时候。</li></ul></li><li><p>使用java.lang.reflect包的方法对类型进行反射调用的时候，如果类型没有进行过初始化，则需要先触发其初始化。</p></li><li><p>当初始化类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。 </p></li><li><p>当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类。 </p></li><li><p>当使用JDK 7新加入的动态语言支持时</p></li><li><p>当一个接口中定义了JDK 8新加入的默认方法（被default关键字修饰的接口方法）时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化。</p></li></ol><h4 id="接口加载过程"><a href="#接口加载过程" class="headerlink" title="接口加载过程"></a>接口加载过程</h4><p>接口的加载过程与类加载过程稍有不同，针对接口需要做一些特殊说明：接口也有初始化过程， 这点与类是一致的，上面的代码都是用静态语句块“static{}”来输出初始化信息的，而接口中不能使用“static{}”语句块，但编译器仍然会为接口生成“<clinit>()”类构造器[2]，用于初始化接口中所定义的成员变量。接口与类真正有所区别的是前面讲述的六种“有且仅有”需要触发初始化场景中的第三种： 当一个类在初始化时，要求其父类全部都已经初始化过了，但是一个接口在初始化时，并不要求其父接口全部都完成了初始化，只有在真正使用到父接口的时候（如引用接口中定义的常量）才会初始化。</p><h4 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h4><h5 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h5><p>加载阶段既可以使用Java虚拟机里内置的引导类加载器来完成，也可以由用户自定义的类加载器去完成，开发人员通过定义自己的类加载器去控制字节流的获取方式（重写一个类加载器的findClass()或loadClass()方法）</p><p>Java虚拟机需要完成以下三件事情： </p><p>1）通过一个类的全限定名来获取定义此类的二进制字节流（从 ZIP 包中获取，网络中获取，运行时动态生成（动态代理）…）。 </p><p>2）将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。 </p><p>3）在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。</p><p>加载阶段结束后，Java虚拟机外部的二进制字节流就按照虚拟机所设定的格式存储在方法区之中。类型数据妥善安置在方法区之后，会在Java堆内存中实例化一个java.lang.Class类的对象， 这个对象将作为程序访问方法区中的类型数据的外部接口。</p><p>加载阶段与连接阶段的部分动作（如一部分字节码文件格式验证动作）是交叉进行的，但开始时间仍保持着固定的先后顺序。</p><h5 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h5><p>验证是连接阶段的第一步，这一阶段的目的是确保Class文件的字节流中包含的信息符合《Java虚拟机规范》的全部约束要求，保证这些信息被当作代码运行后不会危害虚拟机自身的安全。</p><p>验证阶段大致上会完成下面四个阶段的检验动作：文件格式验证、元数据验证、字节码验证和符号引用验证。</p><p><strong>1）文件格式验证</strong></p><p><strong>验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理。</strong></p><ul><li>·是否以魔数0xCAFEBABE开头。 </li><li>·主、次版本号是否在当前Java虚拟机接受范围之内。</li><li>常量池的常量中是否有不被支持的常量类型（检查常量tag标志）。</li><li>·指向常量的各种索引值中是否有指向不存在的常量或不符合类型的常量。 </li><li>·CONSTANT_Utf8_info型的常量中是否有不符合UTF-8编码的数据。 </li></ul><p><strong>2）元数据验证</strong></p><p>对字节码描述的信息进行<strong>语义分析</strong>，以保证其描述的信息符合《Java语言规范》的要求</p><ul><li><p>这个类是否有父类（除了java.lang.Object之外，所有的类都应当有父类）。 </p></li><li><p>这个类的父类是否继承了不允许被继承的类（被final修饰的类）。 </p></li><li><p>如果这个类不是抽象类，是否实现了其父类或接口之中要求实现的所有方法。 </p></li><li><p>类中的字段、方法是否与父类产生矛盾（例如覆盖了父类的final字段，或者出现不符合规则的方 </p></li></ul><p>法重载，例如方法参数都一致，但返回值类型却不同等）。</p><p><strong>3）字节码验证</strong></p><p>通过数据流分析和控制流分析，<strong>确定程序语义是合法的、符合逻辑的</strong>。对类的方法体（Class文件中的Code属性）进行校验分析，保证被校验类的方法在运行时不会做出危害虚拟机安全的行为</p><ul><li><p>保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作，例如不会出现类似于“在操作栈放置了一个int类型的数据，使用时却按long类型来加载入本地变量表中”这样的情况。 </p></li><li><p>保证任何跳转指令都不会跳转到方法体以外的字节码指令上。 </p></li><li><p>保证方法体中的类型转换总是有效的，例如可以把一个子类对象赋值给父类数据类型，这是安全的，但是把父类对象赋值给子类数据类型，甚至把对象赋值给与它毫无继承关系、完全不相干的一个数据类型，则是危险和不合法的。</p></li></ul><p>如果一个类型中有方法体的字节码没有通过字节码验证，那它肯定是有问题的；但如果一个方法体通过了字节码验证，也仍然不能保证它一定就是安全的。通过程序去校验程序逻辑是无法做到绝对准确的，不可能用程序来准确判定一段程序是否存在Bug。 </p><p><strong>4）符号引用验证</strong></p><p><strong>符号引用验证的主要目的是确保解析行为能正常执行。</strong></p><p>在虚拟机将符号引用转化为直接引用[3]的时候，这个转化动作将在连接的第三阶段——解析阶段中发生。符号引用验证可以看作是对类自身以外（常量池中的各种符号引用）的各类信息进行匹配性校验，通俗来说就是，该类是否缺少或者被禁止访问它依赖的某些外部 </p><p>类、方法、字段等资源。本阶段通常需要校验下列内容： </p><ul><li><p>符号引用中通过字符串描述的全限定名是否能找到对应的类。 </p></li><li><p>在指定类中是否存在符合方法的字段描述符及简单名称所描述的方法和字段。 </p></li><li><p>符号引用中的类、字段、方法的可访问性（private、protected、public、<package>）是否可被当 </p></li></ul><p>前类访问。 </p><h5 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h5><p>准备阶段是正式为类中定义的变量（即静态变量，被static修饰的变量）分配内存并设置类变量初始值的阶段。这时候进行内存分配的<strong>仅包括类变量，而不包括实例变量</strong>，实例变量将会在对象实例化时随着对象一起分配在Java堆中。</p><p>从概念上讲，这些变量所使用的内存都应当在<strong>方法区中进行分配</strong>，但必须注意到<strong>方法区本身是一个逻辑上的区域</strong>，在JDK 7及之前，HotSpot使用永久代来实现方法区时，实现是完全符合这种逻辑概念的；而在JDK 8及之后，类变量则会随着Class对象一起存放在Java堆中，这时候“类变量在方法区”就完全是一种对逻辑概念的表述了</p><p>如果类字段的字段属性表中存在ConstantValue属性，那在准备阶段变量值就会被初始化为ConstantValue属性所指定的初始值</p><h5 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h5><p>解析阶段是Java虚拟机将常量池内的符号引用替换为直接引用的过程。符号引用在Class文件中它以CONSTANT_Class_info、 CONSTANT_Fieldref_info、CONSTANT_Methodref_info等类型的常量出现。符号引用与虚拟机实现的内存布局无关，引用的目标并不一定是已经加载到虚拟机内存当中的内容。直接引用是和虚拟机实现的内存布局直接相关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。</p><p>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符这7类符号引用进行，分别对应于常量池的CONSTANT_Class_info、CON-STANT_Fieldref_info、 CONSTANT_Methodref_info、CONSTANT_InterfaceMethodref_info、 CONSTANT_MethodType_info、CONSTANT_MethodHandle_info、CONSTANT_Dyna-mic_info 和 CONSTANT_InvokeDynamic_info 8种常量类型。</p><p>1）类或接口的解析</p><p>假设当前代码所处的类为D，如果要把一个<strong>从未解析过的符号引用N解析为一个类或接口C的直接引用</strong>，虚拟机完成解析过程需要包含 3 个步骤：</p><ul><li>如果 C 不是一个数组，那虚拟机将会把<strong>代表N的全限定名传递给D的类加载器去加载这个类C</strong>。</li><li>如果 C 是一个数组类型，并且数组的元素类型为对象，也就是N的描述符会是类似“[Ljava/lang/Integer”的形式，那将会按照第一点的规则加载数组元素类型。</li><li>在解析完成前还要进行符号引用验证，确认D是否具备对C的访问权限。</li></ul><p>2）字段解析</p><p>要解析一个未被解析过的字段符号引用，首先将会对字段表内class_index[3]项中索引的CONSTANT_Class_info符号引用进行解析，也就是字段所属的类或接口的符号引用。如果解析成功完成，那把这个字段所属的类或接口用C表示，按照如下步骤对 C 进行后续字段的搜索：</p><ul><li>如果 <strong>C 本身</strong>就包含简单名称和字段描述符都与目标相匹配的字段，直接返回字段引用</li><li>如果在C中<strong>实现了接口</strong>，将会按照继承关系从下往上递归搜索各个接口和它的父接口，如果找到直接返回</li><li>如果C不是java.lang.Object的话，将会<strong>按照继承关系从下往上递归搜索其父类</strong>，如果找到直接返回</li><li>查找失败</li></ul><p>3）方法解析</p><p>需要先解析出方法表的class_index[4]项中索引的方法所属的类或接口的符号引用，如果解析成功，那么我们依然用C表示这个类，接下来虚拟机将会按照如下步骤进行后续的方法搜索:</p><ul><li>由于Class文件格式中类的<strong>方法和接口的方法符号引用的常量类型定义是分开的</strong>，如果在类的方法表中发现class_index中<strong>索引的C是个接口的话,，直接抛出异常</strong></li><li>在<strong>类C</strong>中查找是否有简单名称和描述符都与目标相匹配的方法，如果找到直接返回</li><li>在<strong>类C的父类</strong>中递归查找是否有简单名称和描述符都与目标相匹配的方法，如果找到直接返回</li><li>在<strong>类C实现的接口列表及它们的父接口之中</strong>递归查找是否有简单名称和描述符都与目标相匹配的方法，如果存在匹配的方法，说明类C是一个<strong>抽象类</strong>，这时候查找结束，抛出异常</li><li>查找失败</li></ul><p>4）接口方法解析</p><p>需要先解析出接口方法表的class_index[5]项中索引的方法所属的类或接口的符号引用，如果解析成功，依然用C表示这个接口，接下来虚拟机将会按照如下步骤进行后续的接口方法搜索：</p><ul><li>如果在接口方法表中发现class_index中的索引C是个类而不是接口，那么就直接抛出异常</li><li>在接口C中查找是否有简单名称和描述符都与目标相匹配的方法，如果找到直接返回</li><li>在接口C的父接口中递归查找，直到java.lang.Object类（接口方法的查找范围也会包括 Object类中的方法）为止，看是否有简单名称和描述符都与目标相匹配的方法，如果找到直接返回</li><li>查找失败</li></ul><h5 id="初始化（clinit-方法）"><a href="#初始化（clinit-方法）" class="headerlink" title="初始化（clinit 方法）"></a>初始化（clinit 方法）</h5><p>类的初始化阶段是类加载过程的最后一个步骤，之前介绍的几个类加载的动作里，除了在<strong>加载阶段用户应用程序可以通过自定义类加载器的方式局部参与</strong>外，其余动作都完全由Java虚拟机来主导控制。直到初始化阶段，Java虚拟机才真正开始执行类中编写的Java程序代码，将主导权移交给应用程序。</p><p>初始化阶段就是执行类构造器<clinit>()方法的过程。·<clinit>()方法是由==编译器自动收集类中的所有类变量的赋值动作和静态语句块（static{}块）中的语句合并产生的==，编译器收集的顺序是由语句在源文件中出现的顺序决定的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但是不能访问。</p><p>Java虚拟机会保证在子类的<clinit>()方法执行前，父类的<clinit>()方法已经执行完毕。因此在Java虚拟机中第一个被执行的<clinit>()方法的类型肯定是java.lang.Object。 </p><p>·接口中不能使用静态语句块，但仍然有变量初始化的赋值操作，因此接口与类一样都会生成 <clinit>()方法。但接口与类不同的是，执行接口的<clinit>()方法不需要先执行父接口的<clinit>()方法， 因为只有当父接口中定义的变量被使用时，父接口才会被初始化。</p><p>Java虚拟机必须保证一个类的<clinit>()方法在多线程环境中被正确地加锁同步，如果多个线程同时去初始化一个类，那么只会有其中一个线程去执行这个类的<clinit>()方法，<strong>其他线程都需要阻塞等待</strong>，直到活动线程执行完毕<clinit>()方法。</p><h4 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h4><p>Java虚拟机设计团队有意把类加载阶段中的“通过一个类的全限定名来获取描述该类的二进制字节流”这个动作放到Java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需的类。实现这个动作的代码被称为“类加载器”（Class Loader）。</p><p>类加载器虽然只用于实现类的加载动作，但它在Java程序中起到的作用却远超类加载阶段。对于任意一个类，都必须由加载它的类加载器和这个类本身一起共同确立其在Java虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。比较两个类是否“相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义。</p><h5 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h5><p>JDK 8及之前版本的Java三层类加载器</p><ul><li>启动类加载器（Bootstrap Class Loader）：前面已经介绍过，这个类加载器<strong>负责加载存放在<JAVA_HOME>\lib目录</strong>，或者被-Xbootclasspath参数所指定的路径中存放的，而且是Java虚拟机能够识别的（按照文件名识别，如rt.jar、tools.jar，名字不符合的类库即使放在lib目录中也不会被加载）类库加载到虚拟机的内存中。</li><li>扩展类加载器（Extension Class Loader）：它负责加载<JAVA_HOME>\lib\ext目录**中，或者被java.ext.dirs系统变量所指定的路径中所有的类库。</li><li>应用程序类加载器（Application Class Loader）：它<strong>负责加载用户类路径 （ClassPath）上所有的类库</strong>，开发者同样可以直接在代码中使用这个类加载器。如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。 </li></ul><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20211208205114267.png" alt="image-20211208205114267" style="zoom:50%;" /><p><strong>工作过程</strong></p><p>如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到最顶层的启动类加载器中，<strong>只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去完成加载。</strong> </p><p>使用双亲委派模型来组织类加载器之间的关系，一个显而易见的好处就是Java中的类随着它的类加载器一起具备了一种带有优先级的层次关系。例如类java.lang.Object，它存放在rt.jar之中，<strong>无论哪一 个类加载器要加载这个类，最终都是委派给处于模型最顶端的启动类加载器进行加载，因此Object类在程序的各种类加载器环境中都能够保证是同一个类。</strong></p><h5 id="破坏双亲委派"><a href="#破坏双亲委派" class="headerlink" title="破坏双亲委派"></a>破坏双亲委派</h5><h6 id="JNDI"><a href="#JNDI" class="headerlink" title="JNDI"></a><strong>JNDI</strong></h6><p>JNDI服务，它的代码由启动类加载器来完成加载（在JDK 1.3时加入到rt.jar的），它需要调用由其他厂商实现并部署在应用程序的ClassPath下的JNDI服务提供者接口（Service Provider Interface，SPI）的代码。</p><p>Java的设计团队只好引入了一个不太优雅的设计：<strong>线程上下文类加载器</strong>。这个类加载器可以通过java.lang.Thread类的setContext-ClassLoader()方法进行设置，如果创建线程时还未设置，它将会从父线程中继承一个，如果在应用程序的全局范围内都没有设置过的话，那这个类加载器默认就是应用程序类加载器。<strong>JNDI服务使用这个线程上下文类加载器去加载所需的SPI服务代码，这是一种父类加载器去请求子类加载器完成类加载的行为</strong>，这种行为实际上是打通了双亲委派模型的层次结构来逆向使用类加载器。</p><h6 id="OSGi"><a href="#OSGi" class="headerlink" title="OSGi"></a><strong>OSGi</strong></h6><p>OSGi实现模块化热部署的关键是它自定义的类加载器机制的实现，<strong>每一个程序模块（OSGi中称为 Bundle）都有一个自己的类加载器，当需要更换一个Bundle时，就把Bundle连同类加载器一起换掉以实 现代码的热替换。在OSGi环境下，类加载器不再双亲委派模型推荐的树状结构，而是进一步发展为更 加复杂的网状结构</strong>，当收到类加载请求时，OSGi将按照下面的顺序进行类搜索： </p><p>1）将以java.*开头的类，委派给父类加载器加载。 </p><p>2）否则，将委派列表名单内的类，委派给父类加载器加载。 </p><p>3）否则，将Import列表中的类，委派给Export这个类的Bundle的类加载器加载。 </p><p>4）否则，查找当前Bundle的ClassPath，使用自己的类加载器加载。 </p><p>5）否则，查找类是否在自己的Fragment Bundle中，如果在，则委派给Fragment Bundle的类加载器 加载。</p><p>6）否则，<strong>查找Dynamic Import列表的Bundle</strong>，委派给对应Bundle的类加载器加载。 </p><p>7）否则，类查找失败。</p><h6 id="TomCat-6"><a href="#TomCat-6" class="headerlink" title="TomCat 6"></a><strong>TomCat 6</strong></h6><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20211213093415073.png" alt="image-20211213093415073" style="zoom:50%;" /><p>灰色背景的3个类加载器是JDK（以JDK 9之前经典的三层类加载器为例）默认提供的类加载器。而Common类加载器、Catalina类加载器（也称为Server类 加载器）、Shared类加载器和Webapp类加载器则是Tomcat自己定义的类加载器，它们分别加 载/common/<em>、/server/</em>、/shared/<em>和/WebApp/WEB-INF/</em>中的Java类库。其中WebApp类加载器和JSP类 加载器通常还会存在多个实例，<strong>每一个Web应用程序对应一个WebApp类加载器，每一个JSP文件对应 一个JasperLoader类加载器。</strong> </p><p>从图的委派关系中可以看出，Common类加载器能加载的类都可以被Catalina类加载器和Shared 类加载器使用，而Catalina类加载器和Shared类加载器自己能加载的类则与对方相互隔离。<strong>WebApp类 加载器可以使用Shared类加载器加载到的类，但各个WebApp类加载器实例之间相互隔离</strong>。而JasperLoader的加载范围仅仅是这个JSP文件所编译出来的那一个Class文件，它存在的目的就是为了被 丢弃：当服务器检测到JSP文件被修改时，会替换掉目前的JasperLoader的实例，并通过再建立一个新的JSP类加载器来实现JSP文件的HotSwap功能。 </p><p>在Tomcat 6及之后的版本简化了默认的目录结构，只有指定了tomcat/conf/catalina.properties配置文件的server.loader和share.loader项后才会真正建立Catalina类加载器和Shared类加载器的实例，否则会用到这两个类加载器的地方都会用 Common类加载器的实例代替。</p><h3 id="类文件结构"><a href="#类文件结构" class="headerlink" title="类文件结构"></a>类文件结构</h3><p>各种不同平台的Java虚拟机，以及所有平台都统一支持的程序存储格式——字节码（Byte Code）是构成平台无关性的基石。实现语言无关性的基础仍然是虚拟机和字节码存储格式。Java虚拟机不与包括Java语言在内的任何程序语言绑定，它只与“Class文件”这种特定的二进制文件格式所关联。</p><p>Class文件格式采用一种类似于C语言结构体的伪结构来存储数据，这种伪结构中只有两种数据类型：“无符号数”和“表”。</p><ul><li>无符号数属于基本的数据类型，以u1、u2、u4、u8来分别代表1个字节、2个字节、4个字节和8个 字节的无符号数，无符号数可以用来描述数字、索引引用、数量值或者按照UTF-8编码构成字符串值。</li><li>表是由多个无符号数或者其他表作为数据项构成的复合数据类型，。表用于描述有层次关系的复合结构的数据，整个Class文件本质上也可以视作是一张表，这张表由表6-1所示的数据项按严格顺序排列构成。</li></ul><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20211209204359699.png" alt="image-20211209204359699" style="zoom:50%;" /><h4 id="魔数与-Class-文件的版本（magic、minor-version、major-version）"><a href="#魔数与-Class-文件的版本（magic、minor-version、major-version）" class="headerlink" title="魔数与 Class 文件的版本（magic、minor_version、major_version）"></a>魔数与 Class 文件的版本（magic、minor_version、major_version）</h4><p>每个Class文件的头4个字节被称为魔数（Magic Number），它的唯一作用是确定这个文件是否为一个能被虚拟机接受的Class文件。Class文件的魔数取得很有“浪漫气息”， 值为<strong>0xCAFEBABE</strong>。</p><p>紧接着魔数的4个字节存储的是Class文件的版本号：第5和第6个字节是次版本号（Minor Version），第7和第8个字节是主版本号（Major Version）。Java的版本号是从45开始的，JDK 1.1之后的每个JDK大版本发布主版本号向上加1（JDK 1.0～1.1使用了45.0～45.3的版本号），高版本的JDK能向下兼容以前版本的Class文件，但不能运行以后版本的Class文件。</p><h4 id="常量池（constant-pool-count、constant-pool）"><a href="#常量池（constant-pool-count、constant-pool）" class="headerlink" title="常量池（constant_pool_count、constant_pool）"></a>常量池（constant_pool_count、constant_pool）</h4><p>常量池容量计数值（constant_pool_count）。与Java中语言习惯不同，<strong>这个容量计数是从1而不是0开始的</strong>。如果后面某些指向常量池的索引值的数据在特定情况下需要表达“不引用任何一个常量池项目”的含义，可以把索引值设置为0来表示。</p><p>常量池中主要存放两大类常量：<strong>字面量（Literal）和符号引用（Symbolic References）。</strong>字面量比较接近于Java语言层面的常量概念，如文本字符串、被声明为final的常量值等。而符号引用则属于编译理方面的概念，主要包括下面几类常量：</p><ul><li><p>被模块导出或者开放的包（Package） </p></li><li><p>类和接口的全限定名（Fully Qualified Name） </p></li><li><p>字段的名称和描述符（Descriptor） </p></li><li><p>方法的名称和描述符 </p></li><li><p>方法句柄和方法类型（Method Handle、Method Type、Invoke Dynamic） </p></li><li><p>动态调用点和动态常量（Dynamically-Computed Call Site、Dynamically-Computed Constant） </p></li></ul><p>在Class文件中不会保存各个方法、字段最终在内存中的布局信息，这些字段、方法的符号引用不经过虚拟机在运行期转换的话是无法得到真正的内存入口地址，也就无法直接被虚拟机使用的。<strong>当虚拟机做类加载时，将会从常量池获得对应的符号引用，再在类创建时或运行时解析、翻译到具体的内存地址之中。</strong></p><p>常量池中每一项常量都是一个表，最初常量表中共有11种结构各不相同的表结构数据，后来为了更好地支持动态语言调用，额外增加了4种动态语言相关的常量。</p><p>==<strong>常量池中的每一项都由一个标志位和一个表结构组成，根据具体的表结构依次解析</strong>==</p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20211209205804239.png" alt="image-20211209205804239" style="zoom:50%;" /><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20211209210016634.png" alt="image-20211209210016634" style="zoom: 50%;" /><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20211209210039079.png" alt="image-20211209210039079" style="zoom: 80%;" /><img src="C:\Users\ming hoo\AppData\Roaming\Typora\typora-user-images\image-20211209210107237.png" alt="image-20211209210107237" style="zoom: 80%;" /><h4 id="访问标志（access-flags）"><a href="#访问标志（access-flags）" class="headerlink" title="访问标志（access_flags）"></a>访问标志（access_flags）</h4><p>志用于识别一些类或者接口层次的访问信息，包括：这个Class是类还是接口；是否定义为public类型；是否定义为abstract 类型；如果是类的话，是否被声明为final；等等</p><p>如果一个类含有某个标志，就用这个标志做或运算，例如一个普通的public类，它的ACC_PUBLIC、ACC_SUPER标志应当为真，它的access_flags的值应为：0x0001|0x0020=0x0021。</p><img src="C:\Users\ming hoo\AppData\Roaming\Typora\typora-user-images\image-20211209210612740.png" alt="image-20211209210612740" style="zoom:50%;" /><h4 id="类索引（this-class）、父类索引（super-class）与接口索引集合（interfaces）"><a href="#类索引（this-class）、父类索引（super-class）与接口索引集合（interfaces）" class="headerlink" title="类索引（this_class）、父类索引（super_class）与接口索引集合（interfaces）"></a>类索引（this_class）、父类索引（super_class）与接口索引集合（interfaces）</h4><p>类索引（this_class）和父类索引（super_class）都是一个u2类型的数据，而接口索引集合 （interfaces）是一组u2类型的数据的集合，<strong>Class文件中由这三项数据来确定该类型的继承关系</strong>。</p><p>类索引用于确定这个类的全限定名，父类索引用于确定这个类的父类的全限定名。由于Java语言不允许多重继承，所以父类索引只有一个，除了java.lang.Object之外，所有的Java类都有父类，<strong>因此除了java.lang.Object外，所有Java类的父类索引都不为0。</strong></p><p>接口索引集合就用来描述这个类实现了哪些接口，这些被实现的接口将按implements关键字（如果这个Class文件表示的是一个接口，则应当是 extends关键字）后的接口顺序从左到右排列在接口索引集合中。</p><p>类索引、父类索引和接口索引集合都按顺序排列在访问标志之后，<strong>类索引和父类索引用两个u2类型的索引值表示，它们各自指向一个类型为CONSTANT_Class_info的类描述符常量，通过 CONSTANT_Class_info类型的常量中的索引值可以找到定义在CONSTANT_Utf8_info类型的常量中的 全限定名字符串。</strong></p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20211209211634371.png" alt="image-20211209211634371" style="zoom:50%;" /><p>上图类索引为 1 指向常量池第 1 项常量，它是一个 CONSTANT_Class_info ，它内部 index 为 2，指向一个 CONSTANT_Utf8_info，它存储了类的全限定名字符串。父类的限定名查找过程类似。</p><p>对于接口索引集合，入口的第一项u2类型的数据为接口计数器（interfaces_count），表示索引表的容量。如果该类没有实现任何接口，则该计数器值为0，后面接口的索引表不再占用任何字节。</p><p><strong>同样的对于索引集合里的每一个接口索引进行全限定名查找</strong>，过程与类的全限定名查找过程类似。</p><h4 id="字段表集合（fields）"><a href="#字段表集合（fields）" class="headerlink" title="字段表集合（fields）"></a>字段表集合（fields）</h4><p>字段表（field_info）用于<strong>描述接口或者类中声明的变量</strong>。Java语言中的“字段”（Field）包括类级变量以及实例级变量，但<strong>不包括在方法内部声明的局部变量</strong>。</p><p>一个字段包含各种修饰符和字段名，字段类型。修饰符这些可以用 bool 值表示，字段名和字段类型只能引用常量池中的常量来描述。</p><p>同样fields_count 表示字段表的个数，后面跟着字段表的集合。</p><img src="C:\Users\ming hoo\AppData\Roaming\Typora\typora-user-images\image-20211209214554703.png" alt="image-20211209214554703" style="zoom:50%;" /><p>字段修饰符放在access_flags项目中，它与类中的access_flags项目是非常类似的</p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20211209214627762.png" alt="image-20211209214627762" style="zoom:50%;" /><p>name_index和descriptor_index。它们都是<strong>对常量池项的引用</strong>，分别代表着字段的简单名称以及<strong>字段和方法的描述符（这里的是字段）</strong>。描述符的作用是用来描述字段 的数据类型、方法的参数列表（包括数量、类型以及顺序）和返回值。根据描述符规则，基本数据类型（byte、char、double、float、int、long、short、boolean）以及代表无返回值的void类型都用一个大 写字符来表示，而对象类型则用字符L加对象的全限定名来表示。</p><img src="C:\Users\ming hoo\AppData\Roaming\Typora\typora-user-images\image-20211209215425829.png" alt="image-20211209215425829" style="zoom:50%;" /><p>对于数组类型，每一维度将使用一个前置的“[”字符来描述，如一个定义为“java.lang.String[][]”类型 的二维数组将被记录成“[[Ljava/lang/String；”，一个整型数组“int[]”将被记录成“[I”。 </p><p>用描述符来描述方法时，按照先参数列表、后返回值的顺序描述，参数列表按照参数的严格顺序放在一组小括号“()”之内。如方法void inc()的描述符为“()V”，方法java.lang.String toString()的描述符为“()Ljava/lang/String；”，方法int indexOf(char[]source，int sourceOffset，int sourceCount，char[]target，int targetOffset，int targetCount，int fromIndex)的描述符为“([CII[CIII)I”。</p><p>在descriptor_index之后 跟随着一个属性表集合，用于存储一些额外的信息，字段表可以在属性表中附加描述零至多项的额外信息。对于本例中的字段m，它的属性表计数器为0，也就是没有需要额外描述的信息，但是，<strong>如果将字段m的声明改为“final static int m=123；”，那就可能会存在一项名称为ConstantValue的属性，其值指向常量123。</strong></p><h4 id="方法表集合（methods）"><a href="#方法表集合（methods）" class="headerlink" title="方法表集合（methods）"></a>方法表集合（methods）</h4><p>Class文件存储 格式中对方法的描述与对字段的描述采用了几乎完全一致的方式</p><img src="C:\Users\ming hoo\AppData\Roaming\Typora\typora-user-images\image-20211209220010350.png" alt="image-20211209220010350" style="zoom:50%;" /><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20211209220036081.png" alt="image-20211209220036081" style="zoom:50%;" /><p>方法里的Java代码，经过Javac编译器编译成字节码指令之 后，存放在方法属性表集合中一个名为“Code”的属性里面。</p><h4 id="属性表集合"><a href="#属性表集合" class="headerlink" title="属性表集合"></a>属性表集合</h4><p>属性表（attribute_info）在前面的讲解之中已经出现过数次，Class文件、字段表、方法表都可以携带自己的属性表集合，以描述某些场景专有的信息。 《Java虚拟机规范》允许只要不与已有属性名重复，任 何人实现的编译器都可以向属性表中写入自己定义的属性信息，Java虚拟机运行时会忽略掉它不认识 的属性。</p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20211210112511479.png" alt="image-20211210112511479" style="zoom: 67%;" /><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20211210112808863.png" alt="image-20211210112808863" style="zoom:67%;" /><p>对于每一个属性，它的名称都要从常量池中引用一个CONSTANT_Utf8_info类型的常量来表示， 而属性值的结构则是完全自定义的，只需要通过一个u4的长度属性去说明属性值所占用的位数即可。 </p><p>由于属性名称索引与属性长度一共为 6个字节，所以<strong>属性值的长度固定为整个属性表长度减去6个字节。</strong> </p><img src="C:\Users\ming hoo\AppData\Roaming\Typora\typora-user-images\image-20211210113349933.png" alt="image-20211210113349933" style="zoom:50%;" /><h5 id="Code-属性"><a href="#Code-属性" class="headerlink" title="Code 属性"></a>Code 属性</h5><p>Java程序方法体里面的代码经过Javac编译器处理之后，最终变为字节码指令存储在Code属性内。 Code属性出现在方法表的属性集合之中，但并非所有的方法表都必须存在这个属性，譬如接口或者抽象类中的方法就不存在Code属性。</p><img src="C:\Users\ming hoo\AppData\Roaming\Typora\typora-user-images\image-20211210113450313.png" alt="image-20211210113450313" style="zoom:50%;" /><ul><li>attribute_name_index是一项指向CONSTANT_Utf8_info型常量的索引，此<strong>常量值固定为“Code”，它代表了该属性的属性名称</strong></li><li>attribute_length指示了<strong>属性值的长度</strong></li><li>max_stack代表了<strong>操作数栈（Operand Stack）深度的最大值</strong></li><li>max_locals代表了<strong>局部变量表所需的存储空间</strong>。在这里，max_locals的单位是变量槽（Slot），变量槽是虚拟机为局部变量分配内存所使用的最小单位。对于byte、char、float、int、short、boolean和 returnAddress等长度不超过32位的数据类型，每个局部变量占用一个变量槽，而double和long这两种64位的数据类型则需要两个变量槽来存放。</li><li>code_length和code用来存储Java源程序编译后生成的字节码指令。code_length代表字节码长度， code是用于存储字节码指令的一系列字节流。既然叫字节码指令，那顾名思义每个指令就是一个u1类型的单字节，当虚拟机读取到code中的一个字节码时，就可以对应找出这个字节码代表的是什么指令，并且可以知道这条指令后面是否需要跟随参数，以及后续的参数应当如何解析。《<strong>Java虚拟机规范》中明确限制了一个方法不允许超过65535条字节码指令</strong>。</li></ul><p>Code属性是Class文件中最重要的一个属性，如果把一个Java程序中的信息分为代码（Code，方法体里面的Java代码）和元数据（Metadata，包括类、字段、方法定义及其他信息）两部分，<strong>那么在整个Class文件里，Code属性用于描述代码，所有的其他数据项目都用于描述元数据。</strong></p><h5 id="Exceptions属性"><a href="#Exceptions属性" class="headerlink" title="Exceptions属性"></a>Exceptions属性</h5><img src="C:\Users\ming hoo\AppData\Roaming\Typora\typora-user-images\image-20211210114108226.png" alt="image-20211210114108226" style="zoom:50%;" /><ul><li><p>number_of_exceptions表示方法可能抛出number_of_exceptions种受查异常，</p></li><li><p>每一种受查异常使用一个exception_index_table项表示；</p></li><li><p>exception_index_table是一个指向常量池中 CONSTANT_Class_info型常量的索引，代表了该受查异常的类型。 </p></li></ul><h5 id="ConstantValue属性"><a href="#ConstantValue属性" class="headerlink" title="ConstantValue属性"></a>ConstantValue属性</h5><p>ConstantValue属性的作用是通知虚拟机自动为静态变量赋值。只有被static关键字修饰的变量（类变量）才可以使用这项属性。类似“int x=123”和“static int x=123”这样的变量定义在Java程序里面是非常常见的事情，但虚拟机对这两种变量赋值的方式和时刻都有所不同。对非static类型的变量（也就是 实例变量）的赋值是<strong>在实例构造器<init>()方法中进行的</strong>；而对于类变量，则有两种方式可以选择：<strong>在类构造器<clinit>()方法中或者使用ConstantValue属性。</strong></p><img src="C:\Users\ming hoo\AppData\Roaming\Typora\typora-user-images\image-20211210115206868.png" alt="image-20211210115206868" style="zoom:50%;" /><ul><li>constantvalue_index数据项代表了常量池中一个字面量常量的引用，根据字段类型的不同，字面量可以是CONSTANT_Long_info、CONSTANT_Float_info、CONSTANT_Double_info、 CONSTANT_Integer_info和CONSTANT_String_info常量中的一种。</li><li>attribute_length 长度就是2，存储一个 constantvalue_index</li></ul><h5 id="InnerClasses属性"><a href="#InnerClasses属性" class="headerlink" title="InnerClasses属性"></a>InnerClasses属性</h5><p>InnerClasses属性用于记录内部类与宿主类之间的关联。如果一个类中定义了内部类，那编译器将会为它以及它所包含的内部类生成InnerClasses属性。</p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20211210115818750.png" alt="image-20211210115818750" style="zoom:50%;" /><ul><li>number_of_classes 这个类有多少个内部类</li><li>inner_class 内部类信息描述 inner_classes_info表 集合</li></ul><img src="C:\Users\ming hoo\AppData\Roaming\Typora\typora-user-images\image-20211210115934445.png" alt="image-20211210115934445" style="zoom:50%;" /><ul><li>inner_class_info_index和outer_class_info_index都是指向常量池中CONSTANT_Class_info型常量的索引，分别代表了内部类和宿主类的符号引用。 </li><li>inner_name_index是指向常量池中CONSTANT_Utf8_info型常量的索引，代表这个内部类的名称，如果是匿名内部类，这项值为0。</li><li>inner_class_access_flags是内部类的访问标志，类似于类的access_flags。 </li></ul><h5 id="Signature属性"><a href="#Signature属性" class="headerlink" title="Signature属性"></a>Signature属性</h5><p>任何类、接口、初 始化方法或成员的泛型签名如果包含了<strong>类型变量（Type Variable）或参数化类型（Parameterized Type）</strong>，则Signature属性会为它记录泛型签名信息。之所以要专门使用这样一个属性去记录泛型类 型，是因为Java语言的泛型采用的是擦除法实现的伪泛型，字节码（Code属性）中所有的泛型信息编译（类型变量、参数化类型）在编译之后都通通被擦除掉。</p><p>使用擦除法的好处是实现简单（主要修改 Javac编译器，虚拟机内部只做了很少的改动）、非常容易实现Backport，运行期也能够节省一些类型所占的内存空间。但坏处是运行期就无法像C#等有真泛型支持的语言那样，将泛型类型与用户定义的普通类型同等对待，<strong>例如运行期做反射时无法获得泛型信息。Signature属性就是为了弥补这个缺陷而增设的，现在Java的反射API能够获取的泛型类型，最终的数据来源也是这个属性。</strong></p><img src="C:\Users\ming hoo\AppData\Roaming\Typora\typora-user-images\image-20211210140915403.png" alt="image-20211210140915403" style="zoom:50%;" /><ul><li>signature_index项的值必须是一个对常量池的有效索引。表示类签名或方法类型签名或字段类型签名。如果当前的Signature属性 是类文件的属性，则这个结构表示类签名，如果当前的Signature属性是方法表的属性，则这个结构表示方法类型签名，如果当前Signature属性是字段表的属性，则这个结构表示字段类型签名。</li></ul><h5 id="MethodParameters属性"><a href="#MethodParameters属性" class="headerlink" title="MethodParameters属性"></a>MethodParameters属性</h5><p>MethodParameters是在JDK 8时新加入到Class文件格式中的，它是一个用在方法表中的变长属性。 MethodParameters的作用是<strong>记录方法的各个形参名称和信息。</strong></p><img src="C:\Users\ming hoo\AppData\Roaming\Typora\typora-user-images\image-20211210141452072.png" alt="image-20211210141452072" style="zoom:50%;" /><ul><li><p>name_index是一个指向常量池CONSTANT_Utf8_info常量的索引值，代表了该参数的名称。</p></li><li><p>而access_flags是参数的状态指示器，它可以包含以下三种状态中的一种或多种： </p><p>0x0010（ACC_FINAL）：表示该参数被final修饰。 </p><p>0x1000（ACC_SYNTHETIC）：表示该参数并未出现在源文件中，是编译器自动生成的。 0x8000（ACC_MANDATED）：表示该参数是在源文件中隐式定义的。Java语言中的典型场景是this关键字。 </p></li></ul><h5 id="运行时注解相关属性"><a href="#运行时注解相关属性" class="headerlink" title="运行时注解相关属性"></a>运行时注解相关属性</h5><p>为了存储源码中注解信息，Class文件同步增加了RuntimeVisibleAnnotations等四个属性，JDK8又增加了两个属性。以RuntimeVisibleAnnotations为代表进行介绍。</p><p><strong>RuntimeVisibleAnnotations是一个变长属性，它记录了类、字段或方法的声明上记录运行时可见注解，当我们使用反射API来获取类、字段或方法上的注解时，返回值就是通过这个属性来取到的。</strong></p><img src="C:\Users\ming hoo\AppData\Roaming\Typora\typora-user-images\image-20211210142018230.png" alt="image-20211210142018230" style="zoom:50%;" /><ul><li><p>num_annotations 是 annotations 数组的计数器，annotations中每个元素都代表了一个运行时可见的注 </p><p>解，注解在Class文件中以annotation结构来存储</p></li></ul><img src="C:\Users\ming hoo\AppData\Roaming\Typora\typora-user-images\image-20211210142127640.png" alt="image-20211210142127640" style="zoom:50%;" /><ul><li><p>type_index是一个指向常量池CONSTANT_Utf8_info常量的索引值，该常量应以字段描述符的形式表示一个注解。</p></li><li><p>num_element_value_pairs是element_value_pairs数组的计数器，element_value_pairs中每个元素都是一个键值对，代表该<strong>注解的参数和值</strong>。 </p></li></ul><h5 id="其他属性"><a href="#其他属性" class="headerlink" title="其他属性"></a>其他属性</h5><h6 id="LineNumberTable属性"><a href="#LineNumberTable属性" class="headerlink" title="LineNumberTable属性"></a>LineNumberTable属性</h6><p>LineNumberTable属性用于描述Java源码行号与字节码行号（字节码的偏移量）之间的对应关系。 </p><h6 id="LocalVariableTable及LocalVariableTypeTable属性"><a href="#LocalVariableTable及LocalVariableTypeTable属性" class="headerlink" title="LocalVariableTable及LocalVariableTypeTable属性"></a>LocalVariableTable及LocalVariableTypeTable属性</h6><p>LocalVariableTable属性用于描述<strong>栈帧中局部变量表的变量与Java源码中定义的变量之间的关系</strong>，它也不是运行时必需的属性。如果没有生成这项属性，最大的影响就是当其他人引用这个方法时，所有的参数名称都将会丢失。</p><h6 id="SourceFile及SourceDebugExtension属性"><a href="#SourceFile及SourceDebugExtension属性" class="headerlink" title="SourceFile及SourceDebugExtension属性"></a>SourceFile及SourceDebugExtension属性</h6><p>SourceFile属性用于记录生成这个Class文件的源码文件名称。在JDK 5时，新增了 SourceDebugExtension属性用于存储额外的代码调试信息。</p><h3 id="虚拟机字节码执行引擎"><a href="#虚拟机字节码执行引擎" class="headerlink" title="虚拟机字节码执行引擎"></a>虚拟机字节码执行引擎</h3><p>在不同的虚拟机实现中，执行引擎在执行字节码的时候，通常会有解释执行（通过解释器执行）和编译执行（通过即时编译器产生本地代码执行）两种选择，也可能两者兼备，还可能会有同时包含几个不同级别的即时编译器一起工作的执行引擎。但从外观上来看，所有的Java虚拟机的执行引擎输入、输出都是一致的：输入的是字节码二进制流，处理过程是字节码解析执行的等效过程，输出的是执行结果</p><h4 id="运行时栈帧结构"><a href="#运行时栈帧结构" class="headerlink" title="运行时栈帧结构"></a>运行时栈帧结构</h4><p>栈帧存储了方法的局部变量表、操作数栈、动态连接和方法返回地址等信息，如果读者认真阅读过”类文件结构“这一章，应该能<strong>从Class文件格式的方法表中找到以上大多数概念的静态对照物</strong>。<strong>每 一个方法从调用开始至执行结束的过程，都对应着一个栈帧在虚拟机栈里面从入栈到出栈的过程。</strong></p><p>每一个栈帧都包括了局部变量表、操作数栈、动态连接、方法返回地址和一些额外的附加信息。 在编译Java程序源码的时候，<strong>栈帧中需要多大的局部变量表，需要多深的操作数栈就已经被分析计算 出来，并且写入到方法表的Code属性之中</strong>。</p><p>而对于执行引擎来讲，在活动线程中，只有位于栈顶的方法才是在运行的，只有位于栈顶的栈帧才是生效的，其被称为“当前栈帧”（Current Stack Frame），与这个栈帧所关联的方法被称为“当前方法”（Current Method）。执行引擎所运行的所有字节码指令都只针对当前栈帧进行操作。</p><img src="C:\Users\ming hoo\AppData\Roaming\Typora\typora-user-images\image-20211210143728813.png" alt="image-20211210143728813" style="zoom:50%;" /><h5 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h5><p>局部变量表（Local Variables Table）是一组变量值的存储空间，<strong>用于存放方法参数和方法内部定义的局部变量</strong>。在Java程序被编译为Class文件时，就在方法的Code属性的max_locals数据项中确定了该方法所需分配的局部变量表的最大容量。 </p><p>一个变量槽可以存放一个32位以内的数据类型，Java中占用不超过32位存储空间的数据类型有boolean、byte、char、short、int、 float、reference和returnAddress这8种类型。第7种reference类型表示对一个对象实例的引用，《Java虚拟机规范》既没有说明它的长度，也没有明确指出这种引用应有怎样的结构。但是一般来说，虚拟机实现至少都应当能通过这个引用做到两件事情，一是从根据引用直接或间接地查找到对象在Java堆中的数据存放的起始地址或索引，二是根据引用直接或间接地查找到对象所属数据类型在方法区中的存储的类型信息。第8种returnAddress类型目前已经很少见了，它是为字节码指令jsr、jsr_w和ret服务的，指向了一条字节码指令的地址。</p><p>Java虚拟机通过索引定位的方式使用局部变量表，索引值的范围是从0开始至局部变量表最大的变量槽数量。当一个方法被调用时，<strong>Java虚拟机会使用局部变量表来完成参数值到参数变量列表的传递过程</strong>， 即实参到形参的传递。<strong>如果执行的是实例方法（没有被static修饰的方法），那局部变量表中第0位索引的变量槽默认是用于传递方法所属对象实例的引用</strong>，在方法中可以通过关键字“this”来访问到这个隐含的参数。其余参数则按照参数表顺序排列，占用从1开始的局部变量槽，参数表分配完毕后，再根据方法体内部定义的变量顺序和作用域分配其余的变量槽。 </p><p>类的字段变量有两次赋初始值的过程，一次在准备阶段，赋予系统初始值；另外一次在初始化阶段，赋予程序员定义的初始值。因此即使在初始化阶段程序员没有为类变量赋值也没有关系，类变量仍然具有一个确定的初始值，不会产生歧义。但局部变量就不一样了，<strong>如果一个局部变量定义了但没有赋初始值，那它是完全不能使用的</strong>。</p><h5 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h5><p>操作数栈（Operand Stack）也常被称为操作栈，它是一个后入先出（Last In First Out，LIFO） 栈。同局部变量表一样，操作数栈的最大深度也在编译的时候被写入到Code属性的max_stacks数据项之中。操作数栈的每一个元素都可以是包括long和double在内的任意Java数据类型。</p><p><strong>当一个方法刚刚开始执行的时候，这个方法的操作数栈是空的，在方法的执行过程中，会有各种字节码指令往操作数栈中写入和提取内容，也就是出栈和入栈操作。譬如在做算术运算的时候是通过将运算涉及的操作数栈压入栈顶后调用运算指令来进行的，又譬如在调用其他方法的时候是通过操作数栈来进行方法参数的传递。</strong></p><p>操作数栈中元素的数据类型必须与字节码指令的序列严格匹配，在编译程序代码的时候，编译器必须要严格保证这一点，在类校验阶段的数据流分析中还要再次验证这一点。</p><p>另外在概念模型中，两个不同栈帧作为不同方法的虚拟机栈的元素，是完全相互独立的。但是在大多虚拟机的实现里都会进行一些优化处理，令两个栈帧出现一部分重叠。让下面栈帧的部分操作数栈与上面栈帧的部分局部变量表重叠在一起，这样做不仅节约了一些空间，更重要的是在进行方法调用时就可以直接共用一部分数据，无须进行额外的参数复制传递了</p><img src="C:\Users\ming hoo\AppData\Roaming\Typora\typora-user-images\image-20211210145233225.png" alt="image-20211210145233225" style="zoom:50%;" /><h5 id="动态连接"><a href="#动态连接" class="headerlink" title="动态连接"></a>动态连接</h5><p>每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了<strong>支持方法调用过程中的动态连接（Dynamic Linking）</strong>。我们知道Class文件的常量池中存有大量的符号引用，字节码中的方法调用指令就以常量池里指向方法的符号引用作为参数。这些符号 引用一部分会在<strong>类加载阶段或者第一次使用的时候</strong>就被转化为直接引用，这种转化被称为静态解析。 另外一部分将在每一次<strong>运行期间</strong>都转化为直接引用，这部分就称为动态连接。</p><h5 id="方法返回地址"><a href="#方法返回地址" class="headerlink" title="方法返回地址"></a>方法返回地址</h5><p>当一个方法开始执行后，只有两种方式退出这个方法。第一种方式是执行引擎<strong>遇到任意一个方法返回的字节码指</strong>令，这时候可能会有返回值传递给上层的方法调用者（调用当前方法的方法称为调用者或者主调方法），方法是否有返回值以及返回值的类型将根据遇到何种方法返回指令来决定，这种退出方法的方式称为“正常调用完成”（Normal Method Invocation Completion）。 </p><p>另外一种退出方式是在方法执行的过程中遇到了异常，并且这个异常没有在方法体内得到妥善处 理。无论是Java虚拟机内部产生的异常，还是代码中使用athrow字节码指令产生的异常，<strong>只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出</strong>，这种退出方法的方式称为“异常调用完成（Abrupt Method Invocation Completion）”。一个方法使用异常完成出口的方式退出，是不会给它的上层调用者提供任何返回值的。 </p><p>方法退出的过程实际上等同于把当前栈帧出栈，<strong>因此退出时可能执行的操作有：恢复上层方法的局部变量表和操作数栈，把返回值（如果有的话）压入调用者栈帧的操作数栈中，调整PC计数器的值以指向方法调用指令后面的一条指令等</strong>。笔者这里写的“可能”是由于这是基于概念模型的讨论，只有具体到某一款Java虚拟机实现，会执行哪些操作才能确定下来。</p><h4 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h4><p>方法调用并不等同于方法中的代码被执行，方法调用阶段唯一的任务就是<strong>确定被调用方法的版本 （即调用哪一个方法）</strong>，暂时还未涉及方法内部的具体运行过程。在程序运行时，进行方法调用是最普遍、最频繁的操作之一。</p><h5 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h5><p>所有方法调用的目标方法在Class文件里面都是一个常量池中的符号引用，在类加载的解析阶段，会将其中的一部分符号引用转化为直接引用，这种解析能够成立的前提是：方法在程序真正运行之前就有一个可确定的调用版本，并且这个方法的调用版本在运行期是不 可改变的。换句话说，<strong>调用目标在程序代码写好、编译器进行编译那一刻就已经确定下来。这类方法的调用被称为解析（Resolution）。</strong> </p><p>在Java语言中符合“编译期可知，运行期不可变”这个要求的方法，主要有静态方法和私有方法两大类，前者与类型直接关联，后者在外部不可被访问，这两种方法各自的特点决定了它们都不可能通过继承或别的方式重写出其他版本，因此它们都适合在类加载阶段进行解析。 </p><p>在Java虚拟机支持以下5条方法调用字 节码指令，分别是： </p><ul><li>invokestatic。用于调用静态方法。 </li><li>invokespecial。用于调用实例构造器<init>()方法、私有方法和父类中的方法。 </li><li>invokevirtual。用于调用所有的虚方法。 </li><li>invokeinterface。用于调用接口方法，会在运行时再确定一个实现该接口的对象。 </li><li>invokedynamic。先在运行时动态解析出调用点限定符所引用的方法，然后再执行该方法。前面4 条调用指令，分派逻辑都固化在Java虚拟机内部，而invokedynamic指令的分派逻辑是由用户设定的引导方法来决定的。 </li></ul><p>只要能被invokestatic和invokespecial指令调用的方法，都可以在解析阶段中确定唯一的调用版本， Java语言里符合这个条件的方法共有<strong>静态方法、私有方法、实例构造器、父类方法4种，再加上被final 修饰的方法</strong>（尽管它使用invokevirtual指令调用），这5种方法调用会<strong>在类加载的时候就可以把符号引用解析为该方法的直接引用</strong>。这些方法统称为“非虚方法”（Non-Virtual Method），与之相反，其他方法就被称为“虚方法”（Virtual Method）。</p><h5 id="分派"><a href="#分派" class="headerlink" title="分派"></a>分派</h5><h6 id="静态分派"><a href="#静态分派" class="headerlink" title="静态分派"></a>静态分派</h6><p>所有依赖静态类型来决定方法执行版本的分派动作，都称为静态分派。<strong>静态分派的最典型应用表现就是方法重载</strong>。静态分派发生在编译阶段，因此确定静态分派的动作实际上不是由虚拟机来执行的，这点也是为何一些资料选择把它归入“解析”而不是“分派”的原因。</p><img src="C:\Users\ming hoo\AppData\Roaming\Typora\typora-user-images\image-20211210150855521.png" alt="image-20211210150855521" style="zoom:50%;" /><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20211210150913420.png" alt="image-20211210150913420" style="zoom:50%;" /><p>“Human”称为变量的“静态类型”（Static Type），或者叫“外观类型”（Apparent Type），后面的“Man”则被称为变量的“实际类型”（Actual Type）或者叫“运行时类型”（Runtime Type）。静态类型和实际类型在程序中都可能会发生变化，区别是静态类型的变化仅仅在使用时发生，变量本身的静态类型不会被改变，并且最终的静态类型是在编译期可知的；而<strong>实际类型变化的结果在运行期才可确定</strong>。</p><p><strong>虚拟机（或者准确地说是编译器）在重载时是通过参数的静态类型而不是实际类型作为判定依据的。</strong>由于静态类型在编译期可知，所以在编译阶段，Javac编译器就根据参数的静态类型决定了会使用哪个重载版本，因此选择了sayHello(Human)作为调用目标，并把这个方法的符号引用写到main()方法里的两条invokevirtual指令的参数中。 </p><h6 id="动态分派"><a href="#动态分派" class="headerlink" title="动态分派"></a>动态分派</h6><p>它与Java语言多态性的另外 一个重要体现——重写（Override）有着很密切的关联。</p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20211210151742039.png" alt="image-20211210151742039" style="zoom:50%;" /><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20211210151802077.png" alt="image-20211210151802077"></p><p>显然这里选择调用的方法版本是不可能再根据静态类型来决定的，因为静态类型同样都是Human 的两个变量man和woman在调用sayHello()方法时产生了不同的行为，甚至变量man在两次调用中还执行了两个不同的方法。导致这个现象的原因很明显，是<strong>因为这两个变量的实际类型不同</strong>。</p><p>invokevirtual指令的运行时解析过程大致分为以下几步： </p><p>1）找到操作数栈顶的第一个元素所指向的对象的<strong>实际类型</strong>，记作C。 </p><p>2）如果在类型C中找到与<strong>常量中的描述符和简单名称都相符的方法</strong>，则进行访问权限校验，如果通过则返回这个方法的直接引用，查找过程结束；不通过则返回java.lang.IllegalAccessError异常。 </p><p>3）否则，按照<strong>继承关系从下往上依次对C的各个父类进行第二步的搜索和验证过程</strong>。 </p><p>4）如果始终没有找到合适的方法，则抛出java.lang.AbstractMethodError异常。 正是因为invokevirtual指令执行的第一步就是在运行期确定接收者的实际类型，所以两次调用中的 invokevirtual指令并不是把常量池中方法的符号引用解析到直接引用上就结束了，还会<strong>根据方法接收者的实际类型来选择方法版本</strong>，这个过程就是Java语言中方法重写的本质。我们把这种在运行期根据实际类型确定方法执行版本的分派过程称为动态分派。 </p><h6 id="单分派与多分派"><a href="#单分派与多分派" class="headerlink" title="单分派与多分派"></a>单分派与多分派</h6><p>方法的接收者与方法的参数统称为方法的宗量，这个定义最早应该来源于著名的《Java与模式》 一书。根据分派基于多少种宗量，可以将分派划分为<strong>单分派和多分派</strong>两种。单分派是根据一个宗量对目标方法进行选择，多分派则是根据多于一个宗量对目标方法进行选择。 </p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20211210152554601.png" alt="image-20211210152554601" style="zoom:50%;" /><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20211210152620285.png" alt="image-20211210152620285" style="zoom: 67%;" /><p>我们关注的首先是编译阶段中编译器的选择过程，也就是静态分派的过程。这时候选择目标方法的依据有两点：<strong>一是静态类型是Father还是Son，二是方法参数是QQ还是360</strong>。这次选择结果的最终产物是产生了两条invokevirtual指令，两条指令的参数分别为常量池中指向 Father::hardChoice(360)及Father::hardChoice(QQ)方法的符号引用。因为是根据两个宗量进行选择，所以 <strong>Java语言的静态分派属于多分派类型</strong></p><p>再看看运行阶段中虚拟机的选择，也就是动态分派的过程。在执行“son.hardChoice(new QQ())”这 行代码时，更准确地说，是在执行这行代码所对应的invokevirtual指令时，由于<strong>编译期已经决定目标方法的签名必须为hardChoice(QQ)</strong>，虚拟机此时不会关心传递过来的参数“QQ”到底是“腾讯QQ”还是“奇瑞QQ”，因为这时候参数的静态类型、实际类型都对方法的选择不会构成任何影响，<strong>唯一可以影响虚拟机选择的因素只有该方法的接受者的实际类型是Father还是Son</strong>。因为只有一个宗量作为选择依据， 所以<strong>Java语言的动态分派属于单分派类型。</strong> </p><p>根据上述论证的结果，我们可以总结一句：如今（直至本书编写的Java 12和预览版的Java 13）的Java语言是一门静态多分派、动态单分派的语言。</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20211210155815550.png" alt="image-20211210155815550"></p><p>虚方法表中存放着各个方法的实际入口地址<strong>。如果某个方法在子类中没有被重写，那子类的虚方法表中的地址入口和父类相同方法的地址入口是一致的，都指向父类的实现入口。如果子类中重写了 这个方法，子类虚方法表中的地址也会被替换为指向子类实现版本的入口地址。</strong>在图8-3中，Son重写了来自Father的全部方法，因此Son的方法表没有指向Father类型数据的箭头。但是Son和Father都没有重写来自Object的方法，所以它们的方法表中所有从Object继承来的方法都指向了Object的数据类型。 </p><h4 id="基于栈的字节码解释执行引擎"><a href="#基于栈的字节码解释执行引擎" class="headerlink" title="基于栈的字节码解释执行引擎"></a>基于栈的字节码解释执行引擎</h4><p>Javac编译器输出的字节码指令流，基本上[1]是一种基于栈的指令集架构（Instruction Set Architecture，ISA），字节码指令流里面的指令大部分都是零地址指令，它们依赖操作数栈进行工 作。与之相对的另外一套常用的指令集架构是基于寄存器的指令集，最典型的就是x86的二地址指令集。</p><p>基于栈的指令集主要优点是可移植，因为寄存器由硬件直接提供[2]，程序直接依赖这些硬件寄存器则不可避免地要受到硬件的约束。栈架构指令集的主要缺点是理论上执行速度相对来说会稍慢一些，所有主流物理机的指令集都是寄存器架构[3]也从侧面印证了这点。在解释执行时，栈架构指令集的代码虽然紧凑，但是完成相同功能所需的指令数量一般会比寄存器架构来得更多，因为出栈、入栈操作本身就产生了相当大量的指令。</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20211210153535799.png" alt="image-20211210153535799"></p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20211210153604072.png" alt="image-20211210153604072"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

&lt;h2 id=&quot;项目&quot;&gt;&lt;a href=&quot;#项目&quot; class=&quot;headerlink&quot; title=&quot;项目&quot;&gt;&lt;/a&gt;项目&lt;/h2&gt;&lt;h3 id=&quot;Mall&quot;&gt;&lt;a href=&quot;#Mall&quot; class=&quot;headerlink&quot; title
      
    
    </summary>
    
    
      <category term="Java" scheme="https://hoo334.github.io/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>常用集合</title>
    <link href="https://hoo334.github.io/2021/11/06/%E5%B8%B8%E7%94%A8%E9%9B%86%E5%90%88/"/>
    <id>https://hoo334.github.io/2021/11/06/%E5%B8%B8%E7%94%A8%E9%9B%86%E5%90%88/</id>
    <published>2021-11-06T03:19:38.000Z</published>
    <updated>2021-12-14T13:18:19.856Z</updated>
    
    <content type="html"><![CDATA[<p>Java 集合 API</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CollectionTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testStack</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Deque&lt;Integer&gt; stack = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// push</span></span><br><span class="line">        stack.push(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// top</span></span><br><span class="line">        Integer a = stack.peek();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// pop</span></span><br><span class="line">        stack.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Queue&lt;Integer&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="comment">// 队尾添加元素</span></span><br><span class="line">        q.offer(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 取出队头元素</span></span><br><span class="line">        Integer a = q.poll();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 检索队头元素</span></span><br><span class="line">        Integer b = q.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testDeque</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Deque&lt;Integer&gt; deque = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="comment">// 队尾添加元素</span></span><br><span class="line">        deque.addLast(<span class="number">3</span>);</span><br><span class="line">        <span class="comment">// 队头添加元素</span></span><br><span class="line">        deque.addFirst(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取队头元素</span></span><br><span class="line">        Integer a = deque.getFirst();</span><br><span class="line">        <span class="comment">// 获取队尾元素</span></span><br><span class="line">        Integer b = deque.getLast();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 队尾删除元素</span></span><br><span class="line">        deque.removeLast();</span><br><span class="line">        <span class="comment">// 队头删除元素</span></span><br><span class="line">        deque.removeFirst();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testPriorityQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 大根堆</span></span><br><span class="line">        PriorityQueue&lt;Integer&gt; q = <span class="keyword">new</span> PriorityQueue&lt;&gt;((o1, o2) -&gt; o2 - o1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        小根堆</span></span><br><span class="line"><span class="comment">//        PriorityQueue&lt;Integer&gt; queue = new PriorityQueue&lt;&gt;();</span></span><br><span class="line">        <span class="comment">// 添加元素</span></span><br><span class="line">        q.add(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查看堆顶元素和取出堆顶元素</span></span><br><span class="line">        Integer a = q.peek();</span><br><span class="line">        Integer b = q.poll();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 删除堆中指定元素， 删除堆顶元素</span></span><br><span class="line">        q.remove(<span class="number">3</span>);</span><br><span class="line">        q.remove();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java 集合 API&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://hoo334.github.io/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>买卖股票</title>
    <link href="https://hoo334.github.io/2021/10/22/%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8/"/>
    <id>https://hoo334.github.io/2021/10/22/%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8/</id>
    <published>2021-10-22T08:14:35.000Z</published>
    <updated>2021-11-04T03:16:46.933Z</updated>
    
    <content type="html"><![CDATA[<h4 id="121-买卖股票的最佳时机"><a href="#121-买卖股票的最佳时机" class="headerlink" title="121. 买卖股票的最佳时机"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/" target="_blank" rel="noopener">121. 买卖股票的最佳时机</a></h4><p>难度：简单</p><p>给定一个数组 <code>prices</code> ，它的第 <code>i</code> 个元素 <code>prices[i]</code> 表示一支给定股票第 <code>i</code> 天的价格。</p><p>你只能选择 <strong>某一天</strong> 买入这只股票，并选择在 <strong>未来的某一个不同的日子</strong> 卖出该股票。设计一个算法来计算你所能获取的最大利润。</p><p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 <code>0</code> 。</p><a id="more"></a><p> <strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：[7,1,5,3,6,4]</span><br><span class="line">输出：5</span><br><span class="line">解释：在第 2 天（股票价格 &#x3D; 1）的时候买入，在第 5 天（股票价格 &#x3D; 6）的时候卖出，最大利润 &#x3D; 6-1 &#x3D; 5 。</span><br><span class="line">     注意利润不能是 7-1 &#x3D; 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：prices &#x3D; [7,6,4,3,1]</span><br><span class="line">输出：0</span><br><span class="line">解释：在这种情况下, 没有交易完成, 所以最大利润为 0。</span><br></pre></td></tr></table></figure><p> <strong>提示：</strong></p><ul><li><code>1 &lt;= prices.length &lt;= 105</code></li><li><code>0 &lt;= prices[i] &lt;= 104</code></li></ul><p><strong>题解：</strong></p><p>对于只能买卖一次的股票交易，对于 prices 数组中的数对 （<code>prices[i]</code>，<code>prices[j]</code> 且<code>i &lt; j</code>，求 <code>prices[j] - prices[i]</code> 的最大值 。</p><p><strong>方法一：暴力枚举（代码略）</strong></p><p>直接枚举右边界 j，然后向左枚举左边界 i, 维护最大值。</p><ul><li><p>时间：$O(n^2)$</p></li><li><p>空间：$O(1)$ </p></li></ul><p><strong>方法二：一次遍历</strong></p><p>在遍历过程中维护最小值 minStock，省略内层循环。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.length &lt; <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// minStock 为 prices[0 ... i] 中最小值</span></span><br><span class="line">        <span class="keyword">int</span> minStock = prices[<span class="number">0</span>], profit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(prices[i] &gt; minStock)&#123;</span><br><span class="line">                profit = Math.max(profit, prices[i] - minStock);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                minStock = prices[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> profit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>时间：$O(n)$</p></li><li><p>空间：$O(1)$ </p></li></ul><h4 id="122-买卖股票的最佳时机-II"><a href="#122-买卖股票的最佳时机-II" class="headerlink" title="122. 买卖股票的最佳时机 II"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/" target="_blank" rel="noopener">122. 买卖股票的最佳时机 II</a></h4><p>难度：中等</p><p>给定一个数组 <code>prices</code> ，其中 <code>prices[i]</code> 是一支给定股票第 <code>i</code> 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p><p><strong>注意：</strong>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p> <strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: prices &#x3D; [7,1,5,3,6,4]</span><br><span class="line">输出: 7</span><br><span class="line">解释: 在第 2 天（股票价格 &#x3D; 1）的时候买入，在第 3 天（股票价格 &#x3D; 5）的时候卖出, 这笔交易所能获得利润 &#x3D; 5-1 &#x3D; 4 。</span><br><span class="line">     随后，在第 4 天（股票价格 &#x3D; 3）的时候买入，在第 5 天（股票价格 &#x3D; 6）的时候卖出, 这笔交易所能获得利润 &#x3D; 6-3 &#x3D; 3 。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: prices &#x3D; [1,2,3,4,5]</span><br><span class="line">输出: 4</span><br><span class="line">解释: 在第 1 天（股票价格 &#x3D; 1）的时候买入，在第 5 天 （股票价格 &#x3D; 5）的时候卖出, 这笔交易所能获得利润 &#x3D; 5-1 &#x3D; 4 。</span><br><span class="line">     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: prices &#x3D; [7,6,4,3,1]</span><br><span class="line">输出: 0</span><br><span class="line">解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</span><br></pre></td></tr></table></figure><p> <strong>提示：</strong></p><ul><li><code>1 &lt;= prices.length &lt;= 3 * 104</code></li><li><code>0 &lt;= prices[i] &lt;= 104</code></li></ul><p><strong>题解：</strong></p><p><strong>方法一：动态规划</strong></p><p>这次我们可以买卖多次股票，选择第 i - 1天和 第 i 天分析：</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20211022165325957.png" alt="image-20211022165325957"></p><p>第 i 天<strong>有股票</strong>的情况分两种：前一天就有股票；前一天没股票，第 i 天买了股票。</p><p>有股票时的最大利润为两者中的最大值</p><p>类似的，第 i 天<strong>没股票</strong>的情况分两种：前一天没有有股票；前一天有股票，第 i 天买了股票。</p><p>有股票时的最大利润为两者中的最大值</p><p>令 $ f[i][0]$ 为第 i 天<strong>有股票</strong>时的最大利润，令 $ f[i][1]$ 为第 i 天<strong>没股票</strong>时的最大利润，可以得到如下转移方程：<br>$$<br>f[i][0] = max(f[i - 1][0], f[i - 1][1] - prices[i])<br>$$</p><p>$$<br>f[i][1] = max(f[i - 1][1], f[i - 1][0] + prices[i])<br>$$</p><p>初始条件：$ f[i][0] = -prices[0]$，$ f[i][1] = 0$</p><p>第 0 天就持有股票的最大利润为负（利润为 0 时就买了第 0 天的股票），没有持有股票的最大利润为 0 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = prices.length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][<span class="number">2</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">            dp[i][<span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>时间：$O(n)$</p></li><li><p>空间：$O(n)$ </p></li></ul><p>可以看到 第 i 天的状态只与第 i - 1天有关，可以进行空间优化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = prices.length;</span><br><span class="line">        <span class="keyword">int</span> dp0 = <span class="number">0</span>, dp1 = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> newdp0 = Math.max(dp0, dp1 + prices[i]);</span><br><span class="line">            <span class="keyword">int</span> newdp1 = Math.max(dp1, dp0 - prices[i]);</span><br><span class="line">            dp0 = newdp0;</span><br><span class="line">            dp1 = newdp1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>时间：$O(n)$</p></li><li><p>空间：$O(1)$ </p></li></ul><p><strong>方法二：贪心</strong></p><p>由于不限制交易次数，只要今天股价比昨天高，就交易。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> profit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(prices[i] &gt; prices[i - <span class="number">1</span>])&#123;</span><br><span class="line">                profit += prices[i] - prices[i - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> profit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>时间：$O(n)$</p></li><li><p>空间：$O(1)$ </p></li></ul><h4 id="123-买卖股票的最佳时机-III"><a href="#123-买卖股票的最佳时机-III" class="headerlink" title="123. 买卖股票的最佳时机 III"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/" target="_blank" rel="noopener">123. 买卖股票的最佳时机 III</a></h4><p>难度：困难</p><p>给定一个数组，它的第 <code>i</code> 个元素是一支给定的股票在第 <code>i</code> 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 <strong>两笔</strong> 交易。</p><p><strong>注意：</strong>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p> <strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：prices &#x3D; [3,3,5,0,0,3,1,4]</span><br><span class="line">输出：6</span><br><span class="line">解释：在第 4 天（股票价格 &#x3D; 0）的时候买入，在第 6 天（股票价格 &#x3D; 3）的时候卖出，这笔交易所能获得利润 &#x3D; 3-0 &#x3D; 3 。</span><br><span class="line">     随后，在第 7 天（股票价格 &#x3D; 1）的时候买入，在第 8 天 （股票价格 &#x3D; 4）的时候卖出，这笔交易所能获得利润 &#x3D; 4-1 &#x3D; 3 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：prices &#x3D; [1,2,3,4,5]</span><br><span class="line">输出：4</span><br><span class="line">解释：在第 1 天（股票价格 &#x3D; 1）的时候买入，在第 5 天 （股票价格 &#x3D; 5）的时候卖出, 这笔交易所能获得利润 &#x3D; 5-1 &#x3D; 4 。   </span><br><span class="line">     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。   </span><br><span class="line">     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：prices &#x3D; [7,6,4,3,1] </span><br><span class="line">输出：0 </span><br><span class="line">解释：在这个情况下, 没有交易完成, 所以最大利润为 0。</span><br></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：prices &#x3D; [1]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure><p> <strong>提示：</strong></p><ul><li><code>1 &lt;= prices.length &lt;= 105</code></li><li><code>0 &lt;= prices[i] &lt;= 105</code></li></ul><p>此题与 122 不同的是，限制了交易次数，只能交易两次。</p><p>类似的，我们分析一下第 <code>i</code>天有几个状态，第<code>i - 1</code> 天到第<code>i</code> 天的转移关系是什么样的。</p><p>我们可以将每天分为 5 个状态：没有任何买卖操作，第一次持有股票，第一次卖完股票，第二次持有股票，第二次卖完股票。由于没有任何买卖操作，利润总是 0 ，我们需要计算的只有 4 个状态。</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20211022172452534.png" alt="image-20211022172452534"></p><p>令 $ f[i][0]$ 为第 i 天<strong>第一次持有股票</strong>时的最大利润，令 $ f[i][1]$ 为第 i 天<strong>第一次没有股票</strong>时的最大利润，令 $ f[i][2]$ 为第 i 天<strong>第二次持有股票</strong>时的最大利润，令 $ f[i][3]$ 为第 i 天<strong>第二次没有股票</strong>时的最大利润，可以得到如下转移方程：<br>$$<br>f[i][0] = max(f[i - 1][0],  - prices[i])<br>$$</p><p>$$<br>f[i][1] = max(f[i - 1][1], f[i - 1][0] + prices[i])<br>$$</p><p>$$<br>f[i][2] = max(f[i - 1][2], f[i - 1][1] - prices[i])<br>$$</p><p>$$<br>f[i][3] = max(f[i - 1][3], f[i - 1][2] + prices[i])<br>$$</p><p>初始条件：$ f[i][0] = f[i][2] = -prices[0]$，$ f[i][1] = f[i][3] = 0$</p><p>$f[i][2] = -prices[0]$ 可以理解为买了 prices[0]，然后立马卖了 prices[0]，再次买入 prices[0]，这样就是第二次有股票。</p><p>在考虑边界条件时我们注意到以下事实：</p><blockquote><p>==<strong>无论题目中是否允许同一天买入卖出，这一操作都不会对最终结果造成影响，因为这一操作收益为零</strong>==</p></blockquote><p>我们可以进一步优化上述转移方程：<br>$$<br>f[0] = max(f[0],  - prices[i])<br>$$</p><p>$$<br>f[1] = max(f[1], f[0] + prices[i])<br>$$</p><p>$$<br>f[2] = max(f[2], f[1] - prices[i])<br>$$</p><p>$$<br>f[3] = max(f[3], f[2] + prices[i])<br>$$</p><p>对于$f[0] = max(f[0],  - prices[i])$来说，这是滚动数组常用技巧，左边的 $f[0]$代表<strong>今天</strong>第一次持有股票的最大利润，右边的 $f[0]$代表昨天第一次持有股票的最大利润；</p><p>对于$f[1] = max(f[1], f[0] + prices[i])$来说，左边的 $f[1]$代表<strong>今天</strong>第一次没有股票的最大利润，右边的 $f[1]$代表昨天第一次没有股票的最大利润，此时 $f[0]$应该是代表<strong>昨天</strong>第一次持有股票的最大利润，但由于我们刚才已经把值更新为<strong>今天</strong>第一次持有股票的最大利润。为什么这样转移方程依然正确？</p><blockquote><p>将今天的 <code>f[0]</code>带入 <code>f[1]</code> 计算公式中，得到$f[1] = max(f[1], max(f[0], -prices[i])+ prices[i] \ )$，此时 $f[0]$是代表<strong>昨天</strong>第一次持有股票的最大利润。<strong>我们多考虑了第 i 天买入股票的情况，但同时计算 $f[1]$时，又将股票卖出，这样的利润为 0</strong> ,这一操作收益为零，对结果没有影响。所以我们将新的 $f[0]$值用于计算不会导致错误结果。</p></blockquote><p>后面的依此类推。</p><p>最后，我们手中肯定没有股票，结果在  0, $f[1]$，$f[3]$中选择最大的，由于在状态转移中我们维护的是最大值，且$f[1]$，$f[3]$初始值为 0，0不可能为结果。如果最优解为交易一次，即$f[1]$，那么它也会因为我们在转移时允许在同一天买入并且卖出这一宽松的条件，从$f[1]$转移到$f[3]$，因此最后答案为 $f[3]$。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = prices.length;</span><br><span class="line">        <span class="keyword">int</span>[] f = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>];</span><br><span class="line">        <span class="comment">// 分为 5 个阶段：没买也没卖，买了一次，卖了一次，买了两次且卖了一次，卖了两次</span></span><br><span class="line">        f[<span class="number">0</span>] = f[<span class="number">2</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        f[<span class="number">1</span>] = f[<span class="number">3</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">            f[<span class="number">0</span>] = Math.max(f[<span class="number">0</span>], -prices[i]);</span><br><span class="line">            f[<span class="number">1</span>] = Math.max(f[<span class="number">1</span>], f[<span class="number">0</span>] + prices[i]);</span><br><span class="line">            f[<span class="number">2</span>] = Math.max(f[<span class="number">2</span>], f[<span class="number">1</span>] - prices[i]);</span><br><span class="line">            f[<span class="number">3</span>] = Math.max(f[<span class="number">3</span>], f[<span class="number">2</span>] + prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[<span class="number">3</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>时间：$O(n)$</p></li><li><p>空间：$O(1)$ </p></li></ul><h4 id="188-买卖股票的最佳时机-IV"><a href="#188-买卖股票的最佳时机-IV" class="headerlink" title="188. 买卖股票的最佳时机 IV"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/" target="_blank" rel="noopener">188. 买卖股票的最佳时机 IV</a></h4><p>难度：困难</p><p>给定一个整数数组 <code>prices</code> ，它的第 <code>i</code> 个元素 <code>prices[i]</code> 是一支给定的股票在第 <code>i</code> 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 <strong>k</strong> 笔交易。</p><p><strong>注意：</strong>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p> <strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：k &#x3D; 2, prices &#x3D; [2,4,1]</span><br><span class="line">输出：2</span><br><span class="line">解释：在第 1 天 (股票价格 &#x3D; 2) 的时候买入，在第 2 天 (股票价格 &#x3D; 4) 的时候卖出，这笔交易所能获得利润 &#x3D; 4-2 &#x3D; 2 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：k &#x3D; 2, prices &#x3D; [3,2,6,5,0,3]</span><br><span class="line">输出：7</span><br><span class="line">解释：在第 2 天 (股票价格 &#x3D; 2) 的时候买入，在第 3 天 (股票价格 &#x3D; 6) 的时候卖出, 这笔交易所能获得利润 &#x3D; 6-2 &#x3D; 4 。</span><br><span class="line">     随后，在第 5 天 (股票价格 &#x3D; 0) 的时候买入，在第 6 天 (股票价格 &#x3D; 3) 的时候卖出, 这笔交易所能获得利润 &#x3D; 3-0 &#x3D; 3 。</span><br></pre></td></tr></table></figure><p> <strong>提示：</strong></p><ul><li><code>0 &lt;= k &lt;= 100</code></li><li><code>0 &lt;= prices.length &lt;= 1000</code></li><li><code>0 &lt;= prices[i] &lt;= 1000</code></li></ul><p>此题与 123 类似，但可交易 k 次，由之前的经验可以推导，每天应该有 <code>2 * k + 1</code>个状态。</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20211022200055327.png" alt="image-20211022200055327"></p><p>初始化数组 $f$ ，长度为 $2k + 1$，$f[0] = 0$ 表示没有参与任何交易的利润。$f[2<em>j - 1]$表示第 <code>j</code>次*</em>持有股票<strong>的最大利润，$f[2 * j ]$表示第<code>j</code>次</strong>没有股票**的最大利润，其中$1 &lt;= j &lt;= k$。</p><p>令 $j$ 为 数组 $f$  下标，我们可以写出转移方程：<br>$$<br>f[j] = max(f[j], f[j - 1] - prices[i]), j 为奇数<br>$$</p><p>$$<br>f[j] = max(f[j], f[j - 1] + prices[i]), j 为偶数<br>$$</p><p>同样的，最后的结果为第 k 次没有股票的最大利润$f[2 * k]$。</p><p>初始条件：所有奇数下标位置为 $ -prices[0]$, 所有偶数下标位置为 0，分析过程同 123 题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> n = prices.length;</span><br><span class="line">        <span class="keyword">int</span>[] f = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span> * k + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">2</span> * k; j += <span class="number">2</span>)&#123;</span><br><span class="line">            f[j] = -prices[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">2</span> * k; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>((j &amp; <span class="number">1</span>) == <span class="number">1</span>)&#123; <span class="comment">// 买</span></span><br><span class="line">                    f[j] = Math.max(f[j], f[j - <span class="number">1</span>] - prices[i]);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123; <span class="comment">//卖</span></span><br><span class="line">                    f[j] = Math.max(f[j], f[j - <span class="number">1</span>] + prices[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> f[<span class="number">2</span> * k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>时间：$O(nk)$</p></li><li><p>空间：$O(k)$ </p></li></ul><h4 id="309-最佳买卖股票时机含冷冻期"><a href="#309-最佳买卖股票时机含冷冻期" class="headerlink" title="309. 最佳买卖股票时机含冷冻期"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/" target="_blank" rel="noopener">309. 最佳买卖股票时机含冷冻期</a></h4><p>难度：中等</p><p>给定一个整数数组，其中第 <em>i</em> 个元素代表了第 <em>i</em> 天的股票价格 。</p><p>设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:</p><ul><li>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</li><li>卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。</li></ul><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,0,2]</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]</span><br></pre></td></tr></table></figure><p>显然，每天的状态有：持有股票，没有股票，冷冻期。我们画出今天和昨天的关系图：</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20211022213057682.png" alt="image-20211022213057682"></p><p>定义 $f[i][0]$ 第 <code>i</code> 天有股票， $f[i][1]$ 第 <code>i</code> 天无股票冷冻期， $f[i][2]$ 第 <code>i</code> 天无股票非冷冻期。可得到如下转移方程：<br>$$<br>f[i][0] = max(f[i - 1][0], f[i - 1][2] - prices[i])<br>$$</p><p>$$<br>f[i][1] = f[i - 1][0] + prices[i]<br>$$</p><p>$$<br>f[i][2] = max(f[i - 1][1], f[i - 1][2])<br>$$</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.length &lt; <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> n = prices.length;</span><br><span class="line">        <span class="keyword">int</span>[][] f = <span class="keyword">new</span> <span class="keyword">int</span>[n][<span class="number">3</span>];</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">            f[i][<span class="number">0</span>] = Math.max(f[i - <span class="number">1</span>][<span class="number">0</span>], f[i - <span class="number">1</span>][<span class="number">2</span>] - prices[i]);</span><br><span class="line">            f[i][<span class="number">1</span>] = f[i - <span class="number">1</span>][<span class="number">0</span>] + prices[i];</span><br><span class="line">            f[i][<span class="number">2</span>] = Math.max(f[i - <span class="number">1</span>][<span class="number">2</span>], f[i - <span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(f[n - <span class="number">1</span>][<span class="number">1</span>], f[n - <span class="number">1</span>][<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>时间：$O(n)$</p></li><li><p>空间：$O(n)$ </p></li></ul><p>我们可以只保存最近两天的数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.length &lt; <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> n = prices.length;</span><br><span class="line">        <span class="comment">// f[0] 表示第 i 天持有股票时的最大利润，f[1] 表示无股票冷冻期，f[2] 表示无股票非冷冻期</span></span><br><span class="line">        <span class="keyword">int</span>[] f = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line">        f[<span class="number">0</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span>[] newF = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line">            newF[<span class="number">0</span>] = Math.max(f[<span class="number">0</span>], f[<span class="number">2</span>] - prices[i]);</span><br><span class="line">            newF[<span class="number">1</span>] = f[<span class="number">0</span>] + prices[i];</span><br><span class="line">            newF[<span class="number">2</span>] = Math.max(f[<span class="number">2</span>], f[<span class="number">1</span>]);</span><br><span class="line">            f = newF;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(f[<span class="number">1</span>], f[<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间：$O(n)$</li><li>空间：$O(1)$ </li></ul><h4 id="714-买卖股票的最佳时机含手续费"><a href="#714-买卖股票的最佳时机含手续费" class="headerlink" title="714. 买卖股票的最佳时机含手续费"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/" target="_blank" rel="noopener">714. 买卖股票的最佳时机含手续费</a></h4><p>难度：中等</p><p>给定一个整数数组 <code>prices</code>，其中第 <code>i</code> 个元素代表了第 <code>i</code> 天的股票价格 ；整数 <code>fee</code> 代表了交易股票的手续费用。</p><p>你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。</p><p>返回获得利润的最大值。</p><p><strong>注意：</strong>这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：prices &#x3D; [1, 3, 2, 8, 4, 9], fee &#x3D; 2</span><br><span class="line">输出：8</span><br><span class="line">解释：能够达到的最大利润:  </span><br><span class="line">在此处买入 prices[0] &#x3D; 1</span><br><span class="line">在此处卖出 prices[3] &#x3D; 8</span><br><span class="line">在此处买入 prices[4] &#x3D; 4</span><br><span class="line">在此处卖出 prices[5] &#x3D; 9</span><br><span class="line">总利润: ((8 - 1) - 2) + ((9 - 4) - 2) &#x3D; 8</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：prices &#x3D; [1,3,7,5,10,3], fee &#x3D; 3</span><br><span class="line">输出：6</span><br></pre></td></tr></table></figure><p> <strong>提示：</strong></p><ul><li><code>1 &lt;= prices.length &lt;= 5 * 104</code></li><li><code>1 &lt;= prices[i] &lt; 5 * 104</code></li><li><code>0 &lt;= fee &lt; 5 * 104</code></li></ul><p>此题就是 121 加上卖出手续费。关系图如下：</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20211022214139191.png" alt="image-20211022214139191"></p><p>令 $ f[i][0]$ 为第 i 天<strong>有股票</strong>时的最大利润，令 $ f[i][1]$ 为第 i 天<strong>没股票</strong>时的最大利润，可以得到如下转移方程：<br>$$<br>f[i][0] = max(f[i - 1][0], f[i - 1][1] - prices[i])<br>$$</p><p>$$<br>f[i][1] = max(f[i - 1][1], f[i - 1][0] + prices[i] -fee)<br>$$</p><p>初始条件：$ f[i][0] = -prices[0]$，$ f[i][1] = 0$</p><p>只保存最近两天的数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices, <span class="keyword">int</span> fee)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.length &lt; <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> n = prices.length;</span><br><span class="line">        <span class="keyword">int</span>[] f = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        f[<span class="number">0</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// f[0] 代表持有股票，f[1]代表没有股票</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span>[] newF = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">            newF[<span class="number">0</span>] = Math.max(f[<span class="number">0</span>], f[<span class="number">1</span>] - prices[i]);</span><br><span class="line">            <span class="comment">// 卖出收手续费</span></span><br><span class="line">            newF[<span class="number">1</span>] = Math.max(f[<span class="number">1</span>], f[<span class="number">0</span>] + prices[i] - fee);</span><br><span class="line">            f = newF;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>时间：$O(n)$</p></li><li><p>空间：$O(1)$ </p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;121-买卖股票的最佳时机&quot;&gt;&lt;a href=&quot;#121-买卖股票的最佳时机&quot; class=&quot;headerlink&quot; title=&quot;121. 买卖股票的最佳时机&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;121. 买卖股票的最佳时机&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;难度：简单&lt;/p&gt;
&lt;p&gt;给定一个数组 &lt;code&gt;prices&lt;/code&gt; ，它的第 &lt;code&gt;i&lt;/code&gt; 个元素 &lt;code&gt;prices[i]&lt;/code&gt; 表示一支给定股票第 &lt;code&gt;i&lt;/code&gt; 天的价格。&lt;/p&gt;
&lt;p&gt;你只能选择 &lt;strong&gt;某一天&lt;/strong&gt; 买入这只股票，并选择在 &lt;strong&gt;未来的某一个不同的日子&lt;/strong&gt; 卖出该股票。设计一个算法来计算你所能获取的最大利润。&lt;/p&gt;
&lt;p&gt;返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 &lt;code&gt;0&lt;/code&gt; 。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="动态规划" scheme="https://hoo334.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>动态规划总结</title>
    <link href="https://hoo334.github.io/2021/07/31/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%80%BB%E7%BB%93/"/>
    <id>https://hoo334.github.io/2021/07/31/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%80%BB%E7%BB%93/</id>
    <published>2021-07-31T07:58:56.000Z</published>
    <updated>2021-08-24T08:24:13.069Z</updated>
    
    <content type="html"><![CDATA[<h3 id="坐标型动态规划"><a href="#坐标型动态规划" class="headerlink" title="坐标型动态规划"></a>坐标型动态规划</h3><p>是最简单的动态规划类型，通常给定一个序列或网格，记为 A。需要找到序列中某个/些子序列或网格中的某条路径</p><ol><li>某种性质最大/最小</li><li>计数</li><li>存在性</li></ol><a id="more"></a><p>动态规划方程 <code>f[i]</code>中的下标 <code>i</code>表示以<code>A[i]</code>为结尾的满足条件的子序列性质，<code>f[i][j]</code>中的下标<code>i, j</code>表示以<code>A[i][j]</code>为结尾的满足条件的路径的性质。这些性质可能是：</p><ul><li>最大值/最小值</li><li>个数</li><li>是否存在</li></ul><p>坐标型动态规划的初始条件<code>f[0]</code>就是指以<code>A[0]</code>为结尾的子序列的性质，对于网格，初始条件<code>f[0][0]</code>就是以<code>A[0][0]</code>为结尾的子序列的性质。</p><p><a href="https://leetcode-cn.com/problems/longest-continuous-increasing-subsequence/" target="_blank" rel="noopener">674. 最长连续递增序列</a></p><p><a href="https://leetcode-cn.com/problems/minimum-path-sum/" target="_blank" rel="noopener">64. 最小路径和</a></p><p><a href="https://www.lintcode.com/problem/553/" target="_blank" rel="noopener">553 · 炸弹袭击 - LintCode</a></p><h3 id="序列型动态规划"><a href="#序列型动态规划" class="headerlink" title="序列型动态规划"></a>序列型动态规划</h3><p>给定一个序列，动态规划方程 <code>f[i]</code>中的下标 <code>i</code>表示前 <code>i</code>个元素 A[0], A[1], …, A[i - 1]的某种性质，初始化时<code>f[0]</code>表示空序列的性质。</p><p><a href="https://www.lintcode.com/problem/516/" target="_blank" rel="noopener">516 · 房屋染色 II - LintCode</a></p><p><a href="https://www.lintcode.com/problem/392/" target="_blank" rel="noopener">392 · 打劫房屋 - LintCode</a></p><p><a href="https://www.lintcode.com/problem/534/" target="_blank" rel="noopener">534 · 打劫房屋 II - LintCode</a></p><p><a href="https://www.lintcode.com/problem/149/" target="_blank" rel="noopener">149 · 买卖股票的最佳时机 - LintCode</a></p><p><a href="https://www.lintcode.com/problem/150/" target="_blank" rel="noopener">150 · 买卖股票的最佳时机 II - LintCode</a></p><p><a href="https://www.lintcode.com/problem/151/" target="_blank" rel="noopener">151 · 买卖股票的最佳时机 III - LintCode</a></p><p><a href="https://www.lintcode.com/problem/393/" target="_blank" rel="noopener">393 · 买卖股票的最佳时机 IV - LintCode</a></p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20210803154845696.png" alt="image-20210803154845696"></p><h3 id="最长序列型动态规划"><a href="#最长序列型动态规划" class="headerlink" title="最长序列型动态规划"></a>最长序列型动态规划</h3><p>给定一个序列，要求找出符合条件的最长子序列</p><p>方法：</p><ul><li>记录以每个元素 i 结尾的最长子序列的长度</li><li>计算时，在 i 之前枚举子序列的上一个元素</li></ul><p><a href="https://www.lintcode.com/problem/397/" target="_blank" rel="noopener">397 · 最长上升连续子序列 - LintCode</a></p><p><a href="https://www.lintcode.com/problem/76/" target="_blank" rel="noopener">76 · 最长上升子序列 - LintCode</a></p><p><a href="https://www.lintcode.com/problem/602/" target="_blank" rel="noopener">602 · 俄罗斯套娃信封 - LintCode</a></p><h3 id="划分型动态规划"><a href="#划分型动态规划" class="headerlink" title="划分型动态规划"></a>划分型动态规划</h3><p><a href="https://www.lintcode.com/problem/513" target="_blank" rel="noopener">513 · 完美平方 - LintCode</a></p><p><a href="https://www.lintcode.com/problem/108/" target="_blank" rel="noopener">108 · 分割回文串（二） - LintCode</a></p><p><a href="https://www.lintcode.com/problem/437/" target="_blank" rel="noopener">437 · 书籍复印 - LintCode</a></p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20210803155745658.png" alt="image-20210803155745658"></p><h3 id="博弈型动态规划"><a href="#博弈型动态规划" class="headerlink" title="博弈型动态规划"></a>博弈型动态规划</h3><p><a href="https://www.lintcode.com/problem/394/" target="_blank" rel="noopener">394 · 硬币排成线 - LintCode</a></p><h3 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h3><p><a href="https://www.lintcode.com/problem/92/" target="_blank" rel="noopener">92 · 背包问题 - LintCode</a></p><p><a href="https://www.lintcode.com/problem/563/" target="_blank" rel="noopener">563 · 背包问题 V - LintCode</a></p><p><a href="https://www.lintcode.com/problem/564/" target="_blank" rel="noopener">564 · 组合总和 IV - LintCode</a></p><p><a href="https://www.lintcode.com/problem/125/" target="_blank" rel="noopener">125 · 背包问题（二） - LintCode</a></p><p><a href="https://www.lintcode.com/problem/440/" target="_blank" rel="noopener">440 · 背包问题 III - LintCode</a></p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20210805110903881.png" alt="image-20210805110903881"></p><h3 id="区间型动态规划"><a href="#区间型动态规划" class="headerlink" title="区间型动态规划"></a>区间型动态规划</h3><p>给定一个序列/字符串，进行一些操作，最后一步将序列/字符串去头去尾， 剩下的会是一个区间<code>[i, j]</code>，状态自然定义为 <code>f[i][j]</code>，表示面对子序列<code>[i, ..., j]</code>时的最优性质。</p><p>  <a href="https://www.lintcode.com/problem/667/" target="_blank" rel="noopener">667 · 最长的回文序列 - LintCode</a></p><p><a href="https://www.lintcode.com/problem/396/" target="_blank" rel="noopener">396 · 硬币排成线 III - LintCode</a></p><p><a href="https://www.lintcode.com/problem/430/" target="_blank" rel="noopener">430 · 攀爬字符串 - LintCode</a></p><p><a href="https://www.lintcode.com/problem/168/" target="_blank" rel="noopener">168 · 吹气球 - LintCode</a></p><h3 id="双序列型动态规划"><a href="#双序列型动态规划" class="headerlink" title="双序列型动态规划"></a>双序列型动态规划</h3><p><a href="https://www.lintcode.com/problem/77" target="_blank" rel="noopener">77 · 最长公共子序列 - LintCode</a></p><p><a href="https://www.lintcode.com/problem/29" target="_blank" rel="noopener">29 · 交叉字符串 - LintCode</a></p><p><a href="https://www.lintcode.com/problem/119" target="_blank" rel="noopener">119 · 编辑距离 - LintCode</a></p><p><a href="https://www.lintcode.com/problem/118/" target="_blank" rel="noopener">118 · 不同的子序列 - LintCode</a></p><p><a href="https://www.lintcode.com/problem/154/" target="_blank" rel="noopener">154 · 正则表达式匹配 - LintCode</a></p><p><a href="https://www.lintcode.com/problem/192/" target="_blank" rel="noopener">192 · 通配符匹配 - LintCode</a></p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20210808203541323.png" alt="image-20210808203541323"></p><p><a href="https://www.lintcode.com/problem/668/" target="_blank" rel="noopener">668 · 一和零 - LintCode</a></p><p><a href="https://www.lintcode.com/problem/91/" target="_blank" rel="noopener">91 · 最小调整代价 - LintCode</a></p><p><a href="https://www.lintcode.com/problem/622/" target="_blank" rel="noopener">622 · 青蛙跳 - LintCode</a></p><p><a href="https://www.lintcode.com/problem/436/" target="_blank" rel="noopener">436 · 最大正方形 - LintCode</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;坐标型动态规划&quot;&gt;&lt;a href=&quot;#坐标型动态规划&quot; class=&quot;headerlink&quot; title=&quot;坐标型动态规划&quot;&gt;&lt;/a&gt;坐标型动态规划&lt;/h3&gt;&lt;p&gt;是最简单的动态规划类型，通常给定一个序列或网格，记为 A。需要找到序列中某个/些子序列或网格中的某条路径&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;某种性质最大/最小&lt;/li&gt;
&lt;li&gt;计数&lt;/li&gt;
&lt;li&gt;存在性&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="动态规划" scheme="https://hoo334.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>连续的子数组和</title>
    <link href="https://hoo334.github.io/2021/06/03/%E8%BF%9E%E7%BB%AD%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C/"/>
    <id>https://hoo334.github.io/2021/06/03/%E8%BF%9E%E7%BB%AD%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C/</id>
    <published>2021-06-03T02:44:31.000Z</published>
    <updated>2021-06-03T03:24:30.104Z</updated>
    
    <content type="html"><![CDATA[<h4 id="523-连续的子数组和"><a href="#523-连续的子数组和" class="headerlink" title="523. 连续的子数组和"></a><a href="https://leetcode-cn.com/problems/continuous-subarray-sum/" target="_blank" rel="noopener">523. 连续的子数组和</a></h4><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，编写一个函数来判断该数组是否含有同时满足下述条件的连续子数组：</p><ul><li>子数组大小 <strong>至少为 2</strong> ，且</li><li>子数组元素总和为 <code>k</code> 的倍数。</li></ul><p>如果存在，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p>如果存在一个整数 <code>n</code> ，令整数 <code>x</code> 符合 <code>x = n * k</code> ，则称 <code>x</code> 是 <code>k</code> 的一个倍数。</p> <a id="more"></a><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [23,2,4,6,7], k &#x3D; 6</span><br><span class="line">输出：true</span><br><span class="line">解释：[2,4] 是一个大小为 2 的子数组，并且和为 6 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [23,2,6,4,7], k &#x3D; 6</span><br><span class="line">输出：true</span><br><span class="line">解释：[23, 2, 6, 4, 7] 是大小为 5 的子数组，并且和为 42 。 </span><br><span class="line">42 是 6 的倍数，因为 42 &#x3D; 7 * 6 且 7 是一个整数。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [23,2,6,4,7], k &#x3D; 13</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p> <strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 105</code></li><li><code>0 &lt;= nums[i] &lt;= 109</code></li><li><code>0 &lt;= sum(nums[i]) &lt;= 231 - 1</code></li><li><code>1 &lt;= k &lt;= 231 - 1</code></li></ul><p><strong>方法一：前缀和+哈希表</strong></p><p>使用暴力直接枚举所有大小大于 2 的子数组，判断子数组和是否为 k 的倍数。这样做时间复杂度为 O(n^3)。</p><p>我们可以使用前缀和，这样就可以在 O(1) 时间内判断子数组和是否为 k 的倍数。</p><p>用 prefixSum[i] 表示 nums  从下标 0  到下标 i 的前缀和，则 nums 从下标 p + 1 到下标 q 的子数组长度为 q - p，该子数组的元素和为 prefixSum[q] - prefixSum[p]。</p><p>如果 prefixSum[q] - prefixSun[p] 为 k 的倍数，且 q - p &gt;= 2，则上述子数组即满足大小至少为 2 且元素和为 k 的倍数。</p><p>我们只需保存<strong>每个下标对应的前缀和除 k 的余数</strong>即可，使用哈希表存储每个余数第一次出现的下标。</p><p>规定空的前缀的结束下标为 -1，在哈希表中存入键值对(0, -1)。从小到大依次遍历每个 i ，计算每个下标对应的前缀和除以 k 的余数，并维护哈希表。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkSubarraySum</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> remainder = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            remainder = (remainder + nums[i]) % k; <span class="comment">//计算前缀和除 k 的余数</span></span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(remainder))&#123;<span class="comment">//如果存在余数，直接减去见面这个子数组就能得到和为 k 的倍数的子数组</span></span><br><span class="line">                <span class="keyword">int</span> preIndex = map.get(remainder);</span><br><span class="line">                <span class="keyword">if</span>(i - preIndex &gt;= <span class="number">2</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                map.put(remainder, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度O(m)，m 是数组 nums 的长度</li><li>空间复杂度最大O(m)</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;523-连续的子数组和&quot;&gt;&lt;a href=&quot;#523-连续的子数组和&quot; class=&quot;headerlink&quot; title=&quot;523. 连续的子数组和&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/continuous-subarray-sum/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;523. 连续的子数组和&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;给你一个整数数组 &lt;code&gt;nums&lt;/code&gt; 和一个整数 &lt;code&gt;k&lt;/code&gt; ，编写一个函数来判断该数组是否含有同时满足下述条件的连续子数组：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;子数组大小 &lt;strong&gt;至少为 2&lt;/strong&gt; ，且&lt;/li&gt;
&lt;li&gt;子数组元素总和为 &lt;code&gt;k&lt;/code&gt; 的倍数。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果存在，返回 &lt;code&gt;true&lt;/code&gt; ；否则，返回 &lt;code&gt;false&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;如果存在一个整数 &lt;code&gt;n&lt;/code&gt; ，令整数 &lt;code&gt;x&lt;/code&gt; 符合 &lt;code&gt;x = n * k&lt;/code&gt; ，则称 &lt;code&gt;x&lt;/code&gt; 是 &lt;code&gt;k&lt;/code&gt; 的一个倍数。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode Medium" scheme="https://hoo334.github.io/tags/Leetcode-Medium/"/>
    
      <category term="哈希表" scheme="https://hoo334.github.io/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>元素和为目标值的子矩阵数量</title>
    <link href="https://hoo334.github.io/2021/05/29/%E5%85%83%E7%B4%A0%E5%92%8C%E4%B8%BA%E7%9B%AE%E6%A0%87%E5%80%BC%E7%9A%84%E5%AD%90%E7%9F%A9%E9%98%B5%E6%95%B0%E9%87%8F/"/>
    <id>https://hoo334.github.io/2021/05/29/%E5%85%83%E7%B4%A0%E5%92%8C%E4%B8%BA%E7%9B%AE%E6%A0%87%E5%80%BC%E7%9A%84%E5%AD%90%E7%9F%A9%E9%98%B5%E6%95%B0%E9%87%8F/</id>
    <published>2021-05-29T02:30:18.000Z</published>
    <updated>2021-05-29T02:50:14.328Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1074-元素和为目标值的子矩阵数量"><a href="#1074-元素和为目标值的子矩阵数量" class="headerlink" title="1074. 元素和为目标值的子矩阵数量"></a><a href="https://leetcode-cn.com/problems/number-of-submatrices-that-sum-to-target/" target="_blank" rel="noopener">1074. 元素和为目标值的子矩阵数量</a></h4><p>给出矩阵 <code>matrix</code> 和目标值 <code>target</code>，返回元素总和等于目标值的非空子矩阵的数量。</p><p>子矩阵 <code>x1, y1, x2, y2</code> 是满足 <code>x1 &lt;= x &lt;= x2</code> 且 <code>y1 &lt;= y &lt;= y2</code> 的所有单元 <code>matrix[x][y]</code> 的集合。</p><p>如果 <code>(x1, y1, x2, y2)</code> 和 <code>(x1&#39;, y1&#39;, x2&#39;, y2&#39;)</code> 两个子矩阵中部分坐标不同（如：<code>x1 != x1&#39;</code>），那么这两个子矩阵也不同。</p><a id="more"></a><p><strong>示例 1：</strong></p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20210529103118283.png" alt="image-20210529103118283"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix &#x3D; [[0,1,0],[1,1,1],[0,1,0]], target &#x3D; 0</span><br><span class="line">输出：4</span><br><span class="line">解释：四个只含 0 的 1x1 子矩阵。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix &#x3D; [[1,-1],[-1,1]], target &#x3D; 0</span><br><span class="line">输出：5</span><br><span class="line">解释：两个 1x2 子矩阵，加上两个 2x1 子矩阵，再加上一个 2x2 子矩阵。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix &#x3D; [[904]], target &#x3D; 0</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure><p> <strong>提示：</strong></p><ul><li><code>1 &lt;= matrix.length &lt;= 100</code></li><li><code>1 &lt;= matrix[0].length &lt;= 100</code></li><li><code>-1000 &lt;= matrix[i] &lt;= 1000</code></li><li><code>-10^8 &lt;= target &lt;= 10^8</code></li></ul><p><strong>方法一：前缀和</strong></p><p>我们枚举 子矩阵的上下边界，并计算该边界内每列元素的和，则原问题转换为：</p><blockquote><p>给定一个整数数组和一个整数 target，计算该数组中子数组和等于 target 的子数组个数。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numSubmatrixSumTarget</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = matrix.length, n = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123; <span class="comment">// 枚举上边界</span></span><br><span class="line">            <span class="keyword">int</span>[] nums = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; m; j++)&#123; <span class="comment">//枚举下边界</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; n; c++)&#123;</span><br><span class="line">                    nums[c] += matrix[j][c]; <span class="comment">//逐行增加 nums 数组，避免重复计算</span></span><br><span class="line">                &#125;</span><br><span class="line">                ret += subArraySum(nums, target);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//计算子数组和等于 target 的子数组个数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">subArraySum</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="comment">//key 为子数组和，value 为子数组个数</span></span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">//初始化一个子数组和为 0 ，个数为 1</span></span><br><span class="line">        map.put(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// ret 为返回结果，cur 为前缀和变量</span></span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>, cur = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">            cur += num;</span><br><span class="line">            <span class="comment">//判断是否存在一个子数组加上 target 等于当前前缀和 cur，子数组的个数就是 子数组和为target的子数组个数</span></span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(cur - target))&#123;</span><br><span class="line">                ret += map.get(cur - target);</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(cur, map.getOrDefault(cur, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>时间复杂度：O(M^2*n)，其中 m 和 n 分别是矩阵 matrix 的行数和列数。</p></li><li><p>空间复杂度：O(n)。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1074-元素和为目标值的子矩阵数量&quot;&gt;&lt;a href=&quot;#1074-元素和为目标值的子矩阵数量&quot; class=&quot;headerlink&quot; title=&quot;1074. 元素和为目标值的子矩阵数量&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/number-of-submatrices-that-sum-to-target/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;1074. 元素和为目标值的子矩阵数量&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;给出矩阵 &lt;code&gt;matrix&lt;/code&gt; 和目标值 &lt;code&gt;target&lt;/code&gt;，返回元素总和等于目标值的非空子矩阵的数量。&lt;/p&gt;
&lt;p&gt;子矩阵 &lt;code&gt;x1, y1, x2, y2&lt;/code&gt; 是满足 &lt;code&gt;x1 &amp;lt;= x &amp;lt;= x2&lt;/code&gt; 且 &lt;code&gt;y1 &amp;lt;= y &amp;lt;= y2&lt;/code&gt; 的所有单元 &lt;code&gt;matrix[x][y]&lt;/code&gt; 的集合。&lt;/p&gt;
&lt;p&gt;如果 &lt;code&gt;(x1, y1, x2, y2)&lt;/code&gt; 和 &lt;code&gt;(x1&amp;#39;, y1&amp;#39;, x2&amp;#39;, y2&amp;#39;)&lt;/code&gt; 两个子矩阵中部分坐标不同（如：&lt;code&gt;x1 != x1&amp;#39;&lt;/code&gt;），那么这两个子矩阵也不同。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode Hard" scheme="https://hoo334.github.io/tags/Leetcode-Hard/"/>
    
      <category term="哈希表" scheme="https://hoo334.github.io/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
      <category term="数组" scheme="https://hoo334.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>汉明距离总和</title>
    <link href="https://hoo334.github.io/2021/05/28/%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB%E6%80%BB%E5%92%8C/"/>
    <id>https://hoo334.github.io/2021/05/28/%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB%E6%80%BB%E5%92%8C/</id>
    <published>2021-05-28T01:21:51.000Z</published>
    <updated>2021-05-28T01:30:20.479Z</updated>
    
    <content type="html"><![CDATA[<h4 id="477-汉明距离总和"><a href="#477-汉明距离总和" class="headerlink" title="477. 汉明距离总和"></a><a href="https://leetcode-cn.com/problems/total-hamming-distance/" target="_blank" rel="noopener">477. 汉明距离总和</a></h4><p>两个整数的 <a href="https://baike.baidu.com/item/汉明距离/475174?fr=aladdin" target="_blank" rel="noopener">汉明距离</a> 指的是这两个数字的二进制数对应位不同的数量。</p><p>计算一个数组中，任意两个数之间汉明距离的总和。</p><a id="more"></a><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入: 4, 14, 2</span><br><span class="line"></span><br><span class="line">输出: 6</span><br><span class="line"></span><br><span class="line">解释: 在二进制表示中，4表示为0100，14表示为1110，2表示为0010。（这样表示是为了体现后四位之间关系）</span><br><span class="line">所以答案为：</span><br><span class="line">HammingDistance(4, 14) + HammingDistance(4, 2) + HammingDistance(14, 2) &#x3D; 2 + 2 + 2 &#x3D; 6.</span><br></pre></td></tr></table></figure><p><strong>注意:</strong></p><ol><li>数组中元素的范围为从 <code>0</code>到 <code>10^9</code>。</li><li>数组的长度不超过 <code>10^4</code>。</li></ol><p><strong>方法一：逐位统计</strong></p><p>在计算汉明距离时，我们考虑的是同一比特位上的值是否不同，而不同比特位之间是互不影响的。</p><p>对于数组 nums 中的某个元素 val，若其二进制的第 i 位为 1，我们只需统计 nums 中有多少元素的第 i 位为 0 ，这样就就得到了 val 与其他元素在第 i 位上的汉明距离之和。</p><p>若长度为 n 的数组 nums 的所有元素二进制的第 i 位共有 c 个 1， n - c 个 0，这些元素在二进制第 i 位上的汉明距离位<code>c * (n - c)</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">totalHammingDistance</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">30</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">                c += (num &gt;&gt; i) &amp; <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ret += c * (n - c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度O(n * L)，n 为数组长度，L  = 30</li><li>空间复杂度O(1)</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;477-汉明距离总和&quot;&gt;&lt;a href=&quot;#477-汉明距离总和&quot; class=&quot;headerlink&quot; title=&quot;477. 汉明距离总和&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/total-hamming-distance/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;477. 汉明距离总和&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;两个整数的 &lt;a href=&quot;https://baike.baidu.com/item/汉明距离/475174?fr=aladdin&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;汉明距离&lt;/a&gt; 指的是这两个数字的二进制数对应位不同的数量。&lt;/p&gt;
&lt;p&gt;计算一个数组中，任意两个数之间汉明距离的总和。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode Medium" scheme="https://hoo334.github.io/tags/Leetcode-Medium/"/>
    
      <category term="位运算" scheme="https://hoo334.github.io/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>栈的压入、弹出序列</title>
    <link href="https://hoo334.github.io/2021/05/26/%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%E3%80%81%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97/"/>
    <id>https://hoo334.github.io/2021/05/26/%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%E3%80%81%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97/</id>
    <published>2021-05-26T12:26:58.000Z</published>
    <updated>2021-05-26T13:12:38.492Z</updated>
    
    <content type="html"><![CDATA[<h4 id="剑指-Offer-31-栈的压入、弹出序列"><a href="#剑指-Offer-31-栈的压入、弹出序列" class="headerlink" title="剑指 Offer 31. 栈的压入、弹出序列"></a><a href="https://leetcode-cn.com/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/" target="_blank" rel="noopener">剑指 Offer 31. 栈的压入、弹出序列</a></h4><p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如，序列 {1,2,3,4,5} 是某栈的压栈序列，序列 {4,5,3,2,1} 是该压栈序列对应的一个弹出序列，但 {4,3,5,1,2} 就不可能是该压栈序列的弹出序列。</p> <a id="more"></a><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：pushed &#x3D; [1,2,3,4,5], popped &#x3D; [4,5,3,2,1]</span><br><span class="line">输出：true</span><br><span class="line">解释：我们可以按以下顺序执行：</span><br><span class="line">push(1), push(2), push(3), push(4), pop() -&gt; 4,</span><br><span class="line">push(5), pop() -&gt; 5, pop() -&gt; 3, pop() -&gt; 2, pop() -&gt; 1</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：pushed &#x3D; [1,2,3,4,5], popped &#x3D; [4,3,5,1,2]</span><br><span class="line">输出：false</span><br><span class="line">解释：1 不能在 2 之前弹出。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li><code>0 &lt;= pushed.length == popped.length &lt;= 1000</code></li><li><code>0 &lt;= pushed[i], popped[i] &lt; 1000</code></li><li><code>pushed</code> 是 <code>popped</code> 的排列。</li></ol><p><strong>方法一：栈</strong></p><p>我们可以模拟做类似题时的思路：如果栈顶数字不等于当前出栈数字，将入栈序列中的数字依次加入栈中，直到栈顶元素与当前出栈数字相等。</p><p>以示例 1 为例，idx1 指向压入序列，idx2 指向弹出序列。</p><ol><li>栈为空，先将 1 压入栈中</li><li>栈顶数字 1 与数字 4 不相等，继续将 2 压入栈中</li><li>栈顶数字 2 与数字 4 不相等，继续将 3 压入栈中</li><li>栈顶数字 3 与数字 4 不相等，继续将 4 压入栈中</li><li>栈顶数字 4 与数字 4 相等，</li><li>栈顶数字 3 与数字 4 不相等，继续将 4 压入栈中</li><li>栈顶数字 5 与数字 5 相等，将 idx1 和 idx2 后移</li><li>数字 3 与栈顶数字 3 相等，idx2 后移，弹出栈顶元素</li><li>数字 2 与栈顶数字 2 相等，idx2 后移，弹出栈顶元素</li><li>数字 1 与栈顶数字 1 相等，idx2 后移，弹出栈顶元素</li><li>此时栈为空，代表第二个序列是第一个序列的弹出序列，返回 true。</li></ol><p>如果出现栈顶元素与当前弹出数字不相同且 idx1 已经指向入栈序列末尾，返回 false。</p><p>下图可以辅助理解</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/1.jpg" alt="1"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validateStackSequences</span><span class="params">(<span class="keyword">int</span>[] pushed, <span class="keyword">int</span>[] popped)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pushed.length != popped.length)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> n = popped.length;</span><br><span class="line">        Deque&lt;Integer&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> idx1 = <span class="number">0</span>, idx2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(idx2 &lt; n)&#123;</span><br><span class="line">            <span class="comment">//栈为空或者栈顶元素不等于当前弹出数字，直接将当前数字加入栈中</span></span><br><span class="line">            <span class="keyword">while</span>(idx1 &lt; n &amp;&amp; (stack.isEmpty() || stack.peek() != popped[idx2]))&#123;</span><br><span class="line">                stack.push(pushed[idx1]);</span><br><span class="line">                ++idx1;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//栈顶元素等于当前弹出数字</span></span><br><span class="line">            <span class="keyword">if</span>(stack.peek() == popped[idx2])&#123;</span><br><span class="line">                ++idx2;</span><br><span class="line">                stack.pop();</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="comment">//栈顶元素不等于当前弹出数字，出栈序列与入栈序列不匹配</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度O(n)</li><li>空间复杂度O(n)</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;剑指-Offer-31-栈的压入、弹出序列&quot;&gt;&lt;a href=&quot;#剑指-Offer-31-栈的压入、弹出序列&quot; class=&quot;headerlink&quot; title=&quot;剑指 Offer 31. 栈的压入、弹出序列&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;剑指 Offer 31. 栈的压入、弹出序列&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如，序列 {1,2,3,4,5} 是某栈的压栈序列，序列 {4,5,3,2,1} 是该压栈序列对应的一个弹出序列，但 {4,3,5,1,2} 就不可能是该压栈序列的弹出序列。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode Medium" scheme="https://hoo334.github.io/tags/Leetcode-Medium/"/>
    
      <category term="栈" scheme="https://hoo334.github.io/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>制作m束花所需的最少天数</title>
    <link href="https://hoo334.github.io/2021/05/09/%E5%88%B6%E4%BD%9Cm%E6%9D%9F%E8%8A%B1%E6%89%80%E9%9C%80%E7%9A%84%E6%9C%80%E5%B0%91%E5%A4%A9%E6%95%B0/"/>
    <id>https://hoo334.github.io/2021/05/09/%E5%88%B6%E4%BD%9Cm%E6%9D%9F%E8%8A%B1%E6%89%80%E9%9C%80%E7%9A%84%E6%9C%80%E5%B0%91%E5%A4%A9%E6%95%B0/</id>
    <published>2021-05-09T01:51:41.000Z</published>
    <updated>2021-05-09T02:30:41.930Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1482-制作-m-束花所需的最少天数"><a href="#1482-制作-m-束花所需的最少天数" class="headerlink" title="1482. 制作 m 束花所需的最少天数"></a><a href="https://leetcode-cn.com/problems/minimum-number-of-days-to-make-m-bouquets/" target="_blank" rel="noopener">1482. 制作 m 束花所需的最少天数</a></h4><p>给你一个整数数组 <code>bloomDay</code>，以及两个整数 <code>m</code> 和 <code>k</code> 。</p><p>现需要制作 <code>m</code> 束花。制作花束时，需要使用花园中 <strong>相邻的 <code>k</code> 朵花</strong> 。</p><p>花园中有 <code>n</code> 朵花，第 <code>i</code> 朵花会在 <code>bloomDay[i]</code> 时盛开，<strong>恰好</strong> 可以用于 <strong>一束</strong> 花中。</p><p>请你返回从花园中摘 <code>m</code> 束花需要等待的最少的天数。如果不能摘到 <code>m</code> 束花则返回 <strong>-1</strong> 。</p> <a id="more"></a><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：bloomDay &#x3D; [1,10,3,10,2], m &#x3D; 3, k &#x3D; 1</span><br><span class="line">输出：3</span><br><span class="line">解释：让我们一起观察这三天的花开过程，x 表示花开，而 _ 表示花还未开。</span><br><span class="line">现在需要制作 3 束花，每束只需要 1 朵。</span><br><span class="line">1 天后：[x, _, _, _, _]   &#x2F;&#x2F; 只能制作 1 束花</span><br><span class="line">2 天后：[x, _, _, _, x]   &#x2F;&#x2F; 只能制作 2 束花</span><br><span class="line">3 天后：[x, _, x, _, x]   &#x2F;&#x2F; 可以制作 3 束花，答案为 3</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：bloomDay &#x3D; [1,10,3,10,2], m &#x3D; 3, k &#x3D; 2</span><br><span class="line">输出：-1</span><br><span class="line">解释：要制作 3 束花，每束需要 2 朵花，也就是一共需要 6 朵花。而花园中只有 5 朵花，无法满足制作要求，返回 -1 。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：bloomDay &#x3D; [7,7,7,7,12,7,7], m &#x3D; 2, k &#x3D; 3</span><br><span class="line">输出：12</span><br><span class="line">解释：要制作 2 束花，每束需要 3 朵。</span><br><span class="line">花园在 7 天后和 12 天后的情况如下：</span><br><span class="line">7 天后：[x, x, x, x, _, x, x]</span><br><span class="line">可以用前 3 朵盛开的花制作第一束花。但不能使用后 3 朵盛开的花，因为它们不相邻。</span><br><span class="line">12 天后：[x, x, x, x, x, x, x]</span><br><span class="line">显然，我们可以用不同的方式制作两束花。</span><br></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：bloomDay &#x3D; [1000000000,1000000000], m &#x3D; 1, k &#x3D; 1</span><br><span class="line">输出：1000000000</span><br><span class="line">解释：需要等 1000000000 天才能采到花来制作花束</span><br></pre></td></tr></table></figure><p><strong>示例 5：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：bloomDay &#x3D; [1,10,2,9,3,8,4,7,5,6], m &#x3D; 4, k &#x3D; 2</span><br><span class="line">输出：9</span><br></pre></td></tr></table></figure><p> <strong>提示：</strong></p><ul><li><code>bloomDay.length == n</code></li><li><code>1 &lt;= n &lt;= 10^5</code></li><li><code>1 &lt;= bloomDay[i] &lt;= 10^9</code></li><li><code>1 &lt;= m &lt;= 10^6</code></li><li><code>1 &lt;= k &lt;= n</code></li></ul><p><strong>方法一：二分查找</strong></p><p>为了计算制作花束的最少天数，首先需要实现一个辅助函数用于判断在给定的天数内能否制作出指定数量的花束。我们可以遍历数组 bloomDay，计算其中的长度为 k 且最大元素不超过 days 的补充和的连续子数组额数量，如果符合要求的不重合连续子数组的数量大于或等于 m 则返回 True，否则返回 false。</p><p>当 days 很小时，辅助函数总是返回 false，引文天数太少不能收齐 m 个花束；当 days 很大的时候辅助函数总是返回 true，如果给定的序列可以制作出 m 个花束。在 days 慢慢变大的过程中，辅助函数的返回值会从false变为 true，所以我们可以认为这个辅助函数是关于 days 递增的，于是可以通过二分查找得到最少天数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDays</span><span class="params">(<span class="keyword">int</span>[] bloomDay, <span class="keyword">int</span> m, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(k * m &gt; bloomDay.length)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">1</span>, high = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> length = bloomDay.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++)&#123;</span><br><span class="line">            high = Math.max(high, bloomDay[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(low &lt; high)&#123;</span><br><span class="line">            <span class="keyword">int</span> days = (high - low) / <span class="number">2</span> + low;</span><br><span class="line">            <span class="keyword">if</span>(canMake(bloomDay, days, m, k))&#123;</span><br><span class="line">                high = days;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="comment">//从左向右逼近</span></span><br><span class="line">                low = days + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> low;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">canMake</span><span class="params">(<span class="keyword">int</span>[] bloomDay, <span class="keyword">int</span> days, <span class="keyword">int</span> m, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> bouquets = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> flowers = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> length = bloomDay.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length &amp;&amp; bouquets &lt; m; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(bloomDay[i] &lt;= days)&#123;</span><br><span class="line">                flowers++;</span><br><span class="line">                <span class="keyword">if</span>(flowers == k)&#123;</span><br><span class="line">                    bouquets++;</span><br><span class="line">                    flowers = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                flowers = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bouquets &gt;= m;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度 <em>O</em>(<em>n</em>log<em>h</em>) ，n 是数组 bloomDay 的长度，h 是数组 bloomDay 中的最大值。</li><li>空间复杂度O(1)</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1482-制作-m-束花所需的最少天数&quot;&gt;&lt;a href=&quot;#1482-制作-m-束花所需的最少天数&quot; class=&quot;headerlink&quot; title=&quot;1482. 制作 m 束花所需的最少天数&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/minimum-number-of-days-to-make-m-bouquets/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;1482. 制作 m 束花所需的最少天数&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;给你一个整数数组 &lt;code&gt;bloomDay&lt;/code&gt;，以及两个整数 &lt;code&gt;m&lt;/code&gt; 和 &lt;code&gt;k&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;现需要制作 &lt;code&gt;m&lt;/code&gt; 束花。制作花束时，需要使用花园中 &lt;strong&gt;相邻的 &lt;code&gt;k&lt;/code&gt; 朵花&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;花园中有 &lt;code&gt;n&lt;/code&gt; 朵花，第 &lt;code&gt;i&lt;/code&gt; 朵花会在 &lt;code&gt;bloomDay[i]&lt;/code&gt; 时盛开，&lt;strong&gt;恰好&lt;/strong&gt; 可以用于 &lt;strong&gt;一束&lt;/strong&gt; 花中。&lt;/p&gt;
&lt;p&gt;请你返回从花园中摘 &lt;code&gt;m&lt;/code&gt; 束花需要等待的最少的天数。如果不能摘到 &lt;code&gt;m&lt;/code&gt; 束花则返回 &lt;strong&gt;-1&lt;/strong&gt; 。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode Medium" scheme="https://hoo334.github.io/tags/Leetcode-Medium/"/>
    
      <category term="二分查找" scheme="https://hoo334.github.io/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>在D天内送达包裹的能力</title>
    <link href="https://hoo334.github.io/2021/04/28/%E5%9C%A8D%E5%A4%A9%E5%86%85%E9%80%81%E8%BE%BE%E5%8C%85%E8%A3%B9%E7%9A%84%E8%83%BD%E5%8A%9B/"/>
    <id>https://hoo334.github.io/2021/04/28/%E5%9C%A8D%E5%A4%A9%E5%86%85%E9%80%81%E8%BE%BE%E5%8C%85%E8%A3%B9%E7%9A%84%E8%83%BD%E5%8A%9B/</id>
    <published>2021-04-28T01:56:34.000Z</published>
    <updated>2021-04-28T03:13:44.217Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1011-在-D-天内送达包裹的能力"><a href="#1011-在-D-天内送达包裹的能力" class="headerlink" title="1011. 在 D 天内送达包裹的能力"></a><a href="https://leetcode-cn.com/problems/capacity-to-ship-packages-within-d-days/" target="_blank" rel="noopener">1011. 在 D 天内送达包裹的能力</a></h4><p>传送带上的包裹必须在 D 天内从一个港口运送到另一个港口。</p><p>传送带上的第 <code>i</code> 个包裹的重量为 <code>weights[i]</code>。每一天，我们都会按给出重量的顺序往传送带上装载包裹。我们装载的重量不会超过船的最大运载重量。</p><p>返回能在 <code>D</code> 天内将传送带上的所有包裹送达的船的最低运载能力。</p> <a id="more"></a><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入：weights &#x3D; [1,2,3,4,5,6,7,8,9,10], D &#x3D; 5</span><br><span class="line">输出：15</span><br><span class="line">解释：</span><br><span class="line">船舶最低载重 15 就能够在 5 天内送达所有包裹，如下所示：</span><br><span class="line">第 1 天：1, 2, 3, 4, 5</span><br><span class="line">第 2 天：6, 7</span><br><span class="line">第 3 天：8</span><br><span class="line">第 4 天：9</span><br><span class="line">第 5 天：10</span><br><span class="line"></span><br><span class="line">请注意，货物必须按照给定的顺序装运，因此使用载重能力为 14 的船舶并将包装分成 (2, 3, 4, 5), (1, 6, 7), (8), (9), (10) 是不允许的。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：weights &#x3D; [3,2,2,4,1,4], D &#x3D; 3</span><br><span class="line">输出：6</span><br><span class="line">解释：</span><br><span class="line">船舶最低载重 6 就能够在 3 天内送达所有包裹，如下所示：</span><br><span class="line">第 1 天：3, 2</span><br><span class="line">第 2 天：2, 4</span><br><span class="line">第 3 天：1, 4</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：weights &#x3D; [1,2,3,1,1], D &#x3D; 4</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">第 1 天：1</span><br><span class="line">第 2 天：2</span><br><span class="line">第 3 天：3</span><br><span class="line">第 4 天：1, 1</span><br></pre></td></tr></table></figure><p> <strong>提示：</strong></p><ul><li><code>1 &lt;= D &lt;= weights.length &lt;= 5 * 104</code></li><li><code>1 &lt;= weights[i] &lt;= 500</code></li></ul><p><strong>方法一：二分查找转化为判定问题</strong></p><p>假设当船的运载能力为 x 时，我们可以在 D 天内送完所有包裹，那么只要运载能力大于 x，我们同样可以在 D 天内运送完所有包裹，我们只需使用运载能力为 x 的运送方法即可。</p><p>在二分查找过程中，我们需要解决一个判定问题：给定船的运载能力 x，我们是否可以在 D 天内运送完所有包裹？这可以通过贪心来解决：</p><blockquote><p>由于我们必须按照数组 weights 中包裹的顺序进行运送，将连续的包裹都安排在同一天进行运送，当这批包裹重量大于 x 时，我们需要将最后一个包裹安排在下一天运送。当遍历完整个数组后，就得到了最少需要运送的天数。</p></blockquote><p>我们将在「最少需要运送的天数」与 D 比较，当其小于 D 时，证明我们的运载能力较强，可以适当减少，因此我们忽略二分的右半区间。当其大于 D 时，证明我们的运载能力较弱，需要增加，我们忽略二分的左半区间。</p><p>二分初始边界：</p><p>对于左边界而言，由于我们不能拆分一个包裹，因此船的运载能力不能小于包裹中最重的包裹，即左边界为 weights 数组中元素的最大值</p><p>对于右边界而言，船的运载能力也不会超过所有包裹的重量之和，即右边界为数组 weights 中元素的和。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">shipWithinDays</span><span class="params">(<span class="keyword">int</span>[] weights, <span class="keyword">int</span> D)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 确定二分查找左右边界</span></span><br><span class="line">        <span class="keyword">int</span> left = Arrays.stream(weights).max().getAsInt(), right = Arrays.stream(weights).sum();</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="comment">//判断运载能力为 mid 时，需要的天数</span></span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">// need 为需要运送的天数</span></span><br><span class="line">            <span class="comment">// cur 为当前这一天已经运送的包裹重量之和</span></span><br><span class="line">            <span class="keyword">int</span> need = <span class="number">1</span>, cur = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> weight : weights) &#123;</span><br><span class="line">                <span class="keyword">if</span> (cur + weight &gt; mid) &#123;</span><br><span class="line">                    ++need;</span><br><span class="line">                    cur = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                cur += weight;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//需要的天数小于 D，运载能力较强，舍弃右半区间</span></span><br><span class="line">            <span class="keyword">if</span> (need &lt;= D) &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">//需要的天数大于 D，运载能力较弱，舍弃左半区间</span></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>时间复杂度：<img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20210428111123523.png" alt="image-20210428111123523"></p></li><li><p>空间复杂度O(1)</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1011-在-D-天内送达包裹的能力&quot;&gt;&lt;a href=&quot;#1011-在-D-天内送达包裹的能力&quot; class=&quot;headerlink&quot; title=&quot;1011. 在 D 天内送达包裹的能力&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/capacity-to-ship-packages-within-d-days/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;1011. 在 D 天内送达包裹的能力&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;传送带上的包裹必须在 D 天内从一个港口运送到另一个港口。&lt;/p&gt;
&lt;p&gt;传送带上的第 &lt;code&gt;i&lt;/code&gt; 个包裹的重量为 &lt;code&gt;weights[i]&lt;/code&gt;。每一天，我们都会按给出重量的顺序往传送带上装载包裹。我们装载的重量不会超过船的最大运载重量。&lt;/p&gt;
&lt;p&gt;返回能在 &lt;code&gt;D&lt;/code&gt; 天内将传送带上的所有包裹送达的船的最低运载能力。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode Medium" scheme="https://hoo334.github.io/tags/Leetcode-Medium/"/>
    
      <category term="二分查找" scheme="https://hoo334.github.io/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>组合总和Ⅳ</title>
    <link href="https://hoo334.github.io/2021/04/28/%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C%E2%85%A3/"/>
    <id>https://hoo334.github.io/2021/04/28/%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C%E2%85%A3/</id>
    <published>2021-04-28T01:20:32.000Z</published>
    <updated>2021-08-24T08:25:30.967Z</updated>
    
    <content type="html"><![CDATA[<h4 id="377-组合总和-Ⅳ"><a href="#377-组合总和-Ⅳ" class="headerlink" title="377. 组合总和 Ⅳ"></a><a href="https://leetcode-cn.com/problems/combination-sum-iv/" target="_blank" rel="noopener">377. 组合总和 Ⅳ</a></h4><p>给你一个由 <strong>不同</strong> 整数组成的数组 <code>nums</code> ，和一个目标整数 <code>target</code> 。请你从 <code>nums</code> 中找出并返回总和为 <code>target</code> 的元素组合的个数。</p><p>题目数据保证答案符合 32 位整数范围。</p> <a id="more"></a><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [1,2,3], target &#x3D; 4</span><br><span class="line">输出：7</span><br><span class="line">解释：</span><br><span class="line">所有可能的组合为：</span><br><span class="line">(1, 1, 1, 1)</span><br><span class="line">(1, 1, 2)</span><br><span class="line">(1, 2, 1)</span><br><span class="line">(1, 3)</span><br><span class="line">(2, 1, 1)</span><br><span class="line">(2, 2)</span><br><span class="line">(3, 1)</span><br><span class="line">请注意，顺序不同的序列被视作不同的组合。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [9], target &#x3D; 3</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 200</code></li><li><code>1 &lt;= nums[i] &lt;= 1000</code></li><li><code>nums</code> 中的所有元素 <strong>互不相同</strong></li><li><code>1 &lt;= target &lt;= 1000</code></li></ul><p><strong>进阶：</strong>如果给定的数组中含有负数会发生什么？问题会产生何种变化？如果允许负数出现，需要向题目中添加哪些限制条件？</p><p><strong>方法一：回溯（超时）</strong></p><p>我们可以画出搜索路径，很自然写出如下回溯代码</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20210428094002017.png" alt="image-20210428094002017"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">combinationSum4</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> start = <span class="number">0</span>; start &lt; n; ++start)&#123;</span><br><span class="line">            res += backtrack(nums, target, nums[start]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target, <span class="keyword">int</span> cur)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">if</span>(cur &gt; target)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(target == cur)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//每次进入下一层都是从 1 开始</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            res += backtrack(nums, target, cur + nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>方法二：动态规划</strong></p><p>用 dp[x] 选取的元素之和等于 x 的方案数，目标是求 dp[target]。动态规划的边界是 dp[0] = 1。只有当不选取任何元素时，元素之和才为 0 ，因此只有 1 种方案。</p><p>当 <code>1 &lt;= i &lt;= target</code>时，如果存在一种排列，其元素之和等于 i，则该排列最后一个元素一定是数组 nums 种的元素。假设该排列最后一个元素是 num，则一定有 num &lt;= i，对于元素之和等于 i - num 的每一种排列，在最后添加 num 之后可以得到一个元素之和等于 i 的排列，因此在计算 dp[i] 时，应该计算所有的 dp[i - num] 之和。</p><p>当 <code>1 &lt;= i &lt;= target</code>时，得到如下转移方程：<br>$$<br>dp[i] = sum(dp[i - num]), num \leq i<br>$$<br>初始状态 dp[0] = 1。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">combinationSum4</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[target + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; dp.length; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">                <span class="keyword">if</span>(num &lt;= i)&#123;</span><br><span class="line">                    dp[i] += dp[i - num];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度O(target * n)，target 是 目标值，n 是 数组 nums 的长度。</li><li>空间复杂度O(target)</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;377-组合总和-Ⅳ&quot;&gt;&lt;a href=&quot;#377-组合总和-Ⅳ&quot; class=&quot;headerlink&quot; title=&quot;377. 组合总和 Ⅳ&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/combination-sum-iv/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;377. 组合总和 Ⅳ&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;给你一个由 &lt;strong&gt;不同&lt;/strong&gt; 整数组成的数组 &lt;code&gt;nums&lt;/code&gt; ，和一个目标整数 &lt;code&gt;target&lt;/code&gt; 。请你从 &lt;code&gt;nums&lt;/code&gt; 中找出并返回总和为 &lt;code&gt;target&lt;/code&gt; 的元素组合的个数。&lt;/p&gt;
&lt;p&gt;题目数据保证答案符合 32 位整数范围。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode Medium" scheme="https://hoo334.github.io/tags/Leetcode-Medium/"/>
    
      <category term="动态规划" scheme="https://hoo334.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>最大整除子集</title>
    <link href="https://hoo334.github.io/2021/04/23/%E6%9C%80%E5%A4%A7%E6%95%B4%E9%99%A4%E5%AD%90%E9%9B%86/"/>
    <id>https://hoo334.github.io/2021/04/23/%E6%9C%80%E5%A4%A7%E6%95%B4%E9%99%A4%E5%AD%90%E9%9B%86/</id>
    <published>2021-04-23T02:30:25.000Z</published>
    <updated>2021-08-24T08:26:01.846Z</updated>
    
    <content type="html"><![CDATA[<h4 id="368-最大整除子集"><a href="#368-最大整除子集" class="headerlink" title="368. 最大整除子集"></a><a href="https://leetcode-cn.com/problems/largest-divisible-subset/" target="_blank" rel="noopener">368. 最大整除子集</a></h4><p>给你一个由 <strong>无重复</strong> 正整数组成的集合 <code>nums</code> ，请你找出并返回其中最大的整除子集 <code>answer</code> ，子集中每一元素对 <code>(answer[i], answer[j])</code> 都应当满足：</p><ul><li><code>answer[i] % answer[j] == 0</code> ，或</li><li><code>answer[j] % answer[i] == 0</code></li></ul><p>如果存在多个有效解子集，返回其中任何一个均可。</p> <a id="more"></a><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [1,2,3]</span><br><span class="line">输出：[1,2]</span><br><span class="line">解释：[1,3] 也会被视为正确答案。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [1,2,4,8]</span><br><span class="line">输出：[1,2,4,8]</span><br></pre></td></tr></table></figure><p> <strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 1000</code></li><li><code>1 &lt;= nums[i] &lt;= 2 * 109</code></li><li><code>nums</code> 中的所有整数 <strong>互不相同</strong></li></ul><p><strong>方法一：动态规划</strong></p><ol><li>求最大整除子集的长度</li></ol><p>我们首先将输入数组按照升序排序，以便获得一个子集的最小整数或最大整数。dp[i] 定义为：以nums[i] 为最大整数的<strong>有序</strong>整除子集的数字个数，nums[i] 必须被选择。</p><p>从小到大计算 dp 数组的值，在计算 dp[i] 之前，我们已经计算出 dp[0 … i - 1]的值，状态转移方程为：<br>$$<br>dp[i] = max(dp[j]) + 1, 其中 0 \leq j&lt;i 且\ nums[i]\  %\  nums[j] == 0<br>$$<br>最大整除子集长度就是 dp 数组中的最大值。</p><p>在遍历过程中我们保存最大整除子集的长度 maxSize 和子集中的最大数字 maxVal。</p><ol start="2"><li>倒序找出最大整除子集</li></ol><p>假设输入数组为[2,4,7,8,9,12,16,18](已经有序)，得到的动态规划表格如下：</p><table><thead><tr><th>nums</th><th>2</th><th>4</th><th>7</th><th>8</th><th>9</th><th>12</th><th>16</th><th>18</th></tr></thead><tbody><tr><td>dp</td><td>1</td><td>2</td><td>1</td><td>3</td><td>1</td><td>3</td><td>4</td><td>3</td></tr></tbody></table><ol><li>初始时 maxSize = 4, maxVal = 16</li><li>寻找大小为 3 的最大整除子集，我们看到 8 和 12 对应的状态值都是 3，但 16 % 12 != 0，我们选择包含 8 的最大整除子集，此时maxSize = 3, maxVal = 8</li><li>继续向左寻找大小为 2 的最大整除子集，只有 4 对应的状态值为 2 ，选择包含 4 的最大整除子集，此时maxSize = 2, maxVal = 4</li><li>继续向左寻找大小为 1 的最大整除子集，2 对应的状态值为 1 ，选择包含 2 的最大整除子集，此时maxSize = 1, maxVal = 2</li></ol><p>我们就得到最大整除子集[16,8,4,2]。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">largestDivisibleSubset</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//动态规划找出最大子集的个数、最大子集中的最大整数</span></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> maxSize = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> maxVal = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++)&#123;</span><br><span class="line">            dp[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] % nums[j] == <span class="number">0</span>)&#123;</span><br><span class="line">                    dp[i] = Math.max(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(dp[i] &gt; maxSize)&#123;</span><br><span class="line">                maxSize = dp[i];</span><br><span class="line">                maxVal = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//倒推获得最大子集</span></span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(maxSize == <span class="number">1</span>)&#123;</span><br><span class="line">            res.add(nums[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; maxSize &gt; <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[i] == maxSize &amp;&amp; maxVal % nums[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                res.add(nums[i]);</span><br><span class="line">                maxSize--;</span><br><span class="line">                maxVal = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度O(n^2)</li><li>空间复杂度O(n)</li></ul><p>当前问题和使用动态规划解决的经典问题「<a href="https://leetcode-cn.com/problems/longest-increasing-subsequence" target="_blank" rel="noopener">300. 最长递增子序列</a>」有相似之处。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;368-最大整除子集&quot;&gt;&lt;a href=&quot;#368-最大整除子集&quot; class=&quot;headerlink&quot; title=&quot;368. 最大整除子集&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/largest-divisible-subset/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;368. 最大整除子集&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;给你一个由 &lt;strong&gt;无重复&lt;/strong&gt; 正整数组成的集合 &lt;code&gt;nums&lt;/code&gt; ，请你找出并返回其中最大的整除子集 &lt;code&gt;answer&lt;/code&gt; ，子集中每一元素对 &lt;code&gt;(answer[i], answer[j])&lt;/code&gt; 都应当满足：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;answer[i] % answer[j] == 0&lt;/code&gt; ，或&lt;/li&gt;
&lt;li&gt;&lt;code&gt;answer[j] % answer[i] == 0&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果存在多个有效解子集，返回其中任何一个均可。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode Medium" scheme="https://hoo334.github.io/tags/Leetcode-Medium/"/>
    
      <category term="动态规划" scheme="https://hoo334.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>最长递增子序列</title>
    <link href="https://hoo334.github.io/2021/04/23/%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/"/>
    <id>https://hoo334.github.io/2021/04/23/%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/</id>
    <published>2021-04-23T01:59:00.000Z</published>
    <updated>2021-08-24T08:26:26.037Z</updated>
    
    <content type="html"><![CDATA[<h4 id="300-最长递增子序列"><a href="#300-最长递增子序列" class="headerlink" title="300. 最长递增子序列"></a><a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/" target="_blank" rel="noopener">300. 最长递增子序列</a></h4><p>给你一个整数数组 <code>nums</code> ，找到其中最长严格递增子序列的长度。</p><p>子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，<code>[3,6,2,7]</code> 是数组 <code>[0,3,1,6,2,2,7]</code> 的子序列。</p><a id="more"></a><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [10,9,2,5,3,7,101,18]</span><br><span class="line">输出：4</span><br><span class="line">解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [0,1,0,3,2,3]</span><br><span class="line">输出：4</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [7,7,7,7,7,7,7]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p> <strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 2500</code></li><li><code>-104 &lt;= nums[i] &lt;= 104</code></li></ul><p>定义 dp[i] 为考虑前 i 个元素，以第 i 个数字结尾的最长上升子序列长度，<strong>nums[i] 必须被选择</strong>。</p><p>从小到大计算 dp 数组的值，在计算 dp[i] 之前，我们已经计算出 dp[0 … i - 1]的值，状态转移方程为：<br>$$<br>dp[i] = max(dp[j]) + 1, 其中 0 \leq j&lt;i 且nums[j] &lt; nums[i]<br>$$<br>即考虑往 dp[0 … i - 1]中的最长上升子序列后面再加一个 nums[i]，此时 nums[i]必须大于前面的最长子序列中的最后一个元素，假设我们选择最长上升子序列 dp[j]，nums[i] 就必须大于 nums[j]。</p><p>最后整个数组的最长上升子序列即为所有 dp[i] 中的最大值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">int</span> maxLen = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            dp[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//尝试在dp[0 ... i-1]中找一个最长递增子序列</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] &gt; nums[j])&#123;</span><br><span class="line">                    dp[i] = Math.max(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                maxLen = Math.max(maxLen, dp[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxLen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度O(n^2)</li><li>空间复杂度O(n)</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;300-最长递增子序列&quot;&gt;&lt;a href=&quot;#300-最长递增子序列&quot; class=&quot;headerlink&quot; title=&quot;300. 最长递增子序列&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/longest-increasing-subsequence/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;300. 最长递增子序列&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;给你一个整数数组 &lt;code&gt;nums&lt;/code&gt; ，找到其中最长严格递增子序列的长度。&lt;/p&gt;
&lt;p&gt;子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，&lt;code&gt;[3,6,2,7]&lt;/code&gt; 是数组 &lt;code&gt;[0,3,1,6,2,2,7]&lt;/code&gt; 的子序列。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode Medium" scheme="https://hoo334.github.io/tags/Leetcode-Medium/"/>
    
      <category term="动态规划" scheme="https://hoo334.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>解码方法</title>
    <link href="https://hoo334.github.io/2021/04/21/%E8%A7%A3%E7%A0%81%E6%96%B9%E6%B3%95/"/>
    <id>https://hoo334.github.io/2021/04/21/%E8%A7%A3%E7%A0%81%E6%96%B9%E6%B3%95/</id>
    <published>2021-04-21T02:12:39.000Z</published>
    <updated>2021-08-24T08:30:52.626Z</updated>
    
    <content type="html"><![CDATA[<h4 id="91-解码方法"><a href="#91-解码方法" class="headerlink" title="91. 解码方法"></a><a href="https://leetcode-cn.com/problems/decode-ways/" target="_blank" rel="noopener">91. 解码方法</a></h4><p>一条包含字母 <code>A-Z</code> 的消息通过以下映射进行了 <strong>编码</strong> ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#39;A&#39; -&gt; 1</span><br><span class="line">&#39;B&#39; -&gt; 2</span><br><span class="line">...</span><br><span class="line">&#39;Z&#39; -&gt; 26</span><br></pre></td></tr></table></figure><p>要 <strong>解码</strong> 已编码的消息，所有数字必须基于上述映射的方法，反向映射回字母（可能有多种方法）。例如，<code>&quot;11106&quot;</code> 可以映射为：</p><ul><li><code>&quot;AAJF&quot;</code> ，将消息分组为 <code>(1 1 10 6)</code></li><li><code>&quot;KJF&quot;</code> ，将消息分组为 <code>(11 10 6)</code></li></ul><p>注意，消息不能分组为 <code>(1 11 06)</code> ，因为 <code>&quot;06&quot;</code> 不能映射为 <code>&quot;F&quot;</code> ，这是由于 <code>&quot;6&quot;</code> 和 <code>&quot;06&quot;</code> 在映射中并不等价。</p><p>给你一个只含数字的 <strong>非空</strong> 字符串 <code>s</code> ，请计算并返回 <strong>解码</strong> 方法的 <strong>总数</strong> 。</p><p>题目数据保证答案肯定是一个 <strong>32 位</strong> 的整数。</p> <a id="more"></a><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;12&quot;</span><br><span class="line">输出：2</span><br><span class="line">解释：它可以解码为 &quot;AB&quot;（1 2）或者 &quot;L&quot;（12）。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;226&quot;</span><br><span class="line">输出：3</span><br><span class="line">解释：它可以解码为 &quot;BZ&quot; (2 26), &quot;VF&quot; (22 6), 或者 &quot;BBF&quot; (2 2 6) 。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;0&quot;</span><br><span class="line">输出：0</span><br><span class="line">解释：没有字符映射到以 0 开头的数字。</span><br><span class="line">含有 0 的有效映射是 &#39;J&#39; -&gt; &quot;10&quot; 和 &#39;T&#39;-&gt; &quot;20&quot; 。</span><br><span class="line">由于没有字符，因此没有有效的方法对此进行解码，因为所有数字都需要映射。</span><br></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;06&quot;</span><br><span class="line">输出：0</span><br><span class="line">解释：&quot;06&quot; 不能映射到 &quot;F&quot; ，因为字符串含有前导 0（&quot;6&quot; 和 &quot;06&quot; 在映射中并不等价）。</span><br></pre></td></tr></table></figure><p> <strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 100</code></li><li><code>s</code> 只包含数字，并且可能包含前导零。</li></ul><p>对于字符串s = “226”，我们从左至右分析，字符 ‘ 2 ’ 可以解码为‘B’，字符 ’22‘ 可以解码为 ‘V’，解码方法总数为剩下的 ”26“ 和 ”6“解码方法总和，我们可以轻松知道 ”26“的解码方法为 2 种，”6“ 的解码方法为 1 种。</p><p>因此我们可以使用递归来实现这种思想</p><p><strong>方法一：递归（超时）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numDecodings</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//字符串长度为 0 或字符串第一个字符为 0，直接返回 0 </span></span><br><span class="line">        <span class="keyword">if</span>(s.length() == <span class="number">0</span> || s.charAt(<span class="number">0</span>) == <span class="string">'0'</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">char</span>[] chars = s.toCharArray();</span><br><span class="line">        <span class="keyword">return</span> decode(chars, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">decode</span><span class="params">(<span class="keyword">char</span>[] chars, <span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = chars.length;</span><br><span class="line">        <span class="comment">//边界条件</span></span><br><span class="line">        <span class="keyword">if</span>(start == n)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//以 0 开头，直接返回 0 </span></span><br><span class="line">        <span class="keyword">if</span>(chars[start] == <span class="string">'0'</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//取一个字符</span></span><br><span class="line">        <span class="keyword">int</span> ret = decode(chars, start + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//取两个字符</span></span><br><span class="line">        <span class="keyword">if</span>(start + <span class="number">1</span> &lt; n &amp;&amp; isDigit(chars[start], chars[start + <span class="number">1</span>]))&#123;</span><br><span class="line">            ret += decode(chars, start + <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回相加的结果</span></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//判断两个字符是否能解码</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isDigit</span><span class="params">(<span class="keyword">char</span> upper, <span class="keyword">char</span> lower)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> up = (<span class="keyword">int</span>)(upper - <span class="string">'0'</span>);</span><br><span class="line">        <span class="keyword">int</span> low = (<span class="keyword">int</span>)(lower - <span class="string">'0'</span>);</span><br><span class="line">        <span class="keyword">if</span>( (up == <span class="number">1</span> &amp;&amp; <span class="number">0</span> &lt;= low &amp;&amp; low &lt;= <span class="number">9</span>) || (up == <span class="number">2</span> &amp;&amp; <span class="number">0</span> &lt;= low &amp;&amp; low &lt;= <span class="number">6</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>方法二：动态规划</strong></p><p>虽然递归方法超时了，但我们可以尝试使用动态规划。dp[i] 表示 s[i … n] 的解码方法总数，结果为 dp[0]。我们可以使用 dpi, dpi1, dpi2 三个变量来代替 dp 数组，初始时 dpi = 0, dpi1 = 1, dpi2 = 1。我们可以列出如下 dp 方程：<br>$$<br>dp[i] = 0,  s[i] = ‘0’<br>$$<br>$$<br>dp[i] = dp[i + 1],  s[i] \neq ‘0’ &amp; &amp; \ !isDigit(s[i], s[i + 1])<br>$$<br>$$<br>dp[i] = dp[i + 1] + dp[i + 2],  s[i] \neq ‘0’ &amp; &amp; \ isDigit(s[i], s[i + 1])<br>$$</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numDecodings</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span> || s.charAt(<span class="number">0</span>) == <span class="string">'0'</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> dpi = <span class="number">0</span>, dpi1 = <span class="number">1</span>, dpi2 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i) != <span class="string">'0'</span>)&#123;</span><br><span class="line">                dpi += dpi1;</span><br><span class="line">                <span class="keyword">if</span>(i + <span class="number">1</span> &lt; n &amp;&amp; isDigit(s.charAt(i), s.charAt(i + <span class="number">1</span>))) dpi += dpi2;</span><br><span class="line">            &#125;</span><br><span class="line">            dpi2 = dpi1;</span><br><span class="line">            dpi1 = dpi;</span><br><span class="line">            dpi = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dpi1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isDigit</span><span class="params">(<span class="keyword">char</span> upper, <span class="keyword">char</span> lower)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> up = (<span class="keyword">int</span>)(upper - <span class="string">'0'</span>);</span><br><span class="line">        <span class="keyword">int</span> low = (<span class="keyword">int</span>)(lower - <span class="string">'0'</span>);</span><br><span class="line">        <span class="keyword">if</span>( (up == <span class="number">1</span> &amp;&amp; <span class="number">0</span> &lt;= low &amp;&amp; low &lt;= <span class="number">9</span>) || (up == <span class="number">2</span> &amp;&amp; <span class="number">0</span> &lt;= low &amp;&amp; low &lt;= <span class="number">6</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度O(n)</li><li>空间复杂度O(1)</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;91-解码方法&quot;&gt;&lt;a href=&quot;#91-解码方法&quot; class=&quot;headerlink&quot; title=&quot;91. 解码方法&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/decode-ways/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;91. 解码方法&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;一条包含字母 &lt;code&gt;A-Z&lt;/code&gt; 的消息通过以下映射进行了 &lt;strong&gt;编码&lt;/strong&gt; ：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;#39;A&amp;#39; -&amp;gt; 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#39;B&amp;#39; -&amp;gt; 2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#39;Z&amp;#39; -&amp;gt; 26&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;要 &lt;strong&gt;解码&lt;/strong&gt; 已编码的消息，所有数字必须基于上述映射的方法，反向映射回字母（可能有多种方法）。例如，&lt;code&gt;&amp;quot;11106&amp;quot;&lt;/code&gt; 可以映射为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;quot;AAJF&amp;quot;&lt;/code&gt; ，将消息分组为 &lt;code&gt;(1 1 10 6)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;quot;KJF&amp;quot;&lt;/code&gt; ，将消息分组为 &lt;code&gt;(11 10 6)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;注意，消息不能分组为 &lt;code&gt;(1 11 06)&lt;/code&gt; ，因为 &lt;code&gt;&amp;quot;06&amp;quot;&lt;/code&gt; 不能映射为 &lt;code&gt;&amp;quot;F&amp;quot;&lt;/code&gt; ，这是由于 &lt;code&gt;&amp;quot;6&amp;quot;&lt;/code&gt; 和 &lt;code&gt;&amp;quot;06&amp;quot;&lt;/code&gt; 在映射中并不等价。&lt;/p&gt;
&lt;p&gt;给你一个只含数字的 &lt;strong&gt;非空&lt;/strong&gt; 字符串 &lt;code&gt;s&lt;/code&gt; ，请计算并返回 &lt;strong&gt;解码&lt;/strong&gt; 方法的 &lt;strong&gt;总数&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;题目数据保证答案肯定是一个 &lt;strong&gt;32 位&lt;/strong&gt; 的整数。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode Medium" scheme="https://hoo334.github.io/tags/Leetcode-Medium/"/>
    
      <category term="动态规划" scheme="https://hoo334.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>打家劫舍II</title>
    <link href="https://hoo334.github.io/2021/04/15/%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8DII/"/>
    <id>https://hoo334.github.io/2021/04/15/%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8DII/</id>
    <published>2021-04-15T01:17:21.000Z</published>
    <updated>2021-04-15T01:32:07.356Z</updated>
    
    <content type="html"><![CDATA[<h4 id="213-打家劫舍-II"><a href="#213-打家劫舍-II" class="headerlink" title="213. 打家劫舍 II"></a><a href="https://leetcode-cn.com/problems/house-robber-ii/" target="_blank" rel="noopener">213. 打家劫舍 II</a></h4><p>你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 <strong>围成一圈</strong> ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong> 。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你 <strong>在不触动警报装置的情况下</strong> ，能够偷窃到的最高金额。</p> <a id="more"></a><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [2,3,2]</span><br><span class="line">输出：3</span><br><span class="line">解释：你不能先偷窃 1 号房屋（金额 &#x3D; 2），然后偷窃 3 号房屋（金额 &#x3D; 2）, 因为他们是相邻的。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [1,2,3,1]</span><br><span class="line">输出：4</span><br><span class="line">解释：你可以先偷窃 1 号房屋（金额 &#x3D; 1），然后偷窃 3 号房屋（金额 &#x3D; 3）。</span><br><span class="line">     偷窃到的最高金额 &#x3D; 1 + 3 &#x3D; 4 。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [0]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure><p> <strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 100</code></li><li><code>0 &lt;= nums[i] &lt;= 1000</code></li></ul><p><strong>方法一：动态规划</strong></p><p>此题是<a href="https://hoo334.github.io/2020/07/01/%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D/">打家劫舍</a>的进阶，与打家劫舍不同的是，这题中的房屋是首尾相连的，第一间和最后一间房屋相邻，因此第一间房屋和最后一间房屋不能在同一晚上偷窃。</p><p>假设数组 nums 的长度为 n。如果不偷窃最后一间房屋，则偷窃房屋的下标范围是[0, n - 2]；如果偷最后一间房屋，则偷窃房屋的下标是[1, n - 1]。在确定偷窃房屋的下标范围之后，即可用打家劫舍中的方法解决。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//第一个房子和最后一个房子只能选择偷一个，因此做两次动态规划就可以了。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">1</span>)<span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">//偷第一个房子</span></span><br><span class="line">        <span class="keyword">int</span> first = robHelper(Arrays.copyOfRange(nums, <span class="number">0</span>, nums.length-<span class="number">1</span>));</span><br><span class="line">        <span class="comment">//偷最后一个房子</span></span><br><span class="line">        <span class="keyword">int</span> last = robHelper(Arrays.copyOfRange(nums, <span class="number">1</span>, nums.length));</span><br><span class="line">        <span class="keyword">return</span> Math.max(first,last);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">robHelper</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pre=<span class="number">0</span>,cur=<span class="number">0</span>,temp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.length; ++i)&#123;</span><br><span class="line">            temp = cur;</span><br><span class="line">            cur = Math.max(pre+nums[i], cur);</span><br><span class="line">            pre = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度O(n)</li><li>空间复杂度O(1)</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;213-打家劫舍-II&quot;&gt;&lt;a href=&quot;#213-打家劫舍-II&quot; class=&quot;headerlink&quot; title=&quot;213. 打家劫舍 II&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/house-robber-ii/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;213. 打家劫舍 II&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 &lt;strong&gt;围成一圈&lt;/strong&gt; ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，&lt;strong&gt;如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;给定一个代表每个房屋存放金额的非负整数数组，计算你 &lt;strong&gt;在不触动警报装置的情况下&lt;/strong&gt; ，能够偷窃到的最高金额。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode Medium" scheme="https://hoo334.github.io/tags/Leetcode-Medium/"/>
    
      <category term="动态规划" scheme="https://hoo334.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>Aspect Spring AOP</title>
    <link href="https://hoo334.github.io/2021/04/12/Aspect%20Spring%20AOP/"/>
    <id>https://hoo334.github.io/2021/04/12/Aspect%20Spring%20AOP/</id>
    <published>2021-04-12T02:34:09.000Z</published>
    <updated>2021-04-15T03:21:05.482Z</updated>
    
    <content type="html"><![CDATA[<h3 id="基于注解的-Spring-AOP-开发"><a href="#基于注解的-Spring-AOP-开发" class="headerlink" title="基于注解的 Spring AOP 开发"></a>基于注解的 Spring AOP 开发</h3><a id="more"></a><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/v2-b5c523e28bba91c11c8d7f510ab84a79_1440w.png" alt="img"></p><h4 id="定义切入点函数"><a href="#定义切入点函数" class="headerlink" title="定义切入点函数"></a>定义切入点函数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在执行完 UserDao.add() 方法后执行</span></span><br><span class="line"><span class="meta">@After</span>(value=<span class="string">"execution(* com.zejian.spring.springAop.dao.UserDao.addUser(..))"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span></span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"最终通知...."</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>还可采用 @PointCut 关键字定义切入点表达式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用Pointcut定义切点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"execution(* com.zejian.spring.springAop.dao.UserDao.addUser(..))"</span>)</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">myPointcut</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 应用切入点函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@After</span>(value=<span class="string">"myPointcut()"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterDemo</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"最终通知...."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="切入点指示符"><a href="#切入点指示符" class="headerlink" title="切入点指示符"></a>切入点指示符</h4><h5 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h5><p>在定义匹配表达式时，通配符几乎随处可见如 <code>*</code> , <code>..</code> , <code>+</code> ,它们的含义如下：</p><ul><li><code>..</code>：匹配方法定义中任意数量的参数，此外还匹配类定义中任意数量包</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//任意返回值，任意名称，任意参数的公共方法</span></span><br><span class="line">execution(<span class="keyword">public</span> * *(..))</span><br><span class="line"><span class="comment">//匹配com.zejian.dao包及其子包中所有类中的所有方法</span></span><br><span class="line">within(com.zejian.dao..*)</span><br></pre></td></tr></table></figure><ul><li><code>+</code>：匹配给定类的任意子类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//匹配实现了DaoUser接口的所有子类的方法</span></span><br><span class="line">within(com.zejian.dao.DaoUser+)</span><br></pre></td></tr></table></figure><ul><li><code>*</code>：匹配任意数量的字符</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//匹配com.zejian.service包及其子包中所有类的所有方法</span></span><br><span class="line">within(com.zejian.service..*)</span><br><span class="line"><span class="comment">//匹配以set开头，参数为int类型，任意返回值的方法</span></span><br><span class="line">execution(* set*(<span class="keyword">int</span>))</span><br></pre></td></tr></table></figure><h5 id="类型签名表达式"><a href="#类型签名表达式" class="headerlink" title="类型签名表达式"></a>类型签名表达式</h5><p>为了方便类型（如接口、类名、包名）过滤方法，Spring AOP 提供了within关键字。其语法格式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">within(&lt;type name&gt;)</span><br></pre></td></tr></table></figure><p>type name 则使用包名或者类名替换即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//匹配com.zejian.dao包及其子包中所有类中的所有方法</span></span><br><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"within(com.zejian.dao..*)"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//匹配UserDaoImpl类中所有方法</span></span><br><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"within(com.zejian.dao.UserDaoImpl)"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//匹配UserDaoImpl类及其子类中所有方法</span></span><br><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"within(com.zejian.dao.UserDaoImpl+)"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//匹配所有实现UserDao接口的类的所有方法</span></span><br><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"within(com.zejian.dao.UserDao+)"</span>)</span><br></pre></td></tr></table></figure><h5 id="方法签名表达式"><a href="#方法签名表达式" class="headerlink" title="方法签名表达式"></a>方法签名表达式</h5><p>如果想根据方法签名进行过滤，关键字 execution 可以帮到我们，语法表达式如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//scope ：方法作用域，如public,private,protect</span></span><br><span class="line"><span class="comment">//returnt-type：方法返回值类型</span></span><br><span class="line"><span class="comment">//fully-qualified-class-name：方法所在类的完全限定名称</span></span><br><span class="line"><span class="comment">//parameters 方法参数</span></span><br><span class="line">execution(&lt;scope&gt; &lt;<span class="keyword">return</span>-type&gt; &lt;fully-qualified-<span class="class"><span class="keyword">class</span>-<span class="title">name</span>&gt;.*(<span class="title">parameters</span>))</span></span><br></pre></td></tr></table></figure><p>对于给定的作用域、返回值类型、完全限定类名以及参数匹配的方法将会应用切点函数指定的通知，这里给出模型案例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//匹配UserDaoImpl类中的所有方法</span></span><br><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"execution(* com.zejian.dao.UserDaoImpl.*(..))"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//匹配UserDaoImpl类中的所有公共的方法</span></span><br><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"execution(public * com.zejian.dao.UserDaoImpl.*(..))"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//匹配UserDaoImpl类中的所有公共方法并且返回值为int类型</span></span><br><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"execution(public int com.zejian.dao.UserDaoImpl.*(..))"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//匹配UserDaoImpl类中第一个参数为int类型的所有公共的方法</span></span><br><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"execution(public * com.zejian.dao.UserDaoImpl.*(int , ..))"</span>)</span><br></pre></td></tr></table></figure><h5 id="其他指示符"><a href="#其他指示符" class="headerlink" title="其他指示符"></a>其他指示符</h5><ul><li><p>this：用于匹配当前 AOP 代理对象类型的执行方法；请注意是 <strong>AOP代理对象</strong>的类型匹配，这样就可能包括引入接口也类型匹配</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//匹配了任意实现了UserDao接口的代理对象的方法进行过滤</span></span><br><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"this(com.zejian.spring.springAop.dao.UserDao)"</span>)</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">myPointcut2</span><span class="params">()</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>bean：Spring AOP 扩展的，AspectJ没有对应指示符，用于匹配特定名称的 Bean 对象的执行方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//匹配名称中带有后缀Service的Bean。</span></span><br><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"bean(*Service)"</span>)</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">myPointcut1</span><span class="params">()</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>target：用于匹配当前目标对象类型的执行方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//匹配了任意实现了UserDao接口的目标对象的方法进行过滤</span></span><br><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"target(com.zejian.spring.springAop.dao.UserDao)"</span>)</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">myPointcut3</span><span class="params">()</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>@within：用于匹配所有持有指定注解类型内的方法；请注意与 within 是有区别的，within是用于匹配指定类型内的方法执行；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//匹配使用了MarkerAnnotation注解的类(注意是类)</span></span><br><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"@within(com.zejian.spring.annotation.MarkerAnnotation)"</span>)</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">myPointcut4</span><span class="params">()</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>@annotation(com.zejian.spring.MarkerMethodAnnotation) : 根据所应用的注解进行方法过滤</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//匹配使用了MarkerAnnotation注解的方法(注意是方法)</span></span><br><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"@annotation(com.zejian.spring.annotation.MarkerAnnotation)"</span>)</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">myPointcut5</span><span class="params">()</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure></li></ul><p>切点指示符可以使用运算符语法进行表达式的混编，如and、or、not（或者&amp;&amp;、||、！），如下一个简单例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//匹配了任意实现了UserDao接口的目标对象的方法并且该接口不在com.zejian.dao包及其子包下</span></span><br><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"target(com.zejian.spring.springAop.dao.UserDao) ！within(com.zejian.dao..*)"</span>)</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">myPointcut6</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//匹配了任意实现了UserDao接口的目标对象的方法并且该方法名称为addUser</span></span><br><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"target(com.zejian.spring.springAop.dao.UserDao)&amp;&amp;execution(* com.zejian.spring.springAop.dao.UserDao.addUser(..))"</span>)</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">myPointcut7</span><span class="params">()</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><h5 id="5-种通知函数"><a href="#5-种通知函数" class="headerlink" title="5 种通知函数"></a>5 种通知函数</h5><p>通知主要分5种类型，分别是前置通知、后置通知、异常通知、最终通知以及环绕通知，下面分别介绍。</p><ul><li><p>前置通知 @Before</p><p>前置通知通过 @Before 注解进行标注，并可直接传入切点表达式的值，该通知在目标函数执行前执行，JoinPoint 是 Spring 提供的静态变量，通过它，可以获取目标对象的信息，如类名称，方法参数，方法名等，该参数可选。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 前置通知</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> joinPoint 该参数可以获取目标对象的信息,如类名称,方法参数,方法名称等</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Before</span>(<span class="string">"execution(* com.zejian.spring.springAop.dao.UserDao.addUser(..))"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">(JoinPoint joinPoint)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"我是前置通知"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>后置通知 @AfterReturning</p><p>通过 @AfterReturning 标注，该函数在目标函数执行完成后执行，并可以获取到目标函数最终的返回值  returnVal，当目标函数没有返回值时，returnVal 将返回 null。</p><p>必须通过returning = “returnVal”注明参数的名称而且必须与通知函数的参数名称相同。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 后置通知，不需要参数时可以不提供</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@AfterReturning</span>(value=<span class="string">"execution(* com.zejian.spring.springAop.dao.UserDao.*User(..))"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AfterReturning</span><span class="params">()</span></span>&#123;</span><br><span class="line">   System.out.println(<span class="string">"我是后置通知..."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 后置通知</span></span><br><span class="line"><span class="comment">* returnVal,切点方法执行后的返回值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@AfterReturning</span>(value=<span class="string">"execution(* com.zejian.spring.springAop.dao.UserDao.*User(..))"</span>,returning = <span class="string">"returnVal"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AfterReturning</span><span class="params">(JoinPoint joinPoint,Object returnVal)</span></span>&#123;</span><br><span class="line">   System.out.println(<span class="string">"我是后置通知...returnVal+"</span>+returnVal);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>异常通知 @AfterThrowing</p><p>该通知只有在异常时才会被出发，并由 throwing 来声明一个接受异常信息的变量，同样异常通知也用于 Joinpoing 参数，需要时可以加上。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 抛出通知</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> e 抛出异常的信息</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@AfterThrowing</span>(value=<span class="string">"execution(* com.zejian.spring.springAop.dao.UserDao.addUser(..))"</span>,throwing = <span class="string">"e"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterThrowable</span><span class="params">(Throwable e)</span></span>&#123;</span><br><span class="line">  System.out.println(<span class="string">"出现异常:msg="</span>+e.getMessage());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>最终通知 @After</p><p>该通知有点类似于 finally 代码块，只要应用了，无论什么情况下都会执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 无论什么情况下都会执行的方法</span></span><br><span class="line"><span class="comment"> * joinPoint 参数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@After</span>(<span class="string">"execution(* com.zejian.spring.springAop.dao.UserDao.*User(..))"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">(JoinPoint joinPoint)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"最终通知...."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>环绕通知 @Around</p><p>环绕通知既可在目标方法前执行也可以在目标方法后执行，更重要的是环绕通知可以控制目标方法是否指向执行，但即使如此，我们应该尽量以最简单的方式满足需求，在仅需目标方法前执行时，使用前置通知而非环绕通知。</p><p>第一个参数必须是 ProceedingJoinPoint，通过该对象的 proceed() 方法来执行目标函数，proceed() 的返回值就是环绕通知的返回值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Around</span>(<span class="string">"execution(* com.zejian.spring.springAop.dao.UserDao.*User(..))"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">around</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"我是环绕通知前...."</span>);</span><br><span class="line">    <span class="comment">//执行目标函数</span></span><br><span class="line">    Object obj= (Object) joinPoint.proceed();</span><br><span class="line">    System.out.println(<span class="string">"我是环绕通知后...."</span>);</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="通知传递参数"><a href="#通知传递参数" class="headerlink" title="通知传递参数"></a>通知传递参数</h5><p>在 Spring AOP 中，除了 execution 和 bean 指示符不能传递参数给通知方法，其他指示符都可以将<strong>匹配的方法相应参数或对象</strong>自动传递给通知方法。获取到匹配的方法参数后通过 <code>argNames</code>属性指定参数名。如下，args(param)、argNames=”param”、before(int param)这三个参数<strong>命名必须保持一致</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Before</span>(value=<span class="string">"args(param)"</span>, argNames=<span class="string">"param"</span>) <span class="comment">//明确指定了    </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">(<span class="keyword">int</span> param)</span> </span>&#123;    </span><br><span class="line">    System.out.println(<span class="string">"param:"</span> + param);    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可直接使用 args 指示符不带 argNames 声明参数，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Before</span>(<span class="string">"execution(public * com.zejian..*.addUser(..)) &amp;&amp; args(userId,..)"</span>)  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">(<span class="keyword">int</span> userId)</span> </span>&#123;  </span><br><span class="line">    <span class="comment">//调用addUser的方法时如果与addUser的参数匹配则会传递进来会传递进来</span></span><br><span class="line">    System.out.println(<span class="string">"userId:"</span> + userId);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>args(userId,..)表达式表示：只匹配那些至少接收一个参数而且传入的类型必须与userId一致的方法，传递的参数可以简单类型或者对象，只有参数和目标方法也匹配时才有会有值传递进来。</p><h3 id="Aspect-优先级"><a href="#Aspect-优先级" class="headerlink" title="Aspect 优先级"></a>Aspect 优先级</h3><p>如果有多个通知需要在同一个切点函数指定的过滤目标方法上执行，在所有前置通知函数中，优先级最高的通知函数将会被先执行，在所有后置通知函数中，优先级最高的通知函数将会最后执行。</p><p>新建名为 aspectdemo 的工程，首先引入核心依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>添加启动类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AspectdemoApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(AspectdemoApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>开启 AspectJAutoProxy ，添加配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hoo.aspectdemo.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.EnableAspectJAutoProxy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在配置文件中启动<span class="doctag">@Aspect</span>支持后，</span></span><br><span class="line"><span class="comment"> * Spring容器只会尝试自动识别带<span class="doctag">@Aspect</span>的Bean，</span></span><br><span class="line"><span class="comment"> * 前提是任何定义的切面类都必须已在配置文件以Bean的形式声明。</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AspectJConfig</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加测试用 Controller</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/order"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先添加优先级较高的切面</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hoo.aspectdemo.aspect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.AfterReturning;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Before;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Pointcut;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.Ordered;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">切面实现 org.springframework.core.Ordered 接口，该接口用于控制切面类的优先级，同时重写getOrder方法，定制返回值，返回值(int 类型)越小优先级越大</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AspectOrderZero</span> <span class="keyword">implements</span> <span class="title">Ordered</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut</span>(<span class="string">"execution(* com.hoo.aspectdemo.controller.TestController.testOrder())"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pointCut</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"pointCut()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeOne</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"前置通知 ..优先级 0 .. 执行顺序 1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"pointCut()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeTwo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"前置通知 ..优先级 0 .. 执行顺序 2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterReturning</span>(<span class="string">"pointCut()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterReturningThree</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"后置通知 ..优先级 0 .. 执行顺序 3"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterReturning</span>(<span class="string">"pointCut()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterReturningFour</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"后置通知 ..优先级 0 .. 执行顺序 4"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后添加优先级较低的切面</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hoo.aspectdemo.aspect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.AfterReturning;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Before;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Pointcut;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.Ordered;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AspectOrderTwo</span> <span class="keyword">implements</span> <span class="title">Ordered</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut</span>(<span class="string">"execution(* com.hoo.aspectdemo.controller.TestController.testOrder())"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pointCut</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"pointCut()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeOne</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"前置通知 ..优先级 2 .. 执行顺序 1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"pointCut()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeTwo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"前置通知 ..优先级 2 .. 执行顺序 2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterReturning</span>(<span class="string">"pointCut()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterReturningThree</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"后置通知 ..优先级 2 .. 执行顺序 3"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterReturning</span>(<span class="string">"pointCut()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterReturningFour</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"后置通知 ..优先级 2 .. 执行顺序 4"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行，即可在控制台看到如下信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">前置通知 ..优先级 0 .. 执行顺序 1</span><br><span class="line">前置通知 ..优先级 0 .. 执行顺序 2</span><br><span class="line">前置通知 ..优先级 2 .. 执行顺序 1</span><br><span class="line">前置通知 ..优先级 2 .. 执行顺序 2</span><br><span class="line">后置通知 ..优先级 2 .. 执行顺序 3</span><br><span class="line">后置通知 ..优先级 2 .. 执行顺序 4</span><br><span class="line">后置通知 ..优先级 0 .. 执行顺序 3</span><br><span class="line">后置通知 ..优先级 0 .. 执行顺序 4</span><br></pre></td></tr></table></figure><p>总结：在同一个切面中定义多个通知响应同一个切点函数，执行顺序为声明顺序；如果在不同的切面中定义多个通知响应同一个切点，进入时则优先级高的切面类中的通知函数优先执行，退出时则最后执行。</p><h3 id="Spring-AOP-简单应用场景"><a href="#Spring-AOP-简单应用场景" class="headerlink" title="Spring AOP 简单应用场景"></a>Spring AOP 简单应用场景</h3><ol><li>性能监控</li></ol><p>首先我们定义用于测试的controller，并模拟这个接口需要 5s 来执行操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hoo.aspectdemo.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/monitor"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testMonitor</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread.sleep(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后定义性能监控信息类 MonitorTime</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hoo.aspectdemo.aspect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MonitorTime</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String className;</span><br><span class="line">    <span class="keyword">private</span> String methodName;</span><br><span class="line">    <span class="keyword">private</span> Date logTime;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> consumeTime;</span><br><span class="line"> <span class="comment">// 省略 getter 和 setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后定义一个监控的切面类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hoo.aspectdemo.aspect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.ProceedingJoinPoint;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Around;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Pointcut;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimerAspect</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut</span>(<span class="string">"within(com.hoo.aspectdemo.controller..*)"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pointCut</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around</span>(<span class="string">"pointCut()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">logTimer</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        MonitorTime monitor = <span class="keyword">new</span> MonitorTime();</span><br><span class="line">        <span class="comment">//获取目标类名称</span></span><br><span class="line">        String className = joinPoint.getTarget().getClass().getName();</span><br><span class="line">        <span class="comment">//获取目标类方法名称</span></span><br><span class="line">        String methodName = joinPoint.getSignature().getName();</span><br><span class="line"></span><br><span class="line">        monitor.setClassName(className);</span><br><span class="line">        monitor.setMethodName(methodName);</span><br><span class="line">        monitor.setLogTime(<span class="keyword">new</span> Date());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//计时并调用目标函数</span></span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        Object result = joinPoint.proceed();</span><br><span class="line">        <span class="keyword">long</span> time = System.currentTimeMillis() - start;</span><br><span class="line">        monitor.setConsumeTime(time);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//把 MonitorTime 记录的信息上传给监控系统，这里没有实现</span></span><br><span class="line"></span><br><span class="line">        System.out.println(monitor);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动程序，访问<a href="http://localhost:8080/monitor，查看控制台，打印出如下信息：" target="_blank" rel="noopener">http://localhost:8080/monitor，查看控制台，打印出如下信息：</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MonitorTime&#123;className=<span class="string">'com.hoo.aspectdemo.controller.TestController2'</span>, methodName=<span class="string">'testMonitor'</span>, logTime=Mon Apr <span class="number">12</span> <span class="number">17</span>:<span class="number">08</span>:<span class="number">53</span> CST <span class="number">2021</span>, consumeTime=<span class="number">11</span>&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>异常监控</li></ol><p>首先定义异常信息类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hoo.aspectdemo.aspect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionInfo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String className;</span><br><span class="line">    <span class="keyword">private</span> String methodName;</span><br><span class="line">    <span class="keyword">private</span> Date logTime;<span class="comment">//异常记录时间</span></span><br><span class="line">    <span class="keyword">private</span> String message;<span class="comment">//异常信息</span></span><br><span class="line"><span class="comment">// 省略 getter 和 setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义自己的异常类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hoo.aspectdemo.exception;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyException</span> <span class="keyword">extends</span> <span class="title">Exception</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyException</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 TestController2 中添加测试函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/monitor/&#123;mode&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testMonitor2</span><span class="params">(@PathVariable Integer mode)</span> <span class="keyword">throws</span> MyException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(mode == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> MyException(<span class="string">" testMonitor() 方法出错了！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>然后定义异常处理的切面</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hoo.aspectdemo.aspect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.ProceedingJoinPoint;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Around;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Pointcut;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionMonitorAspect</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut</span>(<span class="string">"within(com.hoo.aspectdemo.controller..*)"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">exceptionMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around</span>(<span class="string">"exceptionMethod()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">monitorMethods</span><span class="params">(ProceedingJoinPoint joinPoint)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> joinPoint.proceed();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            ExceptionInfo info = <span class="keyword">new</span> ExceptionInfo();</span><br><span class="line">            info.setClassName(joinPoint.getTarget().getClass().getName());</span><br><span class="line">            info.setMethodName(joinPoint.getSignature().getName());</span><br><span class="line">            info.setLogTime(<span class="keyword">new</span> Date());</span><br><span class="line">            info.setMessage(e.getMessage());</span><br><span class="line"></span><br><span class="line">            System.out.println(info);</span><br><span class="line">            <span class="comment">//上传日志系统，这里省略</span></span><br><span class="line">            <span class="comment">//返回失败信息</span></span><br><span class="line">            <span class="keyword">return</span> e.getMessage();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>浏览器访问 <a href="http://localhost:8080/monitor/0" target="_blank" rel="noopener">http://localhost:8080/monitor/0</a> ，可以看到返回 ”success“信息，并在控制台可以看到访问时间日志：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MonitorTime&#123;className&#x3D;&#39;com.hoo.aspectdemo.controller.TestController2&#39;, methodName&#x3D;&#39;testMonitor2&#39;, logTime&#x3D;Mon Apr 12 21:46:30 CST 2021, consumeTime&#x3D;11&#125;</span><br></pre></td></tr></table></figure><p>浏览器访问 <a href="http://localhost:8080/monitor/1" target="_blank" rel="noopener">http://localhost:8080/monitor/1</a> ，可以看到返回 ”testMonitor() 方法出错了！“信息，并在控制台可以看到访问时间日志：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ExceptionInfo&#123;className&#x3D;&#39;com.hoo.aspectdemo.controller.TestController2&#39;, methodName&#x3D;&#39;testMonitor2&#39;, logTime&#x3D;Mon Apr 12 21:47:15 CST 2021, message&#x3D;&#39; testMonitor() 方法出错了！&#39;&#125;</span><br></pre></td></tr></table></figure><h3 id="Spring-AOP-实现原理概要"><a href="#Spring-AOP-实现原理概要" class="headerlink" title="Spring AOP 实现原理概要"></a>Spring AOP 实现原理概要</h3><p>对于织入过程，一般分为动态织入和静态织入，动态织入在运行时动态地将要增强的代码织入到目标类中，这往往是通过动态代理技术完成的，如 Java JDK 的动态代理（底层通过反射实现）或者 CGLIB 的动态代理（底层通过继承实现）。</p><p>AspectJ 采用静态织入的方式。它在编译器使用 acj 编译器把 aspect 类编译成 class 字节码后，在 java 目标类编译时织入，先编译 aspect 类再编译目标类。</p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20210414190852904.png" alt="image-20210414190852904"></p><h4 id="JDK-动态代理"><a href="#JDK-动态代理" class="headerlink" title="JDK 动态代理"></a>JDK 动态代理</h4><p>首先看一个简单的例子，声明一个 ExInterface 接口，利用 JDK 动态代理技术在 execute() 方法前后加入权限验证和日志记录。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自定义的接口类，JDK 动态代理的实现必须要有对应的接口类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ExInterface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//A类，实现了ExInterface接口类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">implements</span> <span class="title">ExInterface</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"---- A.execute() ----"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="comment">//代理类的实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDKProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 要被代理的目标对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> A target;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JDKProxy</span><span class="params">(A target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 创建代理类</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ExInterface <span class="title">createProxy</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (ExInterface) Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(),<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调用被代理类(目标对象)的任意方法都会触发invoke方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> proxy 代理类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> method 被代理类的方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args 被代理类的方法参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">//过滤不需要该业务的方法</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="string">"execute"</span>.equals(method.getName())) &#123;</span><br><span class="line">            <span class="comment">//调用前验证权限</span></span><br><span class="line">            <span class="comment">//AuthCheck.authCheck();</span></span><br><span class="line">            System.out.println(<span class="string">"---- 鉴权 ----"</span>);</span><br><span class="line">            <span class="comment">//调用目标对象的方法</span></span><br><span class="line">            Object result = method.invoke(target, args);</span><br><span class="line">            <span class="comment">//记录日志数据</span></span><br><span class="line">            <span class="comment">//Report.recordLog();</span></span><br><span class="line">            System.out.println(<span class="string">"---- 记录日志 ----"</span>);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">"delete"</span>.equals(method.getName()))&#123;</span><br><span class="line">            <span class="comment">//.....</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果不需要增强直接执行原方法</span></span><br><span class="line">        <span class="keyword">return</span> method.invoke(target,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        A a = <span class="keyword">new</span> A();</span><br><span class="line">        <span class="comment">//创建 JDK 代理</span></span><br><span class="line">        JDKProxy jdkProxy = <span class="keyword">new</span> JDKProxy(a);</span><br><span class="line">        <span class="comment">//创建代理对象</span></span><br><span class="line">        ExInterface proxy = jdkProxy.createProxy();</span><br><span class="line">        <span class="comment">//执行代理对象方法</span></span><br><span class="line">        proxy.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试结果</span></span><br><span class="line">---- 鉴权 ----</span><br><span class="line">---- A.execute() ----</span><br><span class="line">---- 记录日志 ----</span><br></pre></td></tr></table></figure><p>在 A 的 execute() 方法中没有调用任何权限和日志的 代码，也没有直接操作 a 对象，只是调用了 proxy 代理对象的方法，最终的结果却是预期的，这就是动态代理技术。动态代理的底层通过反射来实现，只要拿到 A 类的 class 文件和 A 类的实现接口，很自然就可以生成相同接口的代理类并调用  a 对象的方法。</p><p>实现 Java 动态代理是先决条件为：<strong>目标对象必须带接口</strong>，如果类的接口是 ExInterface，通过该接口，动态代理可以创建与 A 类类型相同的代理对象。</p><p>用JDK动态代理，被代理类(目标对象，如A类)，必须已有实现接口如(ExInterface)，因为JDK提供的Proxy类将通过目标对象的类加载器ClassLoader和Interface，以及句柄(Callback)创建与A类拥有相同接口的代理对象proxy，该代理对象将拥有接口ExInterface中的所有方法。同时，代理类必须实现一个类似回调函数的InvocationHandler接口并重写该接口中的invoke方法，当调用proxy的每个方法(如案例中的proxy#execute())时，invoke方法将被调用，利用该特性，可以在invoke方法中对目标对象(被代理对象如A)方法执行的前后动态添加其他外围业务操作，此时无需触及目标对象的任何代码，也就实现了外围业务的操作与目标对象(被代理对象如A)完全解耦合的目的。当然缺点也很明显需要拥有接口，这也就有了后来的CGLIB动态代理。  </p><h4 id="CGLIB-动态代理"><a href="#CGLIB-动态代理" class="headerlink" title="CGLIB 动态代理"></a><a href="https://github.com/cglib/cglib" target="_blank" rel="noopener">CGLIB</a> 动态代理</h4><p>通过CGLIB动态代理实现上述功能并不要求目标对象拥有接口类，实际上CGLIB动态代理是通过继承的方式实现的，因此可以减少没必要的接口，下面直接通过简单案例协助理解。</p><p>首先引入 <a href="https://repository.ow2.org/nexus/content/repositories/releases/org/ow2/asm/asm/8.0.1/asm-8.0.1.jar" target="_blank" rel="noopener">asm-8.0.1.jar</a> 和 <a href="https://github.com/cglib/cglib/releases/download/RELEASE_3_3_0/cglib-3.3.0.jar" target="_blank" rel="noopener">cglib-3.3.0.jar</a>，也可使用 maven 下载。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="comment">//被代理的类（目标对象）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"---- A.execute() ----"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.Enhancer;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodInterceptor;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodProxy;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CGLibProxy</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 被代理的目标类</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="keyword">private</span> A target;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CGLibProxy</span><span class="params">(A target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建代理对象</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> A <span class="title">createProxy</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//使用 CGLIB 生成代理</span></span><br><span class="line">        <span class="comment">//1.生成增强类实例，用于生产代理类</span></span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        <span class="comment">//2.设置被代理类字节码，CGLIB 根据字节码生成被代理类的子类</span></span><br><span class="line">        enhancer.setSuperclass(target.getClass());</span><br><span class="line">        <span class="comment">//3. 设置回调函数，即一个方法拦截</span></span><br><span class="line">        enhancer.setCallback(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">//4.创建代理</span></span><br><span class="line">        <span class="keyword">return</span> (A) enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 回调函数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> obj 代理对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> method 委托类方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args 方法参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> proxy 每个被代理的方法都对应一个MethodProxy对象，</span></span><br><span class="line"><span class="comment">     *                    methodProxy.invokeSuper方法最终调用委托类(目标类)的原始方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object obj, Method method, Object[] args, MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">//过滤不需要该业务的方法</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="string">"execute"</span>.equals(method.getName()))&#123;</span><br><span class="line">            <span class="comment">//调用前验证权限</span></span><br><span class="line">            System.out.println(<span class="string">"---- 鉴权 ----"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//调用目标对象的方法（执行 A 独享即被代理对象的 execute 方法）</span></span><br><span class="line">            Object result = proxy.invokeSuper(obj,args);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//记录日志数据（动态添加其他要执行业务）</span></span><br><span class="line">            System.out.println(<span class="string">"---- 日志 ----"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">"delete"</span>.equals(method.getName()))&#123;</span><br><span class="line">            <span class="keyword">return</span> proxy.invokeSuper(obj, args);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//不需要增强直接执行原方法</span></span><br><span class="line">        <span class="keyword">return</span> proxy.invokeSuper(obj,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CGLibTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        A a = <span class="keyword">new</span> A();</span><br><span class="line"></span><br><span class="line">        CGLibProxy cgLibProxy = <span class="keyword">new</span> CGLibProxy(a);</span><br><span class="line"></span><br><span class="line">        A proxy = cgLibProxy.createProxy();</span><br><span class="line"></span><br><span class="line">        proxy.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试结果</span></span><br><span class="line">---- 鉴权 ----</span><br><span class="line">---- A.execute() ----</span><br><span class="line">---- 日志 ----</span><br></pre></td></tr></table></figure><p>被代理的类无需接口即可实现动态代理，而CGLibProxy代理类需要实现一个方法拦截器接口MethodInterceptor并重写intercept方法，类似JDK动态代理的InvocationHandler接口，也是理解为回调函数，同理每次调用代理对象的方法时，intercept方法都会被调用，利用该方法便可以在运行时对方法执行前后进行动态增强。关于代理对象创建则通过Enhancer类来设置的，Enhancer是一个用于产生代理对象的类，作用类似JDK的Proxy类，因为CGLib底层是通过继承实现的动态代理，因此需要传递目标对象(如A)的Class，同时需要设置一个回调函数对调用方法进行拦截并进行相应处理，最后通过create()创建目标对象(如A)的代理对象，运行结果与前面的JDK动态代理效果相同。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>Spring AOP内部已都实现了这两种技术，Spring AOP 在使用时机上也进行自动化调整，当有接口时会自动选择JDK动态代理技术，如果没有则选择CGLIB技术，当然Spring AOP的底层实现并没有这么简单，为更简便生成代理对象，Spring AOP 内部实现了一个专注于生成代理对象的工厂类，这样就避免了大量的手动编码，这点也是十分人性化的，但最核心的还是动态代理技术。从性能上来说，Spring AOP 虽然无需特殊编译器协助，但性能上并不优于AspectJ的静态织入。<img src="https://gitee.com/hoo334/picgo/raw/master//img/v2-b091ac6fd64f493eaeabfeff4cee7fee_1440w.png" alt="img"></p><p><a href="https://blog.csdn.net/javazejian/article/details/56267036" target="_blank" rel="noopener">参考</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;基于注解的-Spring-AOP-开发&quot;&gt;&lt;a href=&quot;#基于注解的-Spring-AOP-开发&quot; class=&quot;headerlink&quot; title=&quot;基于注解的 Spring AOP 开发&quot;&gt;&lt;/a&gt;基于注解的 Spring AOP 开发&lt;/h3&gt;
    
    </summary>
    
    
      <category term="SpringBoot" scheme="https://hoo334.github.io/categories/SpringBoot/"/>
    
    
  </entry>
  
  <entry>
    <title>重构</title>
    <link href="https://hoo334.github.io/2021/04/11/%E9%87%8D%E6%9E%84/"/>
    <id>https://hoo334.github.io/2021/04/11/%E9%87%8D%E6%9E%84/</id>
    <published>2021-04-11T05:52:22.979Z</published>
    <updated>2020-10-16T07:14:52.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="代码的坏味道"><a href="#代码的坏味道" class="headerlink" title="代码的坏味道"></a>代码的坏味道</h2><h3 id="Duplicated-Code（重复代码）"><a href="#Duplicated-Code（重复代码）" class="headerlink" title="Duplicated Code（重复代码）"></a>Duplicated Code（重复代码）</h3><p>如果你在一个以上的地方看见相同的程序结构，将它们合二为一。</p><h3 id="Long-Method（过长函数）"><a href="#Long-Method（过长函数）" class="headerlink" title="Long Method（过长函数）"></a>Long Method（过长函数）</h3><p>将过长的函数分解为若干个小函数。</p><a id="more"></a><h3 id="Large-Class（过大的类）"><a href="#Large-Class（过大的类）" class="headerlink" title="Large Class（过大的类）"></a>Large Class（过大的类）</h3><p>单个类要做的事情太多，将其分解为几个类。</p><h3 id="Long-Parameter-List（过长参数列）"><a href="#Long-Parameter-List（过长参数列）" class="headerlink" title="Long Parameter List（过长参数列）"></a>Long Parameter List（过长参数列）</h3><p>如果参数太多，考虑使用参数对象。</p><h3 id="Divergent-Change（发散式变化）"><a href="#Divergent-Change（发散式变化）" class="headerlink" title="Divergent Change（发散式变化）"></a>Divergent Change（发散式变化）</h3><p>某个类经常因为不同的原因在不同的方向上发生变化。当你看见<strong>一个类</strong>说：“新加入一个数据库，我必须修改三个函数”</p><h3 id="Shotgun-Surgery（霰弹式修改）"><a href="#Shotgun-Surgery（霰弹式修改）" class="headerlink" title="Shotgun Surgery（霰弹式修改）"></a>Shotgun Surgery（霰弹式修改）</h3><p>如果每遇到某种变化，你都必须在许多<strong>不同</strong>的类中做出许多小修改。</p><h3 id="Feature-Envy（依恋情结）"><a href="#Feature-Envy（依恋情结）" class="headerlink" title="Feature Envy（依恋情结）"></a>Feature Envy（依恋情结）</h3><p>函数对某个类的兴趣高过于对自己所处类的兴趣。</p><h3 id="Data-Clumps（数据泥团）"><a href="#Data-Clumps（数据泥团）" class="headerlink" title="Data Clumps（数据泥团）"></a>Data Clumps（数据泥团）</h3><p>常在许多地方看到成群的数据，考虑将其抽取为类。</p><h3 id="Primitive-Obsession（基本类型偏执）"><a href="#Primitive-Obsession（基本类型偏执）" class="headerlink" title="Primitive Obsession（基本类型偏执）"></a>Primitive Obsession（基本类型偏执）</h3><p>尝试将原本单独存在的数据值替换为对象</p><h3 id="Switch-Statements（Switch-语句）"><a href="#Switch-Statements（Switch-语句）" class="headerlink" title="Switch Statements（Switch 语句）"></a>Switch Statements（Switch 语句）</h3><p>大多数时候，一看到 Switch ，就应该考虑使用<strong>多态</strong>来替换它。</p><h3 id="Parallel-Inheritance-Hierarchies（平行继承体系）"><a href="#Parallel-Inheritance-Hierarchies（平行继承体系）" class="headerlink" title="Parallel Inheritance Hierarchies（平行继承体系）"></a>Parallel Inheritance Hierarchies（平行继承体系）</h3><p>每当你为某个类增加一个子类，也必须为另一个类增加一个子类。消除策略：让一个继承体系的实例引用另一个继承体系的实例。</p><h3 id="Lazy-Class（冗余类）"><a href="#Lazy-Class（冗余类）" class="headerlink" title="Lazy Class（冗余类）"></a>Lazy Class（冗余类）</h3><p>删除它。</p><h3 id="Speculative-Generality（夸夸其谈未来性）"><a href="#Speculative-Generality（夸夸其谈未来性）" class="headerlink" title="Speculative Generality（夸夸其谈未来性）"></a>Speculative Generality（夸夸其谈未来性）</h3><p>删掉无用的函数和linshi函数中多余的参数。</p><h3 id="Temporary-Field（令人迷惑的暂时字段）"><a href="#Temporary-Field（令人迷惑的暂时字段）" class="headerlink" title="Temporary Field（令人迷惑的暂时字段）"></a>Temporary Field（令人迷惑的暂时字段）</h3><p>类中某个实例变量仅为某种特定情况而设置，通常你认为对象在所有时候都需要它的所有变量，在变量未被使用的情况下猜测其设置目的，会让你发疯的！将这些变量抽取为类。</p><h3 id="Message-Chains（过度耦合的消息链）"><a href="#Message-Chains（过度耦合的消息链）" class="headerlink" title="Message Chains（过度耦合的消息链）"></a>Message Chains（过度耦合的消息链）</h3><p>用户向一个对象请求另一个对象，然后再向后者请求另一个都西昂，然后再请求另一个对象 ……… 这就是消息链。</p><h3 id="Middle-Man（中间人）"><a href="#Middle-Man（中间人）" class="headerlink" title="Middle Man（中间人）"></a>Middle Man（中间人）</h3><p>某个类接口有一半的函数都委托给其他类，这是就应该去掉 Middle Man，直接和真正负责的对象打交道。</p><h3 id="Inappropriate-Intimacy（狎昵关系）"><a href="#Inappropriate-Intimacy（狎昵关系）" class="headerlink" title="Inappropriate Intimacy（狎昵关系）"></a>Inappropriate Intimacy（狎昵关系）</h3><p>两个类过于亲密，花费太多时间去探究彼此的 private 成分。应该将这两个类分开，帮它们划清界限。</p><h3 id="Alternative-Classes-with-Different-Interfaces（异曲同工的类）"><a href="#Alternative-Classes-with-Different-Interfaces（异曲同工的类）" class="headerlink" title="Alternative Classes with Different Interfaces（异曲同工的类）"></a>Alternative Classes with Different Interfaces（异曲同工的类）</h3><p>两个函数做着同样的事情，却有不同的签名，尝试根据它们的用途进行重命名。</p><h3 id="Data-Class（纯稚的数据类）"><a href="#Data-Class（纯稚的数据类）" class="headerlink" title="Data Class（纯稚的数据类）"></a>Data Class（纯稚的数据类）</h3><p>拥有一些字段，以及用于访问这些字段的函数。</p><h3 id="Refused-Bequest（被拒绝的捐赠）"><a href="#Refused-Bequest（被拒绝的捐赠）" class="headerlink" title="Refused Bequest（被拒绝的捐赠）"></a>Refused Bequest（被拒绝的捐赠）</h3><p>子类不想或不需要继承超类的函数和数据。</p><h3 id="Comments（过多的注释）"><a href="#Comments（过多的注释）" class="headerlink" title="Comments（过多的注释）"></a>Comments（过多的注释）</h3><p> 一段代码中有长长的注释，尝试重构复杂的地方。</p><h3 id="Incomplete-Library-Class（不完美的库类）"><a href="#Incomplete-Library-Class（不完美的库类）" class="headerlink" title="Incomplete Library Class（不完美的库类）"></a>Incomplete Library Class（不完美的库类）</h3><p>想要对库类添加或修改，可以引入本地扩展。</p><h2 id="重新组织函数"><a href="#重新组织函数" class="headerlink" title="重新组织函数"></a>重新组织函数</h2><h3 id="Extract-Method（提炼函数）"><a href="#Extract-Method（提炼函数）" class="headerlink" title="Extract Method（提炼函数）"></a>Extract Method（提炼函数）</h3><p>你有一段代码可以被组织在一起并独立出来。<strong>将这段代码放进一个独立函数中，并让函数名称解释该函数的用途。</strong></p><h3 id="Inline-Method（内联函数）"><a href="#Inline-Method（内联函数）" class="headerlink" title="Inline Method（内联函数）"></a>Inline Method（内联函数）</h3><p>一个函数的本体与名称同样清楚易懂。<strong>在函数调用点插入函数本体，然后删除函数。</strong></p><h3 id="Inline-Temp（内联临时变量）"><a href="#Inline-Temp（内联临时变量）" class="headerlink" title="Inline Temp（内联临时变量）"></a>Inline Temp（内联临时变量）</h3><p>你有一个临时变量，只被一个简单表达式肤质一次，而它妨碍了其他重构手法。</p><p><strong>将所有对该变量的引用动作，替换为对它赋值的表达式自身。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> basePrice = anOrder.basePrice();</span><br><span class="line"><span class="keyword">return</span> basePrice &gt; <span class="number">100</span>;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> anOrder.basePrice() &gt; <span class="number">100</span>;</span><br></pre></td></tr></table></figure><h3 id="Return-Temp-With-Query（以查询取代临时变量）"><a href="#Return-Temp-With-Query（以查询取代临时变量）" class="headerlink" title="Return Temp With Query（以查询取代临时变量）"></a>Return Temp With Query（以查询取代临时变量）</h3><p>你的此程序以一个临时变量保存某一表达式的运算结果。</p><p><strong>将这个表达式提炼到一个独立函数中。将这个临时变量的所有引用点替换为对新函数的调用。此后，新函数就可被其他函数使用。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> basePrice = _quantity * _itemPrice;</span><br><span class="line"><span class="keyword">if</span>(basePrice &gt; <span class="number">1000</span>)</span><br><span class="line">    <span class="keyword">return</span> basePrice * <span class="number">0.95</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> basePrice * <span class="number">0.99</span>;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(basePrice() &gt; <span class="number">1000</span>)</span><br><span class="line">    <span class="keyword">return</span> basePrice() * <span class="number">0.95</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> basePrice() * <span class="number">0.99</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">basePrice</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _quantity * _itemPrice;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Introduce-Explaining-Variable（引用解释性变量）"><a href="#Introduce-Explaining-Variable（引用解释性变量）" class="headerlink" title="Introduce Explaining Variable（引用解释性变量）"></a>Introduce Explaining Variable（引用解释性变量）</h3><p>你有一个复杂的表达式，<strong>将该复杂表达式（或其中一部分）的结果放进一个临时变量，以此变量名称来解释表达式用途。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>((platform.toUpperCase().indexOf(<span class="string">'MAC'</span>) &gt; -<span class="number">1</span>) &amp;&amp;</span><br><span class="line">  (browser.toUpperCase().indexOf(<span class="string">'IE'</span>) &gt; -<span class="number">1</span>) &amp;&amp;</span><br><span class="line">  wasInitialized() &amp;&amp; resize &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">//do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> isMacOS = platform.toUpperCase().indexOf(<span class="string">'MAC'</span>) &gt; -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> isIEBrowser = browser.toUpperCase().indexOf(<span class="string">'IE'</span>) &gt; -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> wasResized = resize &gt; <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(isMacOS &amp;&amp; isIEBrowser &amp;&amp; wasInitialized() &amp;&amp; wasResized)&#123;</span><br><span class="line"><span class="comment">// do something&#125;</span></span><br></pre></td></tr></table></figure><h3 id="Split-Temporary-Variable（分解临时变量）"><a href="#Split-Temporary-Variable（分解临时变量）" class="headerlink" title="Split Temporary Variable（分解临时变量）"></a>Split Temporary Variable（分解临时变量）</h3><p>你的程序有某个临时变量被赋值超过一次，它既不是循环变量，也不被用于收集计算结果。<strong>针对每次赋值，创造一个独立、对应的临时变量。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> temp = <span class="number">2</span> * (_height + _width);</span><br><span class="line">System.out.println(temp);</span><br><span class="line">temp = _height * _width;</span><br><span class="line">System.out.println(temp);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">double</span> perimeter = <span class="number">2</span> * (_height + _width);</span><br><span class="line">System.out.println(perimeter);</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">double</span> area = _height * _width;</span><br><span class="line">System.out.println(area);</span><br></pre></td></tr></table></figure><h3 id="Remove-Assignments-to-Parameters（移除对参数的赋值）"><a href="#Remove-Assignments-to-Parameters（移除对参数的赋值）" class="headerlink" title="Remove Assignments to Parameters（移除对参数的赋值）"></a>Remove Assignments to Parameters（移除对参数的赋值）</h3><p>代码对一个参数进行赋值。<strong>以一个临时变量取代该参数的位置</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">discount</span><span class="params">(<span class="keyword">int</span> inputVal, <span class="keyword">int</span> quantity, <span class="keyword">int</span> yearToDate)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(inputVal &gt; <span class="number">50</span>) inputVal -= <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">discount</span><span class="params">(<span class="keyword">int</span> inputVal, <span class="keyword">int</span> quantity, <span class="keyword">int</span> yearToDate)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = inputVal;</span><br><span class="line">    <span class="keyword">if</span>(result &gt; <span class="number">50</span>) result -= <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Replace-Method-with-Object（以函数对象取代函数）"><a href="#Replace-Method-with-Object（以函数对象取代函数）" class="headerlink" title="Replace Method with Object（以函数对象取代函数）"></a>Replace Method with Object（以函数对象取代函数）</h3><p>你有一个大型函数，其中对局部变量的使用使你无法采用<strong><em>Extract Method</em></strong>。</p><p><strong>将这个函数放进一个单独对象中，如此一来局部变量就成了对象内的字段。然后你可以在同一个对象中将这个大型函数分解为多个小函数。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Order</span></span>&#123;</span><br><span class="line">    <span class="comment">//长函数</span></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">price</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">double</span> primaryBasePrice;</span><br><span class="line">        <span class="keyword">double</span> secondaryBasePrice;</span><br><span class="line">        <span class="keyword">double</span> tertiaryBasePrice;</span><br><span class="line">        <span class="comment">// long computation</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Order</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">price</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PriceCalculator().compute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PriceCalculator</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> primaryBasePrice;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> secondaryBasePrice;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> tertiaryBasePrice;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">compute</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//long computation</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Subsititute-Algorithm（替换算法）"><a href="#Subsititute-Algorithm（替换算法）" class="headerlink" title="Subsititute Algorithm（替换算法）"></a>Subsititute Algorithm（替换算法）</h3><p>你想要把某个算法替换为另一个更清晰的算法。<strong>将函数本体替换为另一个算法。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">String <span class="title">foundPerson</span><span class="params">(String[] people)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; people.length(); i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(people[i].equals(<span class="string">"Don"</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Don"</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(people[i].equals(<span class="string">"John"</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"John"</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(people[i].equals(<span class="string">"Kent"</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Kent"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">String <span class="title">foundPerson</span><span class="params">(String[] people)</span></span>&#123;</span><br><span class="line">    List&lt;String&gt; candidates = Arrays.asList(<span class="keyword">new</span> String[]&#123;<span class="string">"Don"</span>, <span class="string">"John"</span>, <span class="string">"Kent"</span>&#125;);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; people.length(); i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(candidates.contains(people[i]))&#123;</span><br><span class="line">            <span class="keyword">return</span> people[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="在对象之间搬移特性"><a href="#在对象之间搬移特性" class="headerlink" title="在对象之间搬移特性"></a>在对象之间搬移特性</h2><h3 id="Move-Method（搬移函数）"><a href="#Move-Method（搬移函数）" class="headerlink" title="Move Method（搬移函数）"></a>Move Method（搬移函数）</h3><p>你的程序中，有个函数与其驻类之外的另一个类进行更多交流：调用后者，或被后者调用。</p><p>在该函数最常引用的类中建立一个有着类似行为的新函数。将旧函数变成一个单独的委托函数，或者将旧函数完全移除。</p><h3 id="Move-Field（搬移字段）"><a href="#Move-Field（搬移字段）" class="headerlink" title="Move Field（搬移字段）"></a>Move Field（搬移字段）</h3><p>在你的程序中，某个字段被其所驻类之外的另一个类更多地用到。</p><p><strong>在目标类新建一个字段，修改源字段地所有用户，令它们改用新字段。</strong></p><h3 id="Extract-Class（提炼类）"><a href="#Extract-Class（提炼类）" class="headerlink" title="Extract Class（提炼类）"></a>Extract Class（提炼类）</h3><p>某个类做了应该由两个类做的事。</p><p><strong>建立一个新类，将相关的字段和函数从旧类搬移到新类。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String officeAreaCode;</span><br><span class="line">    <span class="keyword">private</span> String officeNumber;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">getTelephoneNumber</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="string">"("</span> + officeAreaCode + <span class="string">")"</span> + officeNumber);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> TelephoneNumber tel;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">getTelephoneNumber</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> tel.getTelephoneNumber();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TelephoneNumber</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String officeAreaCode;</span><br><span class="line">    <span class="keyword">private</span> String officeNumber;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">getTelephoneNumber</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="string">"("</span> + officeAreaCode + <span class="string">")"</span> + officeNumber);</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Inline-Class（将类内联化）"><a href="#Inline-Class（将类内联化）" class="headerlink" title="Inline Class（将类内联化）"></a>Inline Class（将类内联化）</h3><p>某个类没有做太多事情。<strong>将这个类的所有特性搬移到另一个类中，然后移除原类。</strong></p><p>刚好与<strong><em>Extract Class</em></strong>相反。</p><h3 id="Hide-Delegate（隐藏“委托关系”）"><a href="#Hide-Delegate（隐藏“委托关系”）" class="headerlink" title="Hide Delegate（隐藏“委托关系”）"></a>Hide Delegate（隐藏“委托关系”）</h3><p>客户通过一个委托类来调用另一个对象。<strong>在服务类上建立客户所需的所有函数，用以隐藏委托关系。</strong></p><p>如果某个客户先通过服务对象的字段得到另一个对象，然后调用后者的函数，那么客户就必须知晓这一层委托关系。万一委托关系发生变化，客户也得相应变化。你可以在服务对象上放置一个简单的委托函数，将委托关系隐藏起来，然后去除这种依赖。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Department department;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Department <span class="title">getDepartmeent</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> department;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Department</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Person manager;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Persion <span class="title">getManager</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> manager;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果客户希望知道某人的经理是谁，他必须先取得 Department 对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">manager = john.getDepartment().getManager();</span><br></pre></td></tr></table></figure><p>这样就对客户暴露了 Department 的工作原理，我们在 Person 中建立一个简单的委托函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Person <span class="title">getManager</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> department.getManager();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后客户直接调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">manager = john.getManager();</span><br></pre></td></tr></table></figure><h3 id="Remove-Middle-Man（移除中间人）"><a href="#Remove-Middle-Man（移除中间人）" class="headerlink" title="Remove Middle Man（移除中间人）"></a>Remove Middle Man（移除中间人）</h3><p>某个类做了过多的简单委托动作。<strong>让客户直接调用委托类。</strong></p><p>在 <strong><em>Hide Delegate</em></strong> 中这层封装也是有代价的，它的代价就是：每当客户需要使用受托类的新特性时，你就必须在服务端添加一个简单委托函数。随着受托类的特性越来越多，这一过程会让你痛苦不已。这个时候你就应该让客户直接调用受托类。</p><h3 id="Introduce-Foreign-Method（引入外加函数）"><a href="#Introduce-Foreign-Method（引入外加函数）" class="headerlink" title="Introduce Foreign Method（引入外加函数）"></a>Introduce Foreign Method（引入外加函数）</h3><p>你需要为提供服务的类增加一个函数，但你无法修改这个类。<strong>在客户类中建立一个函数，并以第一参数形式传入一个服务类实例。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Date newStart = <span class="keyword">new</span> Date(previousEnd.getYear(), previousEnd.getMonth(), previousEnd.getDate() + <span class="number">1</span>);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Date <span class="keyword">new</span> Start = nextDay(previousEnd);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Date <span class="title">nextDay</span><span class="params">(Date arg)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Date(arg.getYear(), arg.getMonth(), arg.getDate() + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果可以修改源码，可以自行添加一个新函数；如果不能，就得在客户端编码，补足你要的那个函数。</p><p>如果你发现自己为一个服务类建立了大量外加函数，或者发现有许多类都需要同样的外加函数，就不应该再使用本项重构，而应该使用<strong><em>Introduce Local Extension</em></strong>。</p><h3 id="Introduce-Local-Extension（引入本地扩展）"><a href="#Introduce-Local-Extension（引入本地扩展）" class="headerlink" title="Introduce Local Extension（引入本地扩展）"></a>Introduce Local Extension（引入本地扩展）</h3><p>你需要为服务类提供一些额外函数，但你无法修改这个类。</p><p><strong>建立一个新类，使它包含这些额外函数。让这个扩展品成为源类的子类或包装类。</strong></p><p>我们需要将这些额外函数组织在一起，放到一个恰当地方去。有两种标准对象技术——<strong>子类化（subclassing）</strong>和<strong>包装（wrapping）。</strong>将子类和包装类统称为本地扩展（Local Extension）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//子类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MfDateSub</span> <span class="keyword">extends</span> <span class="title">Date</span></span>&#123;</span><br><span class="line">    MfDateSub(String dateString)&#123;</span><br><span class="line">        <span class="keyword">super</span>(dateString);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">Date <span class="title">nextDay</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Date(getYear(), getMonth(), getDate() + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//包装类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MfDateWrap</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Date original;</span><br><span class="line">    MfDateWrap(String dateString)&#123;</span><br><span class="line">        original = <span class="keyword">new</span> Date(dateString);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    MfDateWrap(Date arg)&#123;</span><br><span class="line">        original = arg;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getYear</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> original.getYear();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMonth</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> original.getMonth();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 省略其他对 Date 类函数的包装</span></span><br><span class="line">    </span><br><span class="line">    <span class="function">Date <span class="title">nextDay</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Date(getYear(), getMonth(), getDate() + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="重新组织数据"><a href="#重新组织数据" class="headerlink" title="重新组织数据"></a>重新组织数据</h2><h3 id="Self-Encapsulate-Field（自封装字段）"><a href="#Self-Encapsulate-Field（自封装字段）" class="headerlink" title="Self Encapsulate Field（自封装字段）"></a>Self Encapsulate Field（自封装字段）</h3><p>你直接访问一个字段，但与字段之间的耦合关系逐渐变得笨拙。<strong>为这个字段建立设值/取值函数，并只以这些函数来访问字段。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> low, high;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">includes</span><span class="params">(<span class="keyword">int</span> arg)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arg &gt;= low &amp;&amp; arg &lt;= high;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> low, hign;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">includes</span><span class="params">(<span class="keyword">int</span> arg)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arg &gt;= getLow() &amp;&amp; arg &lt;= getHigh();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Replace-Data-Value-with-Object（以对象取代数据值）"><a href="#Replace-Data-Value-with-Object（以对象取代数据值）" class="headerlink" title="Replace Data Value with Object（以对象取代数据值）"></a>Replace Data Value with Object（以对象取代数据值）</h3><p>你有一个数据项，需要与其他数据和行为一起使用才有意义。<strong>将数据项变成对象。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Order</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String customer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Order</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Customer customer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Customer</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Change-Value-to-Reference（将值对象改为引用对象）"><a href="#Change-Value-to-Reference（将值对象改为引用对象）" class="headerlink" title="Change Value to Reference（将值对象改为引用对象）"></a>Change Value to Reference（将值对象改为引用对象）</h3><p>你从一个类衍生出许多彼此相等的实例，希望将它们替换为同一个对象。<strong>将这个值对象变成引用对象。</strong></p><p>在<strong><em>Replace Data Value with Object</em></strong>中，留下了一个重构后的程序。到目前为止，Customer 对象还是值对象。就算多份订单属于同一用户，但每个 Order 对象还是拥有各自的 Customer 对象。我希望一个用户可以有多个订单，所有 Order 对象共同拥有同一个 Customer 对象<strong>（每一个客户名称只该对应一个Customer对象）</strong>。</p><p>首先使用<strong><em>Replace Constructor with Factory Method</em></strong>。这样，就可以控制 Customer 对象的创建过程。在 Customer 类中定义这个工厂函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Customer</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Customer <span class="title">create</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Customer(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后更改调用点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Order</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Order</span><span class="params">(String customer)</span></span>&#123;</span><br><span class="line">        customer = Customer.create(customer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后把 Customer 类的构造函数改为 private。</p><p>在 Customer 类中使用 HashMap 存储 Customer 对象，并更改工厂方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Customer</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, Customer&gt; instances = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">store</span><span class="params">()</span></span>&#123;</span><br><span class="line">        instances.put(<span class="keyword">this</span>.getName(), <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//直接写死几个数据(应该从数据库读取)</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loadCustomer</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Customer(<span class="string">"a"</span>).store();</span><br><span class="line">        <span class="keyword">new</span> Customer(<span class="string">"b"</span>).store();</span><br><span class="line">        <span class="keyword">new</span> Customer(<span class="string">"c"</span>).store();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//工厂方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Customer <span class="title">getNamed</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (Customer) instances.get(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Change-Reference-to-Value（将引用对象改为值对象）"><a href="#Change-Reference-to-Value（将引用对象改为值对象）" class="headerlink" title="Change Reference to Value（将引用对象改为值对象）"></a>Change Reference to Value（将引用对象改为值对象）</h3><p>你有一个引用对象，很小且<strong>不可变</strong>，而且不易管理。<strong>将它变成一个值对象（类没有修改对象数据的函数）。</strong></p><h3 id="Replace-Array-with-Object（以对象取代数组）"><a href="#Replace-Array-with-Object（以对象取代数组）" class="headerlink" title="Replace Array with Object（以对象取代数组）"></a>Replace Array with Object（以对象取代数组）</h3><p>你有一个数组，其中的元素各自代表不同的东西。<strong>以对象替换数组，对于数组中的每个元素，以一个字段来表示。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String[] row = <span class="keyword">new</span> String[<span class="number">3</span>];</span><br><span class="line">row[<span class="number">0</span>] = <span class="string">"Liverpool"</span>;</span><br><span class="line">row[<span class="number">1</span>] = <span class="string">"15"</span>;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Performance p = <span class="keyword">new</span> Performance();</span><br><span class="line">p.setName(<span class="string">"Livepool"</span>);</span><br><span class="line">p.setWins(<span class="string">"15"</span>);</span><br></pre></td></tr></table></figure><h3 id="Duplicate-Observed-Data-（复制“被监视数据”）"><a href="#Duplicate-Observed-Data-（复制“被监视数据”）" class="headerlink" title="Duplicate Observed Data （复制“被监视数据”）"></a>Duplicate Observed Data （复制“被监视数据”）</h3><p>你有一些领域（Model）数据置身于 GUI 控件中，而领域函数需要访问这些函数。</p><p>将该数据复制到一个领域对象中。建立一个Observer 模式，用以同步领域对象和 GUI 对象内的重复数据。</p><h3 id="Change-Unidirectional-Association-to-Bidirectional（将单向关联改为双向关联）"><a href="#Change-Unidirectional-Association-to-Bidirectional（将单向关联改为双向关联）" class="headerlink" title="Change Unidirectional Association to Bidirectional（将单向关联改为双向关联）"></a>Change Unidirectional Association to Bidirectional（将单向关联改为双向关联）</h3><p>两个类都需要使用对方特性，但其间只有一条单向连接。<strong>添加一个反向指针，并使修改函数（指改变双方关系的函数）能够同时更新两条连接。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个用户可以有多个订单</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Order</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Customer customer;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setCustomer</span><span class="params">(Customer arg)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(customer != <span class="keyword">null</span>)</span><br><span class="line">            customer.friendOrders().remove(<span class="keyword">this</span>);</span><br><span class="line">        customer = arg;</span><br><span class="line">        <span class="keyword">if</span>(customer != <span class="keyword">null</span>)</span><br><span class="line">            customer.friendOrders().add(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Customer</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Set&lt;Order&gt; orders = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="function">Set&lt;Order&gt; <span class="title">friengOrders</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> orders;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Change-Bidirectional-Association-to-Unidirectional-（将双向关联改为单向关联）"><a href="#Change-Bidirectional-Association-to-Unidirectional-（将双向关联改为单向关联）" class="headerlink" title="Change Bidirectional Association to Unidirectional （将双向关联改为单向关联）"></a>Change Bidirectional Association to Unidirectional （将双向关联改为单向关联）</h3><p>两个类之间有双向关联，但其中一个类如今不再需要另一个类的特性。<strong>去除不必要的关联。</strong></p><p>双向关联很有用，但你也为必须为它付出代价，那就是维护双向连接、确保对象被正确创建和删除而增加的复杂度。大量双向连接也容易造成“僵尸对象”：某个对象本来已经死亡了，却仍然保留在系统中，因为对它的引用还没有完全清除。</p><h3 id="Replace-Magic-Number-with-Symbolic-Constant（以字面常量取代魔法数）"><a href="#Replace-Magic-Number-with-Symbolic-Constant（以字面常量取代魔法数）" class="headerlink" title="Replace Magic Number with Symbolic Constant（以字面常量取代魔法数）"></a>Replace Magic Number with Symbolic Constant（以字面常量取代魔法数）</h3><p>你有一个字面数值，带有特别意义。<strong>创建一个常量，根据其意义为它命名，并将上述的字面数值替换为这个常量。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">potentialEnergy</span><span class="params">(<span class="keyword">double</span> mass, <span class="keyword">double</span> height)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mass * <span class="number">9.81</span> * height;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">double</span> GRAVITATIONAL_CONSTANT = <span class="number">9.81</span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">potentialEnergy</span><span class="params">(<span class="keyword">double</span> mass, <span class="keyword">double</span> height)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mass * GRAVITATIONAL_CONSTANT * height;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Encapsulate-Field（封装字段）"><a href="#Encapsulate-Field（封装字段）" class="headerlink" title="Encapsulate Field（封装字段）"></a>Encapsulate Field（封装字段）</h3><p>你的类中存在一个 public 字段。<strong>将它声明为 private，并提供相应的访问函数。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String name;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Encapsulate-Collection（封装集合）"><a href="#Encapsulate-Collection（封装集合）" class="headerlink" title="Encapsulate Collection（封装集合）"></a>Encapsulate Collection（封装集合）</h3><p>有个函数返回一个集合。<strong>让这个函数返回该集合的一个只读副本，并在这个类中提供添加/移除集合元素的函数。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    List&lt;String&gt; skills = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    String[] getSkills()&#123;</span><br><span class="line">        <span class="keyword">return</span> (String[])skills.toArray(<span class="keyword">new</span> String[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setSkill</span><span class="params">(<span class="keyword">int</span> index, String newSkill)</span></span>&#123;</span><br><span class="line">        skill.set(index, newSkill);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Replace-Record-with-Data-Class（以数据类取代记录）"><a href="#Replace-Record-with-Data-Class（以数据类取代记录）" class="headerlink" title="Replace Record with Data Class（以数据类取代记录）"></a>Replace Record with Data Class（以数据类取代记录）</h3><p>你需要面对传统编程环境中的记录结构。为该记录创建一个 POJO。</p><h3 id="Replace-Type-Code-with-Class（以类取代类型码）"><a href="#Replace-Type-Code-with-Class（以类取代类型码）" class="headerlink" title="Replace Type Code with Class（以类取代类型码）"></a>Replace Type Code with Class（以类取代类型码）</h3><p>类之中有一个数值类型码，但它不影响类的行为。<strong>以一个新的类替换该数值类型码。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> O = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> A = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> B = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> AB = <span class="number">3</span>;</span><br><span class="line">    privaet <span class="keyword">int</span> bloodGroup;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> BloodGroup bloddGroup;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BloodGroup</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> BloodGroup O = <span class="keyword">new</span> BloodGroup(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> BloodGroup A = <span class="keyword">new</span> BloodGroup(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> BloodGroup B = <span class="keyword">new</span> BloodGroup(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> BloodGroup AB = <span class="keyword">new</span> BloodGroup(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> BloodGroup[] values = &#123;O,A,B,AB&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> code;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">BloodGroup</span><span class="params">(<span class="keyword">int</span> code)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.code = code;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Replace-Type-Code-with-Subclasses（以子类取代类型码）"><a href="#Replace-Type-Code-with-Subclasses（以子类取代类型码）" class="headerlink" title="Replace Type Code with Subclasses（以子类取代类型码）"></a>Replace Type Code with Subclasses（以子类取代类型码）</h3><p>你有一个不可变的类型码，它会影响类的行为。<strong>以子类取代这个类型码。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ENGINEER = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SALESMAN = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MANAGER = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> type;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Engineer</span> <span class="keyword">extends</span> <span class="title">Employee</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getType</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Employee.ENGINEER;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//其他两个不写了</span></span><br></pre></td></tr></table></figure><h3 id="Replace-Type-Code-with-State-Strategy-（以State-Strategy取代类型码）"><a href="#Replace-Type-Code-with-State-Strategy-（以State-Strategy取代类型码）" class="headerlink" title="Replace Type Code with State/Strategy （以State/Strategy取代类型码）"></a>Replace Type Code with State/Strategy （以State/Strategy取代类型码）</h3><p>你有一个类型码，它会影响类的行为，但你无法通过继承手法消除它。<strong>以状态对象取代类型码。</strong></p><p>继续使用上面的 Employee 例子。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">EmployeeType</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">getTypeCode</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">extends</span> <span class="title">EmployeeType</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getTypeCode</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Employee.ENGNIEER;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//剩余两个省略</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ENGINEER = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SALESMAN = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MANAGER = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">private</span> EmployeeType type;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getType</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> type.getTypeCode();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setType</span><span class="params">(<span class="keyword">int</span> arg)</span></span>&#123;</span><br><span class="line">        <span class="keyword">switch</span>(arg)&#123;</span><br><span class="line">            <span class="keyword">case</span> ENGNIEER:</span><br><span class="line">                type = <span class="keyword">new</span> Engineer();<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> SALESMAN:</span><br><span class="line">                type = <span class="keyword">new</span> Salesman();<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MANAGER:</span><br><span class="line">                type = <span class="keyword">new</span> Manager();<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Incorrect Employee Code"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Replace-Subclass-with-Field（以字段取代子类）"><a href="#Replace-Subclass-with-Field（以字段取代子类）" class="headerlink" title="Replace Subclass with Field（以字段取代子类）"></a>Replace Subclass with Field（以字段取代子类）</h3><p>你的各个子类的唯一差别只在“返回常量数据”的函数上。<strong>修改这些函数，使它们返回超类中的某个（新增）字段，然后销毁子类。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">char</span> <span class="title">getCode</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Male</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">getCode</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'M'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Female</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">getCode</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'F'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> code;</span><br><span class="line">    Person(<span class="keyword">char</span> code)&#123;</span><br><span class="line">        <span class="keyword">this</span>.code = code;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">static</span> Person <span class="title">createMale</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Person(<span class="string">'M'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">static</span> Person <span class="title">createFemale</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Person(<span class="string">'F'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="简化条件表达式"><a href="#简化条件表达式" class="headerlink" title="简化条件表达式"></a>简化条件表达式</h2><h3 id="Decompose-Conditional（分解条件表达式）"><a href="#Decompose-Conditional（分解条件表达式）" class="headerlink" title="Decompose Conditional（分解条件表达式）"></a>Decompose Conditional（分解条件表达式）</h3><p>你有一个复杂的条件（if - then - else）语句。<strong>从 if、then、else 三个段落中分别提炼处独立函数。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(date.before (SUMMER_START) || date.after(SUMMER_END))</span><br><span class="line">    charge = quantity * winterRate + winterServiceCharge;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    charge = quantity * summerRate;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(notSummer(date))</span><br><span class="line">    charge = winterCharge(quantity);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    charge = summerCharge(quantity);</span><br></pre></td></tr></table></figure><h3 id="Consolidate-Conditional-Expression（合并条件表达式）"><a href="#Consolidate-Conditional-Expression（合并条件表达式）" class="headerlink" title="Consolidate Conditional Expression（合并条件表达式）"></a>Consolidate Conditional Expression（合并条件表达式）</h3><p>你有一系列条件测试，都得到相同结果。<strong>将这些测试合并为一个条件表达式，并将这个条件表达式提炼为一个独立函数。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">disabilityAmount</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(seniority &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(monthsDisabled &gt; <span class="number">12</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(isPartTime) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// compute the disability amount</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">disabilityAmount</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(isNotEligibleForDisability()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// compute the disability amount</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isNotEligibleForDisability</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> seniority &lt; <span class="number">2</span> || monthsDisabled &gt; <span class="number">12</span> || isPartTime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Consolidate-Duplicate-Conditional-Fragments（合并重复的条件片段）"><a href="#Consolidate-Duplicate-Conditional-Fragments（合并重复的条件片段）" class="headerlink" title="Consolidate Duplicate Conditional Fragments（合并重复的条件片段）"></a>Consolidate Duplicate Conditional Fragments（合并重复的条件片段）</h3><p>在条件表达式的每个分支上有着相同的一段代码。<strong>将这段重复代码搬移到条件表达式之外。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(isSpecialDeal())&#123;</span><br><span class="line">    total = price * <span class="number">0.95</span>;</span><br><span class="line">    send();</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    total = price * <span class="number">0.98</span>;</span><br><span class="line">    send();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(isSpecialDeal())</span><br><span class="line">    total = price * <span class="number">0.95</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    total = price * <span class="number">0.98</span>;</span><br><span class="line">send();</span><br></pre></td></tr></table></figure><h3 id="Remove-Control-Flag（移除控制标记）"><a href="#Remove-Control-Flag（移除控制标记）" class="headerlink" title="Remove Control Flag（移除控制标记）"></a>Remove Control Flag（移除控制标记）</h3><p>在一系列布尔表达式中，某个变量带有“控制标记（control flag）的作用。<strong>以 break 语句或 return 语句取代控制标记。</strong></p><h3 id="Replace-Nested-Conditional-with-Guard-Classes（以卫语句取代嵌套条件表达式）"><a href="#Replace-Nested-Conditional-with-Guard-Classes（以卫语句取代嵌套条件表达式）" class="headerlink" title="Replace Nested Conditional with Guard Classes（以卫语句取代嵌套条件表达式）"></a>Replace Nested Conditional with Guard Classes（以卫语句取代嵌套条件表达式）</h3><p>函数中的条件逻辑使人难以看清正常的执行路径。<strong>使用卫语句（单独检查语句）</strong>表现所有特殊情况。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">getPayAmount</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> result;</span><br><span class="line">    <span class="keyword">if</span>(isDead) result = deadAmount();</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(isSeparated) result = separatedAmount();</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(isRetired) result = retiredAmount();</span><br><span class="line">            <span class="keyword">else</span> result = normalPayment();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">getPayAmount</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(isDead) <span class="keyword">return</span> deadAmount();</span><br><span class="line">    <span class="keyword">if</span>(isSeparated) <span class="keyword">return</span> separatedAmount();</span><br><span class="line">    <span class="keyword">if</span>(isRetired) <span class="keyword">return</span> retiredAmount();</span><br><span class="line">    <span class="keyword">return</span> normalAmount();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Replace-Conditional-with-Polymorphism（以多态取代条件表达式）"><a href="#Replace-Conditional-with-Polymorphism（以多态取代条件表达式）" class="headerlink" title="Replace Conditional with Polymorphism（以多态取代条件表达式）"></a>Replace Conditional with Polymorphism（以多态取代条件表达式）</h3><p>你手上有个条件表达式，它根据对象类型的不同而选择不同的行为。<strong>将这个条件表达式的每个分支放进一个子类的覆写函数中，然后将原始函数声明为抽象函数。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">getSpeed</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(type)&#123;</span><br><span class="line">        <span class="keyword">case</span> EUROPEAN : <span class="keyword">return</span> getBaseSpeed();</span><br><span class="line">        <span class="keyword">case</span> AFRICAN: <span class="keyword">return</span> getBaseSpeed() - getLoadFactor() * numberOfCoconuts;</span><br><span class="line">        <span class="keyword">case</span> NORWEGIAN_BLUE: <span class="keyword">return</span> isNailed ? <span class="number">0</span> : getBaseSpeed(voltage);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Bird</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">double</span> <span class="title">getSpeed</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">European</span> <span class="keyword">extends</span> <span class="title">Bird</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getSpeed</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getSpeed();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//剩下两个类省略</span></span><br></pre></td></tr></table></figure><h3 id="Introduce-Null-Object（引入-Null-对象）"><a href="#Introduce-Null-Object（引入-Null-对象）" class="headerlink" title="Introduce Null Object（引入 Null 对象）"></a>Introduce Null Object（引入 Null 对象）</h3><p>你需要再三检查某独享是否为 null。<strong>将 null 值替换为 null 对象。</strong></p><h3 id="Introduce-Assertion（引入断言）"><a href="#Introduce-Assertion（引入断言）" class="headerlink" title="Introduce Assertion（引入断言）"></a>Introduce Assertion（引入断言）</h3><p>某一段代码需要对程序状态做出某种假设。<strong>以断言明确表现这种假设。</strong></p><p>断言的失败应该导致一个非受控异常。程序最后的成品往往将断言统统删除。</p><h2 id="简化函数调用"><a href="#简化函数调用" class="headerlink" title="简化函数调用"></a>简化函数调用</h2><h3 id="Remove-Method（函数改名）"><a href="#Remove-Method（函数改名）" class="headerlink" title="Remove Method（函数改名）"></a>Remove Method（函数改名）</h3><p>函数的名称未能揭示函数的用途。<strong>修改函数名称。</strong></p><h3 id="Add-Parameter（添加参数）"><a href="#Add-Parameter（添加参数）" class="headerlink" title="Add Parameter（添加参数）"></a>Add Parameter（添加参数）</h3><p>某个函数需要从调用端得到更多信息。<strong>为此函数添加一个对象参数，让该对象带进函数所需信息。</strong></p><h3 id="Remove-Parameter（移除参数）"><a href="#Remove-Parameter（移除参数）" class="headerlink" title="Remove Parameter（移除参数）"></a>Remove Parameter（移除参数）</h3><p>函数本体不再需要某个参数。<strong>将该参数去除。</strong></p><h3 id="Separate-Query-from-Modifier（将查询函数和修改函数分离）"><a href="#Separate-Query-from-Modifier（将查询函数和修改函数分离）" class="headerlink" title="Separate Query from Modifier（将查询函数和修改函数分离）"></a>Separate Query from Modifier（将查询函数和修改函数分离）</h3><p>某个函数既返回对象状态值，又修改对象状态。<strong>建立两个不同的函数，其中一个负责查询，另一个负责修改。</strong></p><h3 id="Parameterize-Method（令函数携带参数）"><a href="#Parameterize-Method（令函数携带参数）" class="headerlink" title="Parameterize Method（令函数携带参数）"></a>Parameterize Method（令函数携带参数）</h3><p>若干函数做了类似的工作，但在函数本体中却包含了不同的值。<strong>建立单一函数，以参数表达那些不同的值。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fivePercentRaise</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">tenPercentRaise</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">raise</span><span class="params">(<span class="keyword">double</span> percentage)</span></span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Replace-Parameter-with-Explicit-Methods（以明确函数取代参数）"><a href="#Replace-Parameter-with-Explicit-Methods（以明确函数取代参数）" class="headerlink" title="Replace Parameter with Explicit Methods（以明确函数取代参数）"></a>Replace Parameter with Explicit Methods（以明确函数取代参数）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setValue</span><span class="params">(String name, <span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(name.equals(<span class="string">"height"</span>))&#123;</span><br><span class="line">        height = value;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(name.equals(<span class="string">"width"</span>))&#123;</span><br><span class="line">        width = value;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setHeight</span><span class="params">(<span class="keyword">int</span> arg)</span></span>&#123;</span><br><span class="line">    height = arg;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setWidth</span><span class="params">(<span class="keyword">int</span> arg)</span></span>&#123;</span><br><span class="line">    width = arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Preserve-Whole-Object（保持对象完整）"><a href="#Preserve-Whole-Object（保持对象完整）" class="headerlink" title="Preserve Whole Object（保持对象完整）"></a>Preserve Whole Object（保持对象完整）</h3><p>你从某个对象中取出若干值，将它们作为某一次函数调用时的参数。<strong>改为传递整个对象。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> low = daysTempRange().getLow();</span><br><span class="line"><span class="keyword">int</span> high = daysTemoRange().getHigh();</span><br><span class="line">withinPlan = plan.withinRange(low, high);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">withinPlan = plan,withinRange(daysTempRange());</span><br></pre></td></tr></table></figure><h3 id="Replace-Parameter-with-Methods（以函数取代函数）"><a href="#Replace-Parameter-with-Methods（以函数取代函数）" class="headerlink" title="Replace Parameter with Methods（以函数取代函数）"></a>Replace Parameter with Methods（以函数取代函数）</h3><p>对象调用某个函数，并将所得结果作为参数，传递给另一个函数。而接受该参数的函数本身也能调用前一个函数。<strong>让参数接受者去除该项参数，并直接调用前一个函数。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> basePrice = quantity * itemPrice;</span><br><span class="line">discountLevel = getDiscountLevel();</span><br><span class="line"><span class="keyword">double</span> finalPrice = discountedPrice(basePrice, discountLevel);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> basePrice = quantity * itemPrice;</span><br><span class="line"><span class="keyword">double</span> finalPrice = discountedPrice(basePrice);</span><br><span class="line"><span class="comment">// 让 discountedPrice 直接调用 getDiscountLevel 函数</span></span><br></pre></td></tr></table></figure><h3 id="Introduce-Parameter-Object（引入参数对象）"><a href="#Introduce-Parameter-Object（引入参数对象）" class="headerlink" title="Introduce Parameter Object（引入参数对象）"></a>Introduce Parameter Object（引入参数对象）</h3><p>某些参数总是很自然地同时出现。<strong>以一个对象取代这些参数。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Customer</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">amountInvoicedIn</span><span class="params">(Date start, Date end)</span></span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Customer</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">amountInvoicedIn</span><span class="params">(DateRange dateRange)</span></span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Remove-Setting-Method（移除设值函数）"><a href="#Remove-Setting-Method（移除设值函数）" class="headerlink" title="Remove Setting Method（移除设值函数）"></a>Remove Setting Method（移除设值函数）</h3><p>类中的某个字段应该在对象创建时被设值，然后就不再改变。<strong>去掉该字段的所有设值函数。</strong></p><h3 id="Hide-Method（隐藏函数）"><a href="#Hide-Method（隐藏函数）" class="headerlink" title="Hide Method（隐藏函数）"></a>Hide Method（隐藏函数）</h3><p>有一个函数，从来没有被其他任何类用到。<strong>将这个函数修改为 private。</strong></p><h3 id="Replace-Constructor-with-Factory-Method（以工厂函数取代构造函数）"><a href="#Replace-Constructor-with-Factory-Method（以工厂函数取代构造函数）" class="headerlink" title="Replace Constructor with Factory Method（以工厂函数取代构造函数）"></a>Replace Constructor with Factory Method（以工厂函数取代构造函数）</h3><p>你希望在创建对象时不仅仅是做简单的建构动作。<strong>将构造函数替换为工厂函数。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Employee(<span class="keyword">int</span> type)&#123;</span><br><span class="line">    <span class="keyword">this</span>.type = type;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> Employee <span class="title">create</span><span class="params">(<span class="keyword">int</span> type)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Employee(type);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Encapsulate-Downcast（封装向下转型）"><a href="#Encapsulate-Downcast（封装向下转型）" class="headerlink" title="Encapsulate Downcast（封装向下转型）"></a>Encapsulate Downcast（封装向下转型）</h3><p>某个函数返回的对象，需要函数调用者执行向下转型（downcast）。<strong>将向下转型动作移到函数中。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Object <span class="title">lastReading</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> readings.lastElement();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Reading <span class="title">lastReading</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (Reading)readings.lastElement();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Replace-Error-Code-with-Exception（以异常取代错误码）"><a href="#Replace-Error-Code-with-Exception（以异常取代错误码）" class="headerlink" title="Replace Error Code with Exception（以异常取代错误码）"></a>Replace Error Code with Exception（以异常取代错误码）</h3><p>某个函数返回一个特定的代码，用以表示某种特殊情况。<strong>改用异常。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">withdraw</span><span class="params">(<span class="keyword">int</span> amount)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(amount &gt; balance)&#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        balance -= amount;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">withdraw</span><span class="params">(<span class="keyword">int</span> amount)</span> <span class="keyword">throws</span> BalaceException</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(amount &gt; balance) <span class="keyword">throw</span> <span class="keyword">new</span> BalanceException();</span><br><span class="line">    balance -= amount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Replace-Exception-with-Test（以测试取代异常）"><a href="#Replace-Exception-with-Test（以测试取代异常）" class="headerlink" title="Replace Exception with Test（以测试取代异常）"></a>Replace Exception with Test（以测试取代异常）</h3><p>面对一个调用着可以预先检查的条件，你抛出了一个异常。<strong>修改调用者，使它在调用函数之气那先做检查。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">getValueForPeriod</span><span class="params">(<span class="keyword">int</span> periodNumber)</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value[periodNumber];</span><br><span class="line">    &#125; <span class="keyword">catch</span>(ArrayIndexOutOfBoundsException e)&#123; <span class="comment">// 滥用异常</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">getValueForPeriod</span><span class="params">(<span class="keyword">int</span> periodNumber)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(periodNumber &gt;= values.length) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> values[periodNumber];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="处理概括关系（继承关系）"><a href="#处理概括关系（继承关系）" class="headerlink" title="处理概括关系（继承关系）"></a>处理概括关系（继承关系）</h2><h3 id="Pull-Up-Field（字段上移）"><a href="#Pull-Up-Field（字段上移）" class="headerlink" title="Pull Up Field（字段上移）"></a>Pull Up Field（字段上移）</h3><p>两个子类拥有相同的字段。<strong>将该字段移至超类。</strong></p><h3 id="Pull-Up-Method（函数上移）"><a href="#Pull-Up-Method（函数上移）" class="headerlink" title="Pull Up Method（函数上移）"></a>Pull Up Method（函数上移）</h3><p>有些函数，在各个子类中产生完全相同的结果。<strong>将该函数移至超类。</strong></p><h3 id="Pull-Up-Constructor-Body（构造函数本体上移）"><a href="#Pull-Up-Constructor-Body（构造函数本体上移）" class="headerlink" title="Pull Up Constructor Body（构造函数本体上移）"></a>Pull Up Constructor Body（构造函数本体上移）</h3><p>你在各个子类中拥有一些构造函数，它们的本体几乎完全一致。<strong>在超类中新建一个构造函数，并在子类构造函数中调用它。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Manager</span> <span class="keyword">extends</span> <span class="title">Employee</span></span>&#123;</span><br><span class="line">    Manager(String name, String id, <span class="keyword">int</span> grade)&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.grade = grade;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Manager</span> <span class="keyword">extends</span> <span class="title">Employee</span></span>&#123;</span><br><span class="line">    Manager(String name, String id, <span class="keyword">int</span> grade)&#123;</span><br><span class="line">        <span class="keyword">super</span>(name, id);</span><br><span class="line">        <span class="keyword">this</span>.grade = grade;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Push-Down-Method（函数下移）"><a href="#Push-Down-Method（函数下移）" class="headerlink" title="Push Down Method（函数下移）"></a>Push Down Method（函数下移）</h3><p>超类中的某个函数只与部分（而非全部）子类有关。<strong>将这个函数移到相关的那些子类去。</strong></p><h3 id="Push-Down-Field（字段下移）"><a href="#Push-Down-Field（字段下移）" class="headerlink" title="Push Down Field（字段下移）"></a>Push Down Field（字段下移）</h3><p>超类中的某些字段只被部分（而非全部）子类用到。<strong>将这个字段移到需要它的那些子类去。</strong></p><h3 id="Extract-Subclass（提炼子类）"><a href="#Extract-Subclass（提炼子类）" class="headerlink" title="Extract Subclass（提炼子类）"></a>Extract Subclass（提炼子类）</h3><p>类中的某些特性只被某些（而非全部）实例用到。<strong>新建一个子类，将上面所说的那一部分特性移到子类中。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JobItem</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getTotalPrice</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">unitPrice</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">    <span class="function">Employee <span class="title">getEmployee</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JobItem</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getTotalPrice</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">unitPrice</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LaborItem</span> <span class="keyword">extends</span> <span class="title">JobItem</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">unitPrice</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">    <span class="function">Employee <span class="title">getEmployee</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Extract-Superclass（提炼超类）"><a href="#Extract-Superclass（提炼超类）" class="headerlink" title="Extract Superclass（提炼超类）"></a>Extract Superclass（提炼超类）</h3><p>两个类有相似特性。<strong>为这两个类建立一个超类，将相同特性移至超类。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Department</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getTotalAnnualCost</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">    <span class="function">String <span class="title">getName</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getHeadCount</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getAnnualCost</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">    <span class="function">String <span class="title">getName</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">getId</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Party</span></span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">double</span> <span class="title">getAnnualCost</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> String <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">extends</span> <span class="title">Party</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getAnnualCost</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">getId</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Department</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getAnnualCost</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getHeadCount</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Extract-Interface（提炼接口）"><a href="#Extract-Interface（提炼接口）" class="headerlink" title="Extract Interface（提炼接口）"></a>Extract Interface（提炼接口）</h3><p>若干客户使用类接口中的同一子集，或者两个类的接口有部分相同。<strong>将相同的子集提炼到独立接口中。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span></span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">getRate</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">    <span class="function">String <span class="title">hasSpecialSkill</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">    <span class="function">String <span class="title">getName</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">    String getDepartment&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Billable</span></span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">getRate</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">hasSpecialSkill</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">Billable</span></span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">getRate</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">    <span class="function">String <span class="title">hasSpecialSkill</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">    <span class="function">String <span class="title">getName</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">    String getDepartment&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Collapse-Hierarchy（折叠继承体系）"><a href="#Collapse-Hierarchy（折叠继承体系）" class="headerlink" title="Collapse Hierarchy（折叠继承体系）"></a>Collapse Hierarchy（折叠继承体系）</h3><p>超类与子类之间无太大区别。<strong>将它们合为一体。</strong></p><h3 id="Form-Template-Method（塑造模板函数）"><a href="#Form-Template-Method（塑造模板函数）" class="headerlink" title="Form Template Method（塑造模板函数）"></a>Form Template Method（塑造模板函数）</h3><p>你有一些子类，其中相应的某些函数以相同顺序执行类似的操作，但各个操作的细节上有所不同。</p><p><strong>将这些操作分别放金独立函数中，并保持它们都有相同的签名，于是原函数也就变得相同了。然后将原函数上移至超类。</strong></p><h3 id="Replace-Inheritance-with-Delegation（以委托取代继承）"><a href="#Replace-Inheritance-with-Delegation（以委托取代继承）" class="headerlink" title="Replace Inheritance with Delegation（以委托取代继承）"></a>Replace Inheritance with Delegation（以委托取代继承）</h3><p>某个子类只使用超类接口中的一部分，或是根本不需要继承而来得数据。<strong>在子类中新建一个字段用以保存超类；调整子类函数，令它改而委托超类；然后去掉两者之间的继承关系。</strong></p><h3 id="Replace-Delegation-with-Inheritance（以继承取代委托）"><a href="#Replace-Delegation-with-Inheritance（以继承取代委托）" class="headerlink" title="Replace Delegation with Inheritance（以继承取代委托）"></a>Replace Delegation with Inheritance（以继承取代委托）</h3><p>你在两个类之间使用委托关系，并经常为整个接口编写许多极简单的委托函数。<strong>让委托类继承受托类。</strong></p><h2 id="大型重构"><a href="#大型重构" class="headerlink" title="大型重构"></a>大型重构</h2><h3 id="Tease-Apart-Inheritance（梳理并分解继承体系）"><a href="#Tease-Apart-Inheritance（梳理并分解继承体系）" class="headerlink" title="Tease Apart Inheritance（梳理并分解继承体系）"></a>Tease Apart Inheritance（梳理并分解继承体系）</h3><p>某个继承体系同时承担两项责任。<strong>建立两个继承体系，并通过委托关系让其中一个可以调用另一个。</strong></p><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20201016150252385.png" alt="image-20201016150252385"></p><h3 id="Convert-Procedural-Design-to-Objects（将过程化设计转换为对象设计）"><a href="#Convert-Procedural-Design-to-Objects（将过程化设计转换为对象设计）" class="headerlink" title="Convert Procedural Design to Objects（将过程化设计转换为对象设计）"></a>Convert Procedural Design to Objects（将过程化设计转换为对象设计）</h3><p>你手上有一些传统过程化风格的代码。<strong>将数据记录变成对象，将大块的行为分成小块，并将行为移入相关对象中。</strong></p><h3 id="Separate-Domain-from-Presentation（将领域和表述-显示分离）"><a href="#Separate-Domain-from-Presentation（将领域和表述-显示分离）" class="headerlink" title="Separate Domain from Presentation（将领域和表述/显示分离）"></a>Separate Domain from Presentation（将领域和表述/显示分离）</h3><p>某些 GUI 类中包含了领域逻辑。<strong>将领域逻辑分离出来，为它们建立独立的领域类。</strong></p><p>MVC 模式最核心的价值在于：它将用户界面代码（即视图；也是“展示层”）和领域逻辑（即模型）分离了。展现类只含用以处理用户界面的逻辑；领域类不含任何与程序外观的代码，只含业务逻辑相关代码。</p><h3 id="Extract-Hierarchy（提炼继承体系）"><a href="#Extract-Hierarchy（提炼继承体系）" class="headerlink" title="Extract Hierarchy（提炼继承体系）"></a>Extract Hierarchy（提炼继承体系）</h3><p>你有某个类做了太多工作，其中一部分工作是以大量条件表达式完成的。<strong>建立继承体系，以一个子类表示一种特殊情况。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;代码的坏味道&quot;&gt;&lt;a href=&quot;#代码的坏味道&quot; class=&quot;headerlink&quot; title=&quot;代码的坏味道&quot;&gt;&lt;/a&gt;代码的坏味道&lt;/h2&gt;&lt;h3 id=&quot;Duplicated-Code（重复代码）&quot;&gt;&lt;a href=&quot;#Duplicated-Code（重复代码）&quot; class=&quot;headerlink&quot; title=&quot;Duplicated Code（重复代码）&quot;&gt;&lt;/a&gt;Duplicated Code（重复代码）&lt;/h3&gt;&lt;p&gt;如果你在一个以上的地方看见相同的程序结构，将它们合二为一。&lt;/p&gt;
&lt;h3 id=&quot;Long-Method（过长函数）&quot;&gt;&lt;a href=&quot;#Long-Method（过长函数）&quot; class=&quot;headerlink&quot; title=&quot;Long Method（过长函数）&quot;&gt;&lt;/a&gt;Long Method（过长函数）&lt;/h3&gt;&lt;p&gt;将过长的函数分解为若干个小函数。&lt;/p&gt;
    
    </summary>
    
    
      <category term="笔记" scheme="https://hoo334.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>丑数II</title>
    <link href="https://hoo334.github.io/2021/04/11/%E4%B8%91%E6%95%B0II/"/>
    <id>https://hoo334.github.io/2021/04/11/%E4%B8%91%E6%95%B0II/</id>
    <published>2021-04-11T02:37:25.000Z</published>
    <updated>2021-04-11T02:58:56.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="264-丑数-II"><a href="#264-丑数-II" class="headerlink" title="264. 丑数 II"></a><a href="https://leetcode-cn.com/problems/ugly-number-ii/" target="_blank" rel="noopener">264. 丑数 II</a></h4><p>给你一个整数 <code>n</code> ，请你找出并返回第 <code>n</code> 个 <strong>丑数</strong> 。</p><p><strong>丑数</strong> 就是只包含质因数 <code>2</code>、<code>3</code> 和/或 <code>5</code> 的正整数。</p> <a id="more"></a><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n &#x3D; 10</span><br><span class="line">输出：12</span><br><span class="line">解释：[1, 2, 3, 4, 5, 6, 8, 9, 10, 12] 是由前 10 个丑数组成的序列。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n &#x3D; 1</span><br><span class="line">输出：1</span><br><span class="line">解释：1 通常被视为丑数。</span><br></pre></td></tr></table></figure><p> <strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 1690</code></li></ul><p><strong>方法一：最小堆</strong></p><p>初始时堆为空，首先将最小的丑数 1 加入堆，每次取出堆顶元素 x，则 x 是堆中最小的丑数，2x，3x，5x也是丑数，因此将 2x，3x，5x，加入堆中，但这会导致出现重复元素，为了避免出现重复元素，我们使用哈希表去重。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nthUglyNumber</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] factors = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        Set&lt;Long&gt; seen = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        PriorityQueue&lt;Long&gt; heap = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line">        seen.add(<span class="number">1L</span>);</span><br><span class="line">        heap.offer(<span class="number">1L</span>);</span><br><span class="line">        <span class="keyword">int</span> ugly = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">long</span> curr = heap.poll();</span><br><span class="line">            ugly = (<span class="keyword">int</span>) curr;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> factor : factors)&#123;</span><br><span class="line">                <span class="keyword">long</span> next = curr * factor;</span><br><span class="line">                <span class="keyword">if</span>(seen.add(next))&#123; </span><br><span class="line">                    heap.offer(next);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ugly;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度O(nlogn)</li><li>空间复杂度O(n)</li></ul><p><strong>方法二：动态规划</strong></p><p>在方法一中，我们存储了较多的丑数，导致空间复杂度较高。我们可以使用三个指针来指向最小的三个丑数。</p><p>定义数组 dp，dp[i] 表示第 i 个丑数，第 n 个丑数为 dp[n]，dp[1] = 1。</p><p>定义三个指针 p2，p3，p5，下一个丑数是当前指针指向的凑数乘以对应的质因数。下一个丑数分别为，2 * p2, 3 * p3, 5 * p5，我们取这三个数的最小值，然后将使用过的指针加一。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nthUglyNumber</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> p2 = <span class="number">1</span>, p3 = <span class="number">1</span>, p5 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> num2 = dp[p2] * <span class="number">2</span>, num3 = dp[p3] * <span class="number">3</span>, num5 = dp[p5] * <span class="number">5</span>;</span><br><span class="line">            <span class="comment">//取三个数中的最小值</span></span><br><span class="line">            dp[i] = Math.min(Math.min(num2, num3), num5);</span><br><span class="line">            <span class="comment">//将使用过的指针加一</span></span><br><span class="line">            <span class="keyword">if</span>(dp[i] == num2)&#123;</span><br><span class="line">                ++p2;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(dp[i] == num3)&#123;</span><br><span class="line">                ++p3;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(dp[i] == num5)&#123;</span><br><span class="line">                ++p5;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度O(n)</li><li>空间复杂度O(n)</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;264-丑数-II&quot;&gt;&lt;a href=&quot;#264-丑数-II&quot; class=&quot;headerlink&quot; title=&quot;264. 丑数 II&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/ugly-number-ii/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;264. 丑数 II&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;给你一个整数 &lt;code&gt;n&lt;/code&gt; ，请你找出并返回第 &lt;code&gt;n&lt;/code&gt; 个 &lt;strong&gt;丑数&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;丑数&lt;/strong&gt; 就是只包含质因数 &lt;code&gt;2&lt;/code&gt;、&lt;code&gt;3&lt;/code&gt; 和/或 &lt;code&gt;5&lt;/code&gt; 的正整数。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode Medium" scheme="https://hoo334.github.io/tags/Leetcode-Medium/"/>
    
      <category term="动态规划" scheme="https://hoo334.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>搜索旋转排序数组II</title>
    <link href="https://hoo334.github.io/2021/04/07/%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84II/"/>
    <id>https://hoo334.github.io/2021/04/07/%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84II/</id>
    <published>2021-04-07T01:29:14.000Z</published>
    <updated>2021-04-09T02:11:20.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="81-搜索旋转排序数组-II"><a href="#81-搜索旋转排序数组-II" class="headerlink" title="81. 搜索旋转排序数组 II"></a><a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array-ii/" target="_blank" rel="noopener">81. 搜索旋转排序数组 II</a></h4><p>已知存在一个按非降序排列的整数数组 <code>nums</code> ，数组中的值不必互不相同。</p><p>在传递给函数之前，<code>nums</code> 在预先未知的某个下标 <code>k</code>（<code>0 &lt;= k &lt; nums.length</code>）上进行了 <strong>旋转</strong> ，使数组变为 <code>[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]</code>（下标 <strong>从 0 开始</strong> 计数）。例如， <code>[0,1,2,4,4,4,5,6,6,7]</code> 在下标 <code>5</code> 处经旋转后可能变为 <code>[4,5,6,6,7,0,1,2,4,4]</code> 。</p><p>给你 <strong>旋转后</strong> 的数组 <code>nums</code> 和一个整数 <code>target</code> ，请你编写一个函数来判断给定的目标值是否存在于数组中。如果 <code>nums</code> 中存在这个目标值 <code>target</code> ，则返回 <code>true</code> ，否则返回 <code>false</code> 。</p> <a id="more"></a><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [2,5,6,0,0,1,2], target &#x3D; 0</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [2,5,6,0,0,1,2], target &#x3D; 3</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p> <strong>提示：</strong></p><ul><li><p><code>1 &lt;= nums.length &lt;= 5000</code></p></li><li><p><code>-104 &lt;= nums[i] &lt;= 104</code></p></li><li><p>题目数据保证 <code>nums</code> 在预先未知的某个下标上进行了旋转</p></li><li><p><code>-104 &lt;= target &lt;= 104</code></p><p><strong>进阶：</strong></p></li><li><p>这是 <a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/description/" target="_blank" rel="noopener">搜索旋转排序数组</a> 的延伸题目，本题中的 <code>nums</code> 可能包含重复元素。</p></li><li><p>这会影响到程序的时间复杂度吗？会有怎样的影响，为什么？</p></li></ul><p><strong>方法一：二分查找</strong></p><p>可以先查看题解<a href="https://hoo334.github.io/2020/04/27/%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/">搜索旋转排序数组</a>，对于数组中有重复元素的情况，二分查找可能会有<code>nums[l] = nums[mid] = nums[r]</code>,此时我们无法判断区间<code>[l, mid]</code>和 <code>[mid + 1, r]</code>哪个是有序的。</p><p>例如 <code>nums =[3,1,2,3,3,3,3]</code> ,target = 2，首次二分时，无法判断区间<code>[0,3]</code>和<code>[4,6]</code></p><p>哪个是有序的。对于这种情况，我们智能将当前二分区间左边界加一，右边界减一，然后在新区间上继续二分查找。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>] == target;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//当三个数都相等时，左边界加一，右边界减一</span></span><br><span class="line">            <span class="keyword">if</span> (nums[l] == nums[mid] &amp;&amp; nums[mid] == nums[r]) &#123;</span><br><span class="line">                ++l;</span><br><span class="line">                --r;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[l] &lt;= nums[mid]) &#123;<span class="comment">//左边界有序</span></span><br><span class="line">                <span class="keyword">if</span> (nums[l] &lt;= target &amp;&amp; target &lt; nums[mid]) &#123;<span class="comment">//mid 在有序部分</span></span><br><span class="line">                    r = mid - <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;<span class="comment">//mid 不在有序部分</span></span><br><span class="line">                    l = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">//右边界有序</span></span><br><span class="line">                <span class="keyword">if</span> (nums[mid] &lt; target &amp;&amp; target &lt;= nums[r]) &#123;</span><br><span class="line">                    l = mid + <span class="number">1</span>;  <span class="comment">//mid 在有序部分</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;  <span class="comment">//mid 不在有序部分</span></span><br><span class="line">                    r = mid - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度O(logN)</li><li>空间复杂度O(1)</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;81-搜索旋转排序数组-II&quot;&gt;&lt;a href=&quot;#81-搜索旋转排序数组-II&quot; class=&quot;headerlink&quot; title=&quot;81. 搜索旋转排序数组 II&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/search-in-rotated-sorted-array-ii/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;81. 搜索旋转排序数组 II&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;已知存在一个按非降序排列的整数数组 &lt;code&gt;nums&lt;/code&gt; ，数组中的值不必互不相同。&lt;/p&gt;
&lt;p&gt;在传递给函数之前，&lt;code&gt;nums&lt;/code&gt; 在预先未知的某个下标 &lt;code&gt;k&lt;/code&gt;（&lt;code&gt;0 &amp;lt;= k &amp;lt; nums.length&lt;/code&gt;）上进行了 &lt;strong&gt;旋转&lt;/strong&gt; ，使数组变为 &lt;code&gt;[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]&lt;/code&gt;（下标 &lt;strong&gt;从 0 开始&lt;/strong&gt; 计数）。例如， &lt;code&gt;[0,1,2,4,4,4,5,6,6,7]&lt;/code&gt; 在下标 &lt;code&gt;5&lt;/code&gt; 处经旋转后可能变为 &lt;code&gt;[4,5,6,6,7,0,1,2,4,4]&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;给你 &lt;strong&gt;旋转后&lt;/strong&gt; 的数组 &lt;code&gt;nums&lt;/code&gt; 和一个整数 &lt;code&gt;target&lt;/code&gt; ，请你编写一个函数来判断给定的目标值是否存在于数组中。如果 &lt;code&gt;nums&lt;/code&gt; 中存在这个目标值 &lt;code&gt;target&lt;/code&gt; ，则返回 &lt;code&gt;true&lt;/code&gt; ，否则返回 &lt;code&gt;false&lt;/code&gt; 。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode Medium" scheme="https://hoo334.github.io/tags/Leetcode-Medium/"/>
    
      <category term="二分查找" scheme="https://hoo334.github.io/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>森林中的兔子</title>
    <link href="https://hoo334.github.io/2021/04/04/%E6%A3%AE%E6%9E%97%E4%B8%AD%E7%9A%84%E5%85%94%E5%AD%90/"/>
    <id>https://hoo334.github.io/2021/04/04/%E6%A3%AE%E6%9E%97%E4%B8%AD%E7%9A%84%E5%85%94%E5%AD%90/</id>
    <published>2021-04-04T01:57:00.000Z</published>
    <updated>2021-04-04T02:11:22.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="781-森林中的兔子"><a href="#781-森林中的兔子" class="headerlink" title="781. 森林中的兔子"></a><a href="https://leetcode-cn.com/problems/rabbits-in-forest/" target="_blank" rel="noopener">781. 森林中的兔子</a></h4><p>森林中，每个兔子都有颜色。其中一些兔子（可能是全部）告诉你还有多少其他的兔子和自己有相同的颜色。我们将这些回答放在 <code>answers</code> 数组里。</p><p>返回森林中兔子的最少数量。</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">示例:</span><br><span class="line">输入: answers &#x3D; [1, 1, 2]</span><br><span class="line">输出: 5</span><br><span class="line">解释:</span><br><span class="line">两只回答了 &quot;1&quot; 的兔子可能有相同的颜色，设为红色。</span><br><span class="line">之后回答了 &quot;2&quot; 的兔子不会是红色，否则他们的回答会相互矛盾。</span><br><span class="line">设回答了 &quot;2&quot; 的兔子为蓝色。</span><br><span class="line">此外，森林中还应有另外 2 只蓝色兔子的回答没有包含在数组中。</span><br><span class="line">因此森林中兔子的最少数量是 5: 3 只回答的和 2 只没有回答的。</span><br><span class="line"></span><br><span class="line">输入: answers &#x3D; [10, 10, 10]</span><br><span class="line">输出: 11</span><br><span class="line"></span><br><span class="line">输入: answers &#x3D; []</span><br><span class="line">输出: 0</span><br></pre></td></tr></table></figure><p><strong>说明:</strong></p><ol><li><code>answers</code> 的长度最大为<code>1000</code>。</li><li><code>answers[i]</code> 是在 <code>[0, 999]</code> 范围内的整数。</li></ol><p><strong>方法一：贪心</strong></p><p>两只相同颜色的兔子看到的其他同色兔子数必然是相同的。反之，若两只兔子看到的其他同色兔子数不同，那么这两只兔子颜色也不同。</p><p>因此，将 answer 中值相同的元素分为一组，对于每一组，计算出兔子的最少数量，然后将所有组的计算结果累加，就是最终的答案。</p><p>例如，现在有 13 只兔子回答 5，可以肯定至少有 3 种颜色的兔子。假设一只蓝色兔子回答 5 ，那么还有 5 只蓝色兔子；假设还有一只红色兔子回答 5 ，那么还有 5 只红色兔子；为了最小化可能的兔子数量，我们假设这 12 只兔子都在这 13 只兔子中。还剩下 1 只其他颜色兔子回答 5 ，那么其他颜色的兔子也为 5 只。最少会有 18 只兔子。</p><p>一般如果有 x 只兔子回答 y，则至少有 ceil(x / (y  + 1))种不同的颜色，且每种颜色有 y  + 1 只兔子，因此兔子数至少为<br>$$<br>\lceil \frac{x}{y + 1}\rceil * (y + 1)<br>$$</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numRabbits</span><span class="params">(<span class="keyword">int</span>[] answers)</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; count = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> y : answers)&#123;</span><br><span class="line">            count.put(y, count.getOrDefault(y, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;Integer, Integer&gt; entry : count.entrySet())&#123;</span><br><span class="line">            <span class="keyword">int</span> y = entry.getKey(), x = entry.getValue();</span><br><span class="line">            ans += (x + y) / (y + <span class="number">1</span>) * (y + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度O(n)</li><li>空间复杂度O(n)</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;781-森林中的兔子&quot;&gt;&lt;a href=&quot;#781-森林中的兔子&quot; class=&quot;headerlink&quot; title=&quot;781. 森林中的兔子&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/rabbits-in-forest/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;781. 森林中的兔子&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;森林中，每个兔子都有颜色。其中一些兔子（可能是全部）告诉你还有多少其他的兔子和自己有相同的颜色。我们将这些回答放在 &lt;code&gt;answers&lt;/code&gt; 数组里。&lt;/p&gt;
&lt;p&gt;返回森林中兔子的最少数量。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://hoo334.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode Medium" scheme="https://hoo334.github.io/tags/Leetcode-Medium/"/>
    
      <category term="贪心" scheme="https://hoo334.github.io/tags/%E8%B4%AA%E5%BF%83/"/>
    
  </entry>
  
</feed>
