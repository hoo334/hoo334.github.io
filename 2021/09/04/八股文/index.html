<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"hoo334.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="Java八股文集合">
<meta property="og:type" content="article">
<meta property="og:title" content="Java 八股文">
<meta property="og:url" content="https://hoo334.github.io/2021/09/04/%E5%85%AB%E8%82%A1%E6%96%87/index.html">
<meta property="og:site_name" content="echo">
<meta property="og:description" content="Java八股文集合">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://gitee.com/hoo334/picgo/raw/master//img/image-20210804200000105.png">
<meta property="og:image" content="https://gitee.com/hoo334/picgo/raw/master//img/image-20210804205811181.png">
<meta property="og:image" content="https://gitee.com/hoo334/picgo/raw/master//img/image-20210804211851235.png">
<meta property="og:image" content="https://gitee.com/hoo334/picgo/raw/master//img/image-20210815200456496.png">
<meta property="og:image" content="https://gitee.com/hoo334/picgo/raw/master//img/image-20210815203343090.png">
<meta property="og:image" content="https://gitee.com/hoo334/picgo/raw/master//img/6a9e704af49b4380bb686f0c96d33b81~tplv-k3u1fbpfcp-watermark.image">
<meta property="og:image" content="https://gitee.com/hoo334/picgo/raw/master//img/bb174e22dbe04bb79fe3fc126aed0c61~tplv-k3u1fbpfcp-watermark.image">
<meta property="og:image" content="https://gitee.com/hoo334/picgo/raw/master//img/88ff862764024c3b8567367df11df6ab~tplv-k3u1fbpfcp-watermark.image">
<meta property="og:image" content="https://gitee.com/hoo334/picgo/raw/master//img/3077e72a1af049559e81d18205b56fd7~tplv-k3u1fbpfcp-watermark.image">
<meta property="og:image" content="https://gitee.com/hoo334/picgo/raw/master//img/33b193457c928ae02217480f994814b6.png">
<meta property="og:image" content="https://gitee.com/hoo334/picgo/raw/master//img/java-collection-hierarchy.png">
<meta property="og:image" content="https://gitee.com/hoo334/picgo/raw/master//img/image-20210827192442845.png">
<meta property="og:image" content="https://gitee.com/hoo334/picgo/raw/master//img/image-20210830155558454.png">
<meta property="og:image" content="https://gitee.com/hoo334/picgo/raw/master//img/image-20210902152656544.png">
<meta property="og:image" content="https://gitee.com/hoo334/picgo/raw/master//img/image-20210902155135199.png">
<meta property="og:image" content="https://gitee.com/hoo334/picgo/raw/master//img/image-20210831141012291.png">
<meta property="og:image" content="https://gitee.com/hoo334/picgo/raw/master//img/image-20210831162636969.png">
<meta property="og:image" content="https://gitee.com/hoo334/picgo/raw/master//img/image-20210902203746074.png">
<meta property="og:image" content="https://gitee.com/hoo334/picgo/raw/master//img/image-20210904194159096.png">
<meta property="og:image" content="https://gitee.com/hoo334/picgo/raw/master//img/image-20210831164907239.png">
<meta property="og:image" content="https://gitee.com/hoo334/picgo/raw/master//img/image-20210830203732695.png">
<meta property="og:image" content="https://gitee.com/hoo334/picgo/raw/master//img/image-20210830211740198.png">
<meta property="article:published_time" content="2021-09-04T11:54:17.277Z">
<meta property="article:modified_time" content="2021-09-04T11:53:59.327Z">
<meta property="article:author" content="hoo334">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gitee.com/hoo334/picgo/raw/master//img/image-20210804200000105.png">

<link rel="canonical" href="https://hoo334.github.io/2021/09/04/%E5%85%AB%E8%82%A1%E6%96%87/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>Java 八股文 | echo</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="echo" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">echo</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">任生命穿梭 时间的角落 </p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://hoo334.github.io/2021/09/04/%E5%85%AB%E8%82%A1%E6%96%87/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar2.jpg">
      <meta itemprop="name" content="hoo334">
      <meta itemprop="description" content="弃坑C++，转Java！">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="echo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Java 八股文
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2021-09-04 19:54:17 / Modified: 19:53:59" itemprop="dateCreated datePublished" datetime="2021-09-04T19:54:17+08:00">2021-09-04</time>
            </span>

          
            <span class="post-meta-item" title="Views" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2021/09/04/%E5%85%AB%E8%82%A1%E6%96%87/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/09/04/%E5%85%AB%E8%82%A1%E6%96%87/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h1><p>八股文集合</p>
<a id="more"></a>

<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="Java-语言特点"><a href="#Java-语言特点" class="headerlink" title="Java 语言特点"></a>Java 语言特点</h3><ul>
<li>面向对象（封装、继承、多态）</li>
<li>平台无关性（Java 虚拟机实现平台无关性）</li>
<li>多线程（较好的多线程支持）</li>
</ul>
<h3 id="JVM-vs-JDK-vs-JRE"><a href="#JVM-vs-JDK-vs-JRE" class="headerlink" title="JVM vs JDK vs JRE"></a>JVM vs JDK vs JRE</h3><h4 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h4><p>JVM是运行 Java 字节码的虚拟机。JVM 有针对不同系统的特定实现，目的是使用相同的字节码，它们都会给出相同的结果。字节码和不同系统的 JVM 实现是 Java 语言“一次编译，随处可以运行”的关键所在。</p>
<h4 id="JDK"><a href="#JDK" class="headerlink" title="JDK"></a>JDK</h4><p>DK 是 Java Development Kit 缩写，它是功能齐全的 Java SDK。它拥有 JRE 所拥有的一切，还有编译器（javac）和工具（如 javadoc 和 jdb），能够创建和编译程序。</p>
<h4 id="JRE"><a href="#JRE" class="headerlink" title="JRE"></a>JRE</h4><p>JRE 是 Java 运行时环境。它是运行已编译 Java 程序所需的所有内容的集合，包括 Java 虚拟机（JVM），Java 类库，java 命令和其他的一些基础构件。但是，它不能用于创建新程序。</p>
<h3 id="Java-语言“编译与解释并存”"><a href="#Java-语言“编译与解释并存”" class="headerlink" title="Java 语言“编译与解释并存”"></a>Java 语言“编译与解释并存”</h3><p>Java 程序要经过先编译，后解释两个步骤，由 Java 编写的程序需要先经过编译步骤，生成字节码（<code>\*.class</code> 文件），这种字节码必须由 Java 解释器来解释执行。</p>
<h3 id="Java-与-C-的区别"><a href="#Java-与-C-的区别" class="headerlink" title="Java 与 C++ 的区别"></a>Java 与 C++ 的区别</h3><ul>
<li>都是面向对象的语言</li>
<li>Java 不支持通过指针进行内存访问</li>
<li>Java 类只支持单继承，但可以实现多个接口，C++ 支持多继承</li>
<li>Java 有 GC 机制，不用手动释放内存</li>
<li>C++ 同时支持<strong>方法重载</strong>和<strong>运算符重载</strong>，<strong>Java 只支持方法重载</strong></li>
</ul>
<h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20210804200000105.png" alt="image-20210804200000105"></p>
<ul>
<li><p>strictfp 浮点运算更加精确，不会因为不同的硬件平台所执行的结果不一致</p>
</li>
<li><p>transient 修饰字段，用transient关键字标记的成员变量不参与序列化过程。</p>
</li>
<li><p>volatile 当把变量声明为volatile类型后，编译器与运行时都会注意到这个变量是共享的，因此不会将该变量上的操作与其他内存操作一起重排序。在访问volatile变量时不会执行加锁操作，因此也就不会使执行线程阻塞，因此volatile变量是一种比 sychronized 关键字更轻量级的同步机制。</p>
</li>
</ul>
<h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><p>泛型的本质是参数化类型。Java的泛型是伪泛型，Java 在编译期间，所有的泛型信息都会被擦除，这通常叫做<strong>类型擦除</strong>。</p>
<p>泛型通常有三种使用方式：泛型类、泛型接口、泛型方法</p>
<h4 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Generic</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T key;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实例化一个泛型类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Generic&lt;Integer&gt; genericInteger = <span class="keyword">new</span> Generic&lt;Integer&gt;(<span class="number">123456</span>);</span><br></pre></td></tr></table></figure>

<h4 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Generator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">method</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现泛型接口，不指定类型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GeneratorImpl</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Generator</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现泛型接口，指定类型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GeneratorImpl</span> <span class="keyword">implements</span> <span class="title">Generator</span>&lt;<span class="title">String</span>&gt;</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; <span class="function"><span class="keyword">void</span> <span class="title">printArray</span><span class="params">(E[] inputArray)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (E element : inputArray) &#123;</span><br><span class="line">        System.out.printf(<span class="string">"%s "</span>, element);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建不同类型数组： Integer, Double 和 Character</span></span><br><span class="line">Integer[] intArray = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line">String[] stringArray = &#123; <span class="string">"Hello"</span>, <span class="string">"World"</span> &#125;;</span><br><span class="line">printArray(intArray);</span><br><span class="line">printArray(stringArray);</span><br></pre></td></tr></table></figure>

<p><strong>常用的通配符为： T，E，K，V，？</strong></p>
<ul>
<li>？ 表示不确定的 java 类型</li>
<li>T (type) 表示具体的一个 java 类型</li>
<li>K V (key value) 分别代表 java 键值中的 Key Value</li>
<li>E (element) 代表 Element</li>
</ul>
<h3 id="和-equals-的区别"><a href="#和-equals-的区别" class="headerlink" title="==== 和 equals 的区别=="></a>==== 和 equals 的区别==</h3><p>对于基本数据类型来说，== 比较的是值。对于引用数据类型来说， == 比较的是对象的内存地址（也是值比较）。</p>
<p>equals 方法只能用来比较两个对象是否相等：</p>
<ul>
<li><p>当类没有覆盖 equals 方法时，等价于通过 == 比较这两个对象，调用 Object 类的 equals 方法。</p>
</li>
<li><p>当类覆盖了 equals 方法，一般我们都覆盖 equals 方法来比较两个对象中的属性是否相等，若它们的属性相等，则返回true。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String a = <span class="keyword">new</span> String(<span class="string">"ab"</span>); <span class="comment">// a 为一个引用</span></span><br><span class="line">        String b = <span class="keyword">new</span> String(<span class="string">"ab"</span>); <span class="comment">// b为另一个引用,对象的内容一样</span></span><br><span class="line">        String aa = <span class="string">"ab"</span>; <span class="comment">// 放在常量池中</span></span><br><span class="line">        String bb = <span class="string">"ab"</span>; <span class="comment">// 从常量池中查找</span></span><br><span class="line">        <span class="keyword">if</span> (aa == bb) <span class="comment">// true  aa 和 bb 指向常量池中同一个字符串"ab"</span></span><br><span class="line">            System.out.println(<span class="string">"aa==bb"</span>);</span><br><span class="line">        <span class="keyword">if</span> (a == b) <span class="comment">// false，非同一对象</span></span><br><span class="line">            System.out.println(<span class="string">"a==b"</span>);</span><br><span class="line">        <span class="keyword">if</span> (a.equals(b)) <span class="comment">// true</span></span><br><span class="line">            System.out.println(<span class="string">"aEQb"</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">42</span> == <span class="number">42.0</span>) &#123; <span class="comment">// true</span></span><br><span class="line">            System.out.println(<span class="string">"true"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="hashCode-和-equals"><a href="#hashCode-和-equals" class="headerlink" title="==hashCode 和 equals=="></a>==hashCode 和 equals==</h3><p>hashCode 的作用是获取散列码，它的作用是<strong>确定该对象在哈希表中的索引位置</strong>。hashCode 方法在 Object 类中定义，它返回对象的内存地址。</p>
<p>哈希表存储键值对，它能根据“键”快速找出对应的“值”，存储一个对象时，key 就是这个对象的 hashCode，value 就是这个对象。</p>
<h3 id="为什么重写-equals-方法时必须重写-hashCode-方法？"><a href="#为什么重写-equals-方法时必须重写-hashCode-方法？" class="headerlink" title="==为什么重写 equals 方法时必须重写 hashCode 方法？=="></a>==为什么重写 equals 方法时必须重写 hashCode 方法？==</h3><p>我们看一下Object类中关于hashCode()方法的注释</p>
<blockquote>
<p>1.在 Java 应用程序执行期间，在对同一对象多次调用 hashCode 方法时，必须一致地返回相同的整数，前提是将对象进行 equals 比较时所用的信息没有被修改。从某一应用程序的一次执行到同一应用程序的另一次执行，该整数无需保持一致。</p>
<p>2.如果根据 equals(Object) 方法，两个对象是相等的，那么对这两个对象中的每个对象调用 hashCode 方法都必须生成相同的整数结果。</p>
<p>3.如果根据 equals(java.lang.Object) 方法，两个对象不相等，那么对这两个对象中的任一对象上调用 hashCode 方法不要求一定生成不同的整数结果。但是，程序员应该意识到，为不相等的对象生成不同整数结果可以提高哈希表的性能</p>
</blockquote>
<p>如果 <code>a.equals(b) == true</code>，那么<code>a.hashCode() == b.hashCode()</code>；如果<code>a.equals(b) == false</code>，对象a 和 b 的哈希值不必相等，但程序员应该知道，为不相等的对象生成不同的哈希值可以提高哈希表的性能（避免哈希冲突）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> code;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">(<span class="keyword">int</span> code)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.code = code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        A a = (A) o;</span><br><span class="line">        <span class="keyword">return</span> code == a.code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    @Override</span></span><br><span class="line"><span class="comment">//    public int hashCode() &#123;</span></span><br><span class="line"><span class="comment">//        return Objects.hash(code);</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"A&#123;"</span> +</span><br><span class="line">                <span class="string">"code="</span> + code +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        A a = <span class="keyword">new</span> A(<span class="number">1</span>);</span><br><span class="line">        A b = <span class="keyword">new</span> A(<span class="number">1</span>);</span><br><span class="line">        HashSet&lt;A&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        set.add(a);</span><br><span class="line">        set.add(b);</span><br><span class="line">        System.out.println(set.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当只重写了 equals 方法时，输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[A&#123;code&#x3D;1&#125;, A&#123;code&#x3D;1&#125;]</span><br></pre></td></tr></table></figure>

<p>当重写了 equals 和 hashCode 方法时，输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[A&#123;code&#x3D;1&#125;]</span><br></pre></td></tr></table></figure>

<p>可以看到 equals 相等的两个等价对象因为 hashCode 不同，所以在 hashMap 中的 table 数组下标不同，从而这两个对象就会同时存在于集合中，由于 hashSet 就是 hashMap 实现的，在值不重复的 Set 中出现了两个等价对象，这就会出现逻辑错误，如果需要使用集合类，在重写 equals 方法时必须重写 hashCode 方法。</p>
<h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20210804205811181.png" alt="image-20210804205811181"></p>
<p>对于 <code>boolean</code>，官方文档未明确定义，它依赖于 JVM 厂商的具体实现。</p>
<p><strong>基本数据类型直接存放在 Java 虚拟机栈中栈帧的局部变量表中</strong>，而包装类型属于对象类型，我们知道对象实例都存在于堆中。相比于对象类型， 基本数据类型占用的空间非常小。</p>
<p>Java 基本类型的包装类的大部分都实现了==常量池==技术。<strong><code>Byte</code>,<code>Short</code>,<code>Integer</code>,<code>Long</code> 这 4 种包装类默认创建了数值 [-128，127] 的相应类型的缓存数据，<code>Character</code> 创建了数值在[0,127]范围的缓存数据，<code>Boolean</code> 直接返回 <code>True</code> Or <code>False</code>。</strong></p>
<h3 id="在一个静态方法内调用一个非静态方法为什么是非法的？"><a href="#在一个静态方法内调用一个非静态方法为什么是非法的？" class="headerlink" title="在一个静态方法内调用一个非静态方法为什么是非法的？"></a>在一个静态方法内调用一个非静态方法为什么是非法的？</h3><p>静态方法属于类，在类加载时就会分配内存，可以通过类名直接访问。非静态成员属于实例对象，只有在对象实例化之后才存在。在静态方法中调用内存中还不存在的非静态成员属于非法操作。</p>
<h3 id="静态方法和实例方法有何不同？"><a href="#静态方法和实例方法有何不同？" class="headerlink" title="静态方法和实例方法有何不同？"></a>静态方法和实例方法有何不同？</h3><p>静态方法可使用 类名.方法名 和 对象名.方法名 这两种方式使用，实例方法只能使用后一种方法，<strong>调用静态方法无需创建对象</strong></p>
<p>静态方法只能使用类的静态成员变量和方法，不能访问实例成员变量和实例方法，实例方法中无限制。</p>
<h3 id="为什么-Java-中只有值传递？"><a href="#为什么-Java-中只有值传递？" class="headerlink" title="为什么 Java 中只有值传递？"></a>为什么 Java 中只有值传递？</h3><p>Java 总是采用按值调用，方法得到的所有参数值的一个拷贝。当参数为基本数据类型时，传递的是基本类型的拷贝值，当参数为引用对象时，传递的是对象引用的拷贝（这个拷贝的对象引用和原始对象引用<strong>同时</strong>指向堆中的对象内存）。</p>
<p>Java 中方法参数的使用情况：</p>
<ul>
<li>一个方法不能修改一个基本数据类型的参数（即数值型或布尔型）。</li>
<li>一个方法可以改变一个对象参数的状态。</li>
<li>一个方法不能让对象参数引用一个新的对象。</li>
</ul>
<h3 id="重载和重写的区别"><a href="#重载和重写的区别" class="headerlink" title="重载和重写的区别"></a>重载和重写的区别</h3><p>重载- 同名方法可以有不同的方法签名，根据输入数据的不同，做出不同的处理。</p>
<p>重写- 子列继承父类的相同方法（不允许更改方法签名）,需要做出有别于父类的响应时，就要覆盖父类方法。</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20210804211851235.png" alt="image-20210804211851235"></p>
<p>其中子类返回值类型比父类方法返回值类型更小的意思是：如果父类方法返回类 B 的对象，子类方法可返回 B 的子类 C 的对象，但不能返回 B 的父类 A 的对象。对象只能向上转型，不能向下转型。子类的对象可以赋值给父类，父类的对象却不可以赋值给子类，这样对于这个限制我们就能很好理解了。</p>
<h3 id="Java-面向对象"><a href="#Java-面向对象" class="headerlink" title="Java 面向对象"></a>Java 面向对象</h3><h4 id="面向过程和面向对象"><a href="#面向过程和面向对象" class="headerlink" title="面向过程和面向对象"></a>面向过程和面向对象</h4><ul>
<li><p><strong>面向过程</strong> ：<strong>面向过程性能比面向对象高。</strong>但是，<strong>面向过程没有面向对象易维护、易复用、易扩展。</strong></p>
</li>
<li><p><strong>面向对象</strong> ：<strong>面向对象易维护、易复用、易扩展。</strong> 但是，<strong>面向对象性能比面向过程低</strong>。</p>
</li>
</ul>
<h4 id="成员变量和局部变量的区别"><a href="#成员变量和局部变量的区别" class="headerlink" title="成员变量和局部变量的区别"></a>成员变量和局部变量的区别</h4><ol>
<li>成员变量是属于类的，局部变量是在方法或代码块中定义的。成员变量可以被 public、static、private 等修饰符修饰，局部变量不能被这些修饰符修饰，成员变量和局部变量都能被 final 关键字修饰。</li>
<li>成员变量是对象的一部分，随对象的创建而存在，局部变量随着方法的调用而自动消失</li>
<li>成员变量如果没有赋初值，则会自动以类型的默认值为初值（被 final 修饰的成员变量必须显式地赋值），局部变量不会自动赋初值</li>
</ol>
<h4 id="一个类的构造方法的作用是什么？若一个类没有声明构造方法，该程序能正确执行吗？"><a href="#一个类的构造方法的作用是什么？若一个类没有声明构造方法，该程序能正确执行吗？" class="headerlink" title="一个类的构造方法的作用是什么？若一个类没有声明构造方法，该程序能正确执行吗？"></a>一个类的构造方法的作用是什么？若一个类没有声明构造方法，该程序能正确执行吗？</h4><p>构造方法主要完成类对象的初始化工作。</p>
<p>如果一个类没有声明构造方法，也可以执行！一个类即使没有声明构造方法也会有默认的不带参数的构造方法。（如果自己添加类的构造方法，Java 就不会再添加默认的无参数构造方法了）</p>
<h4 id="构造方法有哪些特点？是否可被重写？"><a href="#构造方法有哪些特点？是否可被重写？" class="headerlink" title="构造方法有哪些特点？是否可被重写？"></a>构造方法有哪些特点？是否可被重写？</h4><p>特点：</p>
<ol>
<li>名字与类名相同</li>
<li>没有返回值，但不能用 void 声明构造函数</li>
<li>生成类的对象时自动执行，无需调用</li>
</ol>
<p>构造方法不能被重写，但是可以重载，一个类中可以有多个构造函数</p>
<h4 id="面向对象三大特征"><a href="#面向对象三大特征" class="headerlink" title="面向对象三大特征"></a>面向对象三大特征</h4><ol>
<li><p>封装，把一个对象的状态信息隐藏在对象内部，不允许外部对象直接访问对象的内部信息。但是可以提供一些被外界访问的方法来操作属性。</p>
</li>
<li><p>继承，使用已存在的类的定义作为基础建立新类，新类的定义可以增加新的数据或新的功能，也可以使用父类的功能，通过继承，可以提高代码的重用性。（子类拥有父类所有对象属性和方法，但父类中的私有属性和方法不能访问，子类可以对父类进行扩展，子类可以重写父类的方法）</p>
</li>
<li><p>多态，表示一个对象有多种状态，具体表现为父类的引用指向子类的实例。</p>
<p>多态的特点：</p>
<ul>
<li>对象类型和引用类型之间具有继承（类）/实现（接口）的关系</li>
<li>引用类型变量调用的方法必须在程序运行期间才能确定</li>
<li>多态不能调用“只在子类存在但父类不存在”的方法</li>
<li>如果子类重写了父类的方法，真正执行的是子类覆盖的方法，如果没有重写，执行父类的方法。</li>
</ul>
</li>
</ol>
<h4 id="StringBuffer-和-StringBuilder-的区别是什么？String-为什么是不可变的？"><a href="#StringBuffer-和-StringBuilder-的区别是什么？String-为什么是不可变的？" class="headerlink" title="StringBuffer 和 StringBuilder 的区别是什么？String 为什么是不可变的？"></a>StringBuffer 和 StringBuilder 的区别是什么？String 为什么是不可变的？</h4><h5 id="不可变性"><a href="#不可变性" class="headerlink" title="不可变性"></a>不可变性</h5><p>String 类中<strong>使用 final 关键字修饰字符数组来保存字符串</strong>，<code>private final char value[]</code>，所以 <strong>String 对象是不可变的</strong>。</p>
<blockquote>
<p>在 Java 9 之后，String、StringBuffer 与 StringBuilder 的实现改为 byte 数组存储字符串 <code>private final byte[] value</code></p>
</blockquote>
<p>StringBuilder 和 StringBuffer 都继承自 AbstractStringBuilder 类，在这个类中的字符数组没有用 final 关键字修饰，所以这两种对象都是可变的。</p>
<h5 id="线程安全性"><a href="#线程安全性" class="headerlink" title="线程安全性"></a>线程安全性</h5><p>String 对象是不可变的，不可变对象都是线程安全的。</p>
<p>AbstractStringBuilder 定义的一些字符串的基本操作，如 expandCapacity、append、insert、indexOf 等公共方法。StringBuffer 对方法加了同步锁或对调用的方法加了同步锁，所以是线程安全的。StringBuilder 并没有对方法进行加锁，所以是非线程安全的。</p>
<h5 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h5><p>每次对 String 类型进行改变时，都会生成一个新的 String 对象，然后将引用指向新的 String 对象。StringBuffer 每次都会对StringBuffer 对象本身进行操作。</p>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><ol>
<li>操作少量的数据，使用 String</li>
<li>单线程操作字符串缓冲区大量数据：使用 StringBuilder</li>
<li>多线程操作字符串缓冲区大量数据：使用 StringBuffer</li>
</ol>
<h4 id="Object-类的常见方法总结"><a href="#Object-类的常见方法总结" class="headerlink" title="==Object 类的常见方法总结=="></a>==Object 类的常见方法总结==</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> Class&lt;?&gt; getClass()<span class="comment">//native方法，用于返回当前运行时对象的Class对象，使用了final关键字修饰，故不允许子类重写。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> <span class="comment">//native方法，用于返回对象的哈希码，主要使用在哈希表中，比如JDK中的HashMap。</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span><span class="comment">//用于比较2个对象的内存地址是否相等，String类对该方法进行了重写用户比较字符串的值是否相等。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException<span class="comment">//naitive方法，用于创建并返回当前对象的一份拷贝。一般情况下，对于任何对象 x，表达式 x.clone() != x 为true，x.clone().getClass() == x.getClass() 为true。Object本身没有实现Cloneable接口，所以不重写clone方法并且进行调用的话会发生CloneNotSupportedException异常。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span><span class="comment">//返回类的名字@实例的哈希码的16进制的字符串。建议Object所有的子类都重写这个方法。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">()</span><span class="comment">//native方法，并且不能重写。唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">notifyAll</span><span class="params">()</span><span class="comment">//native方法，并且不能重写。跟notify一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException<span class="comment">//native方法，并且不能重写。暂停线程的执行。注意：sleep方法没有释放锁，而wait方法释放了锁 。timeout是等待时间。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout, <span class="keyword">int</span> nanos)</span> <span class="keyword">throws</span> InterruptedException<span class="comment">//多了nanos参数，这个参数表示额外时间（以毫微秒为单位，范围是 0-999999）。 所以超时的时间还需要加上nanos毫秒。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException<span class="comment">//跟之前的2个wait方法一样，只不过该方法一直等待，没有超时时间这个概念</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123; &#125;<span class="comment">//实例被垃圾回收器回收的时候触发的操作</span></span><br></pre></td></tr></table></figure>

<h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>反射赋予了我们在运行时分析类以及执行类中方法的能力。</p>
<p>通过反射你可以获取任意一个类的所有属性和方法，并可以调用这些方法和属性。</p>
<h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><ul>
<li>优点：让代码更加灵活，为各种框架提供开箱即用功能提供便利</li>
<li>缺点：让我们在运行时有了分析类和操作类的能力。这同样增加了安全问题。比如可以无视泛型参数的安全检查（泛型参数的安全检查发生在编译时），同时，反射的性能稍差。</li>
</ul>
<h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><p>SpringBoot 等框架中大量使用了反射机制，<strong>这些框架中也大量使用了动态代理，而动态代理的实现也依赖反射</strong>。</p>
<p>另外，Java 中的注解也使用了反射，例如 Spring 中，@Component 注解声明一个类为 Spring Bean。这些都是因为可以基于反射分析类，然后获取到 类/属性/方法/方法参数 上的注解。获取到注解后，就可以进一步处理。</p>
<h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><h4 id="层次结构图"><a href="#层次结构图" class="headerlink" title="层次结构图"></a>层次结构图</h4><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20210815200456496.png" alt="image-20210815200456496"></p>
<p><code>Exception</code> 和 <code>Error</code> 二者都是 Java 异常处理的重要子类，各自都包含大量子类。</p>
<ul>
<li><strong><code>Exception</code></strong> :程序本身可以处理的异常，可以通过 <code>catch</code> 来进行捕获。<code>Exception</code> 又可以分为 <strong>受检查异常(必须处理) 和 不受检查异常(可以不处理)</strong>。</li>
<li><strong><code>Error</code></strong> ：<code>Error</code> 属于程序无法处理的错误 ，我们没办法通过 <code>catch</code> 来进行捕获 。例如，Java 虚拟机运行错误（<code>Virtual MachineError</code>）、虚拟机内存不够错误(<code>OutOfMemoryError</code>)、类定义错误（<code>NoClassDefFoundError</code>）等 。这些异常发生时，Java 虚拟机（JVM）一般会选择线程终止。</li>
</ul>
<p>==Java 代码在编译过程中 ，我们即使不处理不受检查异常也可以正常通过编译。==</p>
<h4 id="try-catch-finally"><a href="#try-catch-finally" class="headerlink" title="try-catch-finally"></a>try-catch-finally</h4><p>finally 块不会执行的情况</p>
<ul>
<li>在 try 或 finally 块中用了 System.exit(int) 退出程序。</li>
<li>程序所在线程死亡</li>
<li>关闭 CPU</li>
</ul>
<p>当 try 和 finally 语句中都有 return 语句时，finally 语句的内容将被执行。</p>
<h4 id="使用-try-with-resource-来代替-try-catch-finally"><a href="#使用-try-with-resource-来代替-try-catch-finally" class="headerlink" title="使用 try-with-resource 来代替 try-catch-finally"></a>使用 try-with-resource 来代替 try-catch-finally</h4><p>适用范围（资源）：任何实现 <code>java.lang.AutoCloseable</code>或者 <code>java.io.Closeable</code> 的类</p>
<p>在 finally 块中手动关闭资源</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Scanner scanner = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    scanner = <span class="keyword">new</span> Scanner(<span class="keyword">new</span> File(<span class="string">"D://read.txt"</span>)));</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(scanner != <span class="keyword">null</span>)&#123;</span><br><span class="line">        scanner.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 try-with-resource 自动关闭</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>(Scanner scanner = <span class="keyword">new</span> Scanner(<span class="keyword">new</span> File(<span class="string">"D://read.txt"</span>)));)&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="I-O-流"><a href="#I-O-流" class="headerlink" title="I/O 流"></a>I/O 流</h3><h4 id="序列化与反序列化"><a href="#序列化与反序列化" class="headerlink" title="序列化与反序列化"></a>序列化与反序列化</h4><ul>
<li>序列化：将数据结构或对象转换成二进制字节流的过程</li>
<li>反序列化：将在序列化过程中所生成的二进制字节流的过程转换为数据结构或对象的过程</li>
</ul>
<h4 id="Java-中有些字段不想进行序列化"><a href="#Java-中有些字段不想进行序列化" class="headerlink" title="Java 中有些字段不想进行序列化"></a>Java 中有些字段不想进行序列化</h4><p>使用 transient 关键字修饰，当对象被反序列化时，被 transient 修饰的变量值不会被持久化和恢复。</p>
<h4 id="关于-transient"><a href="#关于-transient" class="headerlink" title="关于 transient"></a>关于 transient</h4><ul>
<li>只能修饰变量</li>
<li>被它修饰的变量，在反序列化后变量值会被置成类型的默认值</li>
<li>static 变量不属于任何对象，不会被序列化</li>
</ul>
<h4 id="获取键盘输入的两种方法"><a href="#获取键盘输入的两种方法" class="headerlink" title="获取键盘输入的两种方法"></a>获取键盘输入的两种方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过 Scanner</span></span><br><span class="line">Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">String s  = input.nextLine();</span><br><span class="line">input.close();</span><br><span class="line"><span class="comment">//通过 BufferReader</span></span><br><span class="line">BufferedReader input = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">String s = input.readLine();</span><br></pre></td></tr></table></figure>

<h4 id="Java-中-IO-流分几种？"><a href="#Java-中-IO-流分几种？" class="headerlink" title="Java 中 IO 流分几种？"></a>Java 中 IO 流分几种？</h4><ul>
<li>按流的流向分，可以分为输入流和输出流</li>
<li>按操作单元划分，可以划分为字节流和字符流</li>
<li>按流的角色分为节点流和处理流</li>
</ul>
<p>Java IO 流的 40 多个类都是从如下 4 个抽象类基类中派生出来的。</p>
<ul>
<li>InputStream/Reader: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。</li>
<li>OutputStream/Writer: 所有输出流的基类，前者是字节输出流，后者是字符输出流。</li>
</ul>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20210815203343090.png" alt="image-20210815203343090"></p>
<h4 id="为什么分字节流和字符流"><a href="#为什么分字节流和字符流" class="headerlink" title="为什么分字节流和字符流"></a>为什么分字节流和字符流</h4><p>字符流由虚拟机将字节转化得到的，这个过程非常耗时，并且在编码类型未知时容易出现乱码问题。IO流就直接提供了一个操作字符的接口，方便对字符进行六操作。如果音频、文件、图片等使用字节流比较好。</p>
<h4 id="BIO、NIO、AIO"><a href="#BIO、NIO、AIO" class="headerlink" title="==BIO、NIO、AIO=="></a>==BIO、NIO、AIO==</h4><p>我们在平常开发过程中接触最多的就是 <strong>磁盘 IO（读写文件）</strong> 和 <strong>网络 IO（网络请求和相应）</strong>。</p>
<p><strong>从应用程序的视角来看的话，我们的应用程序对操作系统的内核发起 IO 调用（系统调用），操作系统负责的内核执行具体的 IO 操作。也就是说，我们的应用程序实际上只是发起了 IO 操作的调用而已，具体 IO 的执行是由操作系统的内核来完成的。</strong></p>
<p>当应用程序发起 I/O 调用后，会经历两个步骤：</p>
<ol>
<li>内核等待 I/O 设备准备好数据</li>
<li>内核将数据从内核空间拷贝到用户空间。</li>
</ol>
<h5 id="BIO-Blocking-IO"><a href="#BIO-Blocking-IO" class="headerlink" title="BIO(Blocking IO)"></a>BIO(Blocking IO)</h5><p>同步阻塞 IO 模型，应用程序发起 read 调用后会一直阻塞，直到在内核把数据拷贝回用户空间</p>
<p>在客户端连接数量不高的情况下可以使用。</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/6a9e704af49b4380bb686f0c96d33b81~tplv-k3u1fbpfcp-watermark.image" alt="图源：《深入拆解Tomcat &amp; Jetty》"></p>
<h5 id="NIO-Non-blocking-New-IO"><a href="#NIO-Non-blocking-New-IO" class="headerlink" title="NIO(Non-blocking/ New IO)"></a>NIO(Non-blocking/ New IO)</h5><p>Java 中的 NIO 于 Java 1.4 中引入，对应 <code>java.nio</code> 包，提供了 <code>Channel</code> , <code>Selector</code>，<code>Buffer</code> 等抽象。NIO 中的 N 可以理解为 Non-blocking，不单纯是 New。它支持面向缓冲的，基于通道的 I/O 操作方法。 对于高负载、高并发的（网络）应用，应使用 NIO 。</p>
<p>Java 中的 NIO 可以看作是 <strong>I/O 多路复用模型</strong>。也有很多人认为，Java 中的 NIO 属于同步非阻塞 IO 模型。</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/bb174e22dbe04bb79fe3fc126aed0c61~tplv-k3u1fbpfcp-watermark.image" alt="图源：《深入拆解Tomcat &amp; Jetty》"></p>
<p>同步非阻塞 IO 模型中，应用程序会一直发起 read 调用，等待数据从内核空间拷贝到用户空间的这段时间里，线程依然是阻塞的，直到在内核把数据拷贝到用户空间。</p>
<p>但是，这种 IO 模型同样存在问题：<strong>应用程序不断进行 I/O 系统调用轮询数据是否已经准备好的过程是十分消耗 CPU 资源的。</strong></p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/88ff862764024c3b8567367df11df6ab~tplv-k3u1fbpfcp-watermark.image" alt="img"></p>
<p>IO 多路复用模型中，线程首先发起 select 调用，询问内核数据是否准备就绪，等内核把数据准备好了，用户线程再发起 read 调用。read 调用的过程（数据从内核空间-&gt;用户空间）还是阻塞的。</p>
<p><strong>IO 多路复用模型，通过减少无效的系统调用，减少了对 CPU 资源的消耗。</strong></p>
<p>Java 中的 NIO ，有一个非常重要的<strong>选择器 ( Selector )</strong> 的概念，也可以被称为 <strong>多路复用器</strong>。通过它，只需要一个线程便可以管理多个客户端连接。当客户端数据到了之后，才会为其服务。</p>
<h5 id="AIO（Asynchronous-IO）"><a href="#AIO（Asynchronous-IO）" class="headerlink" title="AIO（Asynchronous IO）"></a>AIO（Asynchronous IO）</h5><p>异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/3077e72a1af049559e81d18205b56fd7~tplv-k3u1fbpfcp-watermark.image" alt="img"></p>
<h5 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h5><h5 id=""><a href="#" class="headerlink" title=""></a><img src="https://gitee.com/hoo334/picgo/raw/master//img/33b193457c928ae02217480f994814b6.png" alt="img"></h5><h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>在 Java 中除了以 <code>Map</code> 结尾的类之外， 其他类都实现了 <code>Collection</code> 接口。以 <code>Map</code> 结尾的类都实现了 <code>Map</code> 接口。</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/java-collection-hierarchy.png" alt="img"></p>
<h4 id="List，Set，Map-三者的区别"><a href="#List，Set，Map-三者的区别" class="headerlink" title="List，Set，Map 三者的区别"></a>List，Set，Map 三者的区别</h4><ol>
<li>List，存储的元素是==有序的、可重复==的</li>
<li>Set，存储的元素是==无序的、不可重复==的</li>
<li>Map，键值对存储，==key 是无序的、不可重复的，value 是无需的、可重复的==</li>
</ol>
<h4 id="集合底层数据结构"><a href="#集合底层数据结构" class="headerlink" title="集合底层数据结构"></a>集合底层数据结构</h4><h6 id="List"><a href="#List" class="headerlink" title="List"></a>List</h6><p>ArrayList、Vector：Object[] 数组，LinkedList：双向链表（JDK1.6 之前为循环链表）</p>
<h6 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h6><p>HashSet（无序、唯一）：基于 HashMap 实现</p>
<p>LinkedHashSet：是 HashSet 的子类，其内部是通过 LinkedHashMap 实现的</p>
<p>TreeSet（有序、唯一）：红黑树</p>
<h6 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h6><p>HashMap：JDK1.8 之前为数组+链表，之后当链表长度大于阈值（默认为 8 ）将链表转换为红黑树</p>
<p>LinkedHashMap：继承自 HashMap，在 HashMap 基础上，增加了一条双向链表，可以保持键值对的插入顺序，同时对链表进行相应的操作，实现了访问顺序相关逻辑</p>
<p>HashTable：数组+链表</p>
<p>TreeMap：红黑树</p>
<h4 id="如何选用集合"><a href="#如何选用集合" class="headerlink" title="如何选用集合"></a>如何选用集合</h4><p>当需要键值对存储时使用 Map 接口下的集合，排序用 TreeMap，不需要排序用HashMap，保证线程安全用 ConcurrentHashMap</p>
<p>当只用存放元素值时使用 Collection 接口下的集合，保证唯一性用 Set接口的集合例如 TreeSet 和 HashSet，不需要则选择实现 List 接口的如 ArrayList，LinkedList</p>
<h3 id="Collection-子接口-List"><a href="#Collection-子接口-List" class="headerlink" title="Collection 子接口 - List"></a>Collection 子接口 - List</h3><h4 id="ArrayList-和-LinkedList-的区别"><a href="#ArrayList-和-LinkedList-的区别" class="headerlink" title="ArrayList 和 LinkedList 的区别"></a>ArrayList 和 LinkedList 的区别</h4><ol>
<li><p>线程安全：都是不保证线程安全</p>
</li>
<li><p>底层数据结构：ArrayList 底层使用 <strong>Object 数组</strong>，LinkedList 使用<strong>双向链表</strong>数据结构</p>
</li>
<li><p>插入和删除是否受元素位置影响：</p>
<ul>
<li>ArrayList：操作末尾元素 $O(1)$时间复杂度，操作数组头部和中间元素$O(n)$时间复杂度</li>
<li>LinkedList：操作头尾元素$O(1)$时间复杂度，操作中间元素$O(n)$时间复杂度</li>
</ul>
</li>
<li><p>是否支持快速随机访问：ArrayList 底层是数组，所以支持，LinkedList 不支持</p>
</li>
<li><p>内存空间占用：ArrayList 为数组尾部空余空间浪费，LinkedList 为指针域空间占用</p>
</li>
</ol>
<h4 id="ArrayList-扩容机制"><a href="#ArrayList-扩容机制" class="headerlink" title="ArrayList 扩容机制"></a>ArrayList 扩容机制</h4><ol>
<li><p>构造方法：<strong>以无参数构造方法创建 <code>ArrayList</code> 时，实际上初始化赋值的是一个空数组。当真正对数组进行添加元素操作时，才真正分配容量。即向数组中添加第一个元素时，数组容量扩为 10</strong></p>
</li>
<li><p>扩容（grow 方法）：<strong>int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1),所以 ArrayList 每次扩容之后容量都会变为原来的 1.5 倍左右（oldCapacity 为偶数就是 1.5 倍，否则是 1.5 倍左右）</strong>，在添加大量元素时，显示调用 ensureCapacity 方法可以让ArrayList扩容</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// oldCapacity为旧容量，newCapacity为新容量</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="comment">//将oldCapacity 右移一位，其效果相当于oldCapacity /2，</span></span><br><span class="line">    <span class="comment">//我们知道位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍，</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量，</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="comment">//再检查新容量是否超出了ArrayList所定义的最大容量，</span></span><br><span class="line">    <span class="comment">//若超出了，则调用hugeCapacity()来比较minCapacity和 MAX_ARRAY_SIZE，</span></span><br><span class="line">    <span class="comment">//如果minCapacity大于MAX_ARRAY_SIZE，则新容量则为Interger.MAX_VALUE，否则，新容量大小则为 MAX_ARRAY_SIZE。</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Collection-子接口-Set"><a href="#Collection-子接口-Set" class="headerlink" title="Collection 子接口 - Set"></a>Collection 子接口 - Set</h3><h4 id="Comparable-和-Comparator-的区别"><a href="#Comparable-和-Comparator-的区别" class="headerlink" title="Comparable 和 Comparator 的区别"></a>Comparable 和 Comparator 的区别</h4><ul>
<li><code>comparable</code> 接口实际上是出自<code>java.lang</code>包 它有一个 <code>compareTo(Object obj)</code>方法用来排序</li>
<li><code>comparator</code>接口实际上是出自 java.util 包它有一个<code>compare(Object obj1, Object obj2)</code>方法用来排序</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// person对象没有实现Comparable接口，所以必须实现，这样才不会出错，才可以使treemap中的数据按顺序排列</span></span><br><span class="line"><span class="comment">// 前面一个例子的String类已经默认实现了Comparable接口，详细可以查看String类的API文档，另外其他</span></span><br><span class="line"><span class="comment">// 像Integer类等都已经实现了Comparable接口，所以不需要另外实现了</span></span><br><span class="line"><span class="keyword">public</span>  <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Person</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">	<span class="comment">//省略 getter、setter、构造方法	</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重写compareTo方法实现按年龄来排序</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Person o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.age &gt; o.getAge()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.age &lt; o.getAge()) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定制排序的用法</span></span><br><span class="line">Collections.sort(arrayList, <span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> o2.compareTo(o1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="HashSet、LinkedHashSet-和-TreeSet-三者异同"><a href="#HashSet、LinkedHashSet-和-TreeSet-三者异同" class="headerlink" title="HashSet、LinkedHashSet 和 TreeSet 三者异同"></a>HashSet、LinkedHashSet 和 TreeSet 三者异同</h4><p><code>HashSet</code> 是 <code>Set</code> 接口的主要实现类 ，<code>HashSet</code> 的底层是 <code>HashMap</code>，线程不安全的，可以存储 null 值；</p>
<p><code>LinkedHashSet</code> 是 <code>HashSet</code> 的子类，<strong>能够按照添加的顺序遍历</strong>；</p>
<p><code>TreeSet</code> 底层使用红黑树，能够按照添加元素的顺序进行遍历，排序的方式有自然排序和定制排序。</p>
<h3 id="Collection-子接口-Queue"><a href="#Collection-子接口-Queue" class="headerlink" title="Collection 子接口 - Queue"></a>Collection 子接口 - Queue</h3><h4 id="Queue-和-Deque-的区别"><a href="#Queue-和-Deque-的区别" class="headerlink" title="Queue 和 Deque 的区别"></a>Queue 和 Deque 的区别</h4><p>Queue 是单端队列，只能从一端插入元素，另一端删除元素，一般遵循先进先出原则。</p>
<p><code>Queue</code> 扩展了 <code>Collection</code> 的接口，根据 <strong>因为容量问题而导致操作失败后处理方式的不同</strong> 可以分为两类方法: 一种在操作失败后会抛出异常，另一种则会返回特殊值。</p>
<table>
<thead>
<tr>
<th><code>Queue</code> 接口</th>
<th>抛出异常</th>
<th>返回特殊值</th>
</tr>
</thead>
<tbody><tr>
<td>插入队尾</td>
<td>add(E e)</td>
<td>offer(E e)</td>
</tr>
<tr>
<td>删除队首</td>
<td>remove()</td>
<td>poll()</td>
</tr>
<tr>
<td>查询队首元素</td>
<td>element()</td>
<td>peek()</td>
</tr>
</tbody></table>
<p>Deque 是双端队列，在队列的两端均可插入或删除元素</p>
<p><code>Deque</code> 扩展了 <code>Queue</code> 的接口, 增加了在队首和队尾进行插入和删除的方法，同样根据失败后处理方式的不同分为两类：</p>
<table>
<thead>
<tr>
<th><code>Deque</code> 接口</th>
<th>抛出异常</th>
<th>返回特殊值</th>
</tr>
</thead>
<tbody><tr>
<td>插入队首</td>
<td>addFirst(E e)</td>
<td>offerFirst(E e)</td>
</tr>
<tr>
<td>插入队尾</td>
<td>addLast(E e)</td>
<td>offerLast(E e)</td>
</tr>
<tr>
<td>删除队首</td>
<td>removeFirst()</td>
<td>pollFirst()</td>
</tr>
<tr>
<td>删除队尾</td>
<td>removeLast()</td>
<td>pollLast()</td>
</tr>
<tr>
<td>查询队首元素</td>
<td>getFirst()</td>
<td>peekFirst()</td>
</tr>
<tr>
<td>查询队尾元素</td>
<td>getLast()</td>
<td>peekLast()</td>
</tr>
</tbody></table>
<p>事实上，<code>Deque</code> 还提供有 <code>push()</code> 和 <code>pop()</code> 等其他方法，可用于模拟栈。</p>
<h4 id="ArrayDeque-和-LinkedList-的区别"><a href="#ArrayDeque-和-LinkedList-的区别" class="headerlink" title="ArrayDeque 和 LinkedList 的区别"></a>ArrayDeque 和 LinkedList 的区别</h4><p>它们都实现了 Deque 接口，两者都有队列的功能</p>
<ul>
<li>ArrayDeque 基于可变长的数组和双指针实现，LinkedList 通过双向链表实现</li>
<li>ArrayDeque 不支持 Null 数据，LinkedList 支持</li>
<li>ArrayDeque 插入时可能存在扩容过程，均摊后的操作时间复杂度$O(1)$，LinkedList 每次插入数据时均需要申请新的堆空间，均摊性能更慢。</li>
</ul>
<p>从性能的角度上，选用 <code>ArrayDeque</code> 来实现队列要比 <code>LinkedList</code> 更好。此外，<code>ArrayDeque</code> 也可以用于实现栈。</p>
<h4 id="PriorityQueue"><a href="#PriorityQueue" class="headerlink" title="PriorityQueue"></a>PriorityQueue</h4><p>优先级队列，总是优先级最高的元素先出队</p>
<p>它使用二叉堆来实现，底层使用可变长的数组来存储数据，插入元素和删除堆顶元素时间复杂度为$O(log\ n)$，非线程安全，不支持 Null 和 没有实现 Comparable 的对象，默认为小顶堆，可以接受一个 Comparator 自定优先级。</p>
<h3 id="Map-接口"><a href="#Map-接口" class="headerlink" title="Map 接口"></a>Map 接口</h3><h4 id="HashMap-和-HashTable"><a href="#HashMap-和-HashTable" class="headerlink" title="HashMap 和 HashTable"></a>HashMap 和 HashTable</h4><ol>
<li><p>线程安全，HashMap 非线程安全，HashTable 内部的方法基本都使用 synchronized 修饰，是线程安全的</p>
</li>
<li><p>效率，由于线程安全的操作，HashTable 比 HashMap 效率低</p>
</li>
<li><p>对空键和空值的支持，HashMap 支持一个空键，多个空值；HashTable 不允许有空键和空值，否则抛空指针异常</p>
</li>
<li><p>数据结构，HashTable 数组+链表，jdk1.7 HashMap 也是数组+链表，jdk1.8 后当链表长度大于阈值会将链表转换为红黑树</p>
</li>
<li><p>初始容量和扩容不同，HashTabl默认大小为 11，每次扩容容量变为原来的 2n + 1 ，HashMap 初始大小为16，每次扩容为原来的 2 倍。如果给定容量大小，HashTable 直接扩容到给定的大小，HashMap 将会把它扩容到 2 的幂次方。</p>
</li>
</ol>
<h4 id="HashMap-和-HashSet"><a href="#HashMap-和-HashSet" class="headerlink" title="HashMap 和 HashSet"></a>HashMap 和 HashSet</h4><p>如果你看过 <code>HashSet</code> 源码的话就应该知道：<code>HashSet</code> 底层就是基于 <code>HashMap</code> 实现的。（<code>HashSet</code> 的源码非常非常少，因为除了 <code>clone()</code>、<code>writeObject()</code>、<code>readObject()</code>是 <code>HashSet</code> 自己不得不实现之外，其他方法都是直接调用 <code>HashMap</code> 中的方法。</p>
<table>
<thead>
<tr>
<th><code>HashMap</code></th>
<th><code>HashSet</code></th>
</tr>
</thead>
<tbody><tr>
<td>实现了 <code>Map</code> 接口</td>
<td>实现 <code>Set</code> 接口</td>
</tr>
<tr>
<td>存储键值对</td>
<td>仅存储对象</td>
</tr>
<tr>
<td>调用 <code>put()</code>向 map 中添加元素</td>
<td>调用 <code>add()</code>方法向 <code>Set</code> 中添加元素</td>
</tr>
<tr>
<td><code>HashMap</code> 使用键（Key）计算 <code>hashcode</code></td>
<td><code>HashSet</code> 使用成员对象来计算 <code>hashcode</code> 值，对于两个对象来说 <code>hashcode</code> 可能相同，所以<code>equals()</code>方法用来判断对象的相等性</td>
</tr>
</tbody></table>
<h4 id="HashMap-和-TreeMap"><a href="#HashMap-和-TreeMap" class="headerlink" title="HashMap 和 TreeMap"></a>HashMap 和 TreeMap</h4><p><code>TreeMap</code> 和<code>HashMap</code> 都继承自<code>AbstractMap</code> ，但是需要注意的是<code>TreeMap</code>它还实现了<code>NavigableMap</code>接口和<code>SortedMap</code> 接口。</p>
<p>实现 <code>NavigableMap</code> 接口让 <code>TreeMap</code> 有了对集合内元素的搜索的能力。</p>
<p>实现<code>SortMap</code>接口让 <code>TreeMap</code> 有了对集合中的元素根据键排序的能力。</p>
<h4 id="HashSet如何检查重复"><a href="#HashSet如何检查重复" class="headerlink" title="==HashSet如何检查重复=="></a>==HashSet如何检查重复==</h4><p>当你把对象加入<code>HashSet</code>时，<code>HashSet</code> 会先计算对象的<code>hashcode</code>值来判断对象加入的位置，同时也会与其他加入的对象的 <code>hashcode</code> 值作比较，如果没有相符的 <code>hashcode</code>，<code>HashSet</code> 会假设对象没有重复出现。但是如果发现有相同 <code>hashcode</code> 值的对象，这时会调用<code>equals()</code>方法来检查 <code>hashcode</code> 相等的对象是否真的相同。如果两者相同，<code>HashSet</code> 就不会让加入操作成功。</p>
<h4 id="HashMap-底层实现"><a href="#HashMap-底层实现" class="headerlink" title="HashMap 底层实现"></a>HashMap 底层实现</h4><p>JDK1.8 HashMap 的 hash 方法源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="comment">// key.hashCode()：返回散列值也就是hashcode</span></span><br><span class="line">    <span class="comment">// ^ ：按位异或</span></span><br><span class="line">    <span class="comment">// &gt;&gt;&gt;:无符号右移，忽略符号位，空位都以0补齐</span></span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JDK1.8 之后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。</p>
<h4 id="HashMap-的长度为什么是-2-的幂次方"><a href="#HashMap-的长度为什么是-2-的幂次方" class="headerlink" title="==HashMap 的长度为什么是 2 的幂次方=="></a>==HashMap 的长度为什么是 2 的幂次方==</h4><p>一般我们使用 hash 值取余数组的长度 n ，得到存放到数组的下标。但取余操作很慢，HashMap 使用的是 <code>(n - 1) &amp; hash</code>快速求下标的方式。但只有当 n 为 2 的幂次时，<code>hash % n == hash &amp; (n - 1)</code>，所以 HashMap 的长度必须为 2 的幂次。</p>
<h4 id="HashMap-类属性"><a href="#HashMap-类属性" class="headerlink" title="HashMap 类属性"></a>HashMap 类属性</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 序列号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">362498820763181265L</span>;</span><br><span class="line">    <span class="comment">// 默认的初始容量是16</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>;</span><br><span class="line">    <span class="comment">// 最大容量</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line">    <span class="comment">// 默认的填充因子</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line">    <span class="comment">// 当桶(bucket)上的结点数大于这个值时会转成红黑树</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line">    <span class="comment">// 当桶(bucket)上的结点数小于这个值时树转链表</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line">    <span class="comment">// 桶中结构转化为红黑树对应的table的最小大小</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br><span class="line">    <span class="comment">// 存储元素的数组，总是2的幂次倍</span></span><br><span class="line">    <span class="keyword">transient</span> Node&lt;k,v&gt;[] table;</span><br><span class="line">    <span class="comment">// 存放具体元素的集</span></span><br><span class="line">    <span class="keyword">transient</span> Set&lt;map.entry&lt;k,v&gt;&gt; entrySet;</span><br><span class="line">    <span class="comment">// 存放元素的个数，注意这个不等于数组的长度。</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="comment">// 每次扩容和更改map结构的计数器</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br><span class="line">    <span class="comment">// 临界值 当实际大小(容量*填充因子)超过临界值时，会进行扩容</span></span><br><span class="line">    <span class="keyword">int</span> threshold;</span><br><span class="line">    <span class="comment">// 加载因子</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="HashMap-多线程操作死循环问题"><a href="#HashMap-多线程操作死循环问题" class="headerlink" title="HashMap 多线程操作死循环问题"></a>HashMap 多线程操作死循环问题</h4><p>在并发情况下，Rehash 方法会造成元素之间形成一个循环链表</p>
<p><a href="https://coolshell.cn/articles/9606.html" target="_blank" rel="noopener">详解</a></p>
<h4 id="ConcurrentHashMap-和-HashTable"><a href="#ConcurrentHashMap-和-HashTable" class="headerlink" title="ConcurrentHashMap 和 HashTable"></a>ConcurrentHashMap 和 HashTable</h4><ol>
<li>底层数据结构：JDK1.7 之前 ConcurrentHashMap 底层采用分段数组+链表实现，JDK1.8 采用数组 + 链表/红黑树。HashTable 采用数组+链表实现</li>
<li>实现线程安全的方式：<ul>
<li>JDK1.7时 ConcurrentHashMap 对整个桶数组进行了分段分割（segment），每一把锁只锁一部分数据。到JDK1.8时，直接使用 Node 数组+链表/红黑树来实现，并发控制使用 synchronzied 和 CAS 来操作</li>
<li>HashTable 使用全表锁，效率十分低下，一个线程使用 put 添加元素，另一个线程既不能 get 也不能 put。</li>
</ul>
</li>
</ol>
<h4 id="Concurrent底层实现"><a href="#Concurrent底层实现" class="headerlink" title="Concurrent底层实现"></a>Concurrent底层实现</h4><p>JDK1.7</p>
<p>首先将数据分为一段一段，然后给每段数据配一把锁，当一个线程占用锁访问其中一个段数据时，其他段的数据也能被其他线程访问。</p>
<p>ConcurrentHashMap 是由 Segment 数组结构和 HashEntry 数组结构组成。</p>
<p>Segment 实现了 ReentrantLock，Segment 是一种可重入锁，扮演锁的角色。HashEntry 用于存储键值对数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Segment</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">ReentrantLock</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个 ConcurrentHashMap 里包含一个Segment数组，一个 Segment 包含一个 HashEntry 数组，每个 HashEntry 是一个链表结构的元素，当对当前 Segment 内的 HashEntry 进行修改时，必须先获得 Segment 的锁。</p>
<p>JDK1.8</p>
<p><code>ConcurrentHashMap</code> 取消了 <code>Segment</code> 分段锁，采用 CAS 和 <code>synchronized</code> 来保证并发安全。数据结构跟 HashMap1.8 的结构类似，数组+链表/红黑二叉树。Java 8 在链表长度超过一定阈值（8）时将链表（寻址时间复杂度为 O(N)）转换为红黑树（寻址时间复杂度为 $O(logN）$</p>
<h3 id="Collections-工具类"><a href="#Collections-工具类" class="headerlink" title="Collections 工具类"></a>Collections 工具类</h3><h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(List list)</span><span class="comment">//反转</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shuffle</span><span class="params">(List list)</span><span class="comment">//随机排序</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(List list)</span><span class="comment">//按自然排序的升序排序</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(List list, Comparator c)</span><span class="comment">//定制排序，由Comparator控制排序逻辑</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(List list, <span class="keyword">int</span> i , <span class="keyword">int</span> j)</span><span class="comment">//交换两个索引位置的元素</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(List list, <span class="keyword">int</span> distance)</span><span class="comment">//旋转。当distance为正数时，将list后distance个元素整体移到前面。当distance为负数时，将 list的前distance个元素整体移到后面</span></span></span><br></pre></td></tr></table></figure>

<h4 id="查找、替换操作"><a href="#查找、替换操作" class="headerlink" title="查找、替换操作"></a>查找、替换操作</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(List list, Object key)</span><span class="comment">//对List进行二分查找，返回索引，注意List必须是有序的</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(Collection coll)</span><span class="comment">//根据元素的自然顺序，返回最大的元素。 类比int min(Collection coll)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(Collection coll, Comparator c)</span><span class="comment">//根据定制排序，返回最大元素，排序规则由Comparatator类控制。类比int min(Collection coll, Comparator c)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fill</span><span class="params">(List list, Object obj)</span><span class="comment">//用指定的元素代替指定list中的所有元素</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">frequency</span><span class="params">(Collection c, Object o)</span><span class="comment">//统计元素出现次数</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexOfSubList</span><span class="params">(List list, List target)</span><span class="comment">//统计target在list中第一次出现的索引，找不到则返回-1，类比int lastIndexOfSubList(List source, list target)</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">replaceAll</span><span class="params">(List list, Object oldVal, Object newVal)</span><span class="comment">//用新元素替换旧元素</span></span></span><br></pre></td></tr></table></figure>

<h4 id="同步（不推荐，建议使用-JUC-包下的并发集合）"><a href="#同步（不推荐，建议使用-JUC-包下的并发集合）" class="headerlink" title="同步（不推荐，建议使用 JUC 包下的并发集合）"></a>同步（不推荐，建议使用 JUC 包下的并发集合）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">synchronizedCollection(Collection&lt;T&gt;  c) <span class="comment">//返回指定 collection 支持的同步（线程安全的）collection。</span></span><br><span class="line">synchronizedList(List&lt;T&gt; list)<span class="comment">//返回指定列表支持的同步（线程安全的）List。</span></span><br><span class="line">synchronizedMap(Map&lt;K,V&gt; m) <span class="comment">//返回由指定映射支持的同步（线程安全的）Map。</span></span><br><span class="line">synchronizedSet(Set&lt;T&gt; s) <span class="comment">//返回指定 set 支持的同步（线程安全的）set。</span></span><br></pre></td></tr></table></figure>



<h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><h3 id="基础-1"><a href="#基础-1" class="headerlink" title="基础"></a>基础</h3><h4 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h4><p>进程是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。在 Java 中，当我们启动 main 函数时就是启动了一个 JVM 的进程。</p>
<p>线程与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是，同类的多个线程共享进程的<strong>堆</strong>和<strong>方法区</strong>资源，但每个线程都有自己的<strong>程序计数器</strong>、<strong>虚拟机栈</strong>和<strong>本地方法栈</strong>。</p>
<h4 id="程序计数器为什么是线程私有的？"><a href="#程序计数器为什么是线程私有的？" class="headerlink" title="程序计数器为什么是线程私有的？"></a>程序计数器为什么是线程私有的？</h4><ol>
<li>字节码解释器通过程序计数器来读取指令，从而实现代码的流程控制</li>
<li>在多线程情况下，程序计数器用于记录当前线程执行的位置</li>
</ol>
<p>如果执行的是 native 方法，程序计数器记录的是 undefined 地址，只有执行的是 Java 代码时，程序计数器才指向下一条指令的地址</p>
<p>程序计数器私有是为了<strong>线程切换后能恢复到正确的执行位置</strong></p>
<h4 id="虚拟机栈和本地方法栈为什么是私有的？"><a href="#虚拟机栈和本地方法栈为什么是私有的？" class="headerlink" title="虚拟机栈和本地方法栈为什么是私有的？"></a>虚拟机栈和本地方法栈为什么是私有的？</h4><p>虚拟机栈：每个 Java 方法在执行的同时会创建一个栈帧用于存储<strong>局部变量表</strong>，<strong>操作数栈</strong>，<strong>常量池引用</strong>等信息。从方法调用直至执行完成，就对应着一个栈帧在 Java 虚拟机中入栈和出栈的过程</p>
<p>本地方法栈：和虚拟机栈所发挥的作用非常相似，区别是虚拟机栈为虚拟机执行 Java 方法服务，本地方法为虚拟机使用到的 Native 方法服务</p>
<p>为了<strong>保证线程中的局部变量不被其他线程访问到</strong>，虚拟机栈和本地方法栈是私有的</p>
<h4 id="堆和方法区"><a href="#堆和方法区" class="headerlink" title="堆和方法区"></a>堆和方法区</h4><p>堆和方法区是所有线程共享的资源，堆是进程中最大的一块内存，主要用于存放新创建的对象，方法区主要存放已被加载的类信息、常量、静态变量、JIT编译后的数据。</p>
<h4 id="并行和并发"><a href="#并行和并发" class="headerlink" title="并行和并发"></a>并行和并发</h4><ul>
<li>并发：同一时间段，多个任务都在执行，同一时刻只执行一个任务</li>
<li>并发：单位时间内，多个任务同时执行</li>
</ul>
<h4 id="为什么使用多线程以及带来的问题"><a href="#为什么使用多线程以及带来的问题" class="headerlink" title="为什么使用多线程以及带来的问题"></a>为什么使用多线程以及带来的问题</h4><p>多核时代，使用多线程主要为了利用多核 CPU 的能力，创建多个线程，这些线程可以被映射到底层多个CPU核心上执行，这会提高任务执行的效率。</p>
<p>并发编程目的就是提高程序执行效率，但这也不是绝对的，它还会带来内存泄漏，死锁，线程不安全等问题。</p>
<h4 id="线程的生命周期和状态"><a href="#线程的生命周期和状态" class="headerlink" title="线程的生命周期和状态"></a>线程的生命周期和状态</h4><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20210827192442845.png" alt="image-20210827192442845"></p>
<h4 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h4><p>线程在执行过程中会有自己的运行条件和状态（也称上下文），比如程序计数器，栈信息等，当出现如下情况时，线程会从占用 CPU 状态中退出。</p>
<ul>
<li>主动让出 CPU，比如调用 sleep(), wait()等</li>
<li>时间片用完</li>
<li>调用了阻塞类型的系统终端，比如请求 IO</li>
<li>被终止或结束运行</li>
</ul>
<p>前三种状态都会发生线程切换，线程切换意味着需要保存当前线程的上下文，并加载下一个要占用 CPU 的线程上下文。频繁的上下文切换会导致效率低下。</p>
<h4 id="什么是死锁？如何避免死锁"><a href="#什么是死锁？如何避免死锁" class="headerlink" title="什么是死锁？如何避免死锁"></a>什么是死锁？如何避免死锁</h4><p>死锁：多个线程被同时阻塞，它们中的一个或多个都在等待某个资源被释放，由于线程被无限期地阻塞，程序不可能正常终止。</p>
<h4 id="产生死锁的四个条件"><a href="#产生死锁的四个条件" class="headerlink" title="产生死锁的四个条件"></a>产生死锁的四个条件</h4><ol>
<li>请求并保持，一个进程因请求资源而阻塞时，对已获得的资源保持不放</li>
<li>不可剥夺，线程已获得的资源在未使用完之前不能被其他线程强行剥夺</li>
<li>循环等待，若干进程之间形成一种头尾相接的循环等待资源关系。</li>
<li>互斥，资源任意一个时刻只由一个线程占用</li>
</ol>
<h4 id="预防死锁"><a href="#预防死锁" class="headerlink" title="预防死锁"></a>预防死锁</h4><ol>
<li>破坏请求与保持条件，一次性申请所有资源</li>
<li>破坏不可剥夺条件，占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放占有的资源</li>
<li>破坏循环等待条件，按序申请资源，释放资源则反序释放</li>
</ol>
<h4 id="避免死锁"><a href="#避免死锁" class="headerlink" title="避免死锁"></a>避免死锁</h4><p>在资源分配时，借助算法（银行家）对资源分配进行计算评估，使其进入安全状态。</p>
<h4 id="sleep-方法和-wait-方法"><a href="#sleep-方法和-wait-方法" class="headerlink" title="sleep() 方法和 wait() 方法"></a>sleep() 方法和 wait() 方法</h4><p>两者最大区别是：sleep() 方法没有释放锁，而 wait() 方法释放了锁</p>
<p>两者都可以暂停线程的执行。</p>
<p>wait() 通常被用于线程间交互/通信，sleep() 通常被用于暂停执行</p>
<p>wait() 方法被调用后，需要其他线程调用同一个对象上的 notify() 方法和 notifyAll() 方法。sleep() 方法执行完成后会自动苏醒</p>
<h4 id="为什么不能直接调用-run-方法"><a href="#为什么不能直接调用-run-方法" class="headerlink" title="==为什么不能直接调用 run() 方法=="></a>==为什么不能直接调用 run() 方法==</h4><p>新建一个 线程，调用 start() 方法，会启动一个线程并使其进入就绪状态，当分配到时间片后就可以开始运行了。而调用run() 方法会把 run() 方法当成 main 线程下一个普通方法执行，并不会在某个线程中执行它。</p>
<h3 id="synchronized-关键字"><a href="#synchronized-关键字" class="headerlink" title="==synchronized 关键字=="></a>==synchronized 关键字==</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><p><strong>synchronized 解决多个线程访问资源的同步性，它可以保证被修饰的方法或代码块在任意时刻只能有一个线程执行。</strong></p>
<p>因为监视器锁（monitor）是依赖于底层的操作系统的 <code>Mutex Lock</code> 来实现的，Java 的线程是映射到操作系统的原生线程之上的。如果要挂起或者唤醒一个线程，都需要操作系统帮忙完成，而操作系统实现线程之间的切换时需要从用户态转换到内核态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高。</p>
<p>庆幸的是在 Java 6 之后 Java 官方对从 JVM 层面对 <code>synchronized</code> 较大优化，所以现在的 <code>synchronized</code> 锁效率也优化得很不错了。JDK1.6 对锁的实现引入了大量的优化，如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销。</p>
<h4 id="synchronized-关键字使用方式"><a href="#synchronized-关键字使用方式" class="headerlink" title="synchronized 关键字使用方式"></a>synchronized 关键字使用方式</h4><ol>
<li>修饰实例方法：作用于当前对象实例加锁，进入同步代码前要获得==当前对象实例的锁==</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//业务代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>修饰静态方法：给当前类加锁，会作用于类的所有对象实例，进入同步代码前要获得==当前 class 的锁==。如果线程 A 调用实例对象的非静态 synchronized 方法，线程 B 调用实例对象所在类的静态 synchronized 方法，不会发生互斥现象。线程 A 占用的实例对象的锁，线程 B 占用的时当前类的锁。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//业务代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>修饰代码块：指定加锁对象，对给对象/类加锁</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;</span><br><span class="line">    <span class="comment">// 业务代码</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">synchronized</span>(A<span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//业务代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="构造方法可用-synchronized-关键字修饰么？"><a href="#构造方法可用-synchronized-关键字修饰么？" class="headerlink" title="构造方法可用 synchronized 关键字修饰么？"></a>构造方法可用 synchronized 关键字修饰么？</h4><p>不能，构造方法本身就是线程安全的</p>
<h4 id="synchronized-底层原理"><a href="#synchronized-底层原理" class="headerlink" title="==synchronized 底层原理=="></a>==synchronized 底层原理==</h4><ol>
<li><p>修饰语句块的情况（monitorenter、monitorexit）</p>
<p>使用 <strong>monitorenter</strong> 和 <strong>monitorexit</strong> 指令，同步代码块指令放在二者中间，当执行 monitorenter指令时，线程尝试获取锁（对象监视器 monitor）的持有权。在执行 monitorenter 之后，锁计数器加一，变为1。执行monitorexit指令后，锁计数器减一，变为0，此时可重新获取锁。</p>
</li>
<li><p>修饰方法的情况（ACC_SYNCHRONIZED）</p>
<p><code>synchronized</code> 修饰的方法并没有 <code>monitorenter</code> 指令和 <code>monitorexit</code> 指令，取得代之的确实是 <code>ACC_SYNCHRONIZED</code> 标识，该标识指明了该方法是一个同步方法。JVM 通过该 <code>ACC_SYNCHRONIZED</code> 访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用。两者的本质都是对象监视器锁 monitor 的获取。</p>
</li>
</ol>
<h4 id="JDK1-6-后-synchronized-关键字的优化"><a href="#JDK1-6-后-synchronized-关键字的优化" class="headerlink" title="JDK1.6 后 synchronized 关键字的优化"></a>JDK1.6 后 synchronized 关键字的优化</h4><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20210830155558454.png" alt="image-20210830155558454"></p>
<p>锁的级别从低到高分别为：无锁、偏向锁、轻量级锁、重量级锁，锁能升级但不能降级。</p>
<p>左下角图可以看到，当对象状态为偏向锁时， <strong>Mark Word 存储的是偏向的线程ID</strong>；当状态为 轻量级锁时， Mark Word 存储的是指向<strong>线程栈中 Lock Record 的指针</strong>；当状态为重量级锁时， Mark Word 为指向<strong>堆中的monitor对象的指针</strong>。</p>
<h5 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h5><p>大多数情况下锁不紧不存在多线程竞争，而且总是由同一线程多次获得。偏向锁会偏向第一个访问锁的线程，如果在接下的运行过程中，该锁没有被其他线程访问，则持有偏向锁的线程将永远不会出发同步。</p>
<p><strong>加锁</strong>：新线程在进入同步块时，尝试将对象头 MarkWord 中 的线程 ID 改为新线程 ID，如果成功，获得偏向锁，如果失败，开始撤销偏向锁并升级为轻量级锁</p>
<p><strong>撤销</strong>：当其他线程尝试竞争偏向锁时就会撤销锁并升级。偏向锁在升级成轻量级锁时，会暂停拥有偏向锁的线程，重置偏向锁标识，在一个安全点（这个时间点没有字节码运行）停止锁的线程，遍历线程栈，如果存在锁记录，需修复锁记录和 MarkWord 让它变成无锁状态，唤醒被暂停的线程，将当前锁升级为轻量级锁</p>
<h5 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a><strong>轻量级锁</strong></h5><p>多个线程在不同时间段获取同一把锁，即不存在锁竞争的情况，也就没有线程阻塞。</p>
<p><strong>加锁</strong>：JVM会为每个线程在当前线程的栈帧中创建⽤于存储锁记录的空间，我们称为 Displaced Mark Word。如果⼀个线程获得锁的时候发现是轻量级锁，会把锁的Mark Word复制到⾃⼰的Displaced Mark Word⾥⾯。然后线程尝试⽤CAS将锁的Mark Word替换为指向锁记录的指针。如果成功，当前 线程获得锁，如果失败，表示Mark Word已经被替换成了其他线程的锁记录，说明 在与其它线程竞争锁，当前线程就尝试使⽤⾃旋来获取锁。 自旋超过一定次数时，这个锁就会升级成重量级锁。</p>
<p><strong>撤销</strong>：判断对象头中的锁记录指针是否指向当前线程锁记录，并比较Displaced Mark Word 和锁的 MarkWord 是否相等，如果相等直接释放锁，如果失败则说明锁已经升级成了重量级锁。</p>
<h5 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h5><p>重量级锁依赖于操作系统的互斥量（mutex） 实现的，⽽操作系统中线程间状态的 转换需要相对⽐较⻓的时间，所以重量级锁效率很低，但被阻塞的线程不会消耗CPU.</p>
<p>每⼀个对象都可以当做⼀个锁，当多个线程同时请求某个对象锁时，对 象锁会设置⼏种状态⽤来区分请求的线程：</p>
<blockquote>
<p>Contention List：所有请求锁的线程将被⾸先放置到该竞争队列</p>
<p>Entry List：Contention List中那些有资格成为候选⼈的线程被移到Entry List</p>
<p>Wait Set：那些调⽤wait⽅法被阻塞的线程被放置到Wait Set</p>
<p>OnDeck：任何时刻最多只能有⼀个线程正在竞争锁，该线程称为OnDeck</p>
<p>Owner：获得锁的线程称为Owner</p>
<p>!Owner：释放锁的线程 </p>
</blockquote>
<p>当⼀个线程尝试获得锁时，如果该锁已经被占⽤，则会将该线程封装成⼀ 个 ObjectWaiter 对象插⼊到Contention List的队列的队⾸，然后调⽤ park 函数挂 起当前线程。 当线程释放锁时，会从Contention List或EntryList中挑选⼀个线程唤醒，被选中的 线程叫做 Heir presumptive 即假定继承⼈，假定继承⼈被唤醒后会尝试获得锁， 但 synchronized 是⾮公平的，所以假定继承⼈不⼀定能获得锁。这是因为对于重 量级锁，线程先⾃旋尝试获得锁，这样做的⽬的是为了减少执⾏操作系统同步操作 带来的开销。如果⾃旋不成功再进⼊等待队列。</p>
<h5 id="锁升级的流程"><a href="#锁升级的流程" class="headerlink" title="==锁升级的流程=="></a>==锁升级的流程==</h5><p>每个线程在准备获取共享资源时：</p>
<ol>
<li>检查 MarkWord 里放的是不是自己的线程 ID，如果是，代表当前线程有这个偏向锁；如果不是，尝试 CAS 更改共享对象 MarkWord 里的线程 ID，成功的话就获得了偏向锁。失败则代表另一个线程在使用这个共享对象，在等到安全点（这个时间点上没有正在执行的字节码）时如果还有竞争，锁升级</li>
<li>原本持有偏向锁的线程栈中存储共享对象 MarkWord 的拷贝，<strong>原本持有偏向锁的进程获得轻量级锁</strong>（共享对象 MarkWord 中的地址指向这条拷贝的记录），唤醒原来持有偏向锁的线程，从安全点继续执行。想要抢锁的线程也拷贝一个共享对象的 MarkWord，然后就开始 CAS 抢锁（尝试将共享对象 MarkWord 的锁记录指针指向自己的记录），如果经过一定次数的 CAS 还没抢到，证明竞争激烈，锁升级</li>
<li>将共享对象中的MarkWord 换为重量级锁，挂起当前线程，等待当前有锁的线程执行完成后唤醒自己。</li>
</ol>
<table>
<thead>
<tr>
<th>锁</th>
<th>优点</th>
<th>缺点</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td>偏向锁</td>
<td>加锁和解锁不需要额外的消耗，和执行非同步方法仅存在纳秒级的差距</td>
<td>如果线程间存在锁竞争会带来额外的锁撤销的消耗</td>
<td>适用于只有一个线程访问同步块的场景</td>
</tr>
<tr>
<td>轻量级锁</td>
<td>竞争的线程不会阻塞，提高程序的响应速度</td>
<td>如果始终得不到锁，竞争的线程会使用自旋消耗 CPU</td>
<td>追求响应时间，同步块执行时间非常快</td>
</tr>
<tr>
<td>重量级锁</td>
<td>线程竞争不会使用自旋，不消耗 CPU</td>
<td>线程阻塞，响应时间长</td>
<td>追求吞吐量，同步块执行时间较长</td>
</tr>
</tbody></table>
<h4 id="synchronized-和-ReentrantLock"><a href="#synchronized-和-ReentrantLock" class="headerlink" title="synchronized 和 ReentrantLock"></a>synchronized 和 ReentrantLock</h4><p>两者都是可重入锁，“可重入”指的是自己可以再次获取自己的内部锁。</p>
<p>synchronized 依赖 JVM 而 ReentrantLock 依赖于 API，ReentrantLock 需要 lock() 和 unlock() 配合 try/finally 语句块来实现。</p>
<p>ReentrantLock 比 synchronized 增加了一些高级功能</p>
<ul>
<li><p>等待可中断：ReentrantLock 提供了一种能够中断等待锁的机制，通过 lock.lockInterruptibly() 来实现，正在等待的线程可以放弃等待，改为处理其他事情</p>
</li>
<li><p>实现公平锁：公平锁就是先等待的线程先获得锁，synchronized 只能是非公平的，ReentrantLock 默认为非公平的。</p>
</li>
<li><p>可实现选择性通知（锁可以绑定多个条件）：<code>synchronized</code>关键字与<code>wait()</code>和<code>notify()</code>/<code>notifyAll()</code>方法相结合可以实现等待/通知机制。<code>ReentrantLock</code>类当然也可以实现，但是需要借助于<code>Condition</code>接口与<code>newCondition()</code>方法。</p>
</li>
</ul>
<h3 id="volatile-关键字"><a href="#volatile-关键字" class="headerlink" title="volatile 关键字"></a>volatile 关键字</h3><h4 id="JMM（Java-内存模型）"><a href="#JMM（Java-内存模型）" class="headerlink" title="JMM（Java 内存模型）"></a>JMM（Java 内存模型）</h4><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20210902152656544.png" alt="image-20210902152656544"></p>
<p>在 JDK1.2 之前，Java 内存模型总是从<strong>主存</strong>读取变量，不用处理一致性问题。根据JMM的规定，<strong>线程对共享变量的所有操作都必须在⾃⼰的本地内存中进行，不能直接从主内存中读取</strong>。在现在的 Java 内存模型下，线程可以<strong>把变量保存到本地内存（寄存器）中</strong>，而不是直接在主存中读写，这就造成了主存数据和寄存器数据不一致的情况。</p>
<p>要解决这个问题，就需要把变量声明为 volatile，指示 JVM，这个变量是共享且不稳定的，每次使用它都到主存中进行读取。volatile 关键字除了防止 JVM 指令重排，还有一个重要的作用就是保证可见性。</p>
<h4 id="内存可见性"><a href="#内存可见性" class="headerlink" title="内存可见性"></a>内存可见性</h4><p>内存可⻅性，指的是当⼀个线程对 volatile 修饰的变量进⾏写操作时，<strong>JMM会⽴即把该线程对应的本地内存中的共享变量的值刷新到主内 存</strong>；当⼀个线程对 volatile 修饰的变量进⾏读操作时，JMM会把⽴即该线程对应的本地内存置为⽆效，从主内存中读取共享变量的值。 </p>
<h4 id="禁止重排序"><a href="#禁止重排序" class="headerlink" title="禁止重排序"></a>禁止重排序</h4><p>JVM 通过内存屏障实现限制处理器的重排序。在硬件层面，内存屏障分为两种：读屏障（Load Barrier）和写屏障（Store Barrier）。它有两个作用：</p>
<ol>
<li>阻止屏障两侧的指令重排序</li>
<li>强制把 CPU 写缓冲区/高速缓存中的脏数据写回主内存，或者让缓存中的响应数据失效</li>
</ol>
<p>编译器在⽣成字节码时，会在指令序列中插⼊内存屏障来禁⽌特定类型的处理器重排序。编译器选择了⼀个⽐较保守的<strong>JMM</strong>内存屏障插⼊策略，这样可以保证在任何处理器平台，任何程序中都能得到正确的volatile内存语义。</p>
<p>这个策略是： </p>
<ul>
<li><p>在每个volatile写操作前插⼊⼀个StoreStore屏障； </p>
</li>
<li><p>在每个volatile写操作后插⼊⼀个StoreLoad屏障； </p>
</li>
<li><p>在每个volatile读操作后插⼊⼀个LoadLoad屏障； </p>
</li>
<li><p>在每个volatile读操作后再插⼊⼀个LoadStore屏障。 </p>
</li>
</ul>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20210902155135199.png" alt="image-20210902155135199"></p>
<blockquote>
<p>LoadLoad 屏障：在第二个 Load 操作开始前，保证第一个 Load 的数据读取完</p>
<p>StoreStore 屏障：在第二个 Store 操作开始前，保证第一个 Store 的写入操作对其他处理器可见</p>
<p>LoadStore 屏障：在 Store 操作开始前，保证 Load 的数据读取完毕</p>
<p>StoreLoad 屏障：在 Load 操作开始前，保证 Store 的写入对所有处理器可见的（写后读最浪费时间）</p>
</blockquote>
<h4 id="synchronized-和-volatile-的区别"><a href="#synchronized-和-volatile-的区别" class="headerlink" title="==synchronized 和 volatile 的区别=="></a>==synchronized 和 volatile 的区别==</h4><ul>
<li>volatile 是线程同步的轻量级实现，性能比 synchronized 稍好。volatile 只能用于变量，synchronized 关键字可以修饰方法或代码块</li>
<li>volatile 可以保证数据的可见性，但不能保证原子性，synchronized 两者都能保证</li>
<li>volatile 主要解决变量在多个线程之间的可见性，synchronized 解决的是多个线程之间访问资源的同步性</li>
</ul>
<h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h3><p>通常，我们创建的变量可以被任意线程修改，如果香实现每个线程又自己的专属本地变量怎么解决呢？ThreadLocal 类主要解决的就是让每个线程绑定自己的值。</p>
<p>如果你创建了一个 Thread Local 变量，那么访问这个变量的每个线程都会有这个变量的本地副本，这也是 ThreadLocal 变量名的由来，可以使用 get() 和 set() 方法来获取默认值或将其值改为当前线程所存的副本的值，从而避免了线程安全问题。</p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalExample</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// SimpleDateFormat 不是线程安全的，所以每个线程都要有自己独立的副本</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;SimpleDateFormat&gt; formatter = ThreadLocal.withInitial(() -&gt; <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyyMMdd HHmm"</span>));</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ThreadLocalExample obj = <span class="keyword">new</span> ThreadLocalExample();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span> ; i&lt;<span class="number">5</span>; i++)&#123;</span><br><span class="line">            Thread t = <span class="keyword">new</span> Thread(obj, <span class="string">""</span>+i);</span><br><span class="line">            Thread.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">1000</span>));</span><br><span class="line">            t.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Thread Name= "</span>+Thread.currentThread().getName()+<span class="string">" default Formatter = "</span>+formatter.get().toPattern());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">1000</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//formatter pattern is changed here by thread, but it won't reflect to other threads</span></span><br><span class="line">        formatter.set(<span class="keyword">new</span> SimpleDateFormat());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"Thread Name= "</span>+Thread.currentThread().getName()+<span class="string">" formatter = "</span>+formatter.get().toPattern());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输出</span><br><span class="line">Thread Name&#x3D; 0 default Formatter &#x3D; yyyyMMdd HHmm</span><br><span class="line">Thread Name&#x3D; 0 formatter &#x3D; yy-M-d ah:mm</span><br><span class="line">Thread Name&#x3D; 1 default Formatter &#x3D; yyyyMMdd HHmm</span><br><span class="line">Thread Name&#x3D; 1 formatter &#x3D; yy-M-d ah:mm</span><br><span class="line">Thread Name&#x3D; 2 default Formatter &#x3D; yyyyMMdd HHmm</span><br><span class="line">Thread Name&#x3D; 2 formatter &#x3D; yy-M-d ah:mm</span><br><span class="line">Thread Name&#x3D; 3 default Formatter &#x3D; yyyyMMdd HHmm</span><br><span class="line">Thread Name&#x3D; 3 formatter &#x3D; yy-M-d ah:mm</span><br><span class="line">Thread Name&#x3D; 4 default Formatter &#x3D; yyyyMMdd HHmm</span><br><span class="line">Thread Name&#x3D; 4 formatter &#x3D; yy-M-d ah:mm</span><br></pre></td></tr></table></figure>

<p>从输出中可以看出，Thread-0 已经改变了 formatter 的值，但仍然是 thread-2 默认格式化程序与初始化值相同，其他线程也一样。</p>
<h4 id="ThreadLocal-原理"><a href="#ThreadLocal-原理" class="headerlink" title="==ThreadLocal 原理=="></a>==ThreadLocal 原理==</h4><p>我们先看 Thread 类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">     <span class="comment">/* ThreadLocal values pertaining to this thread. This map is maintained</span></span><br><span class="line"><span class="comment">     * by the ThreadLocal class. */</span></span><br><span class="line">    ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * InheritableThreadLocal values pertaining to this thread. This map is</span></span><br><span class="line"><span class="comment">     * maintained by the InheritableThreadLocal class.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ThreadLocal.ThreadLocalMap inheritableThreadLocals = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出 ThreadLocal 副本值存储在线程的 ThreadLocal.ThradLocalMap 中，继续看 ThreadLocalMap </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalMap</span> </span>&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * The entries in this hash map extend WeakReference, using</span></span><br><span class="line"><span class="comment">       * its main ref field as the key (which is always a</span></span><br><span class="line"><span class="comment">       * ThreadLocal object).  Note that null keys (i.e. entry.get()</span></span><br><span class="line"><span class="comment">       * == null) mean that the key is no longer referenced, so the</span></span><br><span class="line"><span class="comment">       * entry can be expunged from table.  Such entries are referred to</span></span><br><span class="line"><span class="comment">       * as "stale entries" in the code that follows.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">          <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">          Object value;</span><br><span class="line"></span><br><span class="line">          Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">              <span class="keyword">super</span>(k);</span><br><span class="line">              value = v;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>ThreadLocal 的 Entry 键值对，key 是 ThradLocal 对象，value 为 Object 对象。</p>
<p>再看 ThreadLocal 类中的 get() 和 set() 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the value in the current thread's copy of this</span></span><br><span class="line"><span class="comment"> * thread-local variable.  If the variable has no value for the</span></span><br><span class="line"><span class="comment"> * current thread, it is first initialized to the value returned</span></span><br><span class="line"><span class="comment"> * by an invocation of the &#123;<span class="doctag">@link</span> #initialValue&#125; method.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the current thread's value of this thread-local</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Sets the current thread's copy of this thread-local variable</span></span><br><span class="line"><span class="comment"> * to the specified value.  Most subclasses will have no need to</span></span><br><span class="line"><span class="comment"> * override this method, relying solely on the &#123;<span class="doctag">@link</span> #initialValue&#125;</span></span><br><span class="line"><span class="comment"> * method to set the values of thread-locals.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value the value to be stored in the current thread's copy of</span></span><br><span class="line"><span class="comment"> *        this thread-local.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Get the map associated with a ThreadLocal. Overridden in</span></span><br><span class="line"><span class="comment"> * InheritableThreadLocal.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  t the current thread</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the map</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 ThreadLocal get() 和 set() 方法都是首先通过 Thread.currentThread() 来获取当前对象 t，进而获取线程的 ThreadLocalMap 对象 t.threadlocals，类似hashmap 操作, get(this) 或者 put(this, value)。</p>
<p>总结：副本值存在每个线程的 ThreadLocalMap 对象中，ThreadLocalMap 存储的键值对，key 为 ThreadLocal 对象，value 为 Object 对象</p>
<h4 id="ThreadLocal-内存泄漏"><a href="#ThreadLocal-内存泄漏" class="headerlink" title="ThreadLocal 内存泄漏"></a>ThreadLocal 内存泄漏</h4><p>ThreadLocalMap 中使用的 key 为 ThreadLocal 的弱引用，而 value 是强引用。如果 ThreadLocal 没有被外部强引用的情况下，在垃圾回收时，key 会被清除掉，而 value 不会知恶扬就会出现 key 为 null 的 Entry。我们不做任何措施的话，value 永远不会被 GC 回收，这样就会产生内存泄漏。</p>
<p>ThreadLocalMap 实现中已经考虑了这种情况，在调用 <code>set()</code>、<code>get()</code>、<code>remove()</code> 方法的时候，会清理掉 key 为 null 的记录。使用完 <code>ThreadLocal</code>方法后 最好手动调用<code>remove()</code>方法，手动删除每个线程的 ThreadLocalMap</p>
<blockquote>
<p>如果一个对象只具有弱引用，那就类似于<strong>可有可无的生活用品</strong>。弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它 所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。</p>
<p>弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java 虚拟机就会把这个弱引用加入到与之关联的引用队列中。</p>
</blockquote>
<h3 id="Atomic-原子类"><a href="#Atomic-原子类" class="headerlink" title="Atomic 原子类"></a>Atomic 原子类</h3><p>Atomic 指一个操作是不可中断的。即使是多个线程一起执行时，一个操作一旦开始，就不会被其他线程干扰。简单来说，原子类就是具有原子/原子操作特征的类。</p>
<p>java.util.concurrent 的原子类都存放在 java.util.concurrent.atomic 下</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20210831141012291.png" alt="image-20210831141012291"></p>
<h4 id="JUC-包原子类是哪-4-类？"><a href="#JUC-包原子类是哪-4-类？" class="headerlink" title="JUC 包原子类是哪 4 类？"></a>JUC 包原子类是哪 4 类？</h4><ol>
<li><p>基本类型，使用原子方式更新基本类型。AtomicInteger、AtomicLong、AtomicBoolean</p>
</li>
<li><p>数组类型，使用原子的方式更新数组里的某个元素。AtomicIntegerArray、AtomicLongArray、AtomicReferenceArray</p>
</li>
<li><p>引用类型</p>
<ul>
<li>AtomicReference：引用类型原子类</li>
<li>AtomicStampedReference：原子更新带有版本号的引用类型。该类将整数值与引用关联起来，可用于解决原子的更新数据和数据的版本号，可以解决使用 CAS 进行原子更新是可能出现的 ABA 问题</li>
<li>AtomicMarkableReference：原子更新带有标记位的引用类型</li>
</ul>
</li>
<li><p>对象的属性修改器</p>
<ul>
<li>AtomicIntegerFieldUpdater：原子更新整形字段的更新器</li>
<li>AtomicLongFieldUpdater：原子更新长整型的更新器</li>
<li>AtomicReferenceFieldUpdator：原子更新引用类型字段的更新器</li>
</ul>
</li>
</ol>
<h4 id="AtomicInteger-的使用"><a href="#AtomicInteger-的使用" class="headerlink" title="AtomicInteger 的使用"></a>AtomicInteger 的使用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> <span class="comment">//获取当前的值</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndSet</span><span class="params">(<span class="keyword">int</span> newValue)</span><span class="comment">//获取当前的值，并设置新的值</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndIncrement</span><span class="params">()</span><span class="comment">//获取当前的值，并自增</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndDecrement</span><span class="params">()</span> <span class="comment">//获取当前的值，并自减</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAdd</span><span class="params">(<span class="keyword">int</span> delta)</span> <span class="comment">//获取当前的值，并加上预期的值</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> <span class="comment">//如果输入的数值等于预期值，则以原子方式将该值设置为输入值（update）</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lazySet</span><span class="params">(<span class="keyword">int</span> newValue)</span><span class="comment">//最终设置为newValue,使用 lazySet 设置之后可能导致其他线程在之后的一小段时间内还是可以读到旧的值。</span></span></span><br></pre></td></tr></table></figure>

<p>使用 AtomicInteger 后不对方法加锁也是线程安全的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class AtomicIntegerTest &#123;</span><br><span class="line">    private AtomicInteger count &#x3D; new AtomicInteger();</span><br><span class="line">    &#x2F;&#x2F;使用AtomicInteger之后，不需要对该方法加锁，也可以实现线程安全。</span><br><span class="line">    public void increment() &#123;</span><br><span class="line">        count.incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getCount() &#123;</span><br><span class="line">        return count.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="AtomicInteger-类的原理"><a href="#AtomicInteger-类的原理" class="headerlink" title="==AtomicInteger 类的原理=="></a>==AtomicInteger 类的原理==</h4><p>AtomicInteger 部分源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// setup to use Unsafe.compareAndSwapInt for updates（更新操作时提供“比较并替换”的作用）</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> valueOffset;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        valueOffset = unsafe.objectFieldOffset</span><br><span class="line">            (AtomicInteger.class.getDeclaredField("value"));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> Error(ex); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, valueOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>AtomicInteger 主要利用 CAS + volatile 和 native 方法来保证原子操作，避免 synchronized 的高开销。这里的 valueOffset 就是 value 在内存中的地址，直接调用 native 方法 compareAndSwapInt 实现 CAS 操作。</p>
<blockquote>
<p>CAS的全称为<code>Compare And Swap</code>，直译就是比较交换。是一条CPU的原子指令，其作用是让<code>CPU</code>先进行比较两个值是否相等，然后原子地更新某个位置的值，其实现方式是给予硬件平台的汇编指令，在<code>intel</code>的<code>CPU</code>中，使用的<code>cmpxchg</code>指令，就是说<code>CAS</code>是靠硬件实现的，从而在硬件层面提升效率。</p>
</blockquote>
<h4 id="CAS存在的问题"><a href="#CAS存在的问题" class="headerlink" title="CAS存在的问题"></a>CAS存在的问题</h4><ol>
<li><strong>ABA 问题</strong><br>所谓ABA问题，就是⼀个值原来是A，变成了B，⼜变回了A。这个时候使⽤CAS是 检查不出变化的，但实际上却被更新了两次。部分乐观锁的实现是通过==<strong>版本号</strong>==（version）的方式来解决ABA问题，<strong>乐观锁每次在执行数据的修改操作时，都会带上一个版本号，一旦版本号和数据的版本号一致就可以执行修改操作并对版本号执行+1操作，否则就执行失败</strong>。因为每次操作的版本号都会随之增加，所以不会出现ABA问题，因为版本号只会增加不会减少。JDK的atomic包⾥提供了⼀个类 AtomicStampedReference 类来解决ABA问题。</li>
<li><strong>循环时间长开销大</strong>。CAS操作如果长时间不成功，会导致其一直自旋，给CPU带来非常大的开销。</li>
<li><strong>只能保证一个共享变量的原子操作</strong>。对一个共享变量执行操作时，CAS能够保证原子操作，但是对多个共享变量操作时，CAS是无法保证操作的原子性的。</li>
</ol>
<h3 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h3><h4 id="原理概览"><a href="#原理概览" class="headerlink" title="原理概览"></a>原理概览</h4><p>*<em>AbstractQueuedSynchronizer *</em> 这个类在 java.util.concurrent.locks 包下面</p>
<p><strong>AQS 核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制 AQS 是用 CLH 队列锁实现的，即将暂时获取不到锁的线程加入到队列中。</strong></p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20210831162636969.png" alt="image-20210831162636969"></p>
<p>AQS 使用一个 int 成员变量来表示同步状态，通过内置的 FIFO 队列来完成获取资源线程的排队工作。AQS 使用 CAS 对该同步状态进行原子操作实现对其值的修改。</p>
<h4 id="AQS-结构"><a href="#AQS-结构" class="headerlink" title="AQS 结构"></a>AQS 结构</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 头结点，你直接把它当做 当前持有锁的线程 可能是最好理解的</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node head;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 阻塞的尾节点，每个新的节点进来，都插入到最后，也就形成了一个链表</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个是最重要的，代表当前锁的状态，0代表没有被占用，大于 0 代表有线程持有当前锁</span></span><br><span class="line"><span class="comment">// 这个值可以大于 1，是因为锁可以重入，每次重入都加上 1</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代表当前持有独占锁的线程，举个最重要的使用例子，因为锁可以重入</span></span><br><span class="line"><span class="comment">// reentrantLock.lock()可以嵌套调用多次，所以每次用这个来判断当前线程是否已经拥有了锁</span></span><br><span class="line"><span class="comment">// if (currentThread == getExclusiveOwnerThread()) &#123;state++&#125;</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Thread exclusiveOwnerThread; <span class="comment">//继承自AbstractOwnableSynchronizer</span></span><br></pre></td></tr></table></figure>

<p>状态信息通过 protected 类型的 getState，setState，compareAndSetState 进行操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回同步状态的当前值</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> state;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//设置同步状态的值</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(<span class="keyword">int</span> newState)</span> </span>&#123;</span><br><span class="line">    state = newState;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//原子地（CAS操作）将同步状态值设置为给定值update如果当前同步状态的值等于expect（期望值）</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSetState</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="AQS-对资源的共享方式"><a href="#AQS-对资源的共享方式" class="headerlink" title="AQS 对资源的共享方式"></a>AQS 对资源的共享方式</h4><ul>
<li><strong>Exclusive</strong>（独占）：只有一个线程执行，如 ReentrantLock，又可分为公平锁和非公平锁</li>
<li><strong>Share</strong>（共享）：多个线程可同时执行，如CountDownLatch，Semaphore、CyclicBarrier、ReadWriteLock</li>
</ul>
<p><code>ReentrantReadWriteLock</code> 可以看成是组合式，因为 <code>ReentrantReadWriteLock</code> 也就是读写锁允许多个线程同时对某一资源进行读。</p>
<p>AQS中关于这两种资源共享模式的定义源码（均在内部类Node中）。我们来看看Node的结构：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 标记⼀个结点（对应的线程）在共享模式下等待</span></span><br><span class="line">      <span class="keyword">static</span> <span class="keyword">final</span> Node SHARED = <span class="keyword">new</span> Node();</span><br><span class="line">      <span class="comment">// 标记⼀个结点（对应的线程）在独占模式下等待</span></span><br><span class="line">      <span class="keyword">static</span> <span class="keyword">final</span> Node EXCLUSIVE = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">// waitStatus的值，表示该结点（对应的线程）已被取消</span></span><br><span class="line">      <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED =  <span class="number">1</span>;</span><br><span class="line"><span class="comment">// waitStatus的值，表示后继结点（对应的线程）需要被唤醒</span></span><br><span class="line">      <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIGNAL    = -<span class="number">1</span>;</span><br><span class="line"><span class="comment">// waitStatus的值，表示该结点（对应的线程）在等待某⼀条件</span></span><br><span class="line">      <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONDITION = -<span class="number">2</span>;</span><br><span class="line"><span class="comment">/*waitStatus的值，表示有资源可⽤，新head结点需要继续唤醒后继结点*/</span></span><br><span class="line">      <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PROPAGATE = -<span class="number">3</span>;</span><br><span class="line">      </span><br><span class="line"><span class="comment">// 等待状态，取值范围，-3，-2，-1，0，1</span></span><br><span class="line">      <span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus;</span><br><span class="line">      <span class="keyword">volatile</span> Node prev; <span class="comment">// 前驱结点</span></span><br><span class="line">      <span class="keyword">volatile</span> Node next; <span class="comment">// 后继结点</span></span><br><span class="line">      <span class="keyword">volatile</span> Thread thread; <span class="comment">// 结点对应的线程</span></span><br><span class="line">      Node nextWaiter; <span class="comment">// 等待队列⾥下⼀个等待条件的结点</span></span><br><span class="line">      </span><br><span class="line"><span class="comment">// 判断共享模式的⽅法</span></span><br><span class="line">      <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> nextWaiter == SHARED;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      Node(Thread thread, Node mode) &#123;     <span class="comment">// Used by addWaiter</span></span><br><span class="line">          <span class="keyword">this</span>.nextWaiter = mode;</span><br><span class="line">          <span class="keyword">this</span>.thread = thread;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      Node(Thread thread, <span class="keyword">int</span> waitStatus) &#123; <span class="comment">// Used by Condition</span></span><br><span class="line">          <span class="keyword">this</span>.waitStatus = waitStatus;</span><br><span class="line">          <span class="keyword">this</span>.thread = thread;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h4 id="AQS-底层使用了模板方法模式"><a href="#AQS-底层使用了模板方法模式" class="headerlink" title="AQS 底层使用了模板方法模式"></a>AQS 底层使用了模板方法模式</h4><p>同步器的设计是基于模板方法模式的，如果需要自定义同步器一般步骤有：</p>
<ol>
<li><p>使用者继承 <code>AbstractQueuedSynchronizer</code> 并重写指定的方法</p>
</li>
<li><p>将 AQS 组合在自定义同步组件的实现中，并调用其模板方法，而这些模板方法会调用使用者重写的方法。</p>
</li>
</ol>
<p>自定义同步器时需要重写下面几个 AQS 提供的模板方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">isHeldExclusively()<span class="comment">//该线程是否正在独占资源。只有用到condition才需要去实现它。</span></span><br><span class="line">tryAcquire(<span class="keyword">int</span>)<span class="comment">//独占方式。尝试获取资源，成功则返回true，失败则返回false。</span></span><br><span class="line">tryRelease(<span class="keyword">int</span>)<span class="comment">//独占方式。尝试释放资源，成功则返回true，失败则返回false。</span></span><br><span class="line">tryAcquireShared(<span class="keyword">int</span>)<span class="comment">//共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</span></span><br><span class="line">tryReleaseShared(<span class="keyword">int</span>)<span class="comment">//共享方式。尝试释放资源，成功则返回true，失败则返回false。</span></span><br></pre></td></tr></table></figure>

<p>一般来说，自定义同步器要么是独占方法，要么是共享方式，他们也只需实现<code>tryAcquire-tryRelease</code>、<code>tryAcquireShared-tryReleaseShared</code>中的一种即可。但 AQS 也支持自定义同步器同时实现独占和共享两种方式，如<code>ReentrantReadWriteLock</code>。</p>
<h4 id="获取资源"><a href="#获取资源" class="headerlink" title="获取资源"></a>获取资源</h4><p>⾸先调⽤tryAcquire(arg)尝试去获取资源，这个⽅法是在<strong>⼦类</strong>具体实现的。如果成功 AQS 的 waitStauts 值变化args, exclusiveOwnerThread 值为当前线程；如果获取资源失败，就通过addWaiter(Node.EXCLUSIVE)⽅法把这个线程插⼊到等待队列中。其中传⼊的参数代表要插⼊的Node是独占式的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp; <span class="comment">// 尝试独占获取锁</span></span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg) <span class="comment">//获锁失败，将当前线程挂起并放入阻塞队列中</span></span><br><span class="line">       )</span><br><span class="line">        selfInterrupt();<span class="comment">//线程中断</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来看 addWaiter 方法，将一个独占模式节点放进队列末尾</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">    <span class="comment">//尝试把 node 加入到链表最后</span></span><br><span class="line">    Node pred = tail;</span><br><span class="line">    <span class="comment">//阻塞队列不为空时</span></span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="comment">// 用CAS把自己设置为队尾, 如果成功后，tail == node 了，这个节点成为阻塞队列新的尾巴</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            <span class="comment">//设置成功，将自己与之前的队尾相连</span></span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="comment">// 线程入队了，可以返回了</span></span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 到这里说明 pred==null(队列是空的) 或者 CAS失败(有线程在竞争入队)</span></span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node t = tail;</span><br><span class="line">        <span class="comment">//队列为空，初始时 head 和 tail 都是 null</span></span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// Must initialize</span></span><br><span class="line">            <span class="comment">//可能有多个进程同时设置 head，需要 CAS设置head</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                tail = head; <span class="comment">//设置 tail，马上 t 就不是 null 了，许多线程要抢了。</span></span><br><span class="line">            				<span class="comment">//注意这里没有返回，下一次循环就要 else 分支了</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//将当前节点加入到队尾，如果 CAS 抢不到就自旋，一直抢，直到成功加入队尾</span></span><br><span class="line">            node.prev = t;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来回到 acquireQueued 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 下面这个方法，参数node，经过addWaiter(Node.EXCLUSIVE)，此时已经进入阻塞队列</span></span><br><span class="line">        <span class="comment">// 注意一下：如果acquireQueued(addWaiter(Node.EXCLUSIVE), arg))返回true的话，</span></span><br><span class="line">        <span class="comment">// 意味着上面这段代码将进入selfInterrupt()，所以正常情况下，下面应该返回false</span></span><br><span class="line">        <span class="comment">// 这个方法非常重要，应该说真正的线程挂起，然后被唤醒后去获取锁，都在这个方法里了</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="comment">// 当前节点的前驱节点为 p</span></span><br><span class="line">                <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">                <span class="comment">// p == head 代表当前节点是阻塞队列第一个，可以尝试抢一下锁</span></span><br><span class="line">                <span class="comment">// 这里我们说一下，为什么可以去试试：</span></span><br><span class="line">                <span class="comment">// 首先，它是队头，这个是第一个条件，其次，当前的head有可能是刚刚初始化的node，</span></span><br><span class="line">                <span class="comment">// enq(node) 方法里面有提到，head是延时初始化的，而且new Node()的时候没有设置任何线程</span></span><br><span class="line">                <span class="comment">// 也就是说，当前的head不属于任何一个线程，所以作为队头，可以去试一试，</span></span><br><span class="line">                <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                    <span class="comment">//当前节点成为 head</span></span><br><span class="line">                    setHead(node);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span> interrupted;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 到这里，说明上面的if分支没有成功，要么当前node本来就不是队头，</span></span><br><span class="line">                <span class="comment">// 要么就是tryAcquire(arg)没有抢赢别人，继续往下看</span></span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())</span><br><span class="line">                    interrupted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//failed 为 true 代表 tryAcquire 抛异常了</span></span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 刚刚说过，会到这里就是没有抢到锁呗，这个方法说的是："当前线程没有抢到锁，是否需要挂起当前线程？"</span></span><br><span class="line">        <span class="comment">// 第一个参数是前驱节点，第二个参数才是代表当前线程的节点</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ws = pred.waitStatus;</span><br><span class="line">        <span class="comment">//前驱节点 waitStatus == - 1，说明前驱节点状态正常，当前线程需要挂起，直接可以返回true</span></span><br><span class="line">        <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 前驱节点 waitStatus大于0 ，之前说过，大于0 说明前驱节点取消了排队。</span></span><br><span class="line">            <span class="comment">// 这里需要知道这点：进入阻塞队列排队的线程会被挂起，而唤醒的操作是由前驱节点完成的。</span></span><br><span class="line">            <span class="comment">// 所以下面这块代码说的是将当前节点的prev指向waitStatus&lt;=0的节点，</span></span><br><span class="line">            <span class="comment">// 简单说，就是为了找个好爹，因为你还得依赖它来唤醒呢，如果前驱节点取消了排队，</span></span><br><span class="line">            <span class="comment">// 找前驱节点的前驱节点做爹，往前遍历总能找到一个好爹的</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                node.prev = pred = pred.prev;</span><br><span class="line">            &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">            pred.next = node;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 仔细想想，如果进入到这个分支意味着什么</span></span><br><span class="line">            <span class="comment">// 前驱节点的waitStatus不等于-1和1，那也就是只可能是0，-2，-3</span></span><br><span class="line">            <span class="comment">// 在我们前面的源码中，都没有看到有设置waitStatus的，所以每个新的node入队时，waitStatu都是0</span></span><br><span class="line">            <span class="comment">// 正常情况下，前驱节点是之前的 tail，那么它的 waitStatus 应该是 0</span></span><br><span class="line">            <span class="comment">// 用CAS将前驱节点的waitStatus设置为Node.SIGNAL(也就是-1)</span></span><br><span class="line">            compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果这个方法返回 false，那么会在 acquireQueued 方法中的 for 循环再走一遍，这次队尾元素前驱节点 waitStatus 一定为 -1，然后会从第一个分支返回 true</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//阻塞当前线程</span></span><br><span class="line">        LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20210902203746074.png" alt="image-20210902203746074"></p>
<h4 id="释放资源"><a href="#释放资源" class="headerlink" title="释放资源"></a>释放资源</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">           Node h = head;</span><br><span class="line">           <span class="comment">//到这里代表锁已经释放了，接下来如果有后继节点则唤醒后继节点，h.waitStatus &lt; 0 代表有等待的后继节点</span></span><br><span class="line">           <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">               unparkSuccessor(h);</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//唤醒一个后面正在等待的节点</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">       <span class="comment">// 如果head节点当前waitStatus&lt;0, 将其修改为0</span></span><br><span class="line">       <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">           compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">       Node s = node.next;</span><br><span class="line">       <span class="comment">//如果阻塞队列第一个节点为空或者该节点取消等待，就队列后面往前找一个正在等待的节点（waitStatus &lt;= 0）</span></span><br><span class="line">       <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           s = <span class="keyword">null</span>;</span><br><span class="line">           <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">               <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                   s = t;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//唤醒节点</span></span><br><span class="line">       <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">           LockSupport.unpark(s.thread);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h4><p>ReentrantLock 可实现公平锁和非公平锁，默认为非公平锁，除非在构造函数中传入参数 true。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 默认非公平锁</span></span><br><span class="line">    sync = <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Reentrant Lock 是独占锁，需要实现 tryAcquire 方法和 tryRelease 方法。首先看 FairSync 和 NonFariSync 的基类 Sync，它提供了基本实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">	<span class="comment">//子类需要实现 lock 方法</span></span><br><span class="line">       <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="comment">//非公平抢锁</span></span><br><span class="line">       <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">           <span class="keyword">int</span> c = getState();</span><br><span class="line">           <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">               <span class="comment">//非公平抢锁，直接开抢，</span></span><br><span class="line">               <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                   setExclusiveOwnerThread(current);</span><br><span class="line">                   <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">               <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">               <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">                   <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">               setState(nextc);</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line">	<span class="comment">//释放锁，非公平锁和公平锁都是通过 AQS 的 release调用此方法</span></span><br><span class="line">       <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">           <span class="comment">//当前进程没有占有锁</span></span><br><span class="line">           <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">           <span class="comment">//是否完全释放锁</span></span><br><span class="line">           <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">           <span class="comment">//完全释放锁之后将占有锁的进程设为空</span></span><br><span class="line">           <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">               free = <span class="keyword">true</span>;</span><br><span class="line">               setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           setState(c);</span><br><span class="line">           <span class="keyword">return</span> free;</span><br><span class="line">       &#125;</span><br><span class="line">	<span class="comment">//当前线程是否独占锁</span></span><br><span class="line">       <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> getExclusiveOwnerThread() == Thread.currentThread();</span><br><span class="line">       &#125;</span><br><span class="line">	<span class="comment">//省略其他方法</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>接下来看 NonFairSync</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="comment">//和公平锁相比，这里会直接先进行一次CAS，成功就返回了</span></span><br><span class="line">          <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">              setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">              acquire(<span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">//直接调用父类方法</span></span><br><span class="line">      <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>再看 FairSync</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">		</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="comment">// state == 0 此时此刻没有线程持有锁</span></span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//虽然锁此时可用，但这是公平锁，先看看有没有别人在队列中等待</span></span><br><span class="line">            <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                    <span class="comment">//没有其他线程在队列中，就用 CAS 尝试获取锁，如果不成功，锁就是被别人抢了（刚才还没有线程持有锁）</span></span><br><span class="line">                compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                <span class="comment">//标记获取到锁的线程是当前线程</span></span><br><span class="line">                setExclusiveOwnerThread(current);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果当前线程已经获得了锁，代表重入了，这里没有并发问题（自己已经有锁了，想怎么改 state 就怎么改）</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">            <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">            <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">            setState(nextc);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//尝试获锁失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：公平锁和非公平锁只有两处不同：</p>
<ol>
<li>非公平锁在调用 lock 后，首先就会调用 CAS 进行一次抢锁，如果这个时候恰巧锁没有被占用，那么直接就获取到锁返回了。</li>
<li>非公平锁在 CAS 失败后，和公平锁一样都会进入到 tryAcquire 方法，在 tryAcquire 方法中，如果发现锁这个时候被释放了（state == 0），非公平锁会直接 CAS 抢锁，但是公平锁会判断等待队列是否有线程处于等待状态，如果有则不去抢锁，乖乖排到后面。</li>
</ol>
<h4 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h4><p>condition 是依赖于 ReentrantLock 的，不管是调用 await 进入等待还是 signal 唤醒，<strong>都必须获取到锁才能进行操作</strong>。每个 ReentrantLock 实例可以通过调用多次 newCondition 方法产生多个 ConditionObject 实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> ConditionObject <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 实例化一个 ConditionObject</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ConditionObject();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们首先来看下我们关注的 Condition 的实现类 <code>AbstractQueuedSynchronizer</code> 类中的 <code>ConditionObject</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConditionObject</span> <span class="keyword">implements</span> <span class="title">Condition</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 条件队列的第一个节点</span></span><br><span class="line">          <span class="comment">// 不要管这里的关键字 transient，是不参与序列化的意思</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">transient</span> Node firstWaiter;</span><br><span class="line">        <span class="comment">// 条件队列的最后一个节点</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">transient</span> Node lastWaiter;</span><br><span class="line">        ......</span><br></pre></td></tr></table></figure>

<p>在介绍 AQS 的时候，我们有一个<strong>阻塞队列</strong>，用于保存等待获取锁的线程的队列，这里引用一个新概念，叫条件队列，如下图：</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20210904194159096.png" alt="image-20210904194159096"></p>
<p>前面 Node 结构中 prev 和 next 域用于实现阻塞队列的双向链表，nextWaiter 用于实现条件队列的单向链表。</p>
<ul>
<li>条件队列和阻塞队列的节点都是 Node 节点，因为条件队列的节点是需要转移到阻塞队列中的。</li>
<li>每个 ReentrantLock 实例可以调用 newCondition 方法来生成多个 Condition 实例，这里对应 condition1 和 condition2，注意 ConditionObject 只有两个属性 firstWaiter 和 lastWaiter。</li>
<li>每个 condition 有一个关联的<strong>条件队列</strong>，如线程 1 调用 <code>condition1.await()</code> 方法即可将当前线程 1 包装成 Node 后加入到条件队列中，然后阻塞在这里，不继续往下执行，条件队列是一个单向链表；</li>
<li>调用<code>condition1.signal()</code> 触发一次唤醒，此时唤醒的是队头，会将condition1 对应的<strong>条件队列</strong>的 firstWaiter（队头） 移到<strong>阻塞队列的队尾</strong>，等待获取锁，获取锁后 await 方法才能返回，继续往下执行。</li>
</ul>
<h4 id="AQS-组件总结"><a href="#AQS-组件总结" class="headerlink" title="AQS 组件总结"></a>AQS 组件总结</h4><ul>
<li><strong><code>Semaphore</code>(信号量)-允许多个线程同时访问：</strong> <code>synchronized</code> 和 <code>ReentrantLock</code> 都是一次只允许一个线程访问某个资源，<code>Semaphore</code>(信号量)可以指定多个线程同时访问某个资源。</li>
<li><strong><code>CountDownLatch</code>（倒计时器）：</strong> <code>CountDownLatch</code> 是一个同步工具类，用来协调多个线程之间的同步。这个工具通常用来控制线程等待，它可以让某一个线程等待直到倒计时结束，再开始执行。</li>
<li><strong><code>CyclicBarrier</code>(循环栅栏)：</strong> <code>CyclicBarrier</code> 和 <code>CountDownLatch</code> 非常类似，它也可以实现线程间的技术等待，但是它的功能比 <code>CountDownLatch</code> 更加复杂和强大。让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程继续执行。</li>
</ul>
<h4 id="CountDownLatch-怎么用的？"><a href="#CountDownLatch-怎么用的？" class="headerlink" title="CountDownLatch 怎么用的？"></a>CountDownLatch 怎么用的？</h4><p>多线程同时处理多个文件，等待多个文件处理完后返回所有的处理结果。还可以使用 <code>CompletableFuture</code> 类来改进！Java8 的 <code>CompletableFuture</code> 提供了很多对多线程友好的方法。</p>
<h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><h4 id="为什么要用线程池？"><a href="#为什么要用线程池？" class="headerlink" title="为什么要用线程池？"></a>为什么要用线程池？</h4><ol>
<li>降低资源消耗。通知重复利用已创建的线程降低线程创建和销毁造成的消耗</li>
<li>提高响应速度。当任务到达时，任务可以不需要等待线程创建</li>
<li>提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一分配、调优和监控</li>
</ol>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20210831164907239.png" alt="image-20210831164907239"></p>
<h4 id="实现-Runnable-和-Callable-接口的区别"><a href="#实现-Runnable-和-Callable-接口的区别" class="headerlink" title="实现 Runnable 和 Callable 接口的区别"></a>实现 Runnable 和 Callable 接口的区别</h4><p>Callable 接口引入是为了处理 Runnable 不支持的用例。Runnable 接口不会返回结果或抛出异常，Callable 接口可以。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 被线程执行，没有返回值也无法抛出异常</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callable</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 计算结果，或在无法这样做时抛出异常。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 计算得出的结果</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> 如果无法计算结果，则抛出异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">V <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="执行-execute-方法和-submit-方法的区别是什么？"><a href="#执行-execute-方法和-submit-方法的区别是什么？" class="headerlink" title="执行 execute() 方法和 submit() 方法的区别是什么？"></a>执行 execute() 方法和 submit() 方法的区别是什么？</h4><ol>
<li>execute() 方法用于提交不需要返回值的任务，无法判断任务是否被线程池成功执行与否</li>
<li>submit() 方法用于提交需要返回值的任务，线程池会返回一个 Future 对象，通过这个 Future 对象可以判断任务是否执行成功，并且可以通过 Future 的 get() 方法来获取返回值，get() 方法会阻塞当前线程直到任务完成。</li>
</ol>
<p>我们以 <strong><code>AbstractExecutorService</code> 接口</strong> 中的一个 <code>submit</code> 方法为例子来看看源代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, <span class="keyword">null</span>);</span><br><span class="line">    execute(ftask);</span><br><span class="line">    <span class="keyword">return</span> ftask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面方法调用的 <code>newTaskFor</code> 方法返回了一个 <code>FutureTask</code> 对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">RunnableFuture&lt;T&gt; <span class="title">newTaskFor</span><span class="params">(Runnable runnable, T value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FutureTask&lt;T&gt;(runnable, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="如何创建线程池"><a href="#如何创建线程池" class="headerlink" title="如何创建线程池"></a>如何创建线程池</h4><p>通常不建议使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式。</p>
<blockquote>
<p>Executors 返回线程池对象的弊端如下：</p>
<ul>
<li><strong>FixedThreadPool 和 SingleThreadExecutor</strong> ： 允许请求的队列长度为 Integer.MAX_VALUE ，可能堆积大量的请求，从而导致 OOM。</li>
<li><strong>CachedThreadPool 和 ScheduledThreadPool</strong> ： 允许创建的线程数量为 Integer.MAX_VALUE ，可能会创建大量线程，从而导致 OOM。</li>
</ul>
</blockquote>
<p>通过构造方法实现</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20210830203732695.png" alt="image-20210830203732695"></p>
<h4 id="ThreadPoolExecutors-类分析"><a href="#ThreadPoolExecutors-类分析" class="headerlink" title="ThreadPoolExecutors 类分析"></a>ThreadPoolExecutors 类分析</h4><p>这里分析最后一个最长的构造函数，其余三个都是在这个构造方法基础上产生。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用给定的初始参数创建一个新的ThreadPoolExecutor。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                      TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                      BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                      ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                      RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">        keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || handler == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">    <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">    <span class="keyword">this</span>.workQueue = workQueue;</span><br><span class="line">    <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">    <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">    <span class="keyword">this</span>.handler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ThreadPoolExecutor 3 个最重要的参数：</p>
<ul>
<li>corePoolSize：核心线程数定义了最小可以同时运行的线程数量</li>
<li>maximumPoolSize：当队列中存放的任务达到队列容量时，当前可以同时运行的线程数量变为最大线程数。</li>
<li>workQueue：当新任务来时，会判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被放到队列中</li>
</ul>
<p>其他常见参数</p>
<ol>
<li>keepAliveTime，当线程池中的线程数量大于 corePoolSize 时，如果没有新的任务提交，<strong>核心线程外的线程不会立即销毁而是等待时间超过了 keepAliveTime 后被回收销毁</strong></li>
<li>unit，keepAliveTime 参数的时间单位</li>
<li>threadFactory，executor 创建新线程会用到</li>
<li>handler，饱和策略</li>
</ol>
<h4 id="ThreadPoolExecutor-饱和策略"><a href="#ThreadPoolExecutor-饱和策略" class="headerlink" title="ThreadPoolExecutor 饱和策略"></a>ThreadPoolExecutor 饱和策略</h4><p>当同时运行的线程数量达到 maximumPoolSize 时，且队列也满时，ThreadPoolTaskExecutor 定义一些策略：</p>
<ul>
<li><p>ThreadPoolExecutor.AbortPolicy：抛出 RejectExecutionException 来拒绝新任务的处理</p>
</li>
<li><p>ThreadPoolExecutor.CallerRunsPolicy： 调用执行自己的线程运行任务，也就是直接在调用<code>execute</code>方法的线程中运行(<code>run</code>)被拒绝的任务，如果执行程序已关闭，则会丢弃该任务。因此这种策略会降低对于新任务提交速度，影响程序的整体性能。</p>
</li>
<li><p>ThreadPoolExecutor.DiscardPolicy：不处理新任务，直接丢弃掉</p>
</li>
<li><p>ThreadPoolExecutor.DiscardOldestPolicy：丢弃最早未处理的任务请求</p>
</li>
</ul>
<h4 id="线程池Demo"><a href="#线程池Demo" class="headerlink" title="线程池Demo"></a>线程池Demo</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Runnable r = () -&gt; &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" Start. Time = "</span> + <span class="keyword">new</span> Date());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" End. Time = "</span> + <span class="keyword">new</span> Date());</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    ThreadPoolExecutor executor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">5</span>, <span class="number">10</span>, <span class="number">1L</span>, TimeUnit.SECONDS,</span><br><span class="line">            <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">100</span>), <span class="keyword">new</span> ThreadPoolExecutor.CallerRunsPolicy());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        executor.execute(r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//终止线程池</span></span><br><span class="line">    executor.shutdown();</span><br><span class="line">    <span class="keyword">while</span> (!executor.isTerminated()) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"Finished all threads"</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">输出：</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span> Start. Time = Mon Aug <span class="number">30</span> <span class="number">21</span>:<span class="number">13</span>:<span class="number">45</span> CST <span class="number">2021</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span> Start. Time = Mon Aug <span class="number">30</span> <span class="number">21</span>:<span class="number">13</span>:<span class="number">45</span> CST <span class="number">2021</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">4</span> Start. Time = Mon Aug <span class="number">30</span> <span class="number">21</span>:<span class="number">13</span>:<span class="number">45</span> CST <span class="number">2021</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">3</span> Start. Time = Mon Aug <span class="number">30</span> <span class="number">21</span>:<span class="number">13</span>:<span class="number">45</span> CST <span class="number">2021</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">5</span> Start. Time = Mon Aug <span class="number">30</span> <span class="number">21</span>:<span class="number">13</span>:<span class="number">45</span> CST <span class="number">2021</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">3</span> End. Time = Mon Aug <span class="number">30</span> <span class="number">21</span>:<span class="number">13</span>:<span class="number">50</span> CST <span class="number">2021</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span> End. Time = Mon Aug <span class="number">30</span> <span class="number">21</span>:<span class="number">13</span>:<span class="number">50</span> CST <span class="number">2021</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">4</span> End. Time = Mon Aug <span class="number">30</span> <span class="number">21</span>:<span class="number">13</span>:<span class="number">50</span> CST <span class="number">2021</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">3</span> Start. Time = Mon Aug <span class="number">30</span> <span class="number">21</span>:<span class="number">13</span>:<span class="number">50</span> CST <span class="number">2021</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">4</span> Start. Time = Mon Aug <span class="number">30</span> <span class="number">21</span>:<span class="number">13</span>:<span class="number">50</span> CST <span class="number">2021</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span> End. Time = Mon Aug <span class="number">30</span> <span class="number">21</span>:<span class="number">13</span>:<span class="number">50</span> CST <span class="number">2021</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">5</span> End. Time = Mon Aug <span class="number">30</span> <span class="number">21</span>:<span class="number">13</span>:<span class="number">50</span> CST <span class="number">2021</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span> Start. Time = Mon Aug <span class="number">30</span> <span class="number">21</span>:<span class="number">13</span>:<span class="number">50</span> CST <span class="number">2021</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span> Start. Time = Mon Aug <span class="number">30</span> <span class="number">21</span>:<span class="number">13</span>:<span class="number">50</span> CST <span class="number">2021</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">5</span> Start. Time = Mon Aug <span class="number">30</span> <span class="number">21</span>:<span class="number">13</span>:<span class="number">50</span> CST <span class="number">2021</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">4</span> End. Time = Mon Aug <span class="number">30</span> <span class="number">21</span>:<span class="number">13</span>:<span class="number">55</span> CST <span class="number">2021</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span> End. Time = Mon Aug <span class="number">30</span> <span class="number">21</span>:<span class="number">13</span>:<span class="number">55</span> CST <span class="number">2021</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span> End. Time = Mon Aug <span class="number">30</span> <span class="number">21</span>:<span class="number">13</span>:<span class="number">55</span> CST <span class="number">2021</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">3</span> End. Time = Mon Aug <span class="number">30</span> <span class="number">21</span>:<span class="number">13</span>:<span class="number">55</span> CST <span class="number">2021</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">5</span> End. Time = Mon Aug <span class="number">30</span> <span class="number">21</span>:<span class="number">13</span>:<span class="number">55</span> CST <span class="number">2021</span></span><br><span class="line">Finished all threads</span><br><span class="line">Finished all threads</span><br></pre></td></tr></table></figure>

<h4 id="线程池原理分析"><a href="#线程池原理分析" class="headerlink" title="==线程池原理分析=="></a>==线程池原理分析==</h4><p>上面 Demo 可以看出，共 10 个任务，线程池先执行 5 个，等待这些任务结束后，继续执行剩下的 5 个任务。</p>
<p>我们看看 execute(worker) 源码 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 存放线程池的运行状态 (runState) 和线程池内有效线程的数量 (workerCount)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">workerCountOf</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c &amp; CAPACITY;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;Runnable&gt; workQueue;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果任务为null，则抛出异常。</span></span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">// ctl 中保存的线程池当前的一些状态信息</span></span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  下面会涉及到 3 步 操作</span></span><br><span class="line">    <span class="comment">// 1.首先判断当前线程池中执行的任务数量是否小于 corePoolSize</span></span><br><span class="line">    <span class="comment">// 如果小于的话，通过addWorker(command, true)新建一个线程，并将任务(command)添加到该线程中；然后，启动该线程从而执行任务。</span></span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2.如果当前执行的任务数量大于等于 corePoolSize 的时候就会走到这里</span></span><br><span class="line">    <span class="comment">// 通过 isRunning 方法判断线程池状态，线程池处于 RUNNING 状态才会被并且队列可以加入任务，该任务才会被加入进去</span></span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">        <span class="comment">// 再次获取线程池状态，如果线程池状态不是 RUNNING 状态就需要从任务队列中移除任务，并尝试判断线程是否全部执行完毕。同时执行拒绝策略。</span></span><br><span class="line">        <span class="keyword">if</span> (!isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            reject(command);</span><br><span class="line">            <span class="comment">// 如果当前线程池为空就新创建一个线程并执行。</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">            addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3. 通过addWorker(command, false)新建一个线程，并将任务(command)添加到该线程中；然后，启动该线程从而执行任务。</span></span><br><span class="line">    <span class="comment">//如果addWorker(command, false)执行失败，则通过reject()执行相应的拒绝策略的内容。</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20210830211740198.png" alt="image-20210830211740198"></p>
<h4 id="线程池大小确定"><a href="#线程池大小确定" class="headerlink" title="==线程池大小确定=="></a>==线程池大小确定==</h4><p>有一个简单并且适用面比较广的公式：</p>
<ul>
<li><strong>CPU 密集型任务(N+1)：</strong> 这种任务消耗的主要是 CPU 资源，可以将线程数设置为 N（CPU 核心数）+1，<strong>比 CPU 核心数多出来的一个线程是为了防止线程偶发的缺页中断，或者其它原因导致的任务暂停而带来的影响</strong>。一旦任务暂停，CPU 就会处于空闲状态，而在这种情况下多出来的一个线程就可以充分利用 CPU 的空闲时间。</li>
<li><strong>I/O 密集型任务(2N)：</strong> 这种任务应用起来，系统会用大部分的时间来处理 I/O 交互，<strong>而线程在处理 I/O 的时间段内不会占用 CPU 来处理，这时就可以将 CPU 交出给其它线程使用</strong>。因此在 I/O 密集型任务的应用中，我们可以多配置一些线程，具体的计算方法是 2N。</li>
</ul>
<p><strong>如何判断是 CPU 密集任务还是 IO 密集任务？</strong></p>
<p>CPU 密集型简单理解就是利用 CPU 计算能力的任务比如你在内存中对大量数据进行排序。单凡涉及到网络读取，文件读取这类都是 IO 密集型，这类任务的特点是 CPU 计算耗费时间相比于等待 IO 操作完成的时间来说很少，大部分时间都花在了等待 IO 操作完成上。</p>
<h4 id="四种常见的线程池"><a href="#四种常见的线程池" class="headerlink" title="四种常见的线程池"></a>四种常见的线程池</h4><h5 id="newCachedThreadPool"><a href="#newCachedThreadPool" class="headerlink" title="newCachedThreadPool"></a>newCachedThreadPool</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> 	<span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,  <span class="comment">//核心池大小 0，最大池大小为整型最大可能导致 OOM</span></span><br><span class="line">								 <span class="number">60L</span>, TimeUnit.SECONDS, <span class="comment">// keepAliveTime 60s</span></span><br><span class="line"> 								<span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;()); <span class="comment">//SynchronousQueue队列</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="newFixedThreadPool"><a href="#newFixedThreadPool" class="headerlink" title="newFixedThreadPool"></a>newFixedThreadPool</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line"> 	<span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads, <span class="comment">//核心池和最大池大小都是传入的参数，只能创建核心线程</span></span><br><span class="line"> 									<span class="number">0L</span>, TimeUnit.MILLISECONDS,<span class="comment">//只能创建核心线程 keepAliveTime 也没啥用</span></span><br><span class="line"> 					<span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()); <span class="comment">//LinkedBlockingQueue的默认⼤⼩Integer.MAX_VALUE</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="newSingleThreadExecutor"><a href="#newSingleThreadExecutor" class="headerlink" title="newSingleThreadExecutor"></a><strong>newSingleThreadExecutor</strong></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> 	<span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService(<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,<span class="comment">//核心池和最大池大小都是1</span></span><br><span class="line"> 											<span class="number">0L</span>, TimeUnit.MILLISECONDS,<span class="comment">//只能创建核心线程 keepAliveTime 也没啥用</span></span><br><span class="line"> 			<span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;())); <span class="comment">//所有任务按照FIFO执行，任务队列大小默认为Integer.MAX_VALUE</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="newScheduledThreadPool"><a href="#newScheduledThreadPool" class="headerlink" title="newScheduledThreadPool"></a><strong>newScheduledThreadPool</strong></h5><p>创建⼀个定⻓线程池，⽀持定时及周期性任务执⾏。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize</span></span></span><br><span class="line"><span class="function"><span class="params"> return new ScheduledThreadPoolExecutor(corePoolSize)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//ScheduledThreadPoolExecutor():</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ScheduledThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">super</span>(corePoolSize, Integer.MAX_VALUE,   <span class="comment">//核心池大小 corePoolSize，最大池大小为整型最大可能导致 OOM</span></span><br><span class="line"> DEFAULT_KEEPALIVE_MILLIS, MILLISECONDS,</span><br><span class="line"> <span class="keyword">new</span> DelayedWorkQueue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h3><p>BlockingQueue⼀般⽤于⽣产者-消费者模式，⽣产者是往队列⾥添加元素的线程， 消费者是从队列⾥拿元素的线程。<strong>BlockingQueue</strong>就是存放元素的容器。 </p>
<h4 id="BlockingQueue-的操作方法"><a href="#BlockingQueue-的操作方法" class="headerlink" title="BlockingQueue 的操作方法"></a>BlockingQueue 的操作方法</h4><p>阻塞队列提供了四组不同的方法用于插入、移除、检查元素：</p>
<table>
<thead>
<tr>
<th>方法/处理方式</th>
<th>抛出异常</th>
<th>返回特殊值</th>
<th>一直阻塞</th>
<th>超时退出</th>
</tr>
</thead>
<tbody><tr>
<td>插入方法</td>
<td>add(e)</td>
<td>offer(e)</td>
<td>put(e)</td>
<td>offer(e, time, unit)</td>
</tr>
<tr>
<td>移除方法</td>
<td>remove</td>
<td>poll()</td>
<td>take()</td>
<td>poll(time, unit)</td>
</tr>
<tr>
<td>检查方法</td>
<td>element()</td>
<td>peek()</td>
<td>-</td>
<td>-</td>
</tr>
</tbody></table>
<ul>
<li>抛出异常：当队列满时插入元素，抛出IllegalStateException(“Queue full”)异常，当队列为空取元素，抛出NoSuchElementException异常</li>
<li>返回特殊值：一般为 true/false</li>
<li>一直阻塞：试图的操作无法立即执行，一直阻塞</li>
<li>超时退出，阻塞超过一定时间后，返回一个特定值告知该操作是否完成</li>
</ul>
<p>注意：不能往阻塞队列中插入 null</p>
<h4 id="BlockingQueue-的实现类"><a href="#BlockingQueue-的实现类" class="headerlink" title="BlockingQueue 的实现类"></a>BlockingQueue 的实现类</h4><h5 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h5><p>由数组结构组成的有界阻塞队列。内部结构是数组，故具有数组的特性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity, <span class="keyword">boolean</span> fair)</span></span>&#123;</span><br><span class="line"> <span class="comment">//..省略代码 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以初始化队列⼤⼩， 且⼀旦初始化不能改变。构造⽅法中的fair表示控制对象的 内部锁是否采⽤公平锁，默认是⾮公平锁。</p>
<h5 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a><strong>LinkedBlockingQueue</strong></h5><p>由链表结构组成的有界阻塞队列。内部结构是链表，具有链表的特性。默认队列的 ⼤⼩是 Integer.MAX_VALUE ，也可以指定⼤⼩。此队列按照先进先出的原则对元素 进⾏排序。</p>
<h5 id="DelayQueue"><a href="#DelayQueue" class="headerlink" title="DelayQueue"></a><strong>DelayQueue</strong></h5><p>该队列中的元素只有当其指定的延迟时间到了，才能够从队列中获取到该元素 。注⼊其中的元素必须实现 Delayed 接口。DelayQueue是⼀个没有⼤⼩限制的队列，因此往队列中插⼊数据的操作（⽣产者）永远不会被阻塞。</p>
<h5 id="PriorityBlockingQueue"><a href="#PriorityBlockingQueue" class="headerlink" title="PriorityBlockingQueue"></a><strong>PriorityBlockingQueue</strong></h5><p>基于优先级的⽆界阻塞队列（优先级的判断通过构造函数传⼊的Compator对象来决定）</p>
<h5 id="SynchronousQueue"><a href="#SynchronousQueue" class="headerlink" title="SynchronousQueue"></a><strong>SynchronousQueue</strong></h5><p>这个队列⽐较特殊，没有任何内部容量，甚⾄连⼀个队列的容量都没有。并且每个put 必须等待⼀个 take，反之亦然。 </p>
<p><strong>==注意==</strong></p>
<p><strong>PriorityBlockingQueue</strong>不会阻塞数据⽣产者（因为队列是⽆界的），⽽只会在没 有可消费的数据时，阻塞数据的消费者。因此使⽤的时候要特别注意，⽣产者⽣产数据的速度绝对不能快于消费者消费数据的速度，否则时间⼀⻓，会最终耗尽所有 的可⽤堆内存空间。对于使⽤默认⼤⼩的<strong>LinkedBlockingQueue</strong>也是⼀样的。 </p>
<h4 id="阻塞队列原理"><a href="#阻塞队列原理" class="headerlink" title="阻塞队列原理"></a>阻塞队列原理</h4><p>阻塞队列的原理很简单，利⽤了Lock锁的多条件（Condition）阻塞控制。接下来我们分析ArrayBlockingQueue JDK 1.8 的源码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数据元素数组</span></span><br><span class="line"><span class="keyword">final</span> Object[] items;</span><br><span class="line"><span class="comment">//下⼀个待取出元素索引</span></span><br><span class="line"><span class="keyword">int</span> takeIndex;</span><br><span class="line"><span class="comment">//下⼀个待添加元素索引</span></span><br><span class="line"><span class="keyword">int</span> putIndex;</span><br><span class="line"><span class="comment">//元素个数</span></span><br><span class="line"><span class="keyword">int</span> count;</span><br><span class="line"><span class="comment">//内部锁</span></span><br><span class="line"><span class="keyword">final</span> ReentrantLock lock;</span><br><span class="line"><span class="comment">//消费者监视器</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty;</span><br><span class="line"><span class="comment">//⽣产者监视器</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notFull; </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity, <span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line"> <span class="comment">//..省略其他代码</span></span><br><span class="line"> lock = <span class="keyword">new</span> ReentrantLock(fair);</span><br><span class="line"> notEmpty = lock.newCondition();</span><br><span class="line"> notFull = lock.newCondition();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="put-方法"><a href="#put-方法" class="headerlink" title="put 方法"></a>put 方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">     checkNotNull(e);</span><br><span class="line">     <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">     <span class="comment">// 1.⾃旋拿锁</span></span><br><span class="line">     lock.lockInterruptibly();</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">// 2.判断队列是否满了</span></span><br><span class="line">         <span class="keyword">while</span> (count == items.length)</span><br><span class="line">             <span class="comment">// 2.1如果满了，阻塞该线程，并标记为notFull线程，</span></span><br><span class="line">             <span class="comment">// 等待notFull的唤醒，唤醒之后继续执⾏while循环。</span></span><br><span class="line">             notFull.await();</span><br><span class="line">         <span class="comment">// 3.如果没有满，则进⼊队列</span></span><br><span class="line">         enqueue(e);</span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">         lock.unlock();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(E x)</span> </span>&#123;</span><br><span class="line">     <span class="comment">// assert lock.getHoldCount() == 1;</span></span><br><span class="line">     <span class="comment">// assert items[putIndex] == null;</span></span><br><span class="line">     <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line">     items[putIndex] = x;</span><br><span class="line">     <span class="keyword">if</span> (++putIndex == items.length)</span><br><span class="line">         putIndex = <span class="number">0</span>;</span><br><span class="line">     count++;</span><br><span class="line">     <span class="comment">// 4 唤醒⼀个等待的线程</span></span><br><span class="line">     notEmpty.signal();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="take-方法"><a href="#take-方法" class="headerlink" title="take 方法"></a>take 方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">     <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    <span class="comment">//自旋拿锁</span></span><br><span class="line">     lock.lockInterruptibly();</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="keyword">while</span> (count == <span class="number">0</span>)</span><br><span class="line">             notEmpty.await(); <span class="comment">//队列为空，阻塞该线程，直到队列不为空</span></span><br><span class="line">         <span class="keyword">return</span> dequeue();</span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">         lock.unlock();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="comment">// assert lock.getHoldCount() == 1;</span></span><br><span class="line"> <span class="comment">// assert items[takeIndex] != null;</span></span><br><span class="line">     <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line">     <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">     E x = (E) items[takeIndex];</span><br><span class="line">     items[takeIndex] = <span class="keyword">null</span>;</span><br><span class="line">     <span class="keyword">if</span> (++takeIndex == items.length)</span><br><span class="line">         takeIndex = <span class="number">0</span>;</span><br><span class="line">     count--;</span><br><span class="line">     <span class="keyword">if</span> (itrs != <span class="keyword">null</span>)</span><br><span class="line">         itrs.elementDequeued();</span><br><span class="line">     notFull.signal();<span class="comment">//唤醒一个等待的线程</span></span><br><span class="line">     <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="使用场景：生产者消费者"><a href="#使用场景：生产者消费者" class="headerlink" title="使用场景：生产者消费者"></a>使用场景：生产者消费者</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ArrayBlockingQueue&lt;Integer&gt; q = <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">10</span>);</span><br><span class="line">    Thread consumer = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">"取走："</span> + q.take() + <span class="string">" 剩余："</span> + q.size());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    Thread producer = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Integer num = (<span class="keyword">int</span>) (Math.random() * <span class="number">100</span>);</span><br><span class="line">                q.put(num);</span><br><span class="line">                System.out.println(<span class="string">"装入："</span> + num + <span class="string">" 剩余："</span> + q.size());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    producer.start();</span><br><span class="line">    consumer.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="锁接口和类"><a href="#锁接口和类" class="headerlink" title="锁接口和类"></a>锁接口和类</h3><h4 id="synchronized-不足之处"><a href="#synchronized-不足之处" class="headerlink" title="synchronized 不足之处"></a>synchronized 不足之处</h4><ul>
<li>如果临界区是只读的，synchronized 排他锁效率较低</li>
<li>synchronized 不知道线程有没有成功获得锁</li>
<li>使用 synchronized ，如果临界区阻塞，当前线程又没有释放锁，就会导致所有线程等待。</li>
</ul>
<h4 id="锁分类"><a href="#锁分类" class="headerlink" title="锁分类"></a>锁分类</h4><h5 id="可重入和非重入锁"><a href="#可重入和非重入锁" class="headerlink" title="可重入和非重入锁"></a>可重入和非重入锁</h5><p>支持线程对资源重复加锁，成为可重入锁。synchronized 也是可重入锁、ReentrantLock 也是可重入锁。</p>
<h5 id="公平锁和非公平锁"><a href="#公平锁和非公平锁" class="headerlink" title="公平锁和非公平锁"></a>公平锁和非公平锁</h5><p>按请求锁的顺序拥有锁，反之锁就是不公平的。非公平锁能提升一定的效率，但可能导致线程饥饿。ReentrantLock 支持公平和非公平锁。</p>
<h5 id="读写锁和排他锁"><a href="#读写锁和排他锁" class="headerlink" title="读写锁和排他锁"></a>读写锁和排他锁</h5><p>synchronized 和 ReentrantLock 都是排他锁，这些锁只允许一个线程进行访问。 Java 提供 ReentrantReadWriteLock 作为读写锁，内部维护了一个读锁和一个写锁，在读多写少的环境下，提高了性能。</p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/07/31/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%80%BB%E7%BB%93/" rel="prev" title="动态规划总结">
      <i class="fa fa-chevron-left"></i> 动态规划总结
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Java"><span class="nav-number">1.</span> <span class="nav-text">Java</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#基础"><span class="nav-number">1.1.</span> <span class="nav-text">基础</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Java-语言特点"><span class="nav-number">1.1.1.</span> <span class="nav-text">Java 语言特点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JVM-vs-JDK-vs-JRE"><span class="nav-number">1.1.2.</span> <span class="nav-text">JVM vs JDK vs JRE</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#JVM"><span class="nav-number">1.1.2.1.</span> <span class="nav-text">JVM</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JDK"><span class="nav-number">1.1.2.2.</span> <span class="nav-text">JDK</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JRE"><span class="nav-number">1.1.2.3.</span> <span class="nav-text">JRE</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java-语言“编译与解释并存”"><span class="nav-number">1.1.3.</span> <span class="nav-text">Java 语言“编译与解释并存”</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java-与-C-的区别"><span class="nav-number">1.1.4.</span> <span class="nav-text">Java 与 C++ 的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#关键字"><span class="nav-number">1.1.5.</span> <span class="nav-text">关键字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#泛型"><span class="nav-number">1.1.6.</span> <span class="nav-text">泛型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#泛型类"><span class="nav-number">1.1.6.1.</span> <span class="nav-text">泛型类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#泛型接口"><span class="nav-number">1.1.6.2.</span> <span class="nav-text">泛型接口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#泛型方法"><span class="nav-number">1.1.6.3.</span> <span class="nav-text">泛型方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#和-equals-的区别"><span class="nav-number">1.1.7.</span> <span class="nav-text">&#x3D;&#x3D;&#x3D;&#x3D; 和 equals 的区别&#x3D;&#x3D;</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#hashCode-和-equals"><span class="nav-number">1.1.8.</span> <span class="nav-text">&#x3D;&#x3D;hashCode 和 equals&#x3D;&#x3D;</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#为什么重写-equals-方法时必须重写-hashCode-方法？"><span class="nav-number">1.1.9.</span> <span class="nav-text">&#x3D;&#x3D;为什么重写 equals 方法时必须重写 hashCode 方法？&#x3D;&#x3D;</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#基本数据类型"><span class="nav-number">1.1.10.</span> <span class="nav-text">基本数据类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#在一个静态方法内调用一个非静态方法为什么是非法的？"><span class="nav-number">1.1.11.</span> <span class="nav-text">在一个静态方法内调用一个非静态方法为什么是非法的？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#静态方法和实例方法有何不同？"><span class="nav-number">1.1.12.</span> <span class="nav-text">静态方法和实例方法有何不同？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#为什么-Java-中只有值传递？"><span class="nav-number">1.1.13.</span> <span class="nav-text">为什么 Java 中只有值传递？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#重载和重写的区别"><span class="nav-number">1.1.14.</span> <span class="nav-text">重载和重写的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java-面向对象"><span class="nav-number">1.1.15.</span> <span class="nav-text">Java 面向对象</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#面向过程和面向对象"><span class="nav-number">1.1.15.1.</span> <span class="nav-text">面向过程和面向对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#成员变量和局部变量的区别"><span class="nav-number">1.1.15.2.</span> <span class="nav-text">成员变量和局部变量的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#一个类的构造方法的作用是什么？若一个类没有声明构造方法，该程序能正确执行吗？"><span class="nav-number">1.1.15.3.</span> <span class="nav-text">一个类的构造方法的作用是什么？若一个类没有声明构造方法，该程序能正确执行吗？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#构造方法有哪些特点？是否可被重写？"><span class="nav-number">1.1.15.4.</span> <span class="nav-text">构造方法有哪些特点？是否可被重写？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#面向对象三大特征"><span class="nav-number">1.1.15.5.</span> <span class="nav-text">面向对象三大特征</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#StringBuffer-和-StringBuilder-的区别是什么？String-为什么是不可变的？"><span class="nav-number">1.1.15.6.</span> <span class="nav-text">StringBuffer 和 StringBuilder 的区别是什么？String 为什么是不可变的？</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#不可变性"><span class="nav-number">1.1.15.6.1.</span> <span class="nav-text">不可变性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#线程安全性"><span class="nav-number">1.1.15.6.2.</span> <span class="nav-text">线程安全性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#性能"><span class="nav-number">1.1.15.6.3.</span> <span class="nav-text">性能</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#总结"><span class="nav-number">1.1.15.6.4.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Object-类的常见方法总结"><span class="nav-number">1.1.15.7.</span> <span class="nav-text">&#x3D;&#x3D;Object 类的常见方法总结&#x3D;&#x3D;</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#反射"><span class="nav-number">1.1.16.</span> <span class="nav-text">反射</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#定义"><span class="nav-number">1.1.16.1.</span> <span class="nav-text">定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#优缺点"><span class="nav-number">1.1.16.2.</span> <span class="nav-text">优缺点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#应用场景"><span class="nav-number">1.1.16.3.</span> <span class="nav-text">应用场景</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#异常"><span class="nav-number">1.1.17.</span> <span class="nav-text">异常</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#层次结构图"><span class="nav-number">1.1.17.1.</span> <span class="nav-text">层次结构图</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#try-catch-finally"><span class="nav-number">1.1.17.2.</span> <span class="nav-text">try-catch-finally</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用-try-with-resource-来代替-try-catch-finally"><span class="nav-number">1.1.17.3.</span> <span class="nav-text">使用 try-with-resource 来代替 try-catch-finally</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#I-O-流"><span class="nav-number">1.1.18.</span> <span class="nav-text">I&#x2F;O 流</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#序列化与反序列化"><span class="nav-number">1.1.18.1.</span> <span class="nav-text">序列化与反序列化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Java-中有些字段不想进行序列化"><span class="nav-number">1.1.18.2.</span> <span class="nav-text">Java 中有些字段不想进行序列化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#关于-transient"><span class="nav-number">1.1.18.3.</span> <span class="nav-text">关于 transient</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#获取键盘输入的两种方法"><span class="nav-number">1.1.18.4.</span> <span class="nav-text">获取键盘输入的两种方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Java-中-IO-流分几种？"><span class="nav-number">1.1.18.5.</span> <span class="nav-text">Java 中 IO 流分几种？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#为什么分字节流和字符流"><span class="nav-number">1.1.18.6.</span> <span class="nav-text">为什么分字节流和字符流</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#BIO、NIO、AIO"><span class="nav-number">1.1.18.7.</span> <span class="nav-text">&#x3D;&#x3D;BIO、NIO、AIO&#x3D;&#x3D;</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#BIO-Blocking-IO"><span class="nav-number">1.1.18.7.1.</span> <span class="nav-text">BIO(Blocking IO)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#NIO-Non-blocking-New-IO"><span class="nav-number">1.1.18.7.2.</span> <span class="nav-text">NIO(Non-blocking&#x2F; New IO)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#AIO（Asynchronous-IO）"><span class="nav-number">1.1.18.7.3.</span> <span class="nav-text">AIO（Asynchronous IO）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#总结-1"><span class="nav-number">1.1.18.7.4.</span> <span class="nav-text">总结</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#"><span class="nav-number">1.1.18.7.5.</span> <span class="nav-text"></span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#容器"><span class="nav-number">1.2.</span> <span class="nav-text">容器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#概述"><span class="nav-number">1.2.1.</span> <span class="nav-text">概述</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#List，Set，Map-三者的区别"><span class="nav-number">1.2.1.1.</span> <span class="nav-text">List，Set，Map 三者的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#集合底层数据结构"><span class="nav-number">1.2.1.2.</span> <span class="nav-text">集合底层数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#List"><span class="nav-number">1.2.1.2.0.1.</span> <span class="nav-text">List</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#Set"><span class="nav-number">1.2.1.2.0.2.</span> <span class="nav-text">Set</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#Map"><span class="nav-number">1.2.1.2.0.3.</span> <span class="nav-text">Map</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#如何选用集合"><span class="nav-number">1.2.1.3.</span> <span class="nav-text">如何选用集合</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Collection-子接口-List"><span class="nav-number">1.2.2.</span> <span class="nav-text">Collection 子接口 - List</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ArrayList-和-LinkedList-的区别"><span class="nav-number">1.2.2.1.</span> <span class="nav-text">ArrayList 和 LinkedList 的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ArrayList-扩容机制"><span class="nav-number">1.2.2.2.</span> <span class="nav-text">ArrayList 扩容机制</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Collection-子接口-Set"><span class="nav-number">1.2.3.</span> <span class="nav-text">Collection 子接口 - Set</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Comparable-和-Comparator-的区别"><span class="nav-number">1.2.3.1.</span> <span class="nav-text">Comparable 和 Comparator 的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HashSet、LinkedHashSet-和-TreeSet-三者异同"><span class="nav-number">1.2.3.2.</span> <span class="nav-text">HashSet、LinkedHashSet 和 TreeSet 三者异同</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Collection-子接口-Queue"><span class="nav-number">1.2.4.</span> <span class="nav-text">Collection 子接口 - Queue</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Queue-和-Deque-的区别"><span class="nav-number">1.2.4.1.</span> <span class="nav-text">Queue 和 Deque 的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ArrayDeque-和-LinkedList-的区别"><span class="nav-number">1.2.4.2.</span> <span class="nav-text">ArrayDeque 和 LinkedList 的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#PriorityQueue"><span class="nav-number">1.2.4.3.</span> <span class="nav-text">PriorityQueue</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Map-接口"><span class="nav-number">1.2.5.</span> <span class="nav-text">Map 接口</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#HashMap-和-HashTable"><span class="nav-number">1.2.5.1.</span> <span class="nav-text">HashMap 和 HashTable</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HashMap-和-HashSet"><span class="nav-number">1.2.5.2.</span> <span class="nav-text">HashMap 和 HashSet</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HashMap-和-TreeMap"><span class="nav-number">1.2.5.3.</span> <span class="nav-text">HashMap 和 TreeMap</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HashSet如何检查重复"><span class="nav-number">1.2.5.4.</span> <span class="nav-text">&#x3D;&#x3D;HashSet如何检查重复&#x3D;&#x3D;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HashMap-底层实现"><span class="nav-number">1.2.5.5.</span> <span class="nav-text">HashMap 底层实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HashMap-的长度为什么是-2-的幂次方"><span class="nav-number">1.2.5.6.</span> <span class="nav-text">&#x3D;&#x3D;HashMap 的长度为什么是 2 的幂次方&#x3D;&#x3D;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HashMap-类属性"><span class="nav-number">1.2.5.7.</span> <span class="nav-text">HashMap 类属性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HashMap-多线程操作死循环问题"><span class="nav-number">1.2.5.8.</span> <span class="nav-text">HashMap 多线程操作死循环问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ConcurrentHashMap-和-HashTable"><span class="nav-number">1.2.5.9.</span> <span class="nav-text">ConcurrentHashMap 和 HashTable</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Concurrent底层实现"><span class="nav-number">1.2.5.10.</span> <span class="nav-text">Concurrent底层实现</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Collections-工具类"><span class="nav-number">1.2.6.</span> <span class="nav-text">Collections 工具类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#排序"><span class="nav-number">1.2.6.1.</span> <span class="nav-text">排序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#查找、替换操作"><span class="nav-number">1.2.6.2.</span> <span class="nav-text">查找、替换操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#同步（不推荐，建议使用-JUC-包下的并发集合）"><span class="nav-number">1.2.6.3.</span> <span class="nav-text">同步（不推荐，建议使用 JUC 包下的并发集合）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#并发"><span class="nav-number">1.3.</span> <span class="nav-text">并发</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#基础-1"><span class="nav-number">1.3.1.</span> <span class="nav-text">基础</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#进程和线程"><span class="nav-number">1.3.1.1.</span> <span class="nav-text">进程和线程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#程序计数器为什么是线程私有的？"><span class="nav-number">1.3.1.2.</span> <span class="nav-text">程序计数器为什么是线程私有的？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#虚拟机栈和本地方法栈为什么是私有的？"><span class="nav-number">1.3.1.3.</span> <span class="nav-text">虚拟机栈和本地方法栈为什么是私有的？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#堆和方法区"><span class="nav-number">1.3.1.4.</span> <span class="nav-text">堆和方法区</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#并行和并发"><span class="nav-number">1.3.1.5.</span> <span class="nav-text">并行和并发</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#为什么使用多线程以及带来的问题"><span class="nav-number">1.3.1.6.</span> <span class="nav-text">为什么使用多线程以及带来的问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#线程的生命周期和状态"><span class="nav-number">1.3.1.7.</span> <span class="nav-text">线程的生命周期和状态</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#上下文切换"><span class="nav-number">1.3.1.8.</span> <span class="nav-text">上下文切换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#什么是死锁？如何避免死锁"><span class="nav-number">1.3.1.9.</span> <span class="nav-text">什么是死锁？如何避免死锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#产生死锁的四个条件"><span class="nav-number">1.3.1.10.</span> <span class="nav-text">产生死锁的四个条件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#预防死锁"><span class="nav-number">1.3.1.11.</span> <span class="nav-text">预防死锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#避免死锁"><span class="nav-number">1.3.1.12.</span> <span class="nav-text">避免死锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#sleep-方法和-wait-方法"><span class="nav-number">1.3.1.13.</span> <span class="nav-text">sleep() 方法和 wait() 方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#为什么不能直接调用-run-方法"><span class="nav-number">1.3.1.14.</span> <span class="nav-text">&#x3D;&#x3D;为什么不能直接调用 run() 方法&#x3D;&#x3D;</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#synchronized-关键字"><span class="nav-number">1.3.2.</span> <span class="nav-text">&#x3D;&#x3D;synchronized 关键字&#x3D;&#x3D;</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#定义-1"><span class="nav-number">1.3.2.1.</span> <span class="nav-text">定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#synchronized-关键字使用方式"><span class="nav-number">1.3.2.2.</span> <span class="nav-text">synchronized 关键字使用方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#构造方法可用-synchronized-关键字修饰么？"><span class="nav-number">1.3.2.3.</span> <span class="nav-text">构造方法可用 synchronized 关键字修饰么？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#synchronized-底层原理"><span class="nav-number">1.3.2.4.</span> <span class="nav-text">&#x3D;&#x3D;synchronized 底层原理&#x3D;&#x3D;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JDK1-6-后-synchronized-关键字的优化"><span class="nav-number">1.3.2.5.</span> <span class="nav-text">JDK1.6 后 synchronized 关键字的优化</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#偏向锁"><span class="nav-number">1.3.2.5.1.</span> <span class="nav-text">偏向锁</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#轻量级锁"><span class="nav-number">1.3.2.5.2.</span> <span class="nav-text">轻量级锁</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#重量级锁"><span class="nav-number">1.3.2.5.3.</span> <span class="nav-text">重量级锁</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#锁升级的流程"><span class="nav-number">1.3.2.5.4.</span> <span class="nav-text">&#x3D;&#x3D;锁升级的流程&#x3D;&#x3D;</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#synchronized-和-ReentrantLock"><span class="nav-number">1.3.2.6.</span> <span class="nav-text">synchronized 和 ReentrantLock</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#volatile-关键字"><span class="nav-number">1.3.3.</span> <span class="nav-text">volatile 关键字</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#JMM（Java-内存模型）"><span class="nav-number">1.3.3.1.</span> <span class="nav-text">JMM（Java 内存模型）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#内存可见性"><span class="nav-number">1.3.3.2.</span> <span class="nav-text">内存可见性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#禁止重排序"><span class="nav-number">1.3.3.3.</span> <span class="nav-text">禁止重排序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#synchronized-和-volatile-的区别"><span class="nav-number">1.3.3.4.</span> <span class="nav-text">&#x3D;&#x3D;synchronized 和 volatile 的区别&#x3D;&#x3D;</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ThreadLocal"><span class="nav-number">1.3.4.</span> <span class="nav-text">ThreadLocal</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#示例"><span class="nav-number">1.3.4.1.</span> <span class="nav-text">示例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ThreadLocal-原理"><span class="nav-number">1.3.4.2.</span> <span class="nav-text">&#x3D;&#x3D;ThreadLocal 原理&#x3D;&#x3D;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ThreadLocal-内存泄漏"><span class="nav-number">1.3.4.3.</span> <span class="nav-text">ThreadLocal 内存泄漏</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Atomic-原子类"><span class="nav-number">1.3.5.</span> <span class="nav-text">Atomic 原子类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#JUC-包原子类是哪-4-类？"><span class="nav-number">1.3.5.1.</span> <span class="nav-text">JUC 包原子类是哪 4 类？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#AtomicInteger-的使用"><span class="nav-number">1.3.5.2.</span> <span class="nav-text">AtomicInteger 的使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#AtomicInteger-类的原理"><span class="nav-number">1.3.5.3.</span> <span class="nav-text">&#x3D;&#x3D;AtomicInteger 类的原理&#x3D;&#x3D;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CAS存在的问题"><span class="nav-number">1.3.5.4.</span> <span class="nav-text">CAS存在的问题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AQS"><span class="nav-number">1.3.6.</span> <span class="nav-text">AQS</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#原理概览"><span class="nav-number">1.3.6.1.</span> <span class="nav-text">原理概览</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#AQS-结构"><span class="nav-number">1.3.6.2.</span> <span class="nav-text">AQS 结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#AQS-对资源的共享方式"><span class="nav-number">1.3.6.3.</span> <span class="nav-text">AQS 对资源的共享方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#AQS-底层使用了模板方法模式"><span class="nav-number">1.3.6.4.</span> <span class="nav-text">AQS 底层使用了模板方法模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#获取资源"><span class="nav-number">1.3.6.5.</span> <span class="nav-text">获取资源</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#释放资源"><span class="nav-number">1.3.6.6.</span> <span class="nav-text">释放资源</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ReentrantLock"><span class="nav-number">1.3.6.7.</span> <span class="nav-text">ReentrantLock</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Condition"><span class="nav-number">1.3.6.8.</span> <span class="nav-text">Condition</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#AQS-组件总结"><span class="nav-number">1.3.6.9.</span> <span class="nav-text">AQS 组件总结</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CountDownLatch-怎么用的？"><span class="nav-number">1.3.6.10.</span> <span class="nav-text">CountDownLatch 怎么用的？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程池"><span class="nav-number">1.3.7.</span> <span class="nav-text">线程池</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#为什么要用线程池？"><span class="nav-number">1.3.7.1.</span> <span class="nav-text">为什么要用线程池？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#实现-Runnable-和-Callable-接口的区别"><span class="nav-number">1.3.7.2.</span> <span class="nav-text">实现 Runnable 和 Callable 接口的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#执行-execute-方法和-submit-方法的区别是什么？"><span class="nav-number">1.3.7.3.</span> <span class="nav-text">执行 execute() 方法和 submit() 方法的区别是什么？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#如何创建线程池"><span class="nav-number">1.3.7.4.</span> <span class="nav-text">如何创建线程池</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ThreadPoolExecutors-类分析"><span class="nav-number">1.3.7.5.</span> <span class="nav-text">ThreadPoolExecutors 类分析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ThreadPoolExecutor-饱和策略"><span class="nav-number">1.3.7.6.</span> <span class="nav-text">ThreadPoolExecutor 饱和策略</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#线程池Demo"><span class="nav-number">1.3.7.7.</span> <span class="nav-text">线程池Demo</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#线程池原理分析"><span class="nav-number">1.3.7.8.</span> <span class="nav-text">&#x3D;&#x3D;线程池原理分析&#x3D;&#x3D;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#线程池大小确定"><span class="nav-number">1.3.7.9.</span> <span class="nav-text">&#x3D;&#x3D;线程池大小确定&#x3D;&#x3D;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#四种常见的线程池"><span class="nav-number">1.3.7.10.</span> <span class="nav-text">四种常见的线程池</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#newCachedThreadPool"><span class="nav-number">1.3.7.10.1.</span> <span class="nav-text">newCachedThreadPool</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#newFixedThreadPool"><span class="nav-number">1.3.7.10.2.</span> <span class="nav-text">newFixedThreadPool</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#newSingleThreadExecutor"><span class="nav-number">1.3.7.10.3.</span> <span class="nav-text">newSingleThreadExecutor</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#newScheduledThreadPool"><span class="nav-number">1.3.7.10.4.</span> <span class="nav-text">newScheduledThreadPool</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#阻塞队列"><span class="nav-number">1.3.8.</span> <span class="nav-text">阻塞队列</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#BlockingQueue-的操作方法"><span class="nav-number">1.3.8.1.</span> <span class="nav-text">BlockingQueue 的操作方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#BlockingQueue-的实现类"><span class="nav-number">1.3.8.2.</span> <span class="nav-text">BlockingQueue 的实现类</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#ArrayBlockingQueue"><span class="nav-number">1.3.8.2.1.</span> <span class="nav-text">ArrayBlockingQueue</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#LinkedBlockingQueue"><span class="nav-number">1.3.8.2.2.</span> <span class="nav-text">LinkedBlockingQueue</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#DelayQueue"><span class="nav-number">1.3.8.2.3.</span> <span class="nav-text">DelayQueue</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#PriorityBlockingQueue"><span class="nav-number">1.3.8.2.4.</span> <span class="nav-text">PriorityBlockingQueue</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#SynchronousQueue"><span class="nav-number">1.3.8.2.5.</span> <span class="nav-text">SynchronousQueue</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#阻塞队列原理"><span class="nav-number">1.3.8.3.</span> <span class="nav-text">阻塞队列原理</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#put-方法"><span class="nav-number">1.3.8.3.1.</span> <span class="nav-text">put 方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#take-方法"><span class="nav-number">1.3.8.3.2.</span> <span class="nav-text">take 方法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用场景：生产者消费者"><span class="nav-number">1.3.8.4.</span> <span class="nav-text">使用场景：生产者消费者</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#锁接口和类"><span class="nav-number">1.3.9.</span> <span class="nav-text">锁接口和类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#synchronized-不足之处"><span class="nav-number">1.3.9.1.</span> <span class="nav-text">synchronized 不足之处</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#锁分类"><span class="nav-number">1.3.9.2.</span> <span class="nav-text">锁分类</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#可重入和非重入锁"><span class="nav-number">1.3.9.2.1.</span> <span class="nav-text">可重入和非重入锁</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#公平锁和非公平锁"><span class="nav-number">1.3.9.2.2.</span> <span class="nav-text">公平锁和非公平锁</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#读写锁和排他锁"><span class="nav-number">1.3.9.2.3.</span> <span class="nav-text">读写锁和排他锁</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="hoo334"
      src="/images/avatar2.jpg">
  <p class="site-author-name" itemprop="name">hoo334</p>
  <div class="site-description" itemprop="description">弃坑C++，转Java！</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">216</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">34</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/hoo334" title="Github → https:&#x2F;&#x2F;github.com&#x2F;hoo334" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>Github</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:liminghu98@foxmail.com" title="E-Mail → mailto:liminghu98@foxmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">hoo334</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'EiY3VXyWjvwDilIGKwC1eVm8-gzGzoHsz',
      appKey     : 'rkL4uHX26hqdosKCRFk0Qf7u',
      placeholder: "Just go go",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
