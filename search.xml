<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>3的幂</title>
    <url>/2020/09/19/3%E7%9A%84%E5%B9%82/</url>
    <content><![CDATA[<h4 id="326-3的幂"><a href="#326-3的幂" class="headerlink" title="326. 3的幂"></a><a href="https://leetcode-cn.com/problems/power-of-three/" target="_blank" rel="noopener">326. 3的幂</a></h4><p>给定一个整数，写一个函数来判断它是否是 3 的幂次方。</p>
<a id="more"></a>

<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 27</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 0</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>

<p><strong>示例 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 9</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>

<p><strong>示例 4:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 45</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>

<p><strong>进阶：</strong><br>你能不使用循环或者递归来完成本题吗？</p>
<p><strong>方法一：循环</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPowerOfThree</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(n % <span class="number">3</span> == <span class="number">0</span>)&#123;</span><br><span class="line">            n /= <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> n == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法二：整数限制</strong></p>
<p>n 最大为 int 的最大值，我们将 int 范围内的最大 3 的幂次整数（1162261467）找出，如果它能整除 n ，则 n 为 3 的幂次。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPowerOfThree</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> n &gt; <span class="number">0</span> &amp;&amp; <span class="number">1162261467</span> % n == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>Leetcode Easy</tag>
      </tags>
  </entry>
  <entry>
    <title>JPA中@Transactional怎么用？</title>
    <url>/2020/09/11/@Transactional%E5%88%B0%E5%BA%95%E6%9C%89%E5%95%A5%E7%94%A8/</url>
    <content><![CDATA[<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>首先新建一个 SpringBoot 项目，修改 pom.xml，增加以下内容：</p>
<a id="more"></a>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.3.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-jpa<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- mysql --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.19<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后新建配置文件 application.yml，我们需要在本地有个 test 数据库。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://127.0.0.1:3306/test?useSSL=true&amp;characterEncoding=utf-8&amp;serverTimezone=Hongkong</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">  <span class="attr">jpa:</span></span><br><span class="line">    <span class="attr">hibernate:</span></span><br><span class="line">      <span class="attr">ddl-auto:</span> <span class="string">update</span></span><br><span class="line">    <span class="attr">database-platform:</span> <span class="string">org.hibernate.dialect.MySQL5InnoDBDialect</span></span><br><span class="line">    <span class="attr">show-sql:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>新建实体类 User：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.persistence.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table</span>(name = <span class="string">"usr"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue</span>(strategy = GenerationType.IDENTITY)</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long money;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(Long money)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.money = money;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>新建启动类 DemoMain：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.transaction.annotation.EnableTransactionManagement;</span><br><span class="line"></span><br><span class="line"><span class="meta">@EnableTransactionManagement</span>  <span class="comment">//开启事务管理</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(DemoMain<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>启动程序，打开Navicat，可以看到 test 数据库中有一张 usr 表。</p>
<p>在Navicat 中插入两个User：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">insert into usr(money) values(10000);</span><br><span class="line">insert into usr(money) values(0);</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20200911211455133.png" alt="image-20200911211455133"></p>
<p>到这里，一切准备就绪。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>新建 UserRepository ：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.data.jpa.repository.JpaRepository;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.jpa.repository.Modifying;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.jpa.repository.Query;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Repository;</span><br><span class="line"><span class="keyword">import</span> org.springframework.transaction.annotation.Transactional;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserRepository</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">User</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="meta">@Modifying</span></span><br><span class="line">    <span class="meta">@Query</span>(value = <span class="string">"update usr set money = money - 1 where id = ?1"</span>, nativeQuery = <span class="keyword">true</span>)</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sub</span><span class="params">(Long userId)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="meta">@Modifying</span></span><br><span class="line">    <span class="meta">@Query</span>(value = <span class="string">"update usr set money = money + 1 where id = ?1"</span>, nativeQuery = <span class="keyword">true</span>)</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(Long userId)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>sub()</code>方法使用户 1 账户减少一块钱，<code>add()</code>方法使用户 2 账户增加一块钱。</p>
<p>实现 UserService：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"><span class="keyword">import</span> org.springframework.transaction.annotation.Transactional;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserRepository userRepository;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//@Transactional //重点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//用户 1 向用户 2 转一千块（每次一块）</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++)&#123;</span><br><span class="line">            userRepository.sub(<span class="number">1L</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//用户 2 每次收到 1 块</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            userRepository.add(<span class="number">2L</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>transfer()</code>方法模拟，用户 1 向用户 2 转账 1000 次，每次 1000 块，但是用户 2 需要等待用户 1 的所有转出都完成才开始转入。</p>
<p>新建 UserController：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/transfer"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">transfer</span><span class="params">()</span></span>&#123;</span><br><span class="line">        userService.transfer();</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"done"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>现在启动DemoMain，访问 <a href="http://localhost:8080/transfer" target="_blank" rel="noopener">http://localhost:8080/transfer</a> ，然后<strong>立即</strong>关闭这个程序。</p>
<p>现在我们来看 usr 表</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20200911212851901.png" alt="image-20200911212851901"></p>
<p> 发现它们账户总和资金并不是 10000 ，这是非常危险的，转账丢钱了！查看控制栏我们也能看到 Hibernate 执行的 sql 信息。</p>
<p>我们再试一次，先启动 DemoMain，访问 <a href="http://localhost:8080/transfer" target="_blank" rel="noopener">http://localhost:8080/transfer</a> ，然后<strong>立即</strong>关闭 MySQL（模拟一次数据库故障），然后再启动 MySQL。</p>
<p>再看 usr 表</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20200911213334624.png" alt="image-20200911213334624"></p>
<p>钱又变少了！！</p>
<p>看到这里，你可能已经猜到了 <code>@Transactional</code>注解是用来干啥的，它就是用来保证转账的金额总和不变。</p>
<p>现在我们将<code>transfer()</code>方法上的<code>@Transactional</code>恢复，然后将两个账户恢复至初始状态（账户 1 中 10000块，账户 2 中 0 块，PS：这两句 SQL 会写吧。。）</p>
<p>我们再尝试一次服务故障，发现控制栏中依然有 Hibernate 执行的 sql 信息，打开 usr 表，账户 1 中依然有 10000块，账户 1 的所有转账都失败了！</p>
<p>再试一次数据库故障，账户 1 中依然有 10000 块，转账依然失败。</p>
<p>这种情况是符合我们的预期，宁可失败，也不能少钱。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通常来说，repository 实例的 CRUD 方法是事务的，如果自己定义 SQL，需要在除 SELECT 语句的方法（INSERT、UPDATE 等）上加上<code>@Transactional</code>（保证事务性）和<code>@Modifying</code>。</p>
<p>另一种方法就是在 service 的方法上添加<code>@Transactional</code>注解，现在 repository 上的<code>@Transactional</code>注解被忽略，永远使用的是最外层的 @Transactional 注解。注意：必须要在启动类上添加 <code>@EnableTransactionManagement</code>开启事务管理。</p>
<p>如果这个事务在中途失败了，Spring 会将该事务回滚。</p>
<p><strong>由于个人水平有限，如有错误和不足请轻喷</strong>。</p>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>Git上传本地项目</title>
    <url>/2020/04/04/Git%E4%B8%8A%E4%BC%A0%E6%9C%AC%E5%9C%B0%E9%A1%B9%E7%9B%AE/</url>
    <content><![CDATA[<h1 id="Git上传本地项目"><a href="#Git上传本地项目" class="headerlink" title="Git上传本地项目"></a>Git上传本地项目</h1><p><strong>如何将本地项目push到GitHub上？</strong></p>
<p>GitHub新建一个 repostory 找到URL 例如：<a href="https://github.com/hoo334/test.git" target="_blank" rel="noopener">https://github.com/hoo334/test.git</a></p>
<p>找到项目文件夹 右键git bash here</p>
<p><strong>git init</strong></p>
<p>*<em>git add . *</em></p>
<p><strong>git commit -m “提交信息”</strong></p>
<p><strong>git remote add origin URL</strong></p>
<p><strong>git push -u origin master</strong></p>
<p><strong>提交更新到Github</strong></p>
<p><strong>git status （可选 查看更改文件）</strong></p>
<p><strong>git add 你想要提交更改的文件 或者git add .</strong></p>
<p><strong>git commit -m “提交信息”</strong></p>
<p><strong>git push  origin master</strong></p>
<p><strong>如果操作失误就直接删掉目录内的.git整个文件夹 重新git init。</strong></p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>24点游戏</title>
    <url>/2020/08/22/24%E7%82%B9%E6%B8%B8%E6%88%8F/</url>
    <content><![CDATA[<h4 id="679-24-点游戏"><a href="#679-24-点游戏" class="headerlink" title="679. 24 点游戏"></a><a href="https://leetcode-cn.com/problems/24-game/" target="_blank" rel="noopener">679. 24 点游戏</a></h4><p>你有 4 张写有 1 到 9 数字的牌。你需要判断是否能通过 <code>*</code>，<code>/</code>，<code>+</code>，<code>-</code>，<code>(</code>，<code>)</code> 的运算得到 24。</p>
<a id="more"></a>

<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [4, 1, 8, 7]</span><br><span class="line">输出: True</span><br><span class="line">解释: (8-4) * (7-1) &#x3D; 24</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1, 2, 1, 2]</span><br><span class="line">输出: False</span><br></pre></td></tr></table></figure>

<p><strong>注意:</strong></p>
<ol>
<li>除法运算符 <code>/</code> 表示实数除法，而不是整数除法。例如 4 / (1 - 2/3) = 12 。</li>
<li>每个运算符对两个数进行运算。特别是我们不能用 <code>-</code> 作为一元运算符。例如，<code>[1, 1, 1, 1]</code> 作为输入时，表达式 <code>-1 - 1 - 1 - 1</code> 是不允许的。</li>
<li>你不能将数字连接在一起。例如，输入为 <code>[1, 2, 1, 2]</code> 时，不能写成 12 + 12 。</li>
</ol>
<p>一共有 4 个数和 3 个运算操作，因此可能性并不多。</p>
<p>首先从 4 个数字中有序取出两个数字共 4 * 3 = 12 种选法，再选择 4 种运算中的一种，将运算的结果取代选出的两个数字。</p>
<p>在剩下的 3 个数字中有序取出两个数字共 3 * 2 = 6 种选法，再选择 4 种运算中的一种，将运算的结果取代选出的两个数字。</p>
<p>最后剩下两个数字，有两种不同的顺序，并选择 4 种运算之一。</p>
<p>总共有 12 * 4 * 6 * 4 * 2 * 4 = 9216 种可能。</p>
<p>我们直接使用暴力方法来求解，用一个列表存储全部数字，每次从列表中选出 2 个数字，再选择 1 种运算操作，用计算的结果取代选出的 2 个数字。重复以上步骤，直到最后剩下一个数字，判断它是否等于 24 即可。</p>
<p>注意到除法运算为实数除法，结果为浮点数，因此在列表中应该全部存储浮点数。两个浮点数差值小于 1e-6 时可认为它们相等。同时，在进行除法运算时，除数不能为 0 ，遇到这种情况我们可以直接排除。</p>
<p>加法和乘法都满足交换律，对于选出的 2 个数字不需要考虑不同的顺序，在第二次运算时直接跳过。</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> TARGET = <span class="number">24</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">double</span> EPSILON = <span class="number">1e-6</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> ADD = <span class="number">0</span>, MULTIPLY = <span class="number">1</span>, SUBTRACT = <span class="number">2</span>, DIVIDE = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">judgePoint24</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        List&lt;Double&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//将所有数字转为 double 并存进list</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">            list.add((<span class="keyword">double</span>) num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> solve(list);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">solve</span><span class="params">(List&lt;Double&gt; list)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(list.size() == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//列表中只剩一个数字，判断它是否等于 24</span></span><br><span class="line">        <span class="keyword">if</span>(list.size() == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> Math.abs(list.get(<span class="number">0</span>) - TARGET) &lt; EPSILON;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> size = list.size();</span><br><span class="line">		<span class="comment">// 有序选出 i，j 位置的两个数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; size; j++)&#123;</span><br><span class="line">                <span class="comment">//选出同一个数</span></span><br><span class="line">                <span class="keyword">if</span>(i == j)&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                List&lt;Double&gt; list2 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                <span class="comment">//保存除 i，j 位置的元素</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; size; k++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(k != i &amp;&amp; k != j)&#123;</span><br><span class="line">                        list2.add(list.get(k));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">				<span class="comment">//选出一种运算</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++)&#123;</span><br><span class="line">                    <span class="comment">//如果是加或乘运算，且这是第二次选中 i 和 j</span></span><br><span class="line">                    <span class="keyword">if</span>(k &lt; <span class="number">2</span> &amp;&amp; i &gt; j)&#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">					<span class="comment">//计算结果</span></span><br><span class="line">                    <span class="keyword">if</span>(k == ADD)&#123;</span><br><span class="line">                        list2.add(list.get(i) + list.get(j));</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(k == MULTIPLY)&#123;</span><br><span class="line">                        list2.add(list.get(i) * list.get(j));</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(k == SUBTRACT)&#123;</span><br><span class="line">                        list2.add(list.get(i) - list.get(j));</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(k == DIVIDE)&#123;</span><br><span class="line">                        <span class="comment">//跳过除数为 0 的情况</span></span><br><span class="line">                        <span class="keyword">if</span>(Math.abs(list.get(j)) &lt; EPSILON)&#123;</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                            list2.add(list.get(i) / list.get(j));</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">					<span class="comment">//继续选出两个数字并计算，如果得到结果，返回 true</span></span><br><span class="line">                    <span class="keyword">if</span>(solve(list2))&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">					<span class="comment">// list 不能得到 24点，删除加入的元素，并尝试下一种运算</span></span><br><span class="line">                    list2.remove(list2.size() - <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度O(1)，空间复杂度O(1)。</p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>Leetcode Hard</tag>
      </tags>
  </entry>
  <entry>
    <title>利用gradle添加依赖</title>
    <url>/2020/04/04/Gradle%E4%BE%9D%E8%B5%96%E4%B8%8B%E8%BD%BD/</url>
    <content><![CDATA[<h1 id="利用gradle添加依赖"><a href="#利用gradle添加依赖" class="headerlink" title="利用gradle添加依赖"></a>利用gradle添加依赖</h1><p>1、新建一个gradle项目</p>
<p>可以看到build.gradle</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/qxOINuGoR7pAsE2.png" alt="img"></p>
<p> 2、编写gradle.properties</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/Bj2opT4nKwUvLyq.png" alt="img"></p>
<p> 3、修改build.gradle编译jar，利用${key} 来获取key的值</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/AjhOQ9rK3IHnL8D.png" alt="img"></p>
<p> 4、等待gradle自动导入</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/WKCFrN3MavV6ncg.png" alt="img"></p>
<p> 可以看到已经导入完成，开始玩耍。。。</p>
<p>如果遇到依赖下载慢的情况 在build.gradle文件repositories加入：           </p>
<p>maven{ url’<a href="http://maven.aliyun.com/nexus/content/groups/public/&#39;}" target="_blank" rel="noopener">http://maven.aliyun.com/nexus/content/groups/public/&#39;}</a></p>
<p>使用阿里云的maven仓库</p>
<p>mavenLocal()可以让项目先检查本地的仓库，有的话不用下载。</p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Gradle</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解Java虚拟机</title>
    <url>/2020/04/04/JVM%20%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/</url>
    <content><![CDATA[<h1 id="JVM-运行时数据区"><a href="#JVM-运行时数据区" class="headerlink" title="JVM 运行时数据区"></a>JVM 运行时数据区</h1><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/ML2CpVz6XdqoJkl.png" alt=""></p>
<p> <img src="https://gitee.com/hoo334/picgo/raw/master//img/VfYt7yh4pav9ure.png" alt=""></p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
  </entry>
  <entry>
    <title>LRU缓存机制</title>
    <url>/2020/05/25/LRU%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h4 id="146-LRU缓存机制"><a href="#146-LRU缓存机制" class="headerlink" title="146. LRU缓存机制"></a><a href="https://leetcode-cn.com/problems/lru-cache/" target="_blank" rel="noopener">146. LRU缓存机制</a></h4><p>运用你所掌握的数据结构，设计和实现一个 <a href="https://baike.baidu.com/item/LRU" target="_blank" rel="noopener">LRU (最近最少使用) 缓存机制</a>。它应该支持以下操作： 获取数据 <code>get</code> 和 写入数据 <code>put</code> 。</p>
<p>获取数据 <code>get(key)</code> - 如果密钥 (key) 存在于缓存中，则获取密钥的值（总是正数），否则返回 -1。<br>写入数据 <code>put(key, value)</code> - 如果密钥已经存在，则变更其数据值；如果密钥不存在，则插入该组「密钥/数据值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。</p>
<a id="more"></a>

<p><strong>进阶:</strong></p>
<p>你是否可以在 <strong>O(1)</strong> 时间复杂度内完成这两种操作？</p>
<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LRUCache cache &#x3D; new LRUCache( 2 &#x2F;* 缓存容量 *&#x2F; );</span><br><span class="line"></span><br><span class="line">cache.put(1, 1);</span><br><span class="line">cache.put(2, 2);</span><br><span class="line">cache.get(1);       &#x2F;&#x2F; 返回  1</span><br><span class="line">cache.put(3, 3);    &#x2F;&#x2F; 该操作会使得密钥 2 作废</span><br><span class="line">cache.get(2);       &#x2F;&#x2F; 返回 -1 (未找到)</span><br><span class="line">cache.put(4, 4);    &#x2F;&#x2F; 该操作会使得密钥 1 作废</span><br><span class="line">cache.get(1);       &#x2F;&#x2F; 返回 -1 (未找到)</span><br><span class="line">cache.get(3);       &#x2F;&#x2F; 返回  3</span><br><span class="line">cache.get(4);       &#x2F;&#x2F; 返回  4</span><br></pre></td></tr></table></figure>

<p>LRU 缓存可以使用一个哈希表和一个双向链表维护在缓存中的键值对。使用哈希表可以将 get 操作达到常数级复杂度。</p>
<ol>
<li><p>get 操作，首先判断 key 是否存在：</p>
<ul>
<li>key 不存在，返回 -1；</li>
<li>key 存在，通过哈希表定位到双向链表中的结点，将其移动到双向链表头部，返回该结点的值。</li>
</ul>
</li>
<li><p>put 操作，首先判断 key 是否存在：</p>
<ul>
<li>key 不存在，直接新建一个结点，将该结点加入哈希表和双向链表头部。并判断是否超出容量，如果超出容量删除链尾结点；</li>
<li>key 存在，更新 value ，并将该结点移动到链表头部。</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">DLinkedNode</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> key;</span><br><span class="line">        <span class="keyword">int</span> value;</span><br><span class="line">        DLinkedNode prev;</span><br><span class="line">        DLinkedNode next;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">DLinkedNode</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">DLinkedNode</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span></span>&#123;<span class="keyword">this</span>.key = key; <span class="keyword">this</span>.value = value;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, DLinkedNode&gt; cache = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br><span class="line">    <span class="keyword">private</span> DLinkedNode head, tail;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.size = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">        head = <span class="keyword">new</span> DLinkedNode();</span><br><span class="line">        tail = <span class="keyword">new</span> DLinkedNode();</span><br><span class="line">        head.next = tail;</span><br><span class="line">        tail.prev = head;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        DLinkedNode node = cache.get(key);</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// key 存在，先通过哈希表定位，再移动到头部</span></span><br><span class="line">        moveToHead(node);</span><br><span class="line">        <span class="keyword">return</span> node.value;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        DLinkedNode node = cache.get(key);</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">// key 不存在，创建一个新的节点</span></span><br><span class="line">            DLinkedNode newNode = <span class="keyword">new</span> DLinkedNode(key, value);</span><br><span class="line">            <span class="comment">//添加进哈希表</span></span><br><span class="line">            cache.put(key, newNode);</span><br><span class="line">            <span class="comment">//添加至双向链表的头部</span></span><br><span class="line">            addToHead(newNode);</span><br><span class="line">            ++size;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(size &gt; capacity)&#123;</span><br><span class="line">                <span class="comment">//超出容量，删除双向链表的尾部结点</span></span><br><span class="line">                DLinkedNode tail = removeTail();</span><br><span class="line">                <span class="comment">//删除哈希表中的对应项</span></span><br><span class="line">                cache.remove(tail.key);</span><br><span class="line">                --size;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//如果 key 存在，先通过哈希表定位，再修改 value，并移到头部</span></span><br><span class="line">            node.value = value;</span><br><span class="line">            moveToHead(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addToHead</span><span class="params">(DLinkedNode node)</span></span>&#123;</span><br><span class="line">        node.prev = head;</span><br><span class="line">        node.next = head.next;</span><br><span class="line">        head.next.prev = node;</span><br><span class="line">        head.next = node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">removeNode</span><span class="params">(DLinkedNode node)</span></span>&#123;</span><br><span class="line">        node.prev.next = node.next;</span><br><span class="line">        node.next.prev = node.prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">moveToHead</span><span class="params">(DLinkedNode node)</span></span>&#123;</span><br><span class="line">        removeNode(node);</span><br><span class="line">        addToHead(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> DLinkedNode <span class="title">removeTail</span><span class="params">()</span></span>&#123;</span><br><span class="line">        DLinkedNode res = tail.prev;</span><br><span class="line">        removeNode(res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your LRUCache object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * LRUCache obj = new LRUCache(capacity);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj.get(key);</span></span><br><span class="line"><span class="comment"> * obj.put(key,value);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<p>空间复杂度O(n) 时间复杂度 O(1)</p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>链表</tag>
        <tag>Leetcode Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 深拷贝和浅拷贝</title>
    <url>/2020/04/04/Java%20%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D/</url>
    <content><![CDATA[<h1 id="Java-深拷贝和浅拷贝"><a href="#Java-深拷贝和浅拷贝" class="headerlink" title="Java 深拷贝和浅拷贝"></a>Java 深拷贝和浅拷贝</h1><p>　　在浅拷贝中，如果原型对象的成员变量是基本类型时，将复制一份给克隆对象；如果原型对象的成员变量是引用类型，则将引用对象的地址复制一份给克隆对象，也就是说原型对象和克隆对象的成员变量指向相同的内存地址。</p>
<p>　　对应的深拷贝，如果时成员变量为引用对象也复制一份给复制对象。</p>
<p>　　</p>
<p><strong>实现</strong></p>
<p>　　<strong>1、新建一个 Person 和 PersonId 类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> PersonId personId;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age, <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.personId = <span class="keyword">new</span> PersonId(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        personId.setId(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Person <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        Person cloned = (Person)<span class="keyword">super</span>.clone();</span><br><span class="line">        <span class="keyword">return</span> cloned;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Person&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", age="</span> + age +</span><br><span class="line">                <span class="string">", personId="</span> + personId +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersonId</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PersonId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"PersonId&#123;"</span> +</span><br><span class="line">                <span class="string">"id="</span> + id +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　<strong>2、使用 CloneDemo 类来测试浅拷贝</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CloneDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        Person person = <span class="keyword">new</span> Person(<span class="string">"zhangsan"</span>,<span class="number">20</span>,<span class="number">123</span>);</span><br><span class="line">        Person cloned = person.clone();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"original: "</span>+person);</span><br><span class="line">        System.out.println(<span class="string">"cloned: "</span>+cloned);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"Modify Age and Id: "</span>);</span><br><span class="line">        cloned.setAge(<span class="number">55</span>);</span><br><span class="line">        cloned.setId(<span class="number">234</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"original: "</span>+person);</span><br><span class="line">        System.out.println(<span class="string">"cloned: "</span>+cloned);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　<strong>3、输出</strong></p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/rXmNxfSUGDFlCnW.png" alt="img"></p>
<p> 　可以看到我们修改了拷贝对象的年龄和ID，原始对象的年龄还是20，原始对象的ID却变成了我们修改后的值，我们并没有对原始对象的ID进行修改，这里说明浅拷贝对于对象仅仅是拷贝了一个对象的引用而已。</p>
<p>　　<strong>4、接下来我们修改 Person 类的 clone() 方法，实现深拷贝。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Person <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">    Person cloned = (Person)<span class="keyword">super</span>.clone();</span><br><span class="line">    cloned.personId = personId.clone();</span><br><span class="line">    <span class="keyword">return</span> cloned;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　<strong>5、为了拷贝PersonId 的对象我们需要PersonId 类实现 Cloneable 接口</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersonId</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PersonId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"PersonId&#123;"</span> +</span><br><span class="line">                <span class="string">"id="</span> + id +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PersonId <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (PersonId)<span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　<strong>6、再次运行 CloneDemo 输出</strong></p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/3jUA4G2YcBlKQCq.png" alt="img"></p>
<p> 　可以看到 原始对象的ID 值没有被修改。</p>
<p>　　<strong>7、使用序列化实现深拷贝</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Cloneable</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> PersonId personId;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age, <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.personId = <span class="keyword">new</span> PersonId(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        personId.setId(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Person <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ByteArrayOutputStream bout = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">            <span class="keyword">try</span>(ObjectOutputStream out = <span class="keyword">new</span> ObjectOutputStream(bout)) &#123;</span><br><span class="line">                out.writeObject(<span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span>(InputStream bin = <span class="keyword">new</span> ByteArrayInputStream(bout.toByteArray()))&#123;</span><br><span class="line">                ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(bin);</span><br><span class="line">                <span class="keyword">return</span> (Person)in.readObject();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException | ClassNotFoundException e) &#123;</span><br><span class="line">            CloneNotSupportedException e2 = <span class="keyword">new</span> CloneNotSupportedException();</span><br><span class="line">            e2.initCause(e);</span><br><span class="line">            <span class="keyword">throw</span> e2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Person&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", age="</span> + age +</span><br><span class="line">                <span class="string">", personId="</span> + personId +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersonId</span> <span class="keyword">implements</span> <span class="title">Cloneable</span>,<span class="title">Serializable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PersonId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"PersonId&#123;"</span> +</span><br><span class="line">                <span class="string">"id="</span> + id +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PersonId <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (PersonId)<span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　所有写入流的对象都要实现 Serializable 接口。将 Person 对象写入流中然后再从流中读取出来实现深拷贝。</p>
<p>　　 输出：</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/q4buBy96jFGdP73.png" alt="img"></p>
<p><strong>总结</strong></p>
<p>　　<strong>若要实现深拷贝，如果对象中引用了其他对象，必须将引用的对象也克隆。</strong></p>
<p>　　</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode第201场周赛</title>
    <url>/2020/08/10/Leetcode%E7%AC%AC201%E5%9C%BA%E5%91%A8%E8%B5%9B/</url>
    <content><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>第二次参加周赛，又是AC两道暴力题，菜鸡只会暴力/(ㄒoㄒ)/~~。</p>
<a id="more"></a>

<h4 id="5483-整理字符串-Easy"><a href="#5483-整理字符串-Easy" class="headerlink" title="5483. 整理字符串(Easy)"></a><a href="https://leetcode-cn.com/problems/make-the-string-great/" target="_blank" rel="noopener">5483. 整理字符串(Easy)</a></h4><p>给你一个由大小写英文字母组成的字符串 <code>s</code> 。</p>
<p>一个整理好的字符串中，<strong>两个相邻字符</strong> <code>s[i]</code> 和 <code>s[i + 1]</code> 不会同时满足下述条件：</p>
<ul>
<li><code>0 &lt;= i &lt;= s.length - 2</code></li>
<li><code>s[i]</code> 是小写字符，但 <code>s[i + 1]</code> 是相同的大写字符；<strong>反之亦然</strong> 。</li>
</ul>
<p>请你将字符串整理好，每次你都可以从字符串中选出满足上述条件的 <strong>两个相邻</strong> 字符并删除，直到字符串整理好为止。</p>
<p>请返回整理好的 <strong>字符串</strong> 。题目保证在给出的约束条件下，测试样例对应的答案是唯一的。</p>
<p><strong>注意：</strong>空字符串也属于整理好的字符串，尽管其中没有任何字符。</p>
<p> <strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;leEeetcode&quot;</span><br><span class="line">输出：&quot;leetcode&quot;</span><br><span class="line">解释：无论你第一次选的是 i &#x3D; 1 还是 i &#x3D; 2，都会使 &quot;leEeetcode&quot; 缩减为 &quot;leetcode&quot; 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;abBAcC&quot;</span><br><span class="line">输出：&quot;&quot;</span><br><span class="line">解释：存在多种不同情况，但所有的情况都会导致相同的结果。例如：</span><br><span class="line">&quot;abBAcC&quot; --&gt; &quot;aAcC&quot; --&gt; &quot;cC&quot; --&gt; &quot;&quot;</span><br><span class="line">&quot;abBAcC&quot; --&gt; &quot;abBA&quot; --&gt; &quot;aA&quot; --&gt; &quot;&quot;</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;s&quot;</span><br><span class="line">输出：&quot;s&quot;</span><br></pre></td></tr></table></figure>

<p> <strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 100</code></li>
<li><code>s</code> 只包含小写和大写英文字母</li>
</ul>
<p>这题目描述简直离谱，一句话来说就是：不断删除字符串中的 “xX” 或 “Xx”两个字符，x 为某个字母小写，X 为小写字母 x 对应的大写字母。</p>
<p>我们直接使用 StringBuffer 来进行字符的删除。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">makeGood</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        StringBuffer sb = <span class="keyword">new</span> StringBuffer(s);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= sb.length() - <span class="number">2</span>;)&#123;</span><br><span class="line">            <span class="keyword">if</span>( Math.abs(sb.charAt(i) - sb.charAt(i + <span class="number">1</span>)) == <span class="number">32</span> )&#123;</span><br><span class="line">                sb.delete(i, i + <span class="number">2</span>);</span><br><span class="line">                i = <span class="number">0</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="1545-找出第-N-个二进制字符串中的第-K-位-Medium"><a href="#1545-找出第-N-个二进制字符串中的第-K-位-Medium" class="headerlink" title="1545. 找出第 N 个二进制字符串中的第 K 位(Medium)"></a><a href="https://leetcode-cn.com/problems/find-kth-bit-in-nth-binary-string/" target="_blank" rel="noopener">1545. 找出第 N 个二进制字符串中的第 K 位(Medium)</a></h4><p>给你两个正整数 <code>n</code> 和 <code>k</code>，二进制字符串 <code>Sn</code> 的形成规则如下：</p>
<ul>
<li><code>S1 = &quot;0&quot;</code></li>
<li>当 <code>i &gt; 1</code> 时，<code>Si = Si-1 + &quot;1&quot; + reverse(invert(Si-1))</code></li>
</ul>
<p>其中 <code>+</code> 表示串联操作，<code>reverse(x)</code> 返回反转 <code>x</code> 后得到的字符串，而 <code>invert(x)</code> 则会翻转 x 中的每一位（0 变为 1，而 1 变为 0）</p>
<p>例如，符合上述描述的序列的前 4 个字符串依次是：</p>
<ul>
<li><code>S1 = &quot;0&quot;</code></li>
<li><code>S2 = &quot;011&quot;</code></li>
<li><code>S3 = &quot;0111001&quot;</code></li>
<li><code>S4 = &quot;011100110110001&quot;</code></li>
</ul>
<p>请你返回 <code>Sn</code> 的 <strong>第 <code>k</code> 位字符</strong> ，题目数据保证 <code>k</code> 一定在 <code>Sn</code> 长度范围以内。</p>
<p> <strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 3, k &#x3D; 1</span><br><span class="line">输出：&quot;0&quot;</span><br><span class="line">解释：S3 为 &quot;0111001&quot;，其第 1 位为 &quot;0&quot; 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 4, k &#x3D; 11</span><br><span class="line">输出：&quot;1&quot;</span><br><span class="line">解释：S4 为 &quot;011100110110001&quot;，其第 11 位为 &quot;1&quot; 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 1, k &#x3D; 1</span><br><span class="line">输出：&quot;0&quot;</span><br></pre></td></tr></table></figure>

<p><strong>示例 4：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 2, k &#x3D; 3</span><br><span class="line">输出：&quot;1&quot;</span><br></pre></td></tr></table></figure>

<p> <strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 20</code></li>
<li><code>1 &lt;= k &lt;= 2n - 1</code></li>
</ul>
<p><strong>方法一：暴力</strong></p>
<p>菜鸡只会暴力。/(ㄒoㄒ)/~~</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">findKthBit</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        StringBuffer sb = <span class="keyword">new</span> StringBuffer(<span class="string">"0"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            StringBuffer temp = invertAndReverse(sb);</span><br><span class="line">            sb.append(<span class="number">1</span>).append(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.charAt(k - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> StringBuffer <span class="title">invertAndReverse</span><span class="params">(StringBuffer s)</span></span>&#123;</span><br><span class="line">        StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i) == <span class="string">'0'</span>)&#123;</span><br><span class="line">                sb.append(<span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                sb.append(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.reverse();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法二：数学</strong></p>
<p>将 n 个字符串从大到小遍历 n - 1 次，计算第 n 个字符串中间位置 midPos，并判断 k 与 midPos 的位置关系：</p>
<ol>
<li><p>如果 k &gt; midPos，第 n 个字符串第 k 个数字等于 第 n - 1 个字符串的第 midPos * 2 - k 个数字，并累加当前取反次数。</p>
</li>
<li><p>如果 k &lt; midPos，无需处理，直接遍历第 n - 1 个字符串。</p>
</li>
<li><p>k == midPos，当前位置为 1，根据取反次数计算返回即可。 </p>
</li>
</ol>
<p>思路来自<a href="https://leetcode-cn.com/problems/find-kth-bit-in-nth-binary-string/solution/zhi-she-ji-jian-dan-de-shu-xue-ji-suan-by-lirunjun/" target="_blank" rel="noopener">___rj</a>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">以 n &#x3D; 3， k &#x3D; 5 来解释第 3 条规则：</span><br><span class="line">s1 &#x3D; 0</span><br><span class="line">s2 &#x3D; 011</span><br><span class="line">s3 &#x3D; 0111001</span><br><span class="line"></span><br><span class="line">所有的下标都是从 1 开始，n &#x3D; 3 时，midPos &#x3D; 2 ^ 2 &#x3D; 4，而 k &#x3D; 5，S3[5] 为 reverse(invert(S2))[5 - 4],为invert(s2)[4 - (5 - 4)],即 invert(s2)[3]。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">findKthBit</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> invertNum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">//计算第 n 个字符串的中间位置</span></span><br><span class="line">            <span class="keyword">int</span> midPos = (<span class="keyword">int</span>)Math.pow(<span class="number">2</span>, n - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(k == midPos)&#123;<span class="comment">//等于中间位置，中间位置为 1 变换 invertNum 次得到的数</span></span><br><span class="line">                <span class="keyword">return</span> invertNum % <span class="number">2</span> == <span class="number">0</span> ? <span class="string">'1'</span> : <span class="string">'0'</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(k &gt; midPos)&#123;<span class="comment">//在第 n - 1个字符串中查找</span></span><br><span class="line">                k = <span class="number">2</span> * midPos - k;</span><br><span class="line">                ++invertNum;</span><br><span class="line">            &#125;</span><br><span class="line">            --n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//结果为 初始值 0 变换 invertNum 次得到</span></span><br><span class="line">        <span class="keyword">return</span> invertNum % <span class="number">2</span> == <span class="number">0</span> ? <span class="string">'0'</span> : <span class="string">'1'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法三：递归</strong></p>
<p>和方法二类似，这里用递归实现。</p>
<p>思路来自<a href="https://leetcode-cn.com/problems/find-kth-bit-in-nth-binary-string/solution/di-gui-shuang-bai-logn-by-233999/" target="_blank" rel="noopener">小名的魔法少爷</a>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">findKthBit</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'0'</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> mid = (<span class="keyword">int</span>)Math.pow(<span class="number">2</span>, n - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(k == mid)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'1'</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(k &lt; mid)&#123;</span><br><span class="line">            <span class="keyword">return</span> findKthBit(n - <span class="number">1</span>, k);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> findKthBit(n - <span class="number">1</span>, <span class="number">2</span> * mid - k) == <span class="string">'0'</span> ? <span class="string">'1'</span> : <span class="string">'0'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="1546-和为目标值的最大数目不重叠非空子数组数目-Medium"><a href="#1546-和为目标值的最大数目不重叠非空子数组数目-Medium" class="headerlink" title="1546. 和为目标值的最大数目不重叠非空子数组数目(Medium)"></a><a href="https://leetcode-cn.com/problems/maximum-number-of-non-overlapping-subarrays-with-sum-equals-target/" target="_blank" rel="noopener">1546. 和为目标值的最大数目不重叠非空子数组数目(Medium)</a></h4><p>给你一个数组 <code>nums</code> 和一个整数 <code>target</code> 。</p>
<p>请你返回 <strong>非空不重叠</strong> 子数组的最大数目，且每个子数组中数字和都为 <code>target</code> 。</p>
<p> <strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [1,1,1,1,1], target &#x3D; 2</span><br><span class="line">输出：2</span><br><span class="line">解释：总共有 2 个不重叠子数组 [(1,1),1,(1,1)] ，它们的和为目标值 2 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [-1,3,5,1,4,2,-9], target &#x3D; 6</span><br><span class="line">输出：2</span><br><span class="line">解释：总共有 3 个子数组和为 6 。</span><br><span class="line">([5,1], [4,2], [3,5,1,4,2,-9]) 但只有前 2 个是不重叠的。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [-2,6,6,3,5,4,1,2,8], target &#x3D; 10</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure>

<p><strong>示例 4：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [0,0,0], target &#x3D; 0</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure>

<p> <strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 10^5</code></li>
<li><code>-10^4 &lt;= nums[i] &lt;= 10^4</code></li>
<li><code>0 &lt;= target &lt;= 10^6</code></li>
</ul>
<p>我们使用前缀和 + 哈希表来实现，此题与<a href="https://leetcode-cn.com/problems/subarray-sum-equals-k/" target="_blank" rel="noopener">560. 和为K的子数组</a>类似，使用 pre[i] 来表示[0 … i] 的子数组的和。使用一个 HashSet 存储已经出现过的连续子数组和 pre[i] ，在遍历的过程中判断是否存在和为 sum - target 的值（连续子数组 pre[j - 1]）：</p>
<ul>
<li>存在，证明 [j … i]是一个满足条件的结果。此时，需要将 HashSet 和 sum 清空，保证不会用到 [j … i] 的元素 ，同时将 sum 加入 HashSet。</li>
<li>不存在，继续将 pre[i] 加入 HashSet。</li>
</ul>
<p>思路来自<a href="https://leetcode-cn.com/problems/maximum-number-of-non-overlapping-subarrays-with-sum-equals-target/solution/c-qian-zhui-he-tan-xin-shuang-bai-by-scyq/" target="_blank" rel="noopener">scyq</a>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxNonOverlapping</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        set.add(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x : nums)&#123;</span><br><span class="line">            sum += x;</span><br><span class="line">            <span class="keyword">if</span>(set.contains(sum - target))&#123;</span><br><span class="line">                set.clear();</span><br><span class="line">                sum = <span class="number">0</span>;</span><br><span class="line">                ++ans;</span><br><span class="line">            &#125;</span><br><span class="line">            set.add(sum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="1547-切棍子的最小成本-Hard"><a href="#1547-切棍子的最小成本-Hard" class="headerlink" title="1547. 切棍子的最小成本(Hard)"></a><a href="https://leetcode-cn.com/problems/minimum-cost-to-cut-a-stick/" target="_blank" rel="noopener">1547. 切棍子的最小成本(Hard)</a></h4><p>有一根长度为 <code>n</code> 个单位的木棍，棍上从 <code>0</code> 到 <code>n</code> 标记了若干位置。例如，长度为 <strong>6</strong> 的棍子可以标记如下：</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20200810164134879.png" alt="image-20200810164134879"></p>
<p>给你一个整数数组 <code>cuts</code> ，其中 <code>cuts[i]</code> 表示你需要将棍子切开的位置。</p>
<p>你可以按顺序完成切割，也可以根据需要更改切割的顺序。</p>
<p>每次切割的成本都是当前要切割的棍子的长度，切棍子的总成本是历次切割成本的总和。对棍子进行切割将会把一根木棍分成两根较小的木棍（这两根木棍的长度和就是切割前木棍的长度）。请参阅第一个示例以获得更直观的解释。</p>
<p>返回切棍子的 <strong>最小总成本</strong> 。</p>
<p> <strong>示例 1：</strong></p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20200810170104715.png" alt="image-20200810170104715"></p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20200810164337518.png" alt="image-20200810164337518"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 7, cuts &#x3D; [1,3,4,5]</span><br><span class="line">输出：16</span><br><span class="line">解释：按 [1, 3, 4, 5] 的顺序切割的情况如上所示。</span><br><span class="line"></span><br><span class="line">第一次切割长度为 7 的棍子，成本为 7 。第二次切割长度为 6 的棍子（即第一次切割得到的第二根棍子），第三次切割为长度 4 的棍子，最后切割长度为 3 的棍子。总成本为 7 + 6 + 4 + 3 &#x3D; 20 。</span><br><span class="line">而将切割顺序重新排列为 [3, 5, 1, 4] 后，总成本 &#x3D; 16（如示例图中 7 + 4 + 3 + 2 &#x3D; 16）。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 9, cuts &#x3D; [5,6,1,4,2]</span><br><span class="line">输出：22</span><br><span class="line">解释：如果按给定的顺序切割，则总成本为 25 。总成本 &lt;&#x3D; 25 的切割顺序很多，例如，[4，6，5，2，1] 的总成本 &#x3D; 22，是所有可能方案中成本最小的。</span><br></pre></td></tr></table></figure>

<p> <strong>提示：</strong></p>
<ul>
<li><code>2 &lt;= n &lt;= 10^6</code></li>
<li><code>1 &lt;= cuts.length &lt;= min(n - 1, 100)</code></li>
<li><code>1 &lt;= cuts[i] &lt;= n - 1</code></li>
<li><code>cuts</code> 数组中的所有整数都 <strong>互不相同</strong></li>
</ul>
<p>我们使用动态规划：<code>dp[i][j]</code> 表示切割<code>[i, j]</code>这段木棍所需要的最小成本，那么就在<code>[i, j]</code>之间找一个切割点，使切割成本最小。</p>
<p>状态转移方程为：<br>$$<br>dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j] + cus[j] - cuts[i])<br>$$<br><code>dp[0][n]</code>为最后结果。我们从较小的木棍长度开始 dp，[i, j] 长度最短为 2 ，否则就没有切割点。</p>
<p>思路来自<a href="https://leetcode-cn.com/problems/minimum-cost-to-cut-a-stick/solution/java-qu-jian-dp-by-deena/" target="_blank" rel="noopener">Evelyn</a> 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minCost</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[] cuts)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//添加头尾</span></span><br><span class="line">        list.add(<span class="number">0</span>);</span><br><span class="line">        list.add(n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x : cuts)&#123;</span><br><span class="line">            list.add(x);</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//排序</span></span><br><span class="line">        Collections.sort(list);</span><br><span class="line">        <span class="keyword">int</span> m = list.size();</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m][m];</span><br><span class="line">        <span class="comment">//[i, j]从最短长度 2 开始 dp</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> len = <span class="number">2</span>; len &lt; m; len++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i + len &lt; m; i++)&#123;</span><br><span class="line">                <span class="keyword">int</span> j = i + len;</span><br><span class="line">                dp[i][j] = Integer.MAX_VALUE;</span><br><span class="line">                <span class="comment">//list.get(j) - list.get(i)为切割[i, j]的成本</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = i + <span class="number">1</span>; k &lt; j; k++)&#123;</span><br><span class="line">                    dp[i][j] = Math.min(dp[i][j], dp[i][k] + dp[k][j] + list.get(j) - list.get(i));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][m - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>哈希表</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode第200场周赛</title>
    <url>/2020/08/02/Leetcode%E7%AC%AC200%E5%9C%BA%E5%91%A8%E8%B5%9B/</url>
    <content><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>第一次参加周赛，AC 两道暴力题，重在参与，哈哈哈。</p>
<a id="more"></a>

<h4 id="5475-统计好三元组-Easy"><a href="#5475-统计好三元组-Easy" class="headerlink" title="5475. 统计好三元组(Easy)"></a><a href="https://leetcode-cn.com/problems/count-good-triplets/" target="_blank" rel="noopener">5475. 统计好三元组(Easy)</a></h4><p>给你一个整数数组 <code>arr</code> ，以及 <code>a</code>、<code>b</code> 、<code>c</code> 三个整数。请你统计其中好三元组的数量。</p>
<p>如果三元组 <code>(arr[i], arr[j], arr[k])</code> 满足下列全部条件，则认为它是一个 <strong>好三元组</strong> 。</p>
<ul>
<li><code>0 &lt;= i &lt; j &lt; k &lt; arr.length</code></li>
<li><code>|arr[i] - arr[j]| &lt;= a</code></li>
<li><code>|arr[j] - arr[k]| &lt;= b</code></li>
<li><code>|arr[i] - arr[k]| &lt;= c</code></li>
</ul>
<p>其中 <code>|x|</code> 表示 <code>x</code> 的绝对值。</p>
<p>返回 <strong>好三元组的数量</strong> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：arr &#x3D; [3,0,1,1,9,7], a &#x3D; 7, b &#x3D; 2, c &#x3D; 3</span><br><span class="line">输出：4</span><br><span class="line">解释：一共有 4 个好三元组：[(3,0,1), (3,0,1), (3,1,1), (0,1,1)] 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：arr &#x3D; [1,1,2,2,3], a &#x3D; 0, b &#x3D; 0, c &#x3D; 1</span><br><span class="line">输出：0</span><br><span class="line">解释：不存在满足所有条件的三元组。</span><br></pre></td></tr></table></figure>

<p> <strong>提示：</strong></p>
<ul>
<li><code>3 &lt;= arr.length &lt;= 100</code></li>
<li><code>0 &lt;= arr[i] &lt;= 1000</code></li>
<li><code>0 &lt;= a, b, c &lt;= 1000</code></li>
</ul>
<p>我们直接使用暴力法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countGoodTriplets</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = arr.length, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">2</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n - <span class="number">1</span>; j++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = j + <span class="number">1</span>; k &lt; n; k++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(Math.abs(arr[i] - arr[j]) &lt;= a &amp;&amp; Math.abs(arr[j] - arr[k]) &lt;= b &amp;&amp; Math.abs(arr[i] - arr[k]) &lt;= c)&#123;</span><br><span class="line">                        ++ans;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度O(n^3)，空间复杂度O(1)。</p>
<h4 id="5476-找出数组游戏的赢家-Medium"><a href="#5476-找出数组游戏的赢家-Medium" class="headerlink" title="5476. 找出数组游戏的赢家(Medium)"></a><a href="https://leetcode-cn.com/problems/find-the-winner-of-an-array-game/" target="_blank" rel="noopener">5476. 找出数组游戏的赢家(Medium)</a></h4><p>给你一个由 <strong>不同</strong> 整数组成的整数数组 <code>arr</code> 和一个整数 <code>k</code> 。</p>
<p>每回合游戏都在数组的前两个元素（即 <code>arr[0]</code> 和 <code>arr[1]</code> ）之间进行。比较 <code>arr[0]</code> 与 <code>arr[1]</code> 的大小，较大的整数将会取得这一回合的胜利并保留在位置 <code>0</code> ，较小的整数移至数组的末尾。当一个整数赢得 <code>k</code> 个连续回合时，游戏结束，该整数就是比赛的 <strong>赢家</strong> 。</p>
<p>返回赢得比赛的整数。</p>
<p>题目数据 <strong>保证</strong> 游戏存在赢家。</p>
<p> <strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：arr &#x3D; [2,1,3,5,4,6,7], k &#x3D; 2</span><br><span class="line">输出：5</span><br><span class="line">解释：一起看一下本场游戏每回合的情况(下图)：</span><br><span class="line">因此将进行 4 回合比赛，其中 5 是赢家，因为它连胜 2 回合。</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/q-example.png" alt="q-example"></p>
<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：arr &#x3D; [3,2,1], k &#x3D; 10</span><br><span class="line">输出：3</span><br><span class="line">解释：3 将会在前 10 个回合中连续获胜。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：arr &#x3D; [1,9,8,2,3,7,6,4,5], k &#x3D; 7</span><br><span class="line">输出：9</span><br></pre></td></tr></table></figure>

<p><strong>示例 4：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：arr &#x3D; [1,11,22,33,44,55,66,77,88,99], k &#x3D; 1000000000</span><br><span class="line">输出：99</span><br></pre></td></tr></table></figure>

<p> <strong>提示：</strong></p>
<ul>
<li><code>2 &lt;= arr.length &lt;= 10^5</code></li>
<li><code>1 &lt;= arr[i] &lt;= 10^6</code></li>
<li><code>arr</code> 所含的整数 <strong>各不相同</strong> 。</li>
<li><code>1 &lt;= k &lt;= 10^9</code></li>
</ul>
<p><strong>方法一：链表</strong></p>
<p>需要频繁在数组头部和尾部进行增删，我首先想到链表。我们使用链表来模拟这个游戏规则。当 k 大于数组的长度时，我们直接返回数组中的最大值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getWinner</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// k 大于数组长度，直接返回数组中的最大值</span></span><br><span class="line">        <span class="keyword">if</span>(k &gt; arr.length)&#123;</span><br><span class="line">            <span class="keyword">int</span> ans = arr[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> x : arr)&#123;</span><br><span class="line">                ans = Math.max(ans, x);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将数组转换为链表</span></span><br><span class="line">        List&lt;Integer&gt; arrList = Arrays.stream(arr).boxed().collect(Collectors.toList());</span><br><span class="line">        LinkedList&lt;Integer&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;(arrList);</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//模拟游戏</span></span><br><span class="line">        <span class="keyword">while</span>(count &lt; k)&#123;</span><br><span class="line">            <span class="keyword">int</span> first = list.get(<span class="number">0</span>), second = list.get(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(first &gt; second)&#123;</span><br><span class="line">                ++count;</span><br><span class="line">                list.addLast(second);</span><br><span class="line">                list.remove(<span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                count = <span class="number">1</span>;<span class="comment">//删除第一个结点时，count 初始化为 1</span></span><br><span class="line">                list.addLast(first);</span><br><span class="line">                list.remove(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//链表中第一个元素为结果</span></span><br><span class="line">        <span class="keyword">return</span> list.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度O(n)，n 为数组的长度。空间复杂度O(n)，n 为数组的长度。</p>
<p><strong>方法二：滑动窗口</strong></p>
<p>如果可以修改数组，我们可以只用一次遍历得到答案。我们每次比较两个数，两者中较小的数绝对不可能成为结果，我们将其修改为较大的值，窗口向后移动，再次比较，同时记录获胜的次数，如果次数等于 k 直接返回。   </p>
<p>思路来自<a href="https://leetcode-cn.com/problems/find-the-winner-of-an-array-game/solution/shuang-bai-by-huth/" target="_blank" rel="noopener">Huth</a>。</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20200802131627474.png" alt="image-20200802131627474"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getWinner</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, t = <span class="number">0</span>, n = arr.length;</span><br><span class="line">        <span class="keyword">while</span>(t &lt; k &amp;&amp; i &lt; n - <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i] &gt; arr[i + <span class="number">1</span>])&#123;</span><br><span class="line">                arr[i + <span class="number">1</span>] = arr[i];</span><br><span class="line">                t++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                t = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度O(n)，n 为数组的长度。空间复杂度O(1)。</p>
<h4 id="5477-排布二进制网格的最少交换次数-Medium"><a href="#5477-排布二进制网格的最少交换次数-Medium" class="headerlink" title="5477. 排布二进制网格的最少交换次数(Medium)"></a><a href="https://leetcode-cn.com/problems/minimum-swaps-to-arrange-a-binary-grid/" target="_blank" rel="noopener">5477. 排布二进制网格的最少交换次数(Medium)</a></h4><p>给你一个 <code>n x n</code> 的二进制网格 <code>grid</code>，每一次操作中，你可以选择网格的 <strong>相邻两行</strong> 进行交换。</p>
<p>一个符合要求的网格需要满足主对角线以上的格子全部都是 <strong>0</strong> 。</p>
<p>请你返回使网格满足要求的最少操作次数，如果无法使网格符合要求，请你返回 <strong>-1</strong> 。</p>
<p>主对角线指的是从 <code>(1, 1)</code> 到 <code>(n, n)</code> 的这些格子。</p>
<p> <strong>示例 1：</strong></p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20200802132108822.png" alt="image-20200802132108822"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：grid &#x3D; [[0,0,1],[1,1,0],[1,0,0]]</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20200802132126421.png" alt="image-20200802132126421"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：grid &#x3D; [[0,1,1,0],[0,1,1,0],[0,1,1,0],[0,1,1,0]]</span><br><span class="line">输出：-1</span><br><span class="line">解释：所有行都是一样的，交换相邻行无法使网格符合要求。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20200802132246790.png" alt="image-20200802132246790"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：grid &#x3D; [[1,0,0],[1,1,0],[1,1,1]]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>n == grid.length</code></li>
<li><code>n == grid[i].length</code></li>
<li><code>1 &lt;= n &lt;= 200</code></li>
<li><code>grid[i][j]</code> 要么是 <code>0</code> 要么是 <code>1</code> 。</li>
</ul>
<p>自己的想法：首先求出每行右侧连续的 0 的个数，使用冒泡排序，将最大值放最上面，将最小值放下面，这不是最佳答案。。。就没想出来。</p>
<p>贪心思路：</p>
<p>从第一行开始，如果该行的后缀 0 满足要求，那么直接跳过进入下一行（因为需要的后缀 0  个数都是从大到小的顺序，所以不必担心前一行使用后一行的后缀 0 个数）。</p>
<p>如果该行的后缀 0 个数不满足条件，那么就往下遍历找到<strong>最先（贪心，这是最小次数）</strong>满足条件的行，一行一行交换上来，记录交换的次数</p>
<p>如果找不到满足条件的后缀 0 ，那么返回 - 1。</p>
<p>贪心思路来自<a href="https://leetcode-cn.com/problems/minimum-swaps-to-arrange-a-binary-grid/solution/c-tan-xin-hou-zhui-0-by-spacex-1/" target="_blank" rel="noopener">spaceX</a>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minSwaps</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = grid.length;</span><br><span class="line">        <span class="keyword">int</span>[] zero = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="comment">//统计每一行的后缀 0 个数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = n - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="number">0</span>)&#123;</span><br><span class="line">                    ++count;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            zero[i] = count;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//记录交换的次数</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//从第一行开始判断</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(zero[i] &gt;= n - i - <span class="number">1</span>) <span class="keyword">continue</span>; <span class="comment">//条件满足</span></span><br><span class="line">            <span class="keyword">else</span>&#123;<span class="comment">//条件不满足</span></span><br><span class="line">                <span class="keyword">int</span> j = i;</span><br><span class="line">                <span class="comment">//尝试找满足条件的后缀 0 个数</span></span><br><span class="line">                <span class="keyword">for</span>(; j &lt; n; j++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(zero[j] &gt;= n - i - <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">				<span class="comment">//未找到</span></span><br><span class="line">                <span class="keyword">if</span>(j == n) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">				<span class="comment">//将找到的后缀 0 个数一直交换上来</span></span><br><span class="line">                <span class="keyword">for</span>(; j &gt; i; j--)&#123;</span><br><span class="line">                    <span class="keyword">int</span> temp = zero[j];</span><br><span class="line">                    zero[j] = zero[j - <span class="number">1</span>];</span><br><span class="line">                    zero[j - <span class="number">1</span>] = temp;</span><br><span class="line">                    <span class="comment">//增加交换次数</span></span><br><span class="line">                    ++count;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度O(n^2)，n 为数组的长度。空间复杂度O(n)。</p>
<h4 id="5478-最大得分-Hard"><a href="#5478-最大得分-Hard" class="headerlink" title="5478. 最大得分(Hard)"></a><a href="https://leetcode-cn.com/problems/get-the-maximum-score/" target="_blank" rel="noopener">5478. 最大得分(Hard)</a></h4><p>你有两个 <strong>有序</strong> 且数组内元素互不相同的数组 <code>nums1</code> 和 <code>nums2</code> 。</p>
<p>一条 <strong>合法路径</strong> 定义如下：</p>
<ul>
<li>选择数组 nums1 或者 nums2 开始遍历（从下标 0 处开始）。</li>
<li>从左到右遍历当前数组。</li>
<li>如果你遇到了 <code>nums1</code> 和 <code>nums2</code> 中都存在的值，那么你可以切换路径到另一个数组对应数字处继续遍历（但在合法路径中重复数字只会被统计一次）。</li>
</ul>
<p>得分定义为合法路径中不同数字的和。</p>
<p>请你返回所有可能合法路径中的最大得分。</p>
<p>由于答案可能很大，请你将它对 10^9 + 7 取余后返回。</p>
<p> <strong>示例 1：</strong></p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20200802140803920.png" alt="image-20200802140803920"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums1 &#x3D; [2,4,5,8,10], nums2 &#x3D; [4,6,8,9]</span><br><span class="line">输出：30</span><br><span class="line">解释：合法路径包括：</span><br><span class="line">[2,4,5,8,10], [2,4,5,8,9], [2,4,6,8,9], [2,4,6,8,10],（从 nums1 开始遍历）</span><br><span class="line">[4,6,8,9], [4,5,8,10], [4,5,8,9], [4,6,8,10]  （从 nums2 开始遍历）</span><br><span class="line">最大得分为上图中的绿色路径 [2,4,6,8,10] 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums1 &#x3D; [1,3,5,7,9], nums2 &#x3D; [3,5,100]</span><br><span class="line">输出：109</span><br><span class="line">解释：最大得分由路径 [1,3,5,100] 得到。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums1 &#x3D; [1,2,3,4,5], nums2 &#x3D; [6,7,8,9,10]</span><br><span class="line">输出：40</span><br><span class="line">解释：nums1 和 nums2 之间无相同数字。</span><br><span class="line">最大得分由路径 [6,7,8,9,10] 得到。</span><br></pre></td></tr></table></figure>

<p><strong>示例 4：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums1 &#x3D; [1,4,5,8,9,11,19], nums2 &#x3D; [2,3,4,11,12]</span><br><span class="line">输出：61</span><br></pre></td></tr></table></figure>

<p> <strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums1.length &lt;= 10^5</code></li>
<li><code>1 &lt;= nums2.length &lt;= 10^5</code></li>
<li><code>1 &lt;= nums1[i], nums2[i] &lt;= 10^7</code></li>
<li><code>nums1</code> 和 <code>nums2</code> 都是严格递增的数组。</li>
</ul>
<p>自己的想法：可以把两个数组看成一个数，从两个根节点开始求路径的最大长度。</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20200802144100427.png" alt="image-20200802144100427"></p>
<p>尝试构建这个二叉树，花费的时间太多，正确的方法应该是使用两个指针来模拟这个过程。</p>
<p>别人的思路：</p>
<p>相交的点将两个数组分成(k + 1)段，取每一段的较大值计入结果，使用双指针实现。</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20200802143441663.png" alt="image-20200802143441663"></p>
<p>思路来自<a href="https://leetcode-cn.com/problems/get-the-maximum-score/solution/cshuang-zhi-zhen-fen-duan-tong-ji-zui-da-he-xiang-/" target="_blank" rel="noopener">LeonDeng</a>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSum</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//nums1 和 nums2 当前计算的段的大小</span></span><br><span class="line">        <span class="keyword">long</span> sum1 = <span class="number">0</span>, sum2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//指针</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; nums1.length &amp;&amp; j &lt; nums2.length)&#123;</span><br><span class="line">            <span class="comment">//有相同的点，当前段结束</span></span><br><span class="line">            <span class="keyword">if</span>(nums1[i] == nums2[j])&#123;</span><br><span class="line">                res += (Math.max(sum1, sum2) + nums1[i]);</span><br><span class="line">                <span class="comment">//重置段长</span></span><br><span class="line">                sum1 = <span class="number">0</span>;</span><br><span class="line">                sum2 = <span class="number">0</span>;</span><br><span class="line">                i++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums1[i] &lt; nums2[j])&#123;</span><br><span class="line">                <span class="comment">//必须先将较小值的指针向后移，先将较大的后移可能会错过相同点</span></span><br><span class="line">                sum1 += nums1[i++];<span class="comment">//将长度添加到段长内</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                sum2 += nums2[j++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//增加剩下的段长</span></span><br><span class="line">        <span class="keyword">while</span>(i &lt; nums1.length)&#123;</span><br><span class="line">            sum1 += nums1[i++];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(j &lt; nums2.length)&#123;</span><br><span class="line">            sum2 += nums2[j++];</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//取两个段长最长加入到结果</span></span><br><span class="line">        res += Math.max(sum1, sum2);</span><br><span class="line">        <span class="comment">//结果取余</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)(res % <span class="number">1000000007</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度O(max(m,n))，m 和 n 为两个数组的长度。空间复杂度O(1)。</p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>链表</tag>
        <tag>滑动窗口</tag>
        <tag>双指针</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>Java并发编程实战</title>
    <url>/2020/08/17/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/</url>
    <content><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>线程的优势：</p>
<ul>
<li>发挥多处理器强大的能力</li>
<li>建模的简单性（为模型中的每种类型的任务都分配一个专门的线程）</li>
<li>异步事件的简化处理</li>
<li>响应更灵敏的用户界面</li>
</ul>
<a id="more"></a>

<h4 id="线程带来的风险"><a href="#线程带来的风险" class="headerlink" title="线程带来的风险"></a>线程带来的风险</h4><h5 id="安全性问题"><a href="#安全性问题" class="headerlink" title="安全性问题"></a>安全性问题</h5><p>线程安全性可能是非常复杂的，在没有充分同步的情况下，多个线程中的操作执行顺序是不可预测的，甚至会产生奇怪的结果。</p>
<h5 id="活跃性问题"><a href="#活跃性问题" class="headerlink" title="活跃性问题"></a>活跃性问题</h5><p>安全性的定义是”永远不发生糟糕的事情”，而活跃性关注于另一个目标“某件正确的事情最终会发生“。<strong>当某个操作无法继续执行下去时，就会发生活跃性问题。</strong>活跃性问题的形式之一就是无意中造成的无限循环。</p>
<h5 id="性能问题"><a href="#性能问题" class="headerlink" title="性能问题"></a>性能问题</h5><p>在设计良好的并发应用程序中，线程能提高程序的性能。但无论如何，线程会带来一定的运行时开销。在多线程程序中，当线程调度器挂起一个活跃线程并转而运行另一个线程时，就会频繁出现上下文切换操作，这会带来极大的开销。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 1-1 非线程安全的数值序列生成器</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnsafeSequence</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 返回一个独一无二的值</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNext</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        UnsafeSequence sequence = <span class="keyword">new</span> UnsafeSequence();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">            Thread t = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                System.out.print(sequence.getNext() + <span class="string">"\t"</span>);</span><br><span class="line">            &#125;);</span><br><span class="line">            t.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在没有充分同步的情况下，生成的序列号可能相同（也可能全部不相同，但是多运行几次一定可以看到相同的序列号）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">一次运行结果：</span><br><span class="line">0	3	2	1	0	5	4	6	7	8</span><br></pre></td></tr></table></figure>

<p>我们将 getNext 修改为一个同步方法（添加 synchronized），就可修复上面的错误，每次都可以得到唯一的序列号。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 1-2 线程安全的数值序列生成器</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sequence</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> nextValue;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">getNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nextValue++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Sequence sequence = <span class="keyword">new</span> Sequence();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">            Thread t = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                System.out.print(sequence.getNext() + <span class="string">"\t"</span>);</span><br><span class="line">            &#125;);</span><br><span class="line">            t.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="线程安全性"><a href="#线程安全性" class="headerlink" title="线程安全性"></a>线程安全性</h3><p>从非正式意义上来说，对象的状态是指存储在状态变量（例如实例和静态域）中的数据。<code>共享</code>意味着变量可以由多个线程同时访问，而<code>可变</code>意味着变量的值可以在生命周期内变化。</p>
<p>当多个线程访问某个状态变量并且其中有一个线程执行写入操作，必须采用<code>同步</code>机制来协同这些线程对变量的访问。Java 中的主要同步机制是关键字 <code>synchronized</code> ，它提供了一种独占的加锁方式，但“同步”这个术语还包括 volatile 类型的变量，显式锁（Explicit Lock） 以及原子变量。</p>
<blockquote>
<p>如果当多个线程访问同一个可变的状态变量时没有使用合适的同步，那么程序就会出现错误，有三种方式可以修复这个问题：</p>
<ol>
<li>不在线程中共享该状态变量</li>
<li>将该状态变量设置为不可变的变量</li>
<li>在访问状态变量时使用同步</li>
</ol>
</blockquote>
<p>在编写并发程序时，一种正常的编程方法就是：首先使代码正确运行，然后提高代码的速度。</p>
<h4 id="什么是线程安全性"><a href="#什么是线程安全性" class="headerlink" title="什么是线程安全性"></a>什么是线程安全性</h4><p>在线程安全性的定义中最核心的概念就是正确性，正确性的含义是，<strong>某个类的行为与其规范完全一致</strong>。在良好的规范中通常会定义各种不变性条件（Invariant）来约束对象的状态，以及定义各种后验条件（Post condition）来描述对象操作的结果。当多线程访问某个类时，这个类始终都能表现出正确的行为，那么这个类就是线程安全的。</p>
<blockquote>
<p>在线程安全的类中封装了必要的同步机制，因此客户端无需进一步采取同步措施。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Request</span></span>&#123;<span class="comment">//Response 和Request 类定义一样</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    <span class="comment">//构造、setter、getter 省略</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 2-1 一个无状态的 Servlet</span></span><br><span class="line"><span class="comment">* 线程安全</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AdderServlet</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(Request request, Response response)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> value = request.getValue();</span><br><span class="line">        System.out.println(<span class="string">"Init Value: "</span> + value);</span><br><span class="line">        value += <span class="number">6</span>;</span><br><span class="line">        System.out.println(<span class="string">"Modified Value: "</span> + value);</span><br><span class="line">        request.setValue(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与大多数 Servlet 相同，AdderServlet 是无状态的：它既不包含任何域，也不包含对任何其他类中域的引用。计算过程中的临时状态仅存在于线程栈上的局部变量中，并且只能由正在执行的线程访问。由于线程访问无状态对象的行为并不会影响其他线程中操作的正确性，因此无状态对象是线程安全的。</p>
<blockquote>
<p>无状态对象一定是线程安全的</p>
</blockquote>
<h4 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h4><p>当我们在无状态对象中增加一个状态时，会出现什么情况？我们在 Servlet 中增加一个 long 类型的域，用它来统计请求的次数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 2-2 在没有同步的情况下统计已请求数量的 Servlet</span></span><br><span class="line"><span class="comment"> * 非线程安全</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnsafeAdderServlet</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(Request request, Response response)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> value = request.getValue();</span><br><span class="line">        System.out.println(<span class="string">"Init Value: "</span> + value);</span><br><span class="line">        value += <span class="number">6</span>;</span><br><span class="line">        System.out.println(<span class="string">"Modified Value: "</span> + value);</span><br><span class="line">        response.setValue(value);</span><br><span class="line">        ++count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Request req = <span class="keyword">new</span> Request(<span class="number">11</span>);</span><br><span class="line">        Response resp = <span class="keyword">new</span> Response();</span><br><span class="line">        UnsafeAdderServlet servlet = <span class="keyword">new</span> UnsafeAdderServlet();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">200000</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                servlet.service(req,resp);</span><br><span class="line">                System.out.println(servlet.getCount());</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们调用 service 方法 200,000 次，最后的 count 也应该是 200,000 ，一次的运行结果却是 199,999。在并发量高的时候，count 值出现了偏差，这是因为自增操作包含三个独立的操作：读取 - 修改 - 写入，结果状态依赖于前面的状态。如果两个线程在没有同步的情况下对 count 变量进行自增操作，可能会带来偏差。以 count 初值为 9 为例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Thread 1:     read(9)  --&gt;  modify(9 + 1 &#x3D; 10)  --&gt;  wirteback(10)</span><br><span class="line">Thread 2:                     read(9)  --&gt;  modify(9 + 1 &#x3D; 10)  --&gt;  wirteback(10)</span><br></pre></td></tr></table></figure>

<p>最终 count 的值为 10，而正确的值为 11 ，这产生了偏差。在并发编程中，这种<strong>由不正确的时序而出现的不正确的结果是一种非常重要的情况</strong>，它有一个正式的名字：<strong>竞态条件</strong>。</p>
<p>当某个计算的正确性取决于多个线程的交替执行时序时，那么就会发生竞态条件。最常见的竞态条件类型就是“先检查后执行（Check-Then-Act）”操作，即通过一个可能失效的观测结果来决定下一步的动作。</p>
<p>使用“先检查后执行”的一种常见情况就是延迟初始化。延迟初始化的目的是将对象的初始化操作推迟到实际被使用时才进行，同时要确保只被初始化一次。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 2-3 延迟初始化中的竞态条件</span></span><br><span class="line"><span class="comment">* 非线程安全</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyInitRace</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ExpensiveObject instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ExpensiveObject <span class="title">getInstance</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> ExpensiveObject();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LazyInitRace lazyInitRace = <span class="keyword">new</span> LazyInitRace();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt;&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(lazyInitRace.getInstance());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExpensiveObject</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ExpensiveObject</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//假设创建对象时间为 200 ms，增加错误几率</span></span><br><span class="line">        Thread.sleep(<span class="number">200</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">运行结果：</span><br><span class="line">concurrencyinpractice.chap2.ExpensiveObject@674827d5</span><br><span class="line">concurrencyinpractice.chap2.ExpensiveObject@674827d5</span><br><span class="line">concurrencyinpractice.chap2.ExpensiveObject@22673956</span><br></pre></td></tr></table></figure>

<p>字符@后面的十六进制数就是对象的哈希码值，在对同一个对象多次调用 hashcode 方法时，哈希码值应该不会改变，结果中出现了两个不同的哈希码值说明我们调用三次 getInstance 方法时，instance 被初始化了两次，这不是我们想要的结果。</p>
<p>为了保证线程安全性，“先检查后操作” 和 “读取 - 修改 - 写入” 操作必须是原子的，我们称这类操作为复合操作。可以使用锁来保证复合操作以原子方式执行，这里我们使用原子变量来修复 UnsafeAdderServlet 的错误。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicLong;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 2-4 使用 AtomicLong 类型的变量来统计已处理请求的数量</span></span><br><span class="line"><span class="comment">* 线程安全</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SafeAdderServlet</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> AtomicLong count = <span class="keyword">new</span> AtomicLong(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(Request request, Response response)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> value = request.getValue();</span><br><span class="line">        System.out.println(<span class="string">"Init Value: "</span> + value);</span><br><span class="line">        value += <span class="number">6</span>;</span><br><span class="line">        System.out.println(<span class="string">"Modified Value: "</span> + value);</span><br><span class="line">        response.setValue(value);</span><br><span class="line">        count.incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getCount</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Request req = <span class="keyword">new</span> Request(<span class="number">11</span>);</span><br><span class="line">        Response resp = <span class="keyword">new</span> Response();</span><br><span class="line">        SafeAdderServlet servlet = <span class="keyword">new</span> SafeAdderServlet();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">500000</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                servlet.service(req,resp);</span><br><span class="line">                System.out.println(servlet.getCount());</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行程序，我们看到最后的count 值为 500,000 与请求的次数相同。通过使用 AtomicLong 来代替 long 类型的计数器，能够确保所有对计数器状态的访问都是原子的。</p>
<p>当在无状态的类中添加一个状态时，如果该状态完全由线程安全的对象来管理，那么这个类仍是线程安全的。</p>
<blockquote>
<p>在实际情况中，应尽可能地使用现有的线程安全对象（例如 AtomicLong）来管理类的状态。</p>
</blockquote>
<p>我们希望提升 Servlet 的性能，将最近计算的结果缓存起来，当两个相同的请求数值到来时，可以直接使用上一次的计算结果，而无须重新计算。</p>
<p>我们通过 AtomicReference 来管理最近执行的数值和结果，它能保证线程安全性吗？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicReference;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicReference;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 2-5 在没有足够原子性保证的情况下对最近计算结果进行缓存</span></span><br><span class="line"><span class="comment">* 非线程安全</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnsafeCachingAdderServlet</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicReference&lt;Integer&gt; lastNumber = <span class="keyword">new</span> AtomicReference&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicReference&lt;Integer&gt; lastResult = <span class="keyword">new</span> AtomicReference&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(Request request, Response response)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        print();</span><br><span class="line">        <span class="keyword">if</span>(request.equals(lastNumber.get()))&#123;</span><br><span class="line">            response.setValue(lastResult.get());</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            response.setValue(request.getValue() + <span class="number">6</span>);</span><br><span class="line">            lastNumber.set(request.getValue());</span><br><span class="line">            Thread.sleep(<span class="number">3</span>);</span><br><span class="line">            lastResult.set(response.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"lastNumber: "</span> + lastNumber + <span class="string">"\t lastResult: "</span> + lastResult);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        UnsafeCachingAdderServlet servlet = <span class="keyword">new</span> UnsafeCachingAdderServlet();</span><br><span class="line">        Response response = <span class="keyword">new</span> Response();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    servlet.service(<span class="keyword">new</span> Request((<span class="keyword">int</span>)(Math.random() * <span class="number">100</span>)), response);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">部分运行结果：</span><br><span class="line">lastNumber: 18	 lastResult: null</span><br><span class="line">lastNumber: 33	 lastResult: 27</span><br><span class="line">lastNumber: 42	 lastResult: 83</span><br></pre></td></tr></table></figure>

<p>这部分结果中，只有第二行是我们期待的结果，其他两行的 result != number + 6。代码中的两组操作（见注释）每一个操作由两个原子操作组成，但这两个原子操作直接串行，不加以同步，这组操作仍是非线程安全的，因为在这两个原子操作中可能有其他线程修改了 AtomicReference 指向的值，这破坏了不变性条件。</p>
<blockquote>
<p>要保持状态的一致性，就要在单个原子操作中更新所有相关的状态变量。</p>
</blockquote>
<h4 id="加锁机制"><a href="#加锁机制" class="headerlink" title="加锁机制"></a>加锁机制</h4><p>Java 提供了一种内置的锁机制来支持原子性：同步代码块（Synchronized Block）。同步代码块包括两部分：一个作为锁的对象引用，一个作为由这个锁保护的代码块。以 synchronized 来修饰的方法就是一种横跨整个方法体的同步代码块，该同步代码块的锁就是方法调用所在的对象。<strong>静态的 synchronized 方法以 Class 对象作为锁</strong>。</p>
<p>每个 Java 对象都可以用做一个实现同步的锁，这些锁被称为内置锁（Intrinsic Lock）或监视器锁（Monitor Lock）。<strong>线程在进入同步代码块之前会自动获得锁，并且在退出同步代码块时自动释放锁</strong>。</p>
<p>在程序 2-6 中使用  synchronized 修饰 service 方法，在同一时刻只能有一个线程可以使用 service 方法，服务的响应性非常低。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 2-6 能正确地缓存最新的计算结果，但并发性非常糟糕（不要这么做）</span></span><br><span class="line"><span class="comment">* 线程安全</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedAdderServlet</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer lastNumber;</span><br><span class="line">    <span class="keyword">private</span> Integer lastResult;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(Request request, Response response)</span></span>&#123;</span><br><span class="line">        print();</span><br><span class="line">        <span class="keyword">if</span>(request.equals(lastNumber))&#123;</span><br><span class="line">            response.setValue(lastNumber);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            lastNumber = request.getValue();</span><br><span class="line">            response.setValue(request.getValue() + <span class="number">6</span>);</span><br><span class="line">            lastResult = response.getValue();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"lastNumber: "</span> + lastNumber + <span class="string">"\t lastResult: "</span> + lastResult);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SynchronizedAdderServlet servlet = <span class="keyword">new</span> SynchronizedAdderServlet();</span><br><span class="line">        Response response = <span class="keyword">new</span> Response();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                servlet.service(<span class="keyword">new</span> Request((<span class="keyword">int</span>)(Math.random() * <span class="number">100</span>)), response);</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>当某个线程请求一个由其他线程持有的锁时，发出请求的线程就会阻塞。然而，由于内置锁是可重入的，因此如果某个线程试图获得一个已经由它自己持有的锁，这个请求就会成功。“重入”意味着获取锁的操作的粒度是“线程”而不是“调用”。重入的一种实现方法是，<strong>为每个锁关联一个获取计数值和一个所有者线程</strong>，当计数值为 0 时，这个锁未被任何线程持有。当线程请求一个未被持有的锁时，JVM 将记下锁的持有者，并将计数值置为 1 ，如果同一个线程再次获取这个数，计数值将会递增。</p>
<p>程序 2-7 中，子类改写了父类的 synchronized 方法，然后调用父类中的方法如果没有可重入的锁，那么这段代码将产生死锁。由于 Widget 和 LoggingWidget 中的 doSomething 方法都是 synchronized 方法，因此每个 doSomething 方法在执行前都会获取 Widget 上的锁。如果内置锁是不可重入的，那么调用 super.doSomething 时无法获得 Widget 上的锁，这个锁已经被持有，线程将永远停顿下去。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 2-7 如果内置锁是不可重入的，这段代码会发生死锁</span></span><br><span class="line"><span class="comment">* 线程安全</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Widget::doSomething()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoggingWidget</span> <span class="keyword">extends</span> <span class="title">Widget</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"LoggingWidget::doSomething()"</span>);</span><br><span class="line">        <span class="keyword">super</span>.doSomething();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LoggingWidget widget = <span class="keyword">new</span> LoggingWidget();</span><br><span class="line">        widget.doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="用锁来保护状态"><a href="#用锁来保护状态" class="headerlink" title="用锁来保护状态"></a>用锁来保护状态</h4><p>由于锁能使其保护的代码路径以穿行形式来访问，因此可以通过锁来构造一些协议以实现对共享状态的独占访问。只要始终遵循这些协议，就能保证状态的一致性。</p>
<p>访问共享状态的复合操作都必须是原子操作以避免产生竞态条件。如果复合操作在执行过程中持有一个锁，那么会使复合操作成为原子操作。然而，仅仅将复合操作封装到同步代码块中是不够的。<strong>如果使用锁来协调对某个变量的访问时，在访问变量的所有位置上都要使用同一个锁</strong>。一种常见的错误认为：只有在写入共享变量时才需要同步，然而并非如此。（见3.1节）</p>
<blockquote>
<p>对于可能被多个线程同时访问的可变状态变量，在访问它时都需要持有同一个锁，在这种情况下，我们称状态变量是由这个锁保护的。</p>
</blockquote>
<p>一种常见的加锁约定是，将所有的可变状态都封装在对象内部，并通过对象的内置锁对所有访问可变状态的代码路径进行同步，使得在该对象上不会发生并发访问。在许多线程安全类中都使用了这种模式，例如 Vector 和其他同步集合类。</p>
<blockquote>
<p>每个共享和可变的变量都应该只由一个锁来保护，从而使维护人员知道是哪一个锁在保护变量。</p>
</blockquote>
<p>只有被多个线程同时访问的可变数据才需要通过锁来保护。</p>
<blockquote>
<p>对于每个包含多个变量的不变性条件，其中涉及的所有变量都需要同一个锁来保护。</p>
</blockquote>
<h4 id="活跃性与性能"><a href="#活跃性与性能" class="headerlink" title="活跃性与性能"></a>活跃性与性能</h4><p>在 UnsafeCachingAdderServlet 中，我们引入了缓存来提升性能，在缓存中需要使用共享状态，因此需要通过同步来维护状态的完整性。然而，如果使用 SynchronizedAdderServlet 中的同步方式，那么代码的执行性能将会十分糟糕。它通过 Servlet 对象的内置锁来保护每一个状态变量，这种简单且粗粒度的方法能保证线程安全性，但读出的代价很高。由于 service 是一个 synchronized 方法，因此每次只有一个线程可以执行，这背离了Servlet 框架的初衷，即 Servlet 需要能同时处理多个请求，这在负载过高的情况下将给用户带来糟糕的体验。</p>
<p>程序2-8中将 Servlet 的代码修改为两个独立的代码块，第一个代码块执行“先检查后执行”序列，另一个代码块负责对缓存更新。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 2-8 缓存最近计算的数值积计算结果的Servlet</span></span><br><span class="line"><span class="comment">* 线程安全</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CachedAdderServlet</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer lastNumber;</span><br><span class="line">    <span class="keyword">private</span> Integer lastResult;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> hits;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> cacheHits;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">long</span> <span class="title">getHits</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hits;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">double</span> <span class="title">getCacheHitRatio</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">double</span>)cacheHits / (<span class="keyword">double</span>)hits;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(Request request, Response response)</span></span>&#123;</span><br><span class="line">        <span class="comment">//不要把从 request 提取数值等耗时操作放在同步代码块中</span></span><br><span class="line">        <span class="keyword">int</span> num = request.getValue();</span><br><span class="line">        <span class="keyword">int</span> result = Integer.MIN_VALUE;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断是否命中缓存</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>)&#123;</span><br><span class="line">            ++hits;</span><br><span class="line">            <span class="keyword">if</span>(lastNumber != <span class="keyword">null</span> &amp;&amp; num == lastNumber)&#123;</span><br><span class="line">                ++cacheHits;</span><br><span class="line">                result = lastResult;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//没有命中缓存就更新缓存的值</span></span><br><span class="line">        <span class="keyword">if</span>(result == Integer.MIN_VALUE)&#123;</span><br><span class="line">            <span class="comment">//计算结果</span></span><br><span class="line">            result = request.getValue() + <span class="number">6</span>;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>)&#123;<span class="comment">//更新缓存</span></span><br><span class="line">                lastNumber = request.getValue();</span><br><span class="line">                lastResult = result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        response.setValue(result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CachedAdderServlet servlet = <span class="keyword">new</span> CachedAdderServlet();</span><br><span class="line">        Response response = <span class="keyword">new</span> Response();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                servlet.service(<span class="keyword">new</span> Request((<span class="keyword">int</span>)(Math.random() * <span class="number">4</span>)), response);</span><br><span class="line">                System.out.println(<span class="string">"Cache Hit Ratio: "</span> + servlet.getCacheHitRatio());</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>通常，在简单性与性能之间存在相互制约的因素。当实现某个同步策略时，一定不要盲目地为了性能而牺牲简单性（这可能破坏安全性）。</p>
</blockquote>
<p>当使用锁时，你应该清楚代码块中实现的功能，以及在执行该代码块时是否需要很长的时间。无论执行计算密集的操作，还是执行某个可能阻塞的操作，如果持有锁的时间过长，那么都会带来活跃性问题。</p>
<blockquote>
<p>当执行时间较长的计算或者可能无法快速完成的操作时（例如，网络 I/O 或控制台 I/O ），一定不要持有锁。</p>
</blockquote>
<h3 id="对象的共享"><a href="#对象的共享" class="headerlink" title="对象的共享"></a>对象的共享</h3><p>要编写正确的并发程序，关键问题在于：在访问共享的可变状态时需要进行正确的管理。我们已经知道同步代码块和同步方法可以确保以原子的方式执行操作，但一种常见的误解是，认为关键字 synchronized 只能用于实现原子性。同步还有一个重要的方面：<strong>内存可见性（Memory Visibility）</strong>。我们不仅希望防止某个线程正在使用对象状态而另一个线程在同时修改该状态，而且希望确保当一个线程修改了对象状态后，其他线程能够看到发生的状态变化。</p>
<h4 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h4><p>可见性是一种复杂的属性，因为可见性中的错误总是会违背我们的直觉。有多个读线程和写线程同时对一个变量进行操作，读线程可能读到的是过期的数据，我们无法确保读线程能<strong>适时</strong>地看到其他线程写入的值，有时甚至是不可能的事情。为了确保多个线程之间对内存写入操作的可见性，必须使用同步。</p>
<p>程序 3-1 中说明了当多个线程在没有同步的情况下共享数据时出现的错误。在代码中，主线程和读线程都将访问共享变量 ready 和 number。主线程启动读线程，然后将 numer 设为 42，并将 ready 设为 true。读线程一直循环知道发现 ready 的值变为 true 然后输出number。虽然看起来可能会输出 42（运行了好多次，都是 42。。），但事实上很可能输出 0 ，或者根本无法终止。这是因为在代码中没有使用足够的同步机制，因此无法保证主线程写入的 ready值和 number 值对于读线程来说是可见的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 3-1 在没有同步的情况下共享变量</span></span><br><span class="line"><span class="comment">* 非线程安全</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NoVisibility</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> ready;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> number;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ReaderThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(!ready)&#123;</span><br><span class="line">                <span class="comment">//暂停当前正在执行的线程对象（及放弃当前拥有的cpu资源）,并执行其他线程</span></span><br><span class="line">                Thread.yield();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(number);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">new</span> ReaderThread().start();</span><br><span class="line">        number = <span class="number">42</span>;</span><br><span class="line">        ready = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>NoVisibility 可能会输出 0 ，因为读线程看到了 ready 的值，但没有看到 number 的值，这种现象称为重排序（Reordering）。</p>
<blockquote>
<p>在没有同步的情况下，编译器、处理器以及运行时都可能对操作的执行顺序进行意向不到的调整。只要有数据在多个线程之间共享，就使用正确的同步。</p>
</blockquote>
<p>NoVisibility 展示了在缺乏同步的程序中可能产生错误结果的一种情况：失效数据。当读线程查看 ready 变量时，可能会得到一个已经失效的值。更糟糕的是，可能获得一个变量的最新值而获得另一个变量的失效值。失效数据还可能导致一些令人困惑的故障，例如意料之外的异常、被破坏的数据结构、不精确的计算以及无限循环等。</p>
<p>程序 3-2 中的 MutableInteger 不是线程安全的，get  和 set 都是在没有同步的情况下访问 value的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 3-2 非线程安全的可变整数类</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MutableInteger</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序 3-3 SynchronizedInteger 通过对 get  和 set 方法进行同步，可以使之成为一个线程安全的类。仅对 set 方法进行同步是不够的，调用 get 的线程仍然会看见失效值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 3-3 线程安全的可变整数类</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedInteger</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>当线程在没有同步的情况下读取变量时，可能会得到一个失效值，但至少这个值是由之前某个线程设置的值，而不是一个随机值。这种安全性保证也被称为最低安全性。</p>
<p>最低安全性适用于绝大多数变量，但有一个例外：非 volatile 类型的 64 位数值变量（double 和 long）。Java 内存模型要求，变量的读取和写入操作必须是原子操作，但对于非 volatile 类型的 long 和 double 变量，JVM 允许将64 位的读写操作分为两个 32 位的操作。当读取到一个新值的高 32 位 和 旧值的低 32 位组合的 64 位数时，就出现了错误。</p>
<blockquote>
<p>在多线程程序中使用共享且可变的 long 和 double 等类型的变量也是不安全的，除非用 volatile 来声明它们，或者用锁保护起来。</p>
</blockquote>
<p>内置锁可以用于确保某个线程以一种可预测的方式来查看另一个线程的执行结果。当后一个线程执行由锁保护的同步代码块时，可以看到前一个线程之前在同一个同步代码块中的所有操作结果。</p>
<blockquote>
<p>加锁的含义不仅仅局限于互斥行为，还包括内存可见性。为了确保所有线程都能看到共享变量的最新值，所有执行读操作或者写操作的线程都必须在同一个锁上同步。</p>
</blockquote>
<p>Java 语言提供了一种稍弱的同步机制，即 <strong>volatile 变量，用来确保将变量的更新操作通知到其他线程。</strong>当把变量声明为 volatile 类型后，编译器与运行时都会注意到这个变量是共享的，因此不会将该变量上的操作与其他内存操作一起重排序。<strong>volatile 变量不会被缓存在寄存器或者对其他处理器不可见的地方，因此在读取 volatile 类型的变量时总会返回最新写入的值。</strong></p>
<p>在访问 volatile 变量时不会执行加锁操作，因此也就不会使执行线程阻塞，因此 volatile 变量是一种比 synchronized 关键字更轻量级的同步机制。从内存可见性的角度来看，写入 volatile 变量相当于退出同步代码块，而读取 volatile 变量相当于进入同步代码块。</p>
<blockquote>
<p>仅当 volatile 变量能简化代码的实现以及对同步策略的验证时，才应该使用它们。如果在验证正确性时需要对可见性进行复杂的判断，那么就不要使用 volatile 变量。</p>
</blockquote>
<p>程序 3-4 给出了 volatile 变量的一种典型用法：检查某个状态标记以判断是否退出循环。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 3-4 数绵羊</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">boolean</span> asleep;</span><br><span class="line">...</span><br><span class="line">    <span class="keyword">while</span>(!asleep)</span><br><span class="line">        countSomeSheep();</span><br></pre></td></tr></table></figure>

<p>volatile 的语义不足以保证递增操作的原子性（count），除非你能确保只有一个线程对变量执行写操作。（如果存在两个线程对变量进行写操作，需要一种机制来保持这两个线程之间的互斥关系，但 volatile 只能保证可见性，不能保证原子性）</p>
<blockquote>
<p>加锁机制既可以确保可见性又可以保证原子性，volatile 变量只能保证可见性。</p>
</blockquote>
<p>当且仅当满足以下所有条件时，才应该使用 volatile 变量：</p>
<ul>
<li>对变量的写入操作不依赖变量的当前值，或者你能确保只有单个线程更新变量的值</li>
<li>该变量不会与其他状态变量一起纳入不变性条件中</li>
<li>在访问变量时不需要加锁</li>
</ul>
<h4 id="发布与逸出"><a href="#发布与逸出" class="headerlink" title="发布与逸出"></a>发布与逸出</h4><p>“发布（Publish）”一个对象指，使对象能够在当前作用域之外的代码中使用。“逸出（Escape）”指，当某个不应该发布的对象被发布。</p>
<p>发布对象最简单的方法是将对象的引用保存到一个公有的静态变量中，以便任何类和线程都能看见该对象。如 3-5 所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 3-5 发布一个对象</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Set&lt;Secret&gt; knownSecrets;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">()</span></span>&#123;</span><br><span class="line">    knownSecrets = <span class="keyword">new</span> HashSet&lt;Secret&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当发布某个对象时，可能会间接地发布其他对象。如果将一个 Secret 对象添加到集合 knownSecrets 中，那么同样会发布这个对象，因为任何代码都能遍历这个集合，获得Secret 对象的引用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 3-6 使内部的可变状态逸出（不要这么做）</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnsafeStates</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String[] states = <span class="keyword">new</span> String[]&#123;</span><br><span class="line">        <span class="string">"AK"</span>, <span class="string">"AL"</span> ...</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> String[] getStates()&#123;<span class="keyword">return</span> states; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码中，任何调用者都能修改 states 数组的内容，数组states已经逸出了它所在的作用域。</p>
<p>当发布一个对象时，在该对象的非私有域中引用的所有对象同样会被发布。</p>
<p>最后一种发布对象或其内部状态的机制就是发布一个内部类的实例。3-7 中，当 ThisEscape 发布 EventListener 时，也隐含地发布了 ThisEscape 实例本身，因为在这个内部类实例中包含了对 ThisEscape 实例地隐含引用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 3-7 隐式地使 this 引用逸出（不要这么做）</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThisEscape</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThisEscape</span><span class="params">(EventSource source)</span></span>&#123;</span><br><span class="line">        source.registerListener(<span class="keyword">new</span> EventListener()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEvent</span><span class="params">(Event e)</span></span>&#123;</span><br><span class="line">                doSomething(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 ThisEscape 中给出了逸出地一个特殊示例，即 this 引用在构造函数中逸出。当从对象的构造函数中发布对象时，只是发布了一个尚未构造完成的对象。在构造过程中使 this 引用逸出的一个常见错误是：在构造函数中启动一个线程。如果想在构造函数中注册一个时间监听器或启动线程，可以使用一个私有的构造函数和一个公共的工厂方法，从而避免不正确的构造过程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 3-8 使用工厂方法来防止 this 引用在构造过程中逸出</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SafeListener</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> EventListener listener;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SafeListener</span><span class="params">()</span></span>&#123;</span><br><span class="line">        listener = <span class="keyword">new</span> EventListener()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEvent</span><span class="params">(Event e)</span></span>&#123;</span><br><span class="line">                doSomething(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SafeListener <span class="title">newInstance</span><span class="params">(EventSource source)</span></span>&#123;</span><br><span class="line">        SafeListener safe = <span class="keyword">new</span> SafeListener();</span><br><span class="line">        source.registerListener(safe.listener);</span><br><span class="line">        <span class="keyword">return</span> safe;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="线程封闭"><a href="#线程封闭" class="headerlink" title="线程封闭"></a>线程封闭</h4><p>当访问共享的可变数据时，通常需要使用同步。一种避免使用同步的方式就是不共享数据。如果尽在单线程内访问数据，就不需要同步。这种技术被称为线程封闭（Thread Confinement）。</p>
<p>栈封闭是线程封闭的一种特例，在栈封闭中，只能通过局部变量才能访问对象。局部变量的固有属性之一就是封闭在执行线程中。它们位于执行线程的栈中，其他线程无法访问。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 3-9 基本类型的局部变量与引用变量的线程封闭性</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadTheArk</span><span class="params">(Collection&lt;Animal&gt; candidates)</span> </span>&#123;</span><br><span class="line">        SortedSet&lt;Animal&gt; animals;</span><br><span class="line">        <span class="keyword">int</span> numPairs = <span class="number">0</span>;</span><br><span class="line">        Animal candidate = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// animals 被封闭在方法中，不要使它们逸出</span></span><br><span class="line">        animals = <span class="keyword">new</span> TreeSet&lt;Animal&gt;(<span class="keyword">new</span> SpeciesGenderComparator());</span><br><span class="line">        animals.addAll(candidates);</span><br><span class="line">        <span class="keyword">for</span> (Animal a : animals) &#123;</span><br><span class="line">            <span class="keyword">if</span> (candidate == <span class="keyword">null</span> || !candidate.isPotentialMate(a))</span><br><span class="line">                candidate = a;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                ark.load(<span class="keyword">new</span> AnimalPair(candidate, a));</span><br><span class="line">                ++numPairs;</span><br><span class="line">                candidate = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> numPairs;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>如果发布了对 animals 的引用，那么线程封闭性将被破坏，并导致对象 animals 的逸出。</p>
<p>维持线程封闭性的一种更规范方法是使用 ThreadLocal，这个类能使线程中的某个值与保存值的对象关联起来。ThreadLocal 对象通常用于防止对可变的单实例变量（Singleton）或全局变量进行共享。 </p>
<p>例如，在单线程程序中可能维持一个全局的数据库连接，并在程序启动时初始化这个连接，由于 JDBC 连接对象不一定是线程安全的。通过将 JDBC 的连接保存到 ThreadLocal 对象中，每个线程都会拥有属于自己的连接。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 3-10 使用 ThreadLocal 来维持线程封闭性</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Connection</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Connection&gt; connectionHandler= <span class="keyword">new</span> ThreadLocal&lt;Connection&gt;()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> Connection <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Connection();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//当第一次调用 get 方法时，initialValue 将会被调用</span></span><br><span class="line">        <span class="keyword">return</span> connectionHandler.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当某个频繁执行的操作需要一个临时对象，例如一个缓冲区，而同时又希望避免在每次执行时都重新分配该临时对象，就可以使用这项技术。</p>
<p>ThreadLocal 变量类似于全局变量，它能降低代码的可重用性，并在类之间引入隐含的耦合性，因此在使用时要格外小心。</p>
<h4 id="不变性"><a href="#不变性" class="headerlink" title="不变性"></a>不变性</h4><p>满足同步需求的另一种方法是使用不可变对象（Immutable Object）。如果某个对象在被创建后其状态就不能被修改，那么这个对象就称为不可变对象。线程安全性是不可变对象的固有属性，它们的不变性条件是由构造函数创建的，只要它们的状态不改变，那么这些不变性条件就能得以维持。</p>
<blockquote>
<p>不可变对象一定是线程安全的。</p>
</blockquote>
<p>当满足以下条件时，对象才是不可变的：</p>
<ul>
<li>对象创建以后其状态不能改变</li>
<li>对象的所有域都是 final 类型</li>
<li>对象是正确创建的（在创建对象期间 this 引用没有逸出）</li>
</ul>
<p>在不可变对象的内部仍可以使用可变对象来管理它们的状态，如程序 3-11 所示，但是其中的 Set 对象在构造完成之后无法对其进行修改。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 3-11 在可变对象基础上构建的不可变类</span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreeStooges</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;String&gt; stooges = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreeStooges</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stooges.add(<span class="string">"Moe"</span>);</span><br><span class="line">        stooges.add(<span class="string">"Larry"</span>);</span><br><span class="line">        stooges.add(<span class="string">"Curly"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isStooge</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stooges.contains(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getStoogeNames</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; stooges = <span class="keyword">new</span> Vector&lt;String&gt;();</span><br><span class="line">        stooges.add(<span class="string">"Moe"</span>);</span><br><span class="line">        stooges.add(<span class="string">"Larry"</span>);</span><br><span class="line">        stooges.add(<span class="string">"Curly"</span>);</span><br><span class="line">        <span class="keyword">return</span> stooges.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>关键字 final 可以视为 C++ 中 const 机制的一种受限版本，用于构造不可变对象。final 类型的域是不能修改的（但如果 final 域所引用的对象是可变的，那么这些被引用的对象是可以修改的）。final 域能确保初始化过程的安全性，从而可以不受限制地访问不可变对象，并在共享这些对象时无须同步。</p>
<blockquote>
<p>正如“除非需要更高的可见性，否则应将所有的域都声明为私有域”是一个良好的编程习惯，“除非需要某个域是可变的，否则应将其声明为 final 域”也是一个良好的编程习惯。</p>
</blockquote>
<p>我们看一个因式分解 Servlet，它包含两个原子操作：更新缓存的结果，以及判断缓存中的数值是否等于请求的数值。每当需要对一组相关数据以原子方式执行某个操作时，就可以考虑创建一个不可变的类来包含这些数据。例如 3-12 的 OneValueCache。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 3-12 对数值及其因数分解结果进行缓存的不可变容器类</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OneValueCache</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BigInteger lastNumber;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BigInteger[] lastFactors;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OneValueCache</span><span class="params">(BigInteger i,</span></span></span><br><span class="line"><span class="function"><span class="params">                         BigInteger[] factors)</span> </span>&#123;</span><br><span class="line">        lastNumber = i;</span><br><span class="line">        <span class="comment">//如果没有调用 copyOf 函数，那么 OneValue 就是不可变的</span></span><br><span class="line">        lastFactors = Arrays.copyOf(factors, factors.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> BigInteger[] getFactors(BigInteger i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (lastNumber == <span class="keyword">null</span> || !lastNumber.equals(i))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> Arrays.copyOf(lastFactors, lastFactors.length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于在访问和更新多个相关变量时出现的竞争条件问题，可以通过将这些变量全部保存在一个不可变对象中来消除。</p>
<p>程序 3-13 中的 VolatileCachedFactorizer 使用了 OneValueCache 来保存缓存的数值及其因数。当一个线程将 volatile 类型的 cache 设置为引用一个新的 OneValueCache 时，其他线程就会立即看到最新缓存的数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 3-13 使用指向不可变容器对象的 volatile 类型引用以缓存最新的结果</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileCachedFactorizer</span> <span class="keyword">extends</span> <span class="title">GenericServlet</span> <span class="keyword">implements</span> <span class="title">Servlet</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> OneValueCache cache = <span class="keyword">new</span> OneValueCache(<span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest req, ServletResponse resp)</span> </span>&#123;</span><br><span class="line">        BigInteger i = extractFromRequest(req);</span><br><span class="line">        BigInteger[] factors = cache.getFactors(i);</span><br><span class="line">        <span class="keyword">if</span> (factors == <span class="keyword">null</span>) &#123;</span><br><span class="line">            factors = factor(i);</span><br><span class="line">            <span class="comment">//更新缓存</span></span><br><span class="line">            cache = <span class="keyword">new</span> OneValueCache(i, factors);</span><br><span class="line">        &#125;</span><br><span class="line">        encodeIntoResponse(resp, factors);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">encodeIntoResponse</span><span class="params">(ServletResponse resp, BigInteger[] factors)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">BigInteger <span class="title">extractFromRequest</span><span class="params">(ServletRequest req)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BigInteger(<span class="string">"7"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    BigInteger[] factor(BigInteger i) &#123;</span><br><span class="line">        <span class="comment">// Doesn't really factor</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BigInteger[]&#123;i&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="安全发布"><a href="#安全发布" class="headerlink" title="安全发布"></a>安全发布</h4><p>在某些情况下我们希望在多个线程间共享对象，此时必须确保安全地进行共享。如果像程序 3-14 那样将对象引用保存到公有域中，那么还不足以安全地发布这个对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 3-14 在没有足够同步的情况下发布对象（不要这么做）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StuffIntoPublic</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Holder holder;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        holder = <span class="keyword">new</span> Holder(<span class="number">42</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于存在可见性问题，其他线程看到的 Holder 对象将处于不一致的状态，即使该对象的构造函数中已经正确地构造了不变性条件。这种不正确地发布将<strong>导致其他线程看到尚未创建完成的对象</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 3-15 由于未被正确发布，因此这个类可能出现故障</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Holder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Holder</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.n = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">assertSanity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n != n)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError(<span class="string">"This statement is false."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于没有使用同步来确保 Holder 对象对其他线程可见，因此将 Holder 称为“未被正确发布”。除了发布对象的线程外，其他线程可以看到的 Holder 域是一个失效值，因此将看到一个空引用或之前的旧值。</p>
<blockquote>
<p>任何线程都可以在不需要额外同步的情况下安全地访问不可变对象，即使在发布这些对象时没有使用同步。</p>
</blockquote>
<p>在没有额外同步地情况下，也可以安全地访问 final 类型的域。然而，如果 final 类型的域所指向的是可变对象，那么在访问这些域所指向的对象的状态是仍然需要同步。</p>
<p>要安全地发布一个对象，对象的引用以及对象的状态必须同时对其他线程可见。一个正确构造的对象可以通过以下方式来安全地发布：</p>
<ul>
<li>在静态初始化函数中初始化一个对象引用。</li>
<li>将对象的引用保存到 volatile 类型的域或者 AtomicReference 对象中。</li>
<li>将对象的引用保存到某个正确构造对象的 final 类型域中。</li>
<li>将对象的引用保存到一个由锁保护的域中。</li>
</ul>
<p>如果对象从技术上来看是可变的，但其状态在发布后不会再改变，那么把这种对象叫做“事实不可变对象（Effectively Immutable Object）”。</p>
<blockquote>
<p>在没有额外同步的情况下，任何线程都可以安全得使用被安全发布得事实不可变对象。</p>
</blockquote>
<p>如果对象在构造后可以修改，那么安全发布只能确保“发布当时”状态得可见性。对于可变对象，不仅在发布对象时需要使用同步，而且在每次对象访问时同样需要使用同步来确保继续修改操作的可见性。</p>
<p>对象的发布需求取决于它的可变性：</p>
<ul>
<li>不可变对象可以通过任意机制来发布</li>
<li>事实不可变对象必须通过安全方式发布</li>
<li>可变对象必须通过安全方式发布，并且必须是线程安全的或者由某个锁保护起来</li>
</ul>
<p>在并发程序中使用和共享对象时，可以使用一些实用的策略，包括：</p>
<ol>
<li><strong>线程封闭</strong>。线程封闭的对象只能由一个而线程拥有，对象被封闭在该线程中，并且只能由这个线程修改。</li>
<li><strong>只读共享</strong>。在没有额外同步的情况下，共享的只读对象可以由多个线程并发访问，但任何线程都不能修改它。共享的只读对象包括不可变对象和事实不可变对象。</li>
<li><strong>线程安全共享</strong>。线程安全的对象在其内部实现同步，因此多个线程可以通过对象的公有接口来进行访问而不需要进一步同步。</li>
<li><strong>保护对象</strong>。被保护的对象只能通过持有特定的锁来访问。保护对象包括封装在线程安全对象中的对象，以及已发布的并且由某个特定锁保护的对象。</li>
</ol>
<h3 id="对象的组合"><a href="#对象的组合" class="headerlink" title="对象的组合"></a>对象的组合</h3>]]></content>
      <categories>
        <category>笔记</category>
      </categories>
  </entry>
  <entry>
    <title>MySQL事务</title>
    <url>/2020/04/04/MySQL%E4%BA%8B%E5%8A%A1/</url>
    <content><![CDATA[<h3 id="什么是事务"><a href="#什么是事务" class="headerlink" title="什么是事务"></a><strong>什么是事务</strong></h3><p>　　事务是逻辑上的一组操作，要么都执行，要么都不执行。</p>
<h3 id="事务的四大特性"><a href="#事务的四大特性" class="headerlink" title="事务的四大特性"></a><strong>事务的四大特性</strong></h3><p>　　1）<strong>原子性（Atomicity）</strong>：事务是最小的执行单位，不允许分割。事务的原子性确保动作全部完成，要么完全不起作用。</p>
<p>　　2）<strong>一致性（Consistency）</strong>：执行事务前后，数据保持一致，多个事务对同一个数据读取的结果是相同的。</p>
<p>　　3）<strong>隔离性（Isolation）</strong>：并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的。</p>
<p>　　4）<strong>持久性（Durability）</strong>：一个事务被提交后。它对数据库中数据的改变是持久的，即使数据库故障也不应该有任何影响。</p>
<p>　　</p>
<h3 id="并发事务会带来的问题"><a href="#并发事务会带来的问题" class="headerlink" title="并发事务会带来的问题"></a><strong>并发事务会带来的问题</strong></h3><p>　　1）<strong>脏读（Dirty Read）</strong>：一个事务正在访问数据并对数据进行修改，修改还没有提交到数据库，这是另外一个事务访问了这个数据，然后使用了这个数据。这个数据更改之前的数据，另一个事务读到的数据是“脏数据”，依靠“脏数据”所做的操作是不正确的。</p>
<p>　　2）<strong>丢失修改（Lost to modify）</strong>：一个事务读取一个数据时，另外一个事务也访问了该数据，在第一个事务中修改数据后，第二个事务也修改了这个数据。第一个事务内的修改结果丢失，因此称作丢失修改。例如事务1读取某表中的数据 A=20 ，事务2也读取A=20，事务1修改A=A-1，事务2也修改A=A-1，最终结果A=19，事务1的修改丢失。</p>
<p>　　3）<strong>不可重复读（Unrepeatable read）</strong>：在一个事务内多次读同一个数据在这个事务还没有结束时，另一个事务也访问该数据。在第一个事务的两次读之间，另一个事务可能已经修改了数据，导致两次读取的数据可能不太一样。</p>
<p>　　4）<strong>幻读（Phanatom read）</strong>：幻读与不可重复读类似。发生在一个事务读了几行数据，接着另一个并发 事务插入了一些数据。在随后的查询中第一个事务就会发现多了一些原本不存在的记录，好像发生了幻觉。</p>
<p>　　<strong>不可重复读与幻读区别</strong>：不可重复读–多次读取数据发现某些列的值被修改。幻读–多次读取数据发现记录变少或者变多。</p>
<p>　　总结：脏读：事务读取到还没来得及修改的数据；丢失修改：多个事务修改同一数据，后面的修改会覆盖掉前面的修改。不可重复读：多次访问一个数据，中间有事务修改数据导致数据不一致；幻读：多次查询记录，中间有事务删除或者增加了记录，导致了记录不一致。</p>
<p>　　</p>
<h3 id="MySQL默认隔离级别"><a href="#MySQL默认隔离级别" class="headerlink" title="MySQL默认隔离级别"></a><strong>MySQL默认隔离级别</strong></h3><p>　　SQL标准定义了四个隔离级别：</p>
<p>　　1）<strong>READ-UNCOMMITTED（读取未提交</strong>）：最低的隔离级别，允许读取未提交的数据变更，可能导致脏读、幻读或不可重复读。</p>
<p>　　2）<strong>READ-COMMITTED（读取已提交）</strong>：允许并发事务读取已经提交的数据，可以阻止脏读，幻读或不可重复读仍可能发生。</p>
<p>　　3）<strong>REPEATABLE-READ（可重复读）</strong>：对同一字段的多次读取结果都是一致的，除非是数据本身被事务自己修改，可以组织脏读和不可重复读，幻读仍可能发生。</p>
<p>　　4）<strong>SERIALIZABLE（可串行化）</strong>：最高的隔离级别。所有事务依次执行。</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/OpzAI9n7via2DHf.png" alt=""></p>
<p> MySQL InnoDB 存储引擎默认支持隔离级别是可重复读。InnoDB 存储引擎在 REPEATABLE-READ（可重复读）事务隔离级别下使用的是 Next-Key Lock锁算法，可以避免幻读的产生。因此InnoDB的可重复读达到了SQL标准的SERIALIZABLE（可串行化）隔离级别。</p>
<p>参考：<a href="https://snailclimb.gitee.io/javaguide/#/docs/database/MySQL" target="_blank" rel="noopener">https://snailclimb.gitee.io/javaguide/#/docs/database/MySQL</a></p>
<p>　　</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
  </entry>
  <entry>
    <title>NSGA2 遗传算法</title>
    <url>/2020/12/27/NSGA2/</url>
    <content><![CDATA[<h1 id="NSGA2"><a href="#NSGA2" class="headerlink" title="NSGA2"></a>NSGA2</h1><p>快速的、精英主义的、多目标遗传算法</p>
<a id="more"></a>

<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>使用非支配排序和共享的多目标进化算法（EA）主要受到批评：1）（3）O(MN^3)计算复杂度（其中，M为目标函数数量和人口数量 N）；  2）非民族主义的方法；  3）需要指定共享参数。 在本文中，我们提出了一种基于非支配排序的多目标EA（MOEA），称为非支配排序遗传算法II（NSGA-II），它可以缓解上述三个难题。 具体来说，提出了一种具有（2）计算复杂度的快速非支配排序方法。 另外，提出了一个选择算子，该算子通过组合父母和后代种群并选择最佳的（相对于适应性和传播性）解决方案来创建交配池。 针对棘手的测试问题的仿真结果表明，与帕累托归档的演化策略和强度帕累托EA相比，拟议的NSGA-II在大多数问题中都能找到更好的解决方案分布，并且能够在真正的帕累托最优前沿附近找到更好的收敛性。 另外两个精英MOEA特别重视创建多样化的帕累托最优阵线。<br>   此外，我们修改了优势的定义，以便有效地解决约束性多目标问题。 将受约束的NSGA-II在许多测试问题（包括五目标七约束的非线性问题）上的仿真结果与另一个受约束的多目标优化器进行了比较，并且观察到NSGA-II的性能要好得多。</p>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="非支配排序"><a href="#非支配排序" class="headerlink" title="非支配排序"></a>非支配排序</h3><p>将种群 P 分级为 F1，F2， F3…</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20201123101830454.png" alt="image-20201123101830454"></p>
<p>对于每个个体，有两个参数：</p>
<ul>
<li>n_p，支配 p 的个体数</li>
<li>S_p，被 p 支配的个体数</li>
</ul>
<p>算法首先对每个个体计算 n_p 和 S_p，并将 n_p = 0 的个体放入 F1集合中，并设 p_rank = 1。这个操作的时间复杂度为 O(N^2)，空间复杂度O(N^2)，N 为种群的个体数。</p>
<p>非支配排序步骤：</p>
<ol>
<li>对集合 F_i（i 初始化为 1）中的每个个体 p（n_p = 0），它的支配个体集合为 S_p，遍历集合中的每个元素 q，执行 n_q -= 1，如果 q 仅被 p 支配（即 n_q = 1），则代表它是下一层 F_(i + 1) 的元素，q_rank = i + 1，将其加入到集合 Q 中。</li>
<li>i = i + 1，记 F_i 中得到的个体为第 i 个非支配层的个体，F_i = Q ，重复步骤 1，直到整个种群被分级。 </li>
</ol>
<h3 id="拥挤度"><a href="#拥挤度" class="headerlink" title="拥挤度"></a>拥挤度</h3><p>拥挤度是指种群中给定个体的周围个体的密度,直观上可表示为个体。</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20201123104555048.png" alt="image-20201123104555048"></p>
<p>长方形的周长就是 i 的拥挤度。拥挤距离计算需要根据每个目标函数值按升序对人群进行排序。</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20201123204159237.png" alt="image-20201123204159237"></p>
<p>在带精英策略的非支配排序遗传算法中，拥挤度的计算是保证种群多样性的一个重要环节。</p>
<p>拥挤距离计算需要根据每个目标函数值按升序对人群进行排序。 </p>
<p>I[i].m 是集合 I 中的第 i 个个体的第 m 个对象函数值。</p>
<p>算法步骤：</p>
<p>初始化每个个体的拥挤度为 0，对于每个目标函数值 m，对种群进行排序，令两个边界的两个个体拥挤度为无穷。</p>
<p>计算拥挤度：</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20201123212058306.png" alt="image-20201123212058306"></p>
<p>将每个归一化后的值加入拥挤度，其中<img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20201123212113353.png" alt="image-20201123212113353">为每个函数值归一化后的值。</p>
<h3 id="拥挤度比较算子"><a href="#拥挤度比较算子" class="headerlink" title="拥挤度比较算子"></a>拥挤度比较算子</h3><p>在经过非支配排序和拥挤度计算后，我们得到非支配排序 i_rank 和拥挤度 i_distance。</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20201123214216461.png" alt="image-20201123214216461"></p>
<p>在具有不同非支配等级的两个解决方案之间，我们倾向于非支配等级较低（更好）的解决方案。否则，如果两个解决方案属于同一个非支配层，那么我们更喜欢位于不拥挤的解决方案（拥挤度越大，证明当前解决方案越稀疏）。</p>
<h3 id="主循环"><a href="#主循环" class="headerlink" title="主循环"></a>主循环</h3><p>最初，将创建一个随机的父母群体。 人口基于非统治进行排序。 每个解决方案的适应性（或等级）均等于其非支配级别（1是最佳级别，2是次佳级别，依此类推）。 因此，假定适合度最小。 首先，通常使用二元锦标赛选择，重组和变异运算符来创建大小为后代的种群Q0。</p>
<p>首先得到一个合并种群<img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20201123221904004.png" alt="image-20201123221904004">，种群大小为 2N。对该种群进行非支配排序，最优非支配集合 F1 中的解是最优解，比种群中的其他解更加重要。如果 F1 的大小小于 N，将其加入新种群P_(t + 1)，将剩下的非支配层按照它们的顺序加入 P_(t + 1)。</p>
<p>我们要使 P_(t + 1)的大小为 N，对最后一个非支配层（例如 图2中的 F3）使用拥挤度比较算子对解进行降序排序，取最后一个非支配层的前 N - |P _ (t + 1)|个解。然后对 P_(t + 1)进行选择，交叉和变异得到 Q _ (t + 1)，然后继续进行下一次循环。</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20201123215417480.png" alt="image-20201123215417480"></p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20201123215444579.png" alt="image-20201123215444579"></p>
<p>  “变异”运算符是用于生成修饰种群的多个运算符（如交叉，变异等）的集合。 交叉算子的目的是从交配池中随机选择两个或多个解决方案（父代），并通过在父解决方案之间交换信息来创建一个或多个解决方案。 交叉算子的交叉概率为p; 指出参与交叉操作的人口成员的比例。 剩下的1-p人口的比例只是复制到修改后的（儿童）人口中。 在具有n个实值变量并涉及与两个父解的交叉的实参优化的上下文中，每个变量可以一次交叉。 依赖于两个父变量值之间的差异的概率分布通常用于创建两个新数字，作为围绕两个父变量值的子变量[5]。 除了可变方式重组算子，矢量方式重组算子还建议将父解决方案变量之间的相关性传播到创建的子解决方案中[6，7]。</p>
<h3 id="支配"><a href="#支配" class="headerlink" title="支配"></a>支配</h3><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20201124133529203.png" alt=""></p>
<h3 id="非支配前沿"><a href="#非支配前沿" class="headerlink" title="非支配前沿"></a>非支配前沿</h3><p>图中的非支配前言为 3，5，6 从 3 到 5 ，f1 的收益变大，但 f2 收益变小。</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20201124134131436.png" alt=""></p>
<h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><p>与单目标优化不同，多目标优化中有两个目标：1）收敛到帕累托最优集；2）维持帕累托最优集的解的多样性。</p>
<p>第一个度量 γ 度量到一组已知的Pareto最优解的收敛程度。第二个度量标准 Δ 衡量获得的解决方案之间实现的扩展程度。</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20201127193127398.png" alt="image-20201127193127398"></p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20201127190055560.png" alt="image-20201127190055560"></p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
  </entry>
  <entry>
    <title>N皇后</title>
    <url>/2020/10/17/N%E7%9A%87%E5%90%8E/</url>
    <content><![CDATA[<h4 id="51-N-皇后"><a href="#51-N-皇后" class="headerlink" title="51. N 皇后"></a><a href="https://leetcode-cn.com/problems/n-queens/" target="_blank" rel="noopener">51. N 皇后</a></h4><p><em>n</em> 皇后问题研究的是如何将 <em>n</em> 个皇后放置在 <em>n</em>×<em>n</em> 的棋盘上，并且使皇后彼此之间不能相互攻击。</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20201017103523238.png" alt="image-20201017103523238"></p>
<p>上图为 8 皇后问题的一种解法。</p>
<p>给定一个整数 <em>n</em>，返回所有不同的 <em>n</em> 皇后问题的解决方案。</p>
<p>每一种解法包含一个明确的 <em>n</em> 皇后问题的棋子放置方案，该方案中 <code>&#39;Q&#39;</code> 和 <code>&#39;.&#39;</code> 分别代表了皇后和空位。</p>
<a id="more"></a>

<p> <strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：4</span><br><span class="line">输出：[</span><br><span class="line"> [&quot;.Q..&quot;,  &#x2F;&#x2F; 解法 1</span><br><span class="line">  &quot;...Q&quot;,</span><br><span class="line">  &quot;Q...&quot;,</span><br><span class="line">  &quot;..Q.&quot;],</span><br><span class="line"></span><br><span class="line"> [&quot;..Q.&quot;,  &#x2F;&#x2F; 解法 2</span><br><span class="line">  &quot;Q...&quot;,</span><br><span class="line">  &quot;...Q&quot;,</span><br><span class="line">  &quot;.Q..&quot;]</span><br><span class="line">]ss</span><br><span class="line">解释: 4 皇后问题存在两个不同的解法。</span><br></pre></td></tr></table></figure>

<p> <strong>提示：</strong></p>
<ul>
<li>皇后彼此不能相互攻击，也就是说：任何两个皇后都不能处于同一条横行、纵行或斜线上。</li>
</ul>
<p><strong>方法一：基于集合的回溯</strong></p>
<p>直接暴力枚举将 n 个皇后放在棋盘中。每行每列仅有一个皇后，且任何两个皇后都不能在同一条斜线上。</p>
<p>使用三个集合 columns、diagonals1，diagonals2 分别记录每一列以及两个方向斜线上是否有皇后。我们从第一行开始，每行放一个皇后，这样每行就只有一个皇后。</p>
<p>方向一的斜线为从左上到右下，同一条斜线上的每个位置满足<strong>行下标与列下标之差相等。</strong></p>
<p>方向二的斜线为从右上到左下，同一条斜线上的每个位置满足<strong>行下标与列下标之和相等。</strong></p>
<p>每次放置皇后时，对每个位置判断其是否在三个集合中，如果都不在，当前位置可以放置皇后。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; solveNQueens(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        List&lt;List&lt;String&gt;&gt; solutions = <span class="keyword">new</span> ArrayList&lt;List&lt;String&gt;&gt;();</span><br><span class="line">        <span class="keyword">int</span>[] queens = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        Arrays.fill(queens, -<span class="number">1</span>);</span><br><span class="line">        Set&lt;Integer&gt; columns = <span class="keyword">new</span> HashSet&lt;Integer&gt;();</span><br><span class="line">        Set&lt;Integer&gt; diagonals1 = <span class="keyword">new</span> HashSet&lt;Integer&gt;();</span><br><span class="line">        Set&lt;Integer&gt; diagonals2 = <span class="keyword">new</span> HashSet&lt;Integer&gt;();</span><br><span class="line">        backtrack(solutions, queens, n, <span class="number">0</span>, columns, diagonals1, diagonals2);</span><br><span class="line">        <span class="keyword">return</span> solutions;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(List&lt;List&lt;String&gt;&gt; solutions, <span class="keyword">int</span>[] queens, <span class="keyword">int</span> n, <span class="keyword">int</span> row, Set&lt;Integer&gt; columns, Set&lt;Integer&gt; diagonals1, Set&lt;Integer&gt; diagonals2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//row = n 代表已经得到一种结果</span></span><br><span class="line">        <span class="keyword">if</span> (row == n) &#123;</span><br><span class="line">            List&lt;String&gt; board = generateBoard(queens, n);</span><br><span class="line">            solutions.add(board);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//尝试在当前行的每个位置放置皇后</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (columns.contains(i)) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> diagonal1 = row - i;</span><br><span class="line">                <span class="keyword">if</span> (diagonals1.contains(diagonal1)) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> diagonal2 = row + i;</span><br><span class="line">                <span class="keyword">if</span> (diagonals2.contains(diagonal2)) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                queens[row] = i;</span><br><span class="line">                columns.add(i);</span><br><span class="line">                diagonals1.add(diagonal1);</span><br><span class="line">                diagonals2.add(diagonal2);</span><br><span class="line">                <span class="comment">//继续放置下一行的皇后</span></span><br><span class="line">                backtrack(solutions, queens, n, row + <span class="number">1</span>, columns, diagonals1, diagonals2);</span><br><span class="line">                <span class="comment">//状态重置</span></span><br><span class="line">                queens[row] = -<span class="number">1</span>;</span><br><span class="line">                columns.remove(i);</span><br><span class="line">                diagonals1.remove(diagonal1);</span><br><span class="line">                diagonals2.remove(diagonal2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生成棋盘</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">generateBoard</span><span class="params">(<span class="keyword">int</span>[] queens, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; board = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">char</span>[] row = <span class="keyword">new</span> <span class="keyword">char</span>[n];</span><br><span class="line">            Arrays.fill(row, <span class="string">'.'</span>);</span><br><span class="line">            row[queens[i]] = <span class="string">'Q'</span>;</span><br><span class="line">            board.add(<span class="keyword">new</span> String(row));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> board;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度O(n!)</li>
<li>空间复杂度O(n)，n 是皇后数量。</li>
</ul>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode Hard</tag>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>时间插入、删除和获取随机元素-允许重复</title>
    <url>/2020/10/31/O(1)%E6%97%B6%E9%97%B4%E6%8F%92%E5%85%A5%E3%80%81%E5%88%A0%E9%99%A4%E5%92%8C%E8%8E%B7%E5%8F%96%E9%9A%8F%E6%9C%BA%E5%85%83%E7%B4%A0-%E5%85%81%E8%AE%B8%E9%87%8D%E5%A4%8D/</url>
    <content><![CDATA[<h4 id="381-O-1-时间插入、删除和获取随机元素-允许重复"><a href="#381-O-1-时间插入、删除和获取随机元素-允许重复" class="headerlink" title="381. O(1) 时间插入、删除和获取随机元素 - 允许重复"></a><a href="https://leetcode-cn.com/problems/insert-delete-getrandom-o1-duplicates-allowed/" target="_blank" rel="noopener">381. O(1) 时间插入、删除和获取随机元素 - 允许重复</a></h4><p>设计一个支持在<em>平均</em> 时间复杂度 <strong>O(1)</strong> 下<strong>，</strong> 执行以下操作的数据结构。</p>
<p><strong>注意: 允许出现重复元素。</strong></p>
<ol>
<li><p><code>insert(val)</code>：向集合中插入元素 val。</p>
</li>
<li><p><code>remove(val)</code>：当 val 存在时，从集合中移除一个 val。</p>
</li>
<li><p><code>getRandom</code>：从现有集合中随机获取一个元素。每个元素被返回的概率应该与其在集合中的数量呈线性相关。</p>
</li>
</ol>
<a id="more"></a>

<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 初始化一个空的集合。</span><br><span class="line">RandomizedCollection collection &#x3D; new RandomizedCollection();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 向集合中插入 1 。返回 true 表示集合不包含 1 。</span><br><span class="line">collection.insert(1);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 向集合中插入另一个 1 。返回 false 表示集合包含 1 。集合现在包含 [1,1] 。</span><br><span class="line">collection.insert(1);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 向集合中插入 2 ，返回 true 。集合现在包含 [1,1,2] 。</span><br><span class="line">collection.insert(2);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; getRandom 应当有 2&#x2F;3 的概率返回 1 ，1&#x2F;3 的概率返回 2 。</span><br><span class="line">collection.getRandom();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 从集合中删除 1 ，返回 true 。集合现在包含 [1,2] 。</span><br><span class="line">collection.remove(1);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; getRandom 应有相同概率返回 1 和 2 。</span><br><span class="line">collection.getRandom();</span><br></pre></td></tr></table></figure>

<p>使用一个数组 nums 存储所有的数字，我们随机生成下标就可在 O(1)时间内得到一个随机元素。</p>
<p>在列表中删除最后一个元素的时间复杂度是 O(1)，如果要在 O(1)时间复杂度删除数组中间的元素，我们需要将它与最后一个元素交换，最后将最后一个元素删除。</p>
<p>remove 函数的参数为删除的数的 val，我们需要将一个数值对应数组中的下标存储起来，使用一个Set 存储。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RandomizedCollection</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Map&lt;Integer, Set&lt;Integer&gt;&gt; map;</span><br><span class="line">    List&lt;Integer&gt; nums;</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RandomizedCollection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        map = <span class="keyword">new</span> HashMap&lt;Integer, Set&lt;Integer&gt;&gt;();</span><br><span class="line">        nums = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Inserts a value to the collection. Returns true if the collection did not already contain the specified element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//将 val 添加到数组中</span></span><br><span class="line">        nums.add(val);</span><br><span class="line">        <span class="comment">//将 当前下标添加进 val 对应的 set</span></span><br><span class="line">        Set&lt;Integer&gt; set = map.getOrDefault(val, <span class="keyword">new</span> HashSet&lt;Integer&gt;());</span><br><span class="line">        set.add(nums.size() - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//将 set 放入 map</span></span><br><span class="line">        map.put(val, set);</span><br><span class="line">        <span class="comment">//数组中是否已经存在 val</span></span><br><span class="line">        <span class="keyword">return</span> set.size() == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Removes a value from the collection. Returns true if the collection contained the specified element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//数组中没有 val，删除失败</span></span><br><span class="line">        <span class="keyword">if</span>(!map.containsKey(val))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//得到 val 对应的一个 数组下标</span></span><br><span class="line">        Iterator&lt;Integer&gt; it = map.get(val).iterator();</span><br><span class="line">        <span class="keyword">int</span> i = it.next();</span><br><span class="line">        <span class="comment">//得到数组中最后一个数字</span></span><br><span class="line">        <span class="keyword">int</span> lastNum = nums.get(nums.size() - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//将最后一个数组拷贝到下标 i 处</span></span><br><span class="line">        nums.set(i, lastNum);</span><br><span class="line">		</span><br><span class="line">        <span class="comment">//删除set 中的下标</span></span><br><span class="line">        map.get(val).remove(i);</span><br><span class="line">        map.get(lastNum).remove(nums.size() - <span class="number">1</span>);</span><br><span class="line">		<span class="comment">//将 lastNum 的新下标加入set</span></span><br><span class="line">        <span class="keyword">if</span>(i &lt; nums.size() - <span class="number">1</span>)&#123;</span><br><span class="line">            map.get(lastNum).add(i);</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//删除后 set 为空，删除这个 键值对</span></span><br><span class="line">        <span class="keyword">if</span>(map.get(val).size() == <span class="number">0</span>)&#123;</span><br><span class="line">            map.remove(val);</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//删除数组中最后一个元素</span></span><br><span class="line">        nums.remove(nums.size() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get a random element from the collection. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getRandom</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//随机生成数组下标</span></span><br><span class="line">        <span class="keyword">return</span> nums.get( (<span class="keyword">int</span>) ( Math.random() * nums.size() ) );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度O(1)</li>
<li>空间复杂度O(N)，N为数组中所有元素的数目。</li>
</ul>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title>Aspect Spring AOP</title>
    <url>/2021/04/12/Aspect%20Spring%20AOP/</url>
    <content><![CDATA[<h3 id="基于注解的-Spring-AOP-开发"><a href="#基于注解的-Spring-AOP-开发" class="headerlink" title="基于注解的 Spring AOP 开发"></a>基于注解的 Spring AOP 开发</h3><a id="more"></a>

<h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/v2-b5c523e28bba91c11c8d7f510ab84a79_1440w.png" alt="img"></p>
<h4 id="定义切入点函数"><a href="#定义切入点函数" class="headerlink" title="定义切入点函数"></a>定义切入点函数</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在执行完 UserDao.add() 方法后执行</span></span><br><span class="line"><span class="meta">@After</span>(value=<span class="string">"execution(* com.zejian.spring.springAop.dao.UserDao.addUser(..))"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span></span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"最终通知...."</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>还可采用 @PointCut 关键字定义切入点表达式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用Pointcut定义切点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"execution(* com.zejian.spring.springAop.dao.UserDao.addUser(..))"</span>)</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">myPointcut</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 应用切入点函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@After</span>(value=<span class="string">"myPointcut()"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterDemo</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"最终通知...."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="切入点指示符"><a href="#切入点指示符" class="headerlink" title="切入点指示符"></a>切入点指示符</h4><h5 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h5><p>在定义匹配表达式时，通配符几乎随处可见如 <code>*</code> , <code>..</code> , <code>+</code> ,它们的含义如下：</p>
<ul>
<li><code>..</code>：匹配方法定义中任意数量的参数，此外还匹配类定义中任意数量包</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//任意返回值，任意名称，任意参数的公共方法</span></span><br><span class="line">execution(<span class="keyword">public</span> * *(..))</span><br><span class="line"><span class="comment">//匹配com.zejian.dao包及其子包中所有类中的所有方法</span></span><br><span class="line">within(com.zejian.dao..*)</span><br></pre></td></tr></table></figure>

<ul>
<li><code>+</code>：匹配给定类的任意子类</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//匹配实现了DaoUser接口的所有子类的方法</span></span><br><span class="line">within(com.zejian.dao.DaoUser+)</span><br></pre></td></tr></table></figure>

<ul>
<li><code>*</code>：匹配任意数量的字符</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//匹配com.zejian.service包及其子包中所有类的所有方法</span></span><br><span class="line">within(com.zejian.service..*)</span><br><span class="line"><span class="comment">//匹配以set开头，参数为int类型，任意返回值的方法</span></span><br><span class="line">execution(* set*(<span class="keyword">int</span>))</span><br></pre></td></tr></table></figure>

<h5 id="类型签名表达式"><a href="#类型签名表达式" class="headerlink" title="类型签名表达式"></a>类型签名表达式</h5><p>为了方便类型（如接口、类名、包名）过滤方法，Spring AOP 提供了within关键字。其语法格式如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">within(&lt;type name&gt;)</span><br></pre></td></tr></table></figure>

<p>type name 则使用包名或者类名替换即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//匹配com.zejian.dao包及其子包中所有类中的所有方法</span></span><br><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"within(com.zejian.dao..*)"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//匹配UserDaoImpl类中所有方法</span></span><br><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"within(com.zejian.dao.UserDaoImpl)"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//匹配UserDaoImpl类及其子类中所有方法</span></span><br><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"within(com.zejian.dao.UserDaoImpl+)"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//匹配所有实现UserDao接口的类的所有方法</span></span><br><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"within(com.zejian.dao.UserDao+)"</span>)</span><br></pre></td></tr></table></figure>

<h5 id="方法签名表达式"><a href="#方法签名表达式" class="headerlink" title="方法签名表达式"></a>方法签名表达式</h5><p>如果想根据方法签名进行过滤，关键字 execution 可以帮到我们，语法表达式如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//scope ：方法作用域，如public,private,protect</span></span><br><span class="line"><span class="comment">//returnt-type：方法返回值类型</span></span><br><span class="line"><span class="comment">//fully-qualified-class-name：方法所在类的完全限定名称</span></span><br><span class="line"><span class="comment">//parameters 方法参数</span></span><br><span class="line">execution(&lt;scope&gt; &lt;<span class="keyword">return</span>-type&gt; &lt;fully-qualified-<span class="class"><span class="keyword">class</span>-<span class="title">name</span>&gt;.*(<span class="title">parameters</span>))</span></span><br></pre></td></tr></table></figure>

<p>对于给定的作用域、返回值类型、完全限定类名以及参数匹配的方法将会应用切点函数指定的通知，这里给出模型案例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//匹配UserDaoImpl类中的所有方法</span></span><br><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"execution(* com.zejian.dao.UserDaoImpl.*(..))"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//匹配UserDaoImpl类中的所有公共的方法</span></span><br><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"execution(public * com.zejian.dao.UserDaoImpl.*(..))"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//匹配UserDaoImpl类中的所有公共方法并且返回值为int类型</span></span><br><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"execution(public int com.zejian.dao.UserDaoImpl.*(..))"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//匹配UserDaoImpl类中第一个参数为int类型的所有公共的方法</span></span><br><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"execution(public * com.zejian.dao.UserDaoImpl.*(int , ..))"</span>)</span><br></pre></td></tr></table></figure>

<h5 id="其他指示符"><a href="#其他指示符" class="headerlink" title="其他指示符"></a>其他指示符</h5><ul>
<li><p>this：用于匹配当前 AOP 代理对象类型的执行方法；请注意是 <strong>AOP代理对象</strong>的类型匹配，这样就可能包括引入接口也类型匹配</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//匹配了任意实现了UserDao接口的代理对象的方法进行过滤</span></span><br><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"this(com.zejian.spring.springAop.dao.UserDao)"</span>)</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">myPointcut2</span><span class="params">()</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>bean：Spring AOP 扩展的，AspectJ没有对应指示符，用于匹配特定名称的 Bean 对象的执行方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//匹配名称中带有后缀Service的Bean。</span></span><br><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"bean(*Service)"</span>)</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">myPointcut1</span><span class="params">()</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>target：用于匹配当前目标对象类型的执行方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//匹配了任意实现了UserDao接口的目标对象的方法进行过滤</span></span><br><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"target(com.zejian.spring.springAop.dao.UserDao)"</span>)</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">myPointcut3</span><span class="params">()</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>@within：用于匹配所有持有指定注解类型内的方法；请注意与 within 是有区别的，within是用于匹配指定类型内的方法执行；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//匹配使用了MarkerAnnotation注解的类(注意是类)</span></span><br><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"@within(com.zejian.spring.annotation.MarkerAnnotation)"</span>)</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">myPointcut4</span><span class="params">()</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>@annotation(com.zejian.spring.MarkerMethodAnnotation) : 根据所应用的注解进行方法过滤</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//匹配使用了MarkerAnnotation注解的方法(注意是方法)</span></span><br><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"@annotation(com.zejian.spring.annotation.MarkerAnnotation)"</span>)</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">myPointcut5</span><span class="params">()</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>切点指示符可以使用运算符语法进行表达式的混编，如and、or、not（或者&amp;&amp;、||、！），如下一个简单例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//匹配了任意实现了UserDao接口的目标对象的方法并且该接口不在com.zejian.dao包及其子包下</span></span><br><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"target(com.zejian.spring.springAop.dao.UserDao) ！within(com.zejian.dao..*)"</span>)</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">myPointcut6</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//匹配了任意实现了UserDao接口的目标对象的方法并且该方法名称为addUser</span></span><br><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"target(com.zejian.spring.springAop.dao.UserDao)&amp;&amp;execution(* com.zejian.spring.springAop.dao.UserDao.addUser(..))"</span>)</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">myPointcut7</span><span class="params">()</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<h5 id="5-种通知函数"><a href="#5-种通知函数" class="headerlink" title="5 种通知函数"></a>5 种通知函数</h5><p>通知主要分5种类型，分别是前置通知、后置通知、异常通知、最终通知以及环绕通知，下面分别介绍。</p>
<ul>
<li><p>前置通知 @Before</p>
<p>前置通知通过 @Before 注解进行标注，并可直接传入切点表达式的值，该通知在目标函数执行前执行，JoinPoint 是 Spring 提供的静态变量，通过它，可以获取目标对象的信息，如类名称，方法参数，方法名等，该参数可选。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 前置通知</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> joinPoint 该参数可以获取目标对象的信息,如类名称,方法参数,方法名称等</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Before</span>(<span class="string">"execution(* com.zejian.spring.springAop.dao.UserDao.addUser(..))"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">(JoinPoint joinPoint)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"我是前置通知"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>后置通知 @AfterReturning</p>
<p>通过 @AfterReturning 标注，该函数在目标函数执行完成后执行，并可以获取到目标函数最终的返回值  returnVal，当目标函数没有返回值时，returnVal 将返回 null。</p>
<p>必须通过returning = “returnVal”注明参数的名称而且必须与通知函数的参数名称相同。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 后置通知，不需要参数时可以不提供</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@AfterReturning</span>(value=<span class="string">"execution(* com.zejian.spring.springAop.dao.UserDao.*User(..))"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AfterReturning</span><span class="params">()</span></span>&#123;</span><br><span class="line">   System.out.println(<span class="string">"我是后置通知..."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 后置通知</span></span><br><span class="line"><span class="comment">* returnVal,切点方法执行后的返回值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@AfterReturning</span>(value=<span class="string">"execution(* com.zejian.spring.springAop.dao.UserDao.*User(..))"</span>,returning = <span class="string">"returnVal"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AfterReturning</span><span class="params">(JoinPoint joinPoint,Object returnVal)</span></span>&#123;</span><br><span class="line">   System.out.println(<span class="string">"我是后置通知...returnVal+"</span>+returnVal);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>异常通知 @AfterThrowing</p>
<p>该通知只有在异常时才会被出发，并由 throwing 来声明一个接受异常信息的变量，同样异常通知也用于 Joinpoing 参数，需要时可以加上。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 抛出通知</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> e 抛出异常的信息</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@AfterThrowing</span>(value=<span class="string">"execution(* com.zejian.spring.springAop.dao.UserDao.addUser(..))"</span>,throwing = <span class="string">"e"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterThrowable</span><span class="params">(Throwable e)</span></span>&#123;</span><br><span class="line">  System.out.println(<span class="string">"出现异常:msg="</span>+e.getMessage());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>最终通知 @After</p>
<p>该通知有点类似于 finally 代码块，只要应用了，无论什么情况下都会执行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 无论什么情况下都会执行的方法</span></span><br><span class="line"><span class="comment"> * joinPoint 参数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@After</span>(<span class="string">"execution(* com.zejian.spring.springAop.dao.UserDao.*User(..))"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">(JoinPoint joinPoint)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"最终通知...."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>环绕通知 @Around</p>
<p>环绕通知既可在目标方法前执行也可以在目标方法后执行，更重要的是环绕通知可以控制目标方法是否指向执行，但即使如此，我们应该尽量以最简单的方式满足需求，在仅需目标方法前执行时，使用前置通知而非环绕通知。</p>
<p>第一个参数必须是 ProceedingJoinPoint，通过该对象的 proceed() 方法来执行目标函数，proceed() 的返回值就是环绕通知的返回值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Around</span>(<span class="string">"execution(* com.zejian.spring.springAop.dao.UserDao.*User(..))"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">around</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"我是环绕通知前...."</span>);</span><br><span class="line">    <span class="comment">//执行目标函数</span></span><br><span class="line">    Object obj= (Object) joinPoint.proceed();</span><br><span class="line">    System.out.println(<span class="string">"我是环绕通知后...."</span>);</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="通知传递参数"><a href="#通知传递参数" class="headerlink" title="通知传递参数"></a>通知传递参数</h5><p>在 Spring AOP 中，除了 execution 和 bean 指示符不能传递参数给通知方法，其他指示符都可以将<strong>匹配的方法相应参数或对象</strong>自动传递给通知方法。获取到匹配的方法参数后通过 <code>argNames</code>属性指定参数名。如下，args(param)、argNames=”param”、before(int param)这三个参数<strong>命名必须保持一致</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Before</span>(value=<span class="string">"args(param)"</span>, argNames=<span class="string">"param"</span>) <span class="comment">//明确指定了    </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">(<span class="keyword">int</span> param)</span> </span>&#123;    </span><br><span class="line">    System.out.println(<span class="string">"param:"</span> + param);    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可直接使用 args 指示符不带 argNames 声明参数，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Before</span>(<span class="string">"execution(public * com.zejian..*.addUser(..)) &amp;&amp; args(userId,..)"</span>)  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">(<span class="keyword">int</span> userId)</span> </span>&#123;  </span><br><span class="line">    <span class="comment">//调用addUser的方法时如果与addUser的参数匹配则会传递进来会传递进来</span></span><br><span class="line">    System.out.println(<span class="string">"userId:"</span> + userId);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>args(userId,..)表达式表示：只匹配那些至少接收一个参数而且传入的类型必须与userId一致的方法，传递的参数可以简单类型或者对象，只有参数和目标方法也匹配时才有会有值传递进来。</p>
<h3 id="Aspect-优先级"><a href="#Aspect-优先级" class="headerlink" title="Aspect 优先级"></a>Aspect 优先级</h3><p>如果有多个通知需要在同一个切点函数指定的过滤目标方法上执行，在所有前置通知函数中，优先级最高的通知函数将会被先执行，在所有后置通知函数中，优先级最高的通知函数将会最后执行。</p>
<p>新建名为 aspectdemo 的工程，首先引入核心依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>添加启动类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AspectdemoApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(AspectdemoApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>开启 AspectJAutoProxy ，添加配置类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hoo.aspectdemo.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.EnableAspectJAutoProxy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在配置文件中启动<span class="doctag">@Aspect</span>支持后，</span></span><br><span class="line"><span class="comment"> * Spring容器只会尝试自动识别带<span class="doctag">@Aspect</span>的Bean，</span></span><br><span class="line"><span class="comment"> * 前提是任何定义的切面类都必须已在配置文件以Bean的形式声明。</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AspectJConfig</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>添加测试用 Controller</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/order"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先添加优先级较高的切面</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hoo.aspectdemo.aspect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.AfterReturning;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Before;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Pointcut;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.Ordered;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">切面实现 org.springframework.core.Ordered 接口，该接口用于控制切面类的优先级，同时重写getOrder方法，定制返回值，返回值(int 类型)越小优先级越大</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AspectOrderZero</span> <span class="keyword">implements</span> <span class="title">Ordered</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut</span>(<span class="string">"execution(* com.hoo.aspectdemo.controller.TestController.testOrder())"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pointCut</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"pointCut()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeOne</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"前置通知 ..优先级 0 .. 执行顺序 1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"pointCut()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeTwo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"前置通知 ..优先级 0 .. 执行顺序 2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterReturning</span>(<span class="string">"pointCut()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterReturningThree</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"后置通知 ..优先级 0 .. 执行顺序 3"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterReturning</span>(<span class="string">"pointCut()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterReturningFour</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"后置通知 ..优先级 0 .. 执行顺序 4"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后添加优先级较低的切面</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hoo.aspectdemo.aspect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.AfterReturning;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Before;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Pointcut;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.Ordered;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AspectOrderTwo</span> <span class="keyword">implements</span> <span class="title">Ordered</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut</span>(<span class="string">"execution(* com.hoo.aspectdemo.controller.TestController.testOrder())"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pointCut</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"pointCut()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeOne</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"前置通知 ..优先级 2 .. 执行顺序 1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"pointCut()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeTwo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"前置通知 ..优先级 2 .. 执行顺序 2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterReturning</span>(<span class="string">"pointCut()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterReturningThree</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"后置通知 ..优先级 2 .. 执行顺序 3"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterReturning</span>(<span class="string">"pointCut()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterReturningFour</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"后置通知 ..优先级 2 .. 执行顺序 4"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行，即可在控制台看到如下信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">前置通知 ..优先级 0 .. 执行顺序 1</span><br><span class="line">前置通知 ..优先级 0 .. 执行顺序 2</span><br><span class="line">前置通知 ..优先级 2 .. 执行顺序 1</span><br><span class="line">前置通知 ..优先级 2 .. 执行顺序 2</span><br><span class="line">后置通知 ..优先级 2 .. 执行顺序 3</span><br><span class="line">后置通知 ..优先级 2 .. 执行顺序 4</span><br><span class="line">后置通知 ..优先级 0 .. 执行顺序 3</span><br><span class="line">后置通知 ..优先级 0 .. 执行顺序 4</span><br></pre></td></tr></table></figure>

<p>总结：在同一个切面中定义多个通知响应同一个切点函数，执行顺序为声明顺序；如果在不同的切面中定义多个通知响应同一个切点，进入时则优先级高的切面类中的通知函数优先执行，退出时则最后执行。</p>
<h3 id="Spring-AOP-简单应用场景"><a href="#Spring-AOP-简单应用场景" class="headerlink" title="Spring AOP 简单应用场景"></a>Spring AOP 简单应用场景</h3><ol>
<li>性能监控</li>
</ol>
<p>首先我们定义用于测试的controller，并模拟这个接口需要 5s 来执行操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hoo.aspectdemo.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/monitor"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testMonitor</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread.sleep(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后定义性能监控信息类 MonitorTime</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hoo.aspectdemo.aspect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MonitorTime</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String className;</span><br><span class="line">    <span class="keyword">private</span> String methodName;</span><br><span class="line">    <span class="keyword">private</span> Date logTime;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> consumeTime;</span><br><span class="line"> <span class="comment">// 省略 getter 和 setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后定义一个监控的切面类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hoo.aspectdemo.aspect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.ProceedingJoinPoint;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Around;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Pointcut;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimerAspect</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut</span>(<span class="string">"within(com.hoo.aspectdemo.controller..*)"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pointCut</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around</span>(<span class="string">"pointCut()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">logTimer</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        MonitorTime monitor = <span class="keyword">new</span> MonitorTime();</span><br><span class="line">        <span class="comment">//获取目标类名称</span></span><br><span class="line">        String className = joinPoint.getTarget().getClass().getName();</span><br><span class="line">        <span class="comment">//获取目标类方法名称</span></span><br><span class="line">        String methodName = joinPoint.getSignature().getName();</span><br><span class="line"></span><br><span class="line">        monitor.setClassName(className);</span><br><span class="line">        monitor.setMethodName(methodName);</span><br><span class="line">        monitor.setLogTime(<span class="keyword">new</span> Date());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//计时并调用目标函数</span></span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        Object result = joinPoint.proceed();</span><br><span class="line">        <span class="keyword">long</span> time = System.currentTimeMillis() - start;</span><br><span class="line">        monitor.setConsumeTime(time);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//把 MonitorTime 记录的信息上传给监控系统，这里没有实现</span></span><br><span class="line"></span><br><span class="line">        System.out.println(monitor);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>启动程序，访问<a href="http://localhost:8080/monitor，查看控制台，打印出如下信息：" target="_blank" rel="noopener">http://localhost:8080/monitor，查看控制台，打印出如下信息：</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MonitorTime&#123;className=<span class="string">'com.hoo.aspectdemo.controller.TestController2'</span>, methodName=<span class="string">'testMonitor'</span>, logTime=Mon Apr <span class="number">12</span> <span class="number">17</span>:<span class="number">08</span>:<span class="number">53</span> CST <span class="number">2021</span>, consumeTime=<span class="number">11</span>&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>异常监控</li>
</ol>
<p>首先定义异常信息类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hoo.aspectdemo.aspect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionInfo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String className;</span><br><span class="line">    <span class="keyword">private</span> String methodName;</span><br><span class="line">    <span class="keyword">private</span> Date logTime;<span class="comment">//异常记录时间</span></span><br><span class="line">    <span class="keyword">private</span> String message;<span class="comment">//异常信息</span></span><br><span class="line">	<span class="comment">// 省略 getter 和 setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义自己的异常类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hoo.aspectdemo.exception;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyException</span> <span class="keyword">extends</span> <span class="title">Exception</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyException</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 TestController2 中添加测试函数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/monitor/&#123;mode&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testMonitor2</span><span class="params">(@PathVariable Integer mode)</span> <span class="keyword">throws</span> MyException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(mode == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> MyException(<span class="string">" testMonitor() 方法出错了！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>然后定义异常处理的切面</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hoo.aspectdemo.aspect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.ProceedingJoinPoint;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Around;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Pointcut;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionMonitorAspect</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut</span>(<span class="string">"within(com.hoo.aspectdemo.controller..*)"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">exceptionMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around</span>(<span class="string">"exceptionMethod()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">monitorMethods</span><span class="params">(ProceedingJoinPoint joinPoint)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> joinPoint.proceed();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            ExceptionInfo info = <span class="keyword">new</span> ExceptionInfo();</span><br><span class="line">            info.setClassName(joinPoint.getTarget().getClass().getName());</span><br><span class="line">            info.setMethodName(joinPoint.getSignature().getName());</span><br><span class="line">            info.setLogTime(<span class="keyword">new</span> Date());</span><br><span class="line">            info.setMessage(e.getMessage());</span><br><span class="line"></span><br><span class="line">            System.out.println(info);</span><br><span class="line">            <span class="comment">//上传日志系统，这里省略</span></span><br><span class="line">            <span class="comment">//返回失败信息</span></span><br><span class="line">            <span class="keyword">return</span> e.getMessage();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>浏览器访问 <a href="http://localhost:8080/monitor/0" target="_blank" rel="noopener">http://localhost:8080/monitor/0</a> ，可以看到返回 ”success“信息，并在控制台可以看到访问时间日志：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MonitorTime&#123;className&#x3D;&#39;com.hoo.aspectdemo.controller.TestController2&#39;, methodName&#x3D;&#39;testMonitor2&#39;, logTime&#x3D;Mon Apr 12 21:46:30 CST 2021, consumeTime&#x3D;11&#125;</span><br></pre></td></tr></table></figure>

<p>浏览器访问 <a href="http://localhost:8080/monitor/1" target="_blank" rel="noopener">http://localhost:8080/monitor/1</a> ，可以看到返回 ”testMonitor() 方法出错了！“信息，并在控制台可以看到访问时间日志：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ExceptionInfo&#123;className&#x3D;&#39;com.hoo.aspectdemo.controller.TestController2&#39;, methodName&#x3D;&#39;testMonitor2&#39;, logTime&#x3D;Mon Apr 12 21:47:15 CST 2021, message&#x3D;&#39; testMonitor() 方法出错了！&#39;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Spring-AOP-实现原理概要"><a href="#Spring-AOP-实现原理概要" class="headerlink" title="Spring AOP 实现原理概要"></a>Spring AOP 实现原理概要</h3><p>对于织入过程，一般分为动态织入和静态织入，动态织入在运行时动态地将要增强的代码织入到目标类中，这往往是通过动态代理技术完成的，如 Java JDK 的动态代理（底层通过反射实现）或者 CGLIB 的动态代理（底层通过继承实现）。</p>
<p>AspectJ 采用静态织入的方式。它在编译器使用 acj 编译器把 aspect 类编译成 class 字节码后，在 java 目标类编译时织入，先编译 aspect 类再编译目标类。</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20210414190852904.png" alt="image-20210414190852904"></p>
<h4 id="JDK-动态代理"><a href="#JDK-动态代理" class="headerlink" title="JDK 动态代理"></a>JDK 动态代理</h4><p>首先看一个简单的例子，声明一个 ExInterface 接口，利用 JDK 动态代理技术在 execute() 方法前后加入权限验证和日志记录。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//自定义的接口类，JDK 动态代理的实现必须要有对应的接口类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ExInterface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//A类，实现了ExInterface接口类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">implements</span> <span class="title">ExInterface</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"---- A.execute() ----"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="comment">//代理类的实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDKProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 要被代理的目标对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> A target;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JDKProxy</span><span class="params">(A target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 创建代理类</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ExInterface <span class="title">createProxy</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (ExInterface) Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(),<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调用被代理类(目标对象)的任意方法都会触发invoke方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> proxy 代理类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> method 被代理类的方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args 被代理类的方法参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">//过滤不需要该业务的方法</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="string">"execute"</span>.equals(method.getName())) &#123;</span><br><span class="line">            <span class="comment">//调用前验证权限</span></span><br><span class="line">            <span class="comment">//AuthCheck.authCheck();</span></span><br><span class="line">            System.out.println(<span class="string">"---- 鉴权 ----"</span>);</span><br><span class="line">            <span class="comment">//调用目标对象的方法</span></span><br><span class="line">            Object result = method.invoke(target, args);</span><br><span class="line">            <span class="comment">//记录日志数据</span></span><br><span class="line">            <span class="comment">//Report.recordLog();</span></span><br><span class="line">            System.out.println(<span class="string">"---- 记录日志 ----"</span>);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">"delete"</span>.equals(method.getName()))&#123;</span><br><span class="line">            <span class="comment">//.....</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果不需要增强直接执行原方法</span></span><br><span class="line">        <span class="keyword">return</span> method.invoke(target,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        A a = <span class="keyword">new</span> A();</span><br><span class="line">        <span class="comment">//创建 JDK 代理</span></span><br><span class="line">        JDKProxy jdkProxy = <span class="keyword">new</span> JDKProxy(a);</span><br><span class="line">        <span class="comment">//创建代理对象</span></span><br><span class="line">        ExInterface proxy = jdkProxy.createProxy();</span><br><span class="line">        <span class="comment">//执行代理对象方法</span></span><br><span class="line">        proxy.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//测试结果</span></span><br><span class="line">---- 鉴权 ----</span><br><span class="line">---- A.execute() ----</span><br><span class="line">---- 记录日志 ----</span><br></pre></td></tr></table></figure>

<p>在 A 的 execute() 方法中没有调用任何权限和日志的 代码，也没有直接操作 a 对象，只是调用了 proxy 代理对象的方法，最终的结果却是预期的，这就是动态代理技术。动态代理的底层通过反射来实现，只要拿到 A 类的 class 文件和 A 类的实现接口，很自然就可以生成相同接口的代理类并调用  a 对象的方法。</p>
<p>实现 Java 动态代理是先决条件为：<strong>目标对象必须带接口</strong>，如果类的接口是 ExInterface，通过该接口，动态代理可以创建与 A 类类型相同的代理对象。</p>
<p>用JDK动态代理，被代理类(目标对象，如A类)，必须已有实现接口如(ExInterface)，因为JDK提供的Proxy类将通过目标对象的类加载器ClassLoader和Interface，以及句柄(Callback)创建与A类拥有相同接口的代理对象proxy，该代理对象将拥有接口ExInterface中的所有方法。同时，代理类必须实现一个类似回调函数的InvocationHandler接口并重写该接口中的invoke方法，当调用proxy的每个方法(如案例中的proxy#execute())时，invoke方法将被调用，利用该特性，可以在invoke方法中对目标对象(被代理对象如A)方法执行的前后动态添加其他外围业务操作，此时无需触及目标对象的任何代码，也就实现了外围业务的操作与目标对象(被代理对象如A)完全解耦合的目的。当然缺点也很明显需要拥有接口，这也就有了后来的CGLIB动态代理。  </p>
<h4 id="CGLIB-动态代理"><a href="#CGLIB-动态代理" class="headerlink" title="CGLIB 动态代理"></a><a href="https://github.com/cglib/cglib" target="_blank" rel="noopener">CGLIB</a> 动态代理</h4><p>通过CGLIB动态代理实现上述功能并不要求目标对象拥有接口类，实际上CGLIB动态代理是通过继承的方式实现的，因此可以减少没必要的接口，下面直接通过简单案例协助理解。</p>
<p>首先引入 <a href="https://repository.ow2.org/nexus/content/repositories/releases/org/ow2/asm/asm/8.0.1/asm-8.0.1.jar" target="_blank" rel="noopener">asm-8.0.1.jar</a> 和 <a href="https://github.com/cglib/cglib/releases/download/RELEASE_3_3_0/cglib-3.3.0.jar" target="_blank" rel="noopener">cglib-3.3.0.jar</a>，也可使用 maven 下载。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="comment">//被代理的类（目标对象）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"---- A.execute() ----"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.Enhancer;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodInterceptor;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodProxy;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CGLibProxy</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 被代理的目标类</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="keyword">private</span> A target;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CGLibProxy</span><span class="params">(A target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建代理对象</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> A <span class="title">createProxy</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//使用 CGLIB 生成代理</span></span><br><span class="line">        <span class="comment">//1.生成增强类实例，用于生产代理类</span></span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        <span class="comment">//2.设置被代理类字节码，CGLIB 根据字节码生成被代理类的子类</span></span><br><span class="line">        enhancer.setSuperclass(target.getClass());</span><br><span class="line">        <span class="comment">//3. 设置回调函数，即一个方法拦截</span></span><br><span class="line">        enhancer.setCallback(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">//4.创建代理</span></span><br><span class="line">        <span class="keyword">return</span> (A) enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 回调函数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> obj 代理对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> method 委托类方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args 方法参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> proxy 每个被代理的方法都对应一个MethodProxy对象，</span></span><br><span class="line"><span class="comment">     *                    methodProxy.invokeSuper方法最终调用委托类(目标类)的原始方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object obj, Method method, Object[] args, MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">//过滤不需要该业务的方法</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="string">"execute"</span>.equals(method.getName()))&#123;</span><br><span class="line">            <span class="comment">//调用前验证权限</span></span><br><span class="line">            System.out.println(<span class="string">"---- 鉴权 ----"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//调用目标对象的方法（执行 A 独享即被代理对象的 execute 方法）</span></span><br><span class="line">            Object result = proxy.invokeSuper(obj,args);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//记录日志数据（动态添加其他要执行业务）</span></span><br><span class="line">            System.out.println(<span class="string">"---- 日志 ----"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">"delete"</span>.equals(method.getName()))&#123;</span><br><span class="line">            <span class="keyword">return</span> proxy.invokeSuper(obj, args);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//不需要增强直接执行原方法</span></span><br><span class="line">        <span class="keyword">return</span> proxy.invokeSuper(obj,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CGLibTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        A a = <span class="keyword">new</span> A();</span><br><span class="line"></span><br><span class="line">        CGLibProxy cgLibProxy = <span class="keyword">new</span> CGLibProxy(a);</span><br><span class="line"></span><br><span class="line">        A proxy = cgLibProxy.createProxy();</span><br><span class="line"></span><br><span class="line">        proxy.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//测试结果</span></span><br><span class="line">---- 鉴权 ----</span><br><span class="line">---- A.execute() ----</span><br><span class="line">---- 日志 ----</span><br></pre></td></tr></table></figure>

<p>被代理的类无需接口即可实现动态代理，而CGLibProxy代理类需要实现一个方法拦截器接口MethodInterceptor并重写intercept方法，类似JDK动态代理的InvocationHandler接口，也是理解为回调函数，同理每次调用代理对象的方法时，intercept方法都会被调用，利用该方法便可以在运行时对方法执行前后进行动态增强。关于代理对象创建则通过Enhancer类来设置的，Enhancer是一个用于产生代理对象的类，作用类似JDK的Proxy类，因为CGLib底层是通过继承实现的动态代理，因此需要传递目标对象(如A)的Class，同时需要设置一个回调函数对调用方法进行拦截并进行相应处理，最后通过create()创建目标对象(如A)的代理对象，运行结果与前面的JDK动态代理效果相同。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>Spring AOP内部已都实现了这两种技术，Spring AOP 在使用时机上也进行自动化调整，当有接口时会自动选择JDK动态代理技术，如果没有则选择CGLIB技术，当然Spring AOP的底层实现并没有这么简单，为更简便生成代理对象，Spring AOP 内部实现了一个专注于生成代理对象的工厂类，这样就避免了大量的手动编码，这点也是十分人性化的，但最核心的还是动态代理技术。从性能上来说，Spring AOP 虽然无需特殊编译器协助，但性能上并不优于AspectJ的静态织入。<img src="https://gitee.com/hoo334/picgo/raw/master//img/v2-b091ac6fd64f493eaeabfeff4cee7fee_1440w.png" alt="img"></p>
<p><a href="https://blog.csdn.net/javazejian/article/details/56267036" target="_blank" rel="noopener">参考</a></p>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
  </entry>
  <entry>
    <title>Pow(x, n)</title>
    <url>/2020/04/27/Pow(x,n)/</url>
    <content><![CDATA[<h4 id="50-Pow-x-n"><a href="#50-Pow-x-n" class="headerlink" title="50. Pow(x, n)"></a><a href="https://leetcode-cn.com/problems/powx-n/" target="_blank" rel="noopener">50. Pow(x, n)</a></h4><p>实现 <a href="https://www.cplusplus.com/reference/valarray/pow/" target="_blank" rel="noopener">pow(<em>x</em>, <em>n</em>)</a> ，即计算 x 的 n 次幂函数。</p>
 <a id="more"></a>

<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 2.00000, 10</span><br><span class="line">输出: 1024.00000</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 2.10000, 3</span><br><span class="line">输出: 9.26100</span><br></pre></td></tr></table></figure>

<p><strong>示例 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 2.00000, -2</span><br><span class="line">输出: 0.25000</span><br><span class="line">解释: 2-2 &#x3D; 1&#x2F;22 &#x3D; 1&#x2F;4 &#x3D; 0.25</span><br></pre></td></tr></table></figure>

<p><strong>说明:</strong></p>
<ul>
<li>-100.0 &lt; <em>x</em> &lt; 100.0</li>
<li><em>n</em> 是 32 位有符号整数，其数值范围是 [−231, 231 − 1] 。</li>
</ul>
<p>采用快速幂等法。有递归和迭代两个版本。</p>
<p><strong>递归版本</strong></p>
<p>快速幂算法的本质是分治算法。例如在计算 x^64 时我们可以看作求 x^32 的平方，进而可以看作求 x^16 的四次方……</p>
<p>再来看一般情况如果需要求 x^77 ，可以看作 x^38 * x^38 *x，对 x^38 可以看作 x^19 的平方，x^19 可以看作 x^9 * x^9 * x……</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> N = n;</span><br><span class="line">        <span class="comment">// n 为负数时，求 -n 次方并取倒数</span></span><br><span class="line">        <span class="keyword">return</span> N &gt;= <span class="number">0</span> ? quickMul(x, N) : <span class="number">1.0</span> / quickMul(x, -N);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">quickMul</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">long</span> N)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(N == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">double</span> y = quickMul(x, N/<span class="number">2</span>);</span><br><span class="line">        <span class="comment">//n 不是偶数时需要乘 x</span></span><br><span class="line">        <span class="keyword">return</span> N % <span class="number">2</span> == <span class="number">0</span> ? y * y : y * y * x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度 O(logN)，空间复杂度 O(logN)。</p>
<p><strong>迭代版本</strong></p>
<p>以 x^77 为例，首先看 77 这个整数，77化为二进制得到1001101，我们可以将 77 表示为 64+8+4+1。我们只需算出 x 的 2 的指数倍次方的结果就可以表示 x 的所有次方。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> N = n;</span><br><span class="line">        <span class="keyword">return</span> N &gt;= <span class="number">0</span> ? quickMul(x, N) : <span class="number">1.0</span> / quickMul(x, -N);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">quickMul</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">long</span> N)</span></span>&#123;</span><br><span class="line">        <span class="keyword">double</span> ans = <span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">double</span> x_contribute = x;</span><br><span class="line">        <span class="keyword">while</span>(N != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>( (N &amp; <span class="number">1</span>) == <span class="number">1</span> )&#123;</span><br><span class="line">                ans *= x_contribute;</span><br><span class="line">            &#125;</span><br><span class="line">			<span class="comment">// 计算 x 的 2 的指数次方结果</span></span><br><span class="line">            x_contribute *= x_contribute;</span><br><span class="line">            N = N &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度 O(logN)，空间复杂度 O(1)。</p>
<p>迭代法真是妙蛙种子吃着妙脆角妙进了米奇妙妙屋，妙到家了。</p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode Medium</tag>
        <tag>二分查找</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>Object</title>
    <url>/2020/04/14/Object/</url>
    <content><![CDATA[<h2 id="java-lang-Object"><a href="#java-lang-Object" class="headerlink" title="java.lang.Object"></a>java.lang.Object</h2><p>类Object是类层次结构的根。 每个类都有Object作为超类。 所有对象，包括数组，实现这个类的方法。</p>
<h3 id="类层次结构"><a href="#类层次结构" class="headerlink" title="类层次结构"></a>类层次结构</h3><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/6IRKvZyzNhxYTgk.png" alt="image-20200414205022670"></p>
<h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>public Object(){}</p>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><h4 id="registerNatives"><a href="#registerNatives" class="headerlink" title="registerNatives"></a>registerNatives</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">registerNatives</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">	registerNatives();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Java 中有两种方法：Java 方法和本地方法。Java 方法是由 Java 语言编写，编译成字节码，存储在 class 文件中。本地方法是由其他语言（比如 C 、C++ 、汇编）编写的，编译成和处理器相关的机器代码。本地方法保存在动态链接库中，格式是各个平台专有的。Java 方法是平台无关的，但本地方法不是。运行中的 Java 程序调用本地方法是，虚拟机装载包含这个本地方法的动态库。本地方法是联系 Java 程序和底层主机操作系统的连接方法。</p>
<p>本地方法的实现是由其他语言编写并保存在动态链接库中，因此在 Java 类中不需要方法实现。registerNatives() 本质上就是一个本地方法，但这又是一个区别于一般本地方法的本地方法，从本地方法名可以猜测出该方法是用来注册本地方法的。上述代码的功能就是先定义了registerNatives()方法，然后当该类被加载的时候，调用该方法完成对该类中本地方法的注册。</p>
<p>凡是包含registerNatives()本地方法的类，同时也包含了其他本地方法。所以，显然，当包含registerNatives()方法的类被加载的时候，<strong>注册的方法就是该类所包含的除了registerNatives()方法以外的所有本地方法</strong>。</p>
<p>一个Java程序要想调用一个本地方法，需要执行两个步骤：第一，通过System.loadLibrary()将包含本地方法实现的动态文件加载进内存；第二，当Java程序需要调用本地方法时，虚拟机在加载的动态文件中定位并链接该本地方法，从而得以执行本地方法。registerNatives()方法的作用就是取代第二步，让程序主动将本地方法链接到调用方，当Java程序需要调用本地方法时就可以直接调用，而不需要虚拟机再去定位并链接。</p>
<h4 id="getClass"><a href="#getClass" class="headerlink" title="getClass"></a>getClass</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> Class&lt;?&gt; getClass();</span><br></pre></td></tr></table></figure>

<p>返回运行时类的Object 。 返回Class对象被 static synchronized 所表示的类方法修饰。<br>实际结果的类型是Class&lt;? extends |X|&gt;，其中|X| 是getClass被调用时静态类型的擦除。 例如，下列代码不需要强制转换。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Number n = <span class="number">0</span>; </span><br><span class="line">Class&lt;? extends Number&gt; c = n.getClass();</span><br></pre></td></tr></table></figure>



<h4 id="hashcode"><a href="#hashcode" class="headerlink" title="hashcode"></a>hashcode</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>返回该对象的哈希码值。 为其他哈希表提供支持，例如 java.util.HashMap 。<br>一般 hashCode 满足以下规则：</p>
<ul>
<li><p>在应用程序的执行期间，只要对象的equals方法的比较操作所用到的信息没有被修改，那么对同一个对象的多次调用，hashCode方法都必须始终返回同一个值。在一个应用程序与另一个应用程序的执行过程中，执行hashCode方法所返回的值可以不一致。</p>
</li>
<li><p>如果两个对象由 equals() 判断为 true ，那么他们的哈希码值必须相等。</p>
</li>
<li><p>如果两个对象由 equals() 判断为 false ，那么他们的哈希码值可以相等。应该为不同的对象生成不同的哈希码来提高哈希表的性能。哈希码值一般是将对象地址转成一个整数来得到。</p>
</li>
</ul>
<h4 id="equals"><a href="#equals" class="headerlink" title="equals"></a>equals</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (<span class="keyword">this</span> == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>判断某个其他对象是否 “等于” 这个对象。默认比较的是两个对象的地址，当且仅当 this 和 obj 同时指向同一个对象时返回 true。</p>
<p>按照约定，equals要满足以下规则。</p>
<ul>
<li><strong>自反性</strong>:  x.equals(x) 一定是true</li>
<li><strong>对null</strong>:  x.equals(null) 一定是false</li>
<li><strong>对称性</strong>:  x.equals(y)  和 y.equals(x)结果一致</li>
<li><strong>传递性</strong>:  a 和 b equals , b 和 c  equals，那么 a 和 c也一定equals。</li>
<li><strong>一致性</strong>:  在某个运行时期间，2个对象的状态的改变不会影响equals的决策结果，那么，在这个运行时期间，无论调用多少次equals，都返回相同的结果。</li>
</ul>
<p>通常 equals 方法被重写时，必须重写 hashcode 方法。如果重写了 equals 方法，没有重写 hashcode 方法，判断两个值相等的对象时，当 equals 方法判断为 true（对象的值相等则为 true）时，由于两个值相等的对象地址不一样，所以生成的 hashcode 也不一样。违反了 hashcode 的规则：equals 为 true 两个对象的哈希码值必须相等。</p>
<h4 id="clone"><a href="#clone" class="headerlink" title="clone"></a>clone</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span>;</span><br></pre></td></tr></table></figure>

<p>创建并返回此对象的副本。按照惯例，返回的对象应该通过调用<code>super.clone</code>获得。</p>
<p><code>clone</code>的方法<code>Object</code>执行特定的克隆操作。  首先，如果此对象的类不实现接口<code>Cloneable</code>  ，则抛出<code>CloneNotSupportedException</code> 。  请注意，所有数组都被认为是实现接口<code>Cloneable</code>  ，并且数组类型<code>T[]</code>的<code>clone</code>方法的返回类型是<code>T[]</code>  ，其中T是任何引用或原始类型。  否则，该方法将创建该对象的类的新实例，并将其所有字段初始化为完全符合该对象的相应字段的内容，就像通过赋值一样。  这些字段的内容本身不被克隆。 因此，该方法执行该对象的“浅拷贝”，而不是“深度拷贝”操作。 </p>
<p><code>Object</code>类本身并不实现接口<code>Cloneable</code>  ，因此在类别为<code>Object</code>的对象上调用<code>clone</code>方法将导致运行时抛出异常</p>
<h4 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString"></a>toString</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getClass().getName() + <span class="string">"@"</span> + Integer.toHexString(hashCode());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>返回一个代表对象的字符串。这个字符串中含有对象的相关信息，便于阅读。建议所有的子类重写这个方法。</p>
<p>Object 类的 toString 方法返回对象的类名 + ‘@’ + 对象的哈希码值得十六进制数。</p>
<h4 id="notify"><a href="#notify" class="headerlink" title="notify"></a>notify</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>唤醒<strong>任意</strong>一个正在等待该对象的监视器锁（对象的内置锁）的线程。一个线程通过调用 wait 方法来等待对象的监视器锁。被唤醒的线程只有在当前线程放弃了对象的锁之后才能被执行。被唤醒的线程与其他线程平等竞争对象的锁。该方法只能由作为该对象的监视器的所有者线程调用。</p>
<p>线程有三种方式成为对象监视器锁的所有者：</p>
<ol>
<li><p>通过执行对象的同步方法。</p>
</li>
<li><p>通过执行对象的同步语句（锁住此对象）。</p>
</li>
<li><p>执行类的同步静态方法。</p>
</li>
</ol>
<h4 id="notifyAll"><a href="#notifyAll" class="headerlink" title="notifyAll"></a>notifyAll</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">notifyAll</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>唤醒<strong>所有</strong>一个正在等待该对象的监视器锁的线程。一个线程通过调用 wait 方法来等待对象的监视器锁。</p>
<h4 id="wait"><a href="#wait" class="headerlink" title="wait"></a>wait</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br></pre></td></tr></table></figure>

<p>使当前线程阻塞直到另一个线程调用此对象的 notify 方法或 notifyAll 方法或指定的时间已过，当前线程变为就绪状态。当前线程必须拥有此对象的监视器锁。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout, <span class="keyword">int</span> nanos)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (timeout &lt; <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"timeout value is negative"</span>);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (nanos &lt; <span class="number">0</span> || nanos &gt; <span class="number">999999</span>) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                               <span class="string">"nanosecond timeout value out of range"</span>);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (nanos &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           timeout++;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       wait(timeout);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>与只有一个参数的 wait 方法类似，更加精细地控制等待被唤醒的时间直到放弃。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        wait(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>使当前线程阻塞直到另一个线程调用此对象的 notify 方法或 notifyAll 方法。</p>
<h4 id="finalize"><a href="#finalize" class="headerlink" title="finalize"></a>finalize</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123; &#125;</span><br></pre></td></tr></table></figure>

<p>当垃圾收集器确定不再有该对象的引用时调用。finalize 方法通常的目的是在对象不可撤销丢弃之前执行清除动作。甚至finalize 方法可以让此对象再次可用于其他线程而避免被垃圾收集器清除。finalize 方法只能调用一次。</p>
<p>参考：</p>
<p><a href="https://blog.csdn.net/Saintyyu/article/details/90452826" target="_blank" rel="noopener">https://blog.csdn.net/Saintyyu/article/details/90452826</a></p>
]]></content>
      <categories>
        <category>JDK 源码分析</category>
      </categories>
      <tags>
        <tag>java.lang包</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot自动配置解析</title>
    <url>/2021/03/10/SpringBoot%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<p>使用Spring Initializer 生成一个最简单的 Web 应用，打开启动类。</p>
<a id="more"></a>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01Application</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(Demo01Application<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>点击 @SpringBootApplication ，我们可以看到如下注解信息：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(excludeFilters = &#123; <span class="meta">@Filter</span>(type = FilterType.CUSTOM, classes = TypeExcludeFilter<span class="class">.<span class="keyword">class</span>),</span></span><br><span class="line"><span class="class">		@<span class="title">Filter</span>(<span class="title">type</span> </span>= FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter<span class="class">.<span class="keyword">class</span>) &#125;)</span></span><br></pre></td></tr></table></figure>

<h4 id="SpringBootConfiguration"><a href="#SpringBootConfiguration" class="headerlink" title="@SpringBootConfiguration"></a>@SpringBootConfiguration</h4><p>@SpringBootConfiguration 表示一个类提供Spring Boot应用程序。它的作用等同于@Configuration，以便可以自动找到配置。应用程序应该只包含<strong>一个</strong>@SpringBootConfiguration ，通常的Spring Boot应用程序将从@SpringBootApplication自动继承它。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootConfiguration &#123;</span><br><span class="line">	<span class="meta">@AliasFor</span>(annotation = Configuration<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">	<span class="title">boolean</span> <span class="title">proxyBeanMethods</span>() <span class="title">default</span> <span class="title">true</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>proxyBeanMethods 方法指定是否应代理@Bean方法：<strong>默认为 Full模式</strong>，保证每个@Bean方法被调用多少次返回的Bean都是单实例的；也可为 Lite 模式（值为 false），每次调用 @Bean 方法都会返回新的实例。<br>如果配置类 Bean 之间有依赖关系，则强制使用 Full 模式。<br>新建 MyConfig 配置类来测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">()</span></span>&#123; <span class="comment">//User 为一个POJO，这里省略定义</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> User(<span class="string">"li"</span>, <span class="number">18</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来在 Main 方法中添加如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MyConfig bean = run.getBean(MyConfig<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">User u1 = bean.getUser();</span><br><span class="line">User u2 = bean.getUser();</span><br><span class="line">System.out.println(<span class="string">"U1 == U2? "</span> + (u1 == u2));</span><br></pre></td></tr></table></figure>

<p>运行，可以看到结果为 true，在用户代码中直接调用@Bean方法的情况下也返回共享的单例bean实例。</p>
<p>接下来为 <code>@Configuration</code> 添加配置<code>@Configuration(proxyBeanMethods = false)</code>,再次运行，可以看到结果为 false，返回了两个不同的实例。</p>
<p>接下来测试组建依赖，修改 MyConfig 为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span>(proxyBeanMethods = <span class="keyword">true</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">()</span></span>&#123;</span><br><span class="line">        User u = <span class="keyword">new</span> User(<span class="string">"li"</span>, <span class="number">18</span>);</span><br><span class="line">        u.setPet(getPet());</span><br><span class="line">        <span class="keyword">return</span> u;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Pet <span class="title">getPet</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Pet(<span class="string">"tom"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果将 proxyBeanMethods 改为 false，IDEA 将会提示“使用 Bean 标记的方法被 proxyBeanMethods 为 false 的配置类调用，将其改为 true 或者使用依赖注入。”</p>
<h4 id="ComponentScan"><a href="#ComponentScan" class="headerlink" title="@ComponentScan"></a>@ComponentScan</h4><p>替换默认的 Filter，替换为AutoConfigurationExcludeFilter</p>
<h4 id="EnableAutoConfiguration"><a href="#EnableAutoConfiguration" class="headerlink" title="@EnableAutoConfiguration"></a>@EnableAutoConfiguration</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@AutoConfigurationPackage</span></span><br><span class="line"><span class="meta">@Import</span>(AutoConfigurationImportSelector<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> @<span class="title">interface</span> <span class="title">EnableAutoConfiguration</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><p>@AutoConfigurationPackage<br>使用 @AutoConfigurationPackage 来注册包。如果没有指定 base packages 或 base package classes，则注册带有@AutoConfigurationPackage 的类所在的包。</p>
</li>
<li><p>@Import(AutoConfigurationPackages.Registrar.class)<br>AutoConfigurationImportSelector 中有如下函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String[] selectImports(AnnotationMetadata annotationMetadata) &#123;</span><br><span class="line">	<span class="keyword">if</span> (!isEnabled(annotationMetadata)) &#123;</span><br><span class="line">		<span class="keyword">return</span> NO_IMPORTS;</span><br><span class="line">	&#125;</span><br><span class="line">	AutoConfigurationEntry autoConfigurationEntry = getAutoConfigurationEntry(annotationMetadata);</span><br><span class="line">	<span class="keyword">return</span> StringUtils.toStringArray(autoConfigurationEntry.getConfigurations());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>找到 getAutoConfigurationEntry 定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> AutoConfigurationEntry <span class="title">getAutoConfigurationEntry</span><span class="params">(AnnotationMetadata annotationMetadata)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!isEnabled(annotationMetadata)) &#123;</span><br><span class="line">		<span class="keyword">return</span> EMPTY_ENTRY;</span><br><span class="line">	&#125;</span><br><span class="line">       <span class="comment">//获取注解元信息</span></span><br><span class="line">	AnnotationAttributes attributes = getAttributes(annotationMetadata);</span><br><span class="line">       <span class="comment">//获取所有配置类</span></span><br><span class="line">	List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata, attributes);</span><br><span class="line">	<span class="comment">//去掉重复的配置类，去掉需要排除的配置类，最终返回</span></span><br><span class="line">       configurations = removeDuplicates(configurations);</span><br><span class="line">	Set&lt;String&gt; exclusions = getExclusions(annotationMetadata, attributes);</span><br><span class="line">	checkExcludedClasses(configurations, exclusions);</span><br><span class="line">	configurations.removeAll(exclusions);</span><br><span class="line">	configurations = getConfigurationClassFilter().filter(configurations);</span><br><span class="line">	fireAutoConfigurationImportEvents(configurations, exclusions);</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> AutoConfigurationEntry(configurations, exclusions);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中最核心的方法是 getCandidateConfigurations ，用来获取所有的配置类，点击进入。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> List&lt;String&gt; <span class="title">getCandidateConfigurations</span><span class="params">(AnnotationMetadata metadata, AnnotationAttributes attributes)</span> </span>&#123;</span><br><span class="line">	List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(getSpringFactoriesLoaderFactoryClass(),</span><br><span class="line">			getBeanClassLoader());</span><br><span class="line">	Assert.notEmpty(configurations, <span class="string">"No auto configuration classes found in META-INF/spring.factories. If you "</span></span><br><span class="line">			+ <span class="string">"are using a custom packaging, make sure that file is correct."</span>);</span><br><span class="line">	<span class="keyword">return</span> configurations;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>点击进入 loadFactoryNames 方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">loadFactoryNames</span><span class="params">(Class&lt;?&gt; factoryType, @Nullable ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">	ClassLoader classLoaderToUse = classLoader;</span><br><span class="line">	<span class="keyword">if</span> (classLoaderToUse == <span class="keyword">null</span>) &#123;</span><br><span class="line">		classLoaderToUse = SpringFactoriesLoader<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>()</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	String factoryTypeName = factoryType.getName();</span><br><span class="line">	<span class="keyword">return</span> loadSpringFactories(classLoaderToUse).getOrDefault(factoryTypeName, Collections.emptyList());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>点击进入 loadSpringFactories方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, List&lt;String&gt;&gt; loadSpringFactories(ClassLoader classLoader) &#123;</span><br><span class="line">	Map&lt;String, List&lt;String&gt;&gt; result = cache.get(classLoader);</span><br><span class="line">	<span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	result = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		Enumeration&lt;URL&gt; urls = classLoader.getResources(FACTORIES_RESOURCE_LOCATION);</span><br><span class="line">		<span class="keyword">while</span> (urls.hasMoreElements()) &#123;</span><br><span class="line">			URL url = urls.nextElement();</span><br><span class="line">			UrlResource resource = <span class="keyword">new</span> UrlResource(url);</span><br><span class="line">			Properties properties = PropertiesLoaderUtils.loadProperties(resource);</span><br><span class="line">			<span class="keyword">for</span> (Map.Entry&lt;?, ?&gt; entry : properties.entrySet()) &#123;</span><br><span class="line">				String factoryTypeName = ((String) entry.getKey()).trim();</span><br><span class="line">				String[] factoryImplementationNames =</span><br><span class="line">						StringUtils.commaDelimitedListToStringArray((String) entry.getValue());</span><br><span class="line">				<span class="keyword">for</span> (String factoryImplementationName : factoryImplementationNames) &#123;</span><br><span class="line">					result.computeIfAbsent(factoryTypeName, key -&gt; <span class="keyword">new</span> ArrayList&lt;&gt;())</span><br><span class="line">							.add(factoryImplementationName.trim());</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Replace all lists with unmodifiable lists containing unique elements</span></span><br><span class="line">		result.replaceAll((factoryType, implementations) -&gt; implementations.stream().distinct()</span><br><span class="line">				.collect(Collectors.collectingAndThen(Collectors.toList(), Collections::unmodifiableList)));</span><br><span class="line">		cache.put(classLoader, result);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Unable to load factories from location ["</span> +</span><br><span class="line">				FACTORIES_RESOURCE_LOCATION + <span class="string">"]"</span>, ex);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打断点运行到 classLoader.getResource位置，我们可以看到 FACTORIES_RESOURCE_LOCATION 此时为<code>META-INF/spring.factories</code>,这里扫描系统中所有 <code>META-INF/spring.factories</code>位置的文件，spring-boot-autoconfigure-2.4.3.jar 中的 spring.factories 文件写死了 springboot 启动就给容器中加载所有的配置类（xxxxx AutoConfiguration）。</p>
<p>在 spring boot 启动过程中，所有的自动配置都是条件配置，以org.springframework.boot.autoconfigure.web.servlet 为例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@AutoConfigureOrder</span>(Ordered.HIGHEST_PRECEDENCE)</span><br><span class="line"><span class="meta">@Configuration</span>(proxyBeanMethods = <span class="keyword">false</span>)</span><br><span class="line"><span class="meta">@ConditionalOnWebApplication</span>(type = Type.SERVLET)</span><br><span class="line"><span class="meta">@ConditionalOnClass</span>(DispatcherServlet<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">AutoConfigureAfter</span>(<span class="title">ServletWebServerFactoryAutoConfiguration</span>.<span class="title">class</span>)</span></span><br></pre></td></tr></table></figure>

<p>@ConditionalOnClass(DispatcherServlet.class) 注解指定 只有 DispatcherServlet.class 在类路径中存在才自动配置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnBean</span>(MultipartResolver<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">ConditionalOnMissingBean</span>(<span class="title">name</span> </span>= DispatcherServlet.MULTIPART_RESOLVER_BEAN_NAME)</span><br><span class="line"><span class="function"><span class="keyword">public</span> MultipartResolver <span class="title">multipartResolver</span><span class="params">(MultipartResolver resolver)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// Detect if the user has created a MultipartResolver but named it incorrectly</span></span><br><span class="line">	<span class="keyword">return</span> resolver;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还可以自己配置 MultipartResolver，如果自行定义了这个 Bean，那么 spring boot 就会使用用户自定义的。</p>
<p>总结：</p>
<ul>
<li><p>SpringBoot先加载所有的自动配置类  xxxxxAutoConfiguration</p>
</li>
<li><p>每个自动配置类按照条件进行生效，默认都会绑定配置文件指定的值。xxxxProperties里面拿。xxxProperties和配置文件进行了绑定</p>
</li>
<li><p>生效的配置类就会给容器中装配很多组件</p>
</li>
<li><p>只要容器中有这些组件，相当于这些功能就有了</p>
</li>
<li><p>定制化配置</p>
</li>
<li><ul>
<li>用户直接自己@Bean替换底层的组件</li>
<li>用户去看这个组件是获取的配置文件什么值就去修改。</li>
</ul>
</li>
</ul>
<p><strong>xxxxxAutoConfiguration —&gt; 组件  —&gt;</strong> <strong>xxxxProperties里面拿值  —-&gt; application.properties</strong></p>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>三数之和</title>
    <url>/2020/07/01/%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<h4 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15. 三数之和"></a><a href="https://leetcode-cn.com/problems/3sum/" target="_blank" rel="noopener">15. 三数之和</a></h4><p>给你一个包含 <em>n</em> 个整数的数组 <code>nums</code>，判断 <code>nums</code> 中是否存在三个元素 <em>a，b，c ，*使得 *a + b + c =</em> 0 ？请你找出所有满足条件且不重复的三元组。</p>
<p><strong>注意：</strong>答案中不可以包含重复的三元组。</p>
 <a id="more"></a>

<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定数组 nums &#x3D; [-1, 0, 1, 2, -1, -4]，</span><br><span class="line"></span><br><span class="line">满足要求的三元组集合为：</span><br><span class="line">[</span><br><span class="line">  [-1, 0, 1],</span><br><span class="line">  [-1, -1, 2]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>题目中要找到所有「不重复」且和为 0 的三元组，这个「不重复」的要求使我们不能简单地使用三重循环枚举所有三元组。如果直接使用三重循环枚举三元组，会得到O(n^3) 个满足题目要求的三元组，时间复杂度至少为 O(n^3)。在这之后还需要进行去重操作，时间复杂度和空间复杂度都很高。</p>
<p>我们先将数组进行排序枚举三元组(a, b, c) 满足 a &lt;= b &lt;= c，这样排除了(b, c, a)等情况。同时对于每一重循环而言，相邻两次枚举的元素不能相同，否则也会造成重复。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[0, 1, 2, 2, 3]</span><br><span class="line"> ^  ^  ^</span><br></pre></td></tr></table></figure>

<p>三重循环第一次枚举到的三元组为 (0, 1, 2)，如果第三重循环继续枚举下一个元素，则会造成重复。因此我们需要将第三重循环跳到下一个不相同的元素。</p>
<p>对于第二三重循环，我们可以使用双指针来降低复杂度，当第一层循环遍历到数字 a 时，就变为求 nums 中 a 后的有序子数组中两数之和为 -a，可以使用双指针来找出这两个数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//枚举 a</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> a = <span class="number">0</span>; a &lt; n; a++)&#123;</span><br><span class="line">            <span class="comment">//需要和上一次枚举的数不相同</span></span><br><span class="line">            <span class="keyword">if</span>(a &gt; <span class="number">0</span> &amp;&amp; nums[a] == nums[a - <span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// c 对应的指针初始指向数组的最右端</span></span><br><span class="line">            <span class="keyword">int</span> c = n - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> target = -nums[a];</span><br><span class="line">            <span class="comment">//枚举 b</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> b = a + <span class="number">1</span>; b &lt; n; ++b)&#123;</span><br><span class="line">                <span class="comment">//需要和上一次枚举的数不相同,a 和 b 都不同，结果组合一定不会相同</span></span><br><span class="line">                <span class="keyword">if</span>(b &gt; a + <span class="number">1</span> &amp;&amp; nums[b] == nums[b - <span class="number">1</span>])&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// b 的指针在 c 指针左侧</span></span><br><span class="line">                <span class="keyword">while</span>(b &lt; c &amp;&amp; nums[b] + nums[c] &gt; target)&#123;</span><br><span class="line">                    --c;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//指针重合，随着 b 的增加就不会有满足 a+b+c=0 且 满足 b&lt;c 的 c 了，退出循环</span></span><br><span class="line">                <span class="keyword">if</span>(b == c)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(nums[b] + nums[c] == target)&#123;</span><br><span class="line">                    List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                    list.add(nums[a]);</span><br><span class="line">                    list.add(nums[b]);</span><br><span class="line">                    list.add(nums[c]);</span><br><span class="line">                    ans.add(list);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度 O(n^2)，空间复杂度O(logN)，这里忽略了存储答案的空间。</p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode Medium</tag>
        <tag>双指针</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>三角形最小路径和</title>
    <url>/2020/07/14/%E4%B8%89%E8%A7%92%E5%BD%A2%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/</url>
    <content><![CDATA[<h4 id="120-三角形最小路径和"><a href="#120-三角形最小路径和" class="headerlink" title="120. 三角形最小路径和"></a><a href="https://leetcode-cn.com/problems/triangle/" target="_blank" rel="noopener">120. 三角形最小路径和</a></h4><p>给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。</p>
<p><strong>相邻的结点</strong> 在这里指的是 <code>下标</code> 与 <code>上一层结点下标</code> 相同或者等于 <code>上一层结点下标 + 1</code> 的两个结点。</p>
 <a id="more"></a>

<p>例如，给定三角形：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">     [2],</span><br><span class="line">    [3,4],</span><br><span class="line">   [6,5,7],</span><br><span class="line">  [4,1,8,3]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>自顶向下的最小路径和为 <code>11</code>（即，<strong>2</strong> + <strong>3</strong> + <strong>5</strong> + <strong>1</strong> = 11）。</p>
<p> <strong>说明：</strong></p>
<p>如果你可以只使用 <em>O</em>(<em>n</em>) 的额外空间（<em>n</em> 为三角形的总行数）来解决这个问题，那么你的算法会很加分。</p>
<p>我们使用 <code>f[i][j]</code>来表示从三角形顶部走到位置<code>(i, j)</code>的最小路径和。这里的 <code>i</code> 和 <code>j</code> 指的是三角形中第<code>i</code>行第<code>j</code>列（从 0 开始编号）的的位置。</p>
<p>由于每一步只能移动到下一个相邻的结点，要到位置<code>(i, j)</code>，上一步位置就只能在<code>(i - 1, j)</code>或<code>(i - 1, j - 1)</code>中选择。我们在两者之间找一个路径和比较小的来转移，状态方程为：<br>$$<br>f[i][j] = min(f[i -1][j - 1], f[i - 1][j]) + c[i][j]<br>$$<br>其中<code>c[i][j]</code>表示位置<code>(i, j)</code>对应的元素值。</p>
<p>注意边界条件：</p>
<ul>
<li><p>当 j == 0 时，没有左上结点，只能从上一个结点转移过来，状态转移方程为：<br>$$<br>f[i][j] = f[i - 1][j] + c[i][j]<br>$$</p>
</li>
<li><p>当 j == i 时，没有上结点，只能从左上结点转移过来，状态转移方程为：</p>
</li>
</ul>
<p>$$<br>f[i][j] = f[i - 1][j - 1] + c[i][j]<br>$$</p>
<p>最终的答案为 <code>f[n - 1][0]</code> 到 <code>f[n - 1][n - 1]</code> 的最小值，其中  n 是三角形的行数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumTotal</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; triangle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = triangle.size();</span><br><span class="line">        <span class="keyword">if</span>(m == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> n = triangle.get(m - <span class="number">1</span>).size();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = triangle.get(<span class="number">0</span>).get(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i + <span class="number">1</span>; j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> up = j != i ? dp[i - <span class="number">1</span>][j] : Integer.MAX_VALUE;</span><br><span class="line">                <span class="keyword">int</span> upLeft = j - <span class="number">1</span> &gt;= <span class="number">0</span> ? dp[i - <span class="number">1</span>][j - <span class="number">1</span>] : Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line">                dp[i][j] = triangle.get(i).get(j) + Math.min(up, upLeft); </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> min = dp[m - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">            min = Math.min(min, dp[m - <span class="number">1</span>][i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度O(n^2)，空间复杂度O(n^2)。</p>
<p>我们可以看到 dp 数组中第 i 行的值只与第 i - 1 行的值有关，我们可以只使用一个一维数组存储。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumTotal</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; triangle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = triangle.size();</span><br><span class="line">        <span class="keyword">if</span>(m == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> n = triangle.get(m - <span class="number">1</span>).size();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        dp[<span class="number">0</span>]= triangle.get(<span class="number">0</span>).get(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> up = <span class="number">0</span>, upLeft = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i + <span class="number">1</span>; j++)&#123;</span><br><span class="line">                up = dp[j];</span><br><span class="line">                <span class="keyword">if</span>(j == <span class="number">0</span>)&#123;</span><br><span class="line">                    dp[j] = up + triangle.get(i).get(j);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(j == i)&#123;</span><br><span class="line">                    dp[j] = upLeft + triangle.get(i).get(j);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[j] = Math.min(up, upLeft) + triangle.get(i).get(j);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//第 j + 1 个元素的左上元素等于第 j 个元素上方的元素</span></span><br><span class="line">                upLeft = up;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> min = dp[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">            min = Math.min(min, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度O(n^2)，空间复杂度O(n)。</p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode Medium</tag>
        <tag>动态规划</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>下一个排列</title>
    <url>/2020/11/10/%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97/</url>
    <content><![CDATA[<h4 id="31-下一个排列"><a href="#31-下一个排列" class="headerlink" title="31. 下一个排列"></a><a href="https://leetcode-cn.com/problems/next-permutation/" target="_blank" rel="noopener">31. 下一个排列</a></h4><p>实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。</p>
<p>如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。</p>
<p>必须<strong><a href="https://baike.baidu.com/item/原地算法" target="_blank" rel="noopener">原地</a></strong>修改，只允许使用额外常数空间。</p>
<a id="more"></a>

<p>以下是一些例子，输入位于左侧列，其相应输出位于右侧列。<br><code>1,2,3</code> → <code>1,3,2</code><br><code>3,2,1</code> → <code>1,2,3</code><br><code>1,1,5</code> → <code>1,5,1</code></p>
<p>下一个排列总是比当前排列要大，除非当前排列是最大的，我们需要找到一个下一个排列，且变化的幅度尽量小。</p>
<p>我们需要找到一个尽量靠右的<em>较小数</em>和尽量小的<em>较大数</em>，交换这两个数使排列变大，同时交换之后我们需要将较小数右边的递减序列重排，来得到变换幅度最小的序列。</p>
<p>以[1, 5, 8, 4, 7, 6, 5, 3, 1]为例，我们可以得到下一个序列[1, 5, 8, 5, 1, 3, 4, 6, 7]。</p>
<p>直观的想法是，从右至左找到第一个不是递减序列中的值，找到了 4，它右边的递减序列为 [7, 6, 5, 3, 1]。接下来找一个数和 4 交换，这个数必须比 4 大（比 4 小的序列已经生成过）又要使变化幅度最小，我们找到了第一个大于 4 的数 5。将 4 和 5 交换，得到[1, 5, 8, 5, 7, 6, 4, 3, 1]，还需要将 5 右边的递减序列翻转，得到[1, 5, 8, 5, 1, 3, 4, 6, 7]。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nextPermutation</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = nums.length - <span class="number">2</span>;</span><br><span class="line">        <span class="comment">//从右至左找到一个不是递减序列中的值</span></span><br><span class="line">        <span class="keyword">while</span>(i &gt;= <span class="number">0</span> &amp;&amp; nums[i] &gt;= nums[i + <span class="number">1</span>])&#123;</span><br><span class="line">            --i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(i &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//在递减序列中找到一个比前一个找到的值稍大的数</span></span><br><span class="line">            <span class="keyword">int</span> j = nums.length - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(j &gt;= <span class="number">0</span> &amp;&amp; nums[i] &gt;= nums[j])&#123;</span><br><span class="line">                --j;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//交换这两个数</span></span><br><span class="line">            swap(nums, i, j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将右边的递减序列翻转</span></span><br><span class="line">        reverse(nums, i + <span class="number">1</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = start, right = end;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            swap(nums, left, right);</span><br><span class="line">            ++left;</span><br><span class="line">            --right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度O(N)</li>
<li>空间复杂度O(1)</li>
</ul>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode Medium</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>下载文泉学堂 PDF</title>
    <url>/2020/04/04/%E4%B8%8B%E8%BD%BD%E6%96%87%E6%B3%89%E5%AD%A6%E5%A0%82%20PDF/</url>
    <content><![CDATA[<h1 id="下载文泉学堂-PDF"><a href="#下载文泉学堂-PDF" class="headerlink" title="下载文泉学堂 PDF"></a>下载文泉学堂 PDF</h1><p>　　今天画了20多大洋买了一本电子书，这本书居然只能在他们自己的网站上看。只能在他们自己的网站上我也忍了，但是这个体验非常糟糕，不能快速翻页一直在异步加载图片而不是一次性全部加载好的。最骚的是写这个阅读器的人把你看过的页码统统模糊掉，你想要往上翻又要加载一次，体验非常的糟糕，就想着能不能把这本书的pdf下载下来。</p>
<p>　　最后找到了一个方法：</p>
<p>　　1）安装油猴扩展，具体方法见百度。</p>
<p>　　2）安装下载脚本。<a href="https://greasyfork.org/zh-CN/scripts/396025-文泉学堂pdf下载" target="_blank" rel="noopener">https://greasyfork.org/zh-CN/scripts/396025-%E6%96%87%E6%B3%89%E5%AD%A6%E5%A0%82pdf%E4%B8%8B%E8%BD%BD</a></p>
<p>　　3）打开文泉学堂 pdf 阅读器，点击某一页 pdf 即可开始下载，下载的比较慢，稍等一会你能看见自动翻页，必须等待前两个pdf 下载完后才能挂后台，chrome 有一个连续下载的提示框。</p>
<p>　　4）将下载的多个 pdf 合并为一个 pdf 。<a href="https://dl.pconline.com.cn/download/364420.html" target="_blank" rel="noopener">https://dl.pconline.com.cn/download/364420.html</a></p>
<p>　　参考：<a href="https://github.com/Kevin0z0/wenquan-pdf-download" target="_blank" rel="noopener">https://github.com/Kevin0z0/wenquan-pdf-download</a></p>
<p>　　感谢大佬，tql。</p>
<p>　　所有下载的pdf请在24小时内删除，请勿传播或进行营利，一切法律责任由用户自己承担，与本人无关。</p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
  </entry>
  <entry>
    <title>不同的二叉搜索树</title>
    <url>/2020/07/15/%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
    <content><![CDATA[<h4 id="96-不同的二叉搜索树"><a href="#96-不同的二叉搜索树" class="headerlink" title="96. 不同的二叉搜索树"></a><a href="https://leetcode-cn.com/problems/unique-binary-search-trees/" target="_blank" rel="noopener">96. 不同的二叉搜索树</a></h4><p>给定一个整数 <em>n</em>，求以 1 … <em>n</em> 为节点组成的二叉搜索树有多少种？</p>
<a id="more"></a>

<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 3</span><br><span class="line">输出: 5</span><br><span class="line">解释:</span><br><span class="line">给定 n &#x3D; 3, 一共有 5 种不同结构的二叉搜索树:</span><br><span class="line"></span><br><span class="line">   1         3     3      2      1</span><br><span class="line">    \       &#x2F;     &#x2F;      &#x2F; \      \</span><br><span class="line">     3     2     1      1   3      2</span><br><span class="line">    &#x2F;     &#x2F;       \                 \</span><br><span class="line">   2     1         2                 3</span><br></pre></td></tr></table></figure>

<p>给定一个有序序列 1 … n，为了构建出一颗二叉搜索树，我们可以将数字 i 作为树根，将 1 … i - 1作为左子树，将 i + 1 … n 作为右子树。由于根植的不同，我们能保证每颗二叉搜索树是唯一的。</p>
<p>记<code>f[n]</code> 为整数 1 … n 构成的二叉搜索树种数，得到动态规划方程：<br>$$<br>f[n] = \sum^{n}_{i = 1}{f[i - 1]*f[n - i]}<br>$$<br>边界条件，当序列长度为1（只有根）或为 0（空树）时只有一种情况： f[0] = 1，f[1] = 1。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++)&#123;</span><br><span class="line">                dp[i] += dp[j - <span class="number">1</span>] * dp[i - j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度O(n^2)，空间复杂度O(n)。</p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode Medium</tag>
        <tag>动态规划</tag>
        <tag>二叉搜索树</tag>
      </tags>
  </entry>
  <entry>
    <title>不同的二叉搜索树II</title>
    <url>/2020/07/21/%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91II/</url>
    <content><![CDATA[<h4 id="95-不同的二叉搜索树-II"><a href="#95-不同的二叉搜索树-II" class="headerlink" title="95. 不同的二叉搜索树 II"></a><a href="https://leetcode-cn.com/problems/unique-binary-search-trees-ii/" target="_blank" rel="noopener">95. 不同的二叉搜索树 II</a></h4><p>给定一个整数 <em>n</em>，生成所有由 1 … <em>n</em> 为节点所组成的 <strong>二叉搜索树</strong> 。</p>
 <a id="more"></a>

<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：3</span><br><span class="line">输出：</span><br><span class="line">[</span><br><span class="line">  [1,null,3,2],</span><br><span class="line">  [3,2,null,1],</span><br><span class="line">  [3,1,null,null,2],</span><br><span class="line">  [2,1,3],</span><br><span class="line">  [1,null,2,null,3]</span><br><span class="line">]</span><br><span class="line">解释：</span><br><span class="line">以上的输出对应以下 5 种不同结构的二叉搜索树：</span><br><span class="line"></span><br><span class="line">   1         3     3      2      1</span><br><span class="line">    \       &#x2F;     &#x2F;      &#x2F; \      \</span><br><span class="line">     3     2     1      1   3      2</span><br><span class="line">    &#x2F;     &#x2F;       \                 \</span><br><span class="line">   2     1         2                 3</span><br></pre></td></tr></table></figure>

<p> <strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= n &lt;= 8</code></li>
</ul>
<p>我们枚举根结点的值为 i ，根据 BST 的性质，我们可以知道左子树的结点值集合为 [1 … i - 1]，右子树的结点值集合为 [i + 1 … n]。我们可以使用递归来建立子树。</p>
<p>我们定义 <code>generateTrees(start, end)</code>函数表示当前值的集合为 [start, end]，返回序列 [start, end]生成的所有可行的 BST。我们在 [start, end] 中枚举根结点 i ，将序列分为 [start, i - 1] 和 [i + 1, end] 递归地调用 generateTrees 函数。我们获得了所有的可行的右子树，最后一步，我们从左右子树集合中任选两课拼接到根结点上。</p>
<p>当 start &gt; end 时递归，BST 为空，返回空结点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;TreeNode&gt; <span class="title">generateTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> generateTrees(<span class="number">1</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">List&lt;TreeNode&gt; <span class="title">generateTrees</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        List&lt;TreeNode&gt; allTrees = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(start &gt; end)&#123;</span><br><span class="line">            allTrees.add(<span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">return</span> allTrees;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//枚举根结点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt;= end; i++)&#123;</span><br><span class="line">            <span class="comment">//得到左子树结点</span></span><br><span class="line">            List&lt;TreeNode&gt; leftTrees = generateTrees(start, i - <span class="number">1</span>);</span><br><span class="line">            <span class="comment">//得到右子树结点</span></span><br><span class="line">            List&lt;TreeNode&gt; rightTrees = generateTrees(i + <span class="number">1</span>, end);</span><br><span class="line">			<span class="comment">//从左右子树结点集合中拿出两个结点连接到根结点</span></span><br><span class="line">            <span class="keyword">for</span>(TreeNode left : leftTrees)&#123;</span><br><span class="line">                <span class="keyword">for</span>(TreeNode right : rightTrees)&#123;</span><br><span class="line">                    TreeNode curTree = <span class="keyword">new</span> TreeNode(i);</span><br><span class="line">                    curTree.left = left;</span><br><span class="line">                    curTree.right = right;</span><br><span class="line">                    allTrees.add(curTree);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> allTrees;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后的结果存储了许多 BST 的根结点，我们以 n = 5， i = 3 为例来解释：</p>
<p>以  3 为根结点，左子树结点集合 为指向 1、2 的两个结点，右子树结点为指向 4、5 的两个结点，左右各取一个结点，新建一个根结点，生成 4 棵以 3 为根结点的 BST。</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20200721114003250.png" alt="image-20200721114003250"></p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode Medium</tag>
        <tag>二叉搜索树</tag>
      </tags>
  </entry>
  <entry>
    <title>不同路径 II</title>
    <url>/2020/07/01/%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84-II/</url>
    <content><![CDATA[<h4 id="63-不同路径-II"><a href="#63-不同路径-II" class="headerlink" title="63. 不同路径 II"></a><a href="https://leetcode-cn.com/problems/unique-paths-ii/" target="_blank" rel="noopener">63. 不同路径 II</a></h4><p>一个机器人位于一个 <em>m x n</em> 网格的左上角 （起始点在下图中标记为“Start” ）。</p>
<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p>
<p>现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？</p>
 <a id="more"></a>

<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/ymcKdA4V1LXFkaP-1594979791519.png" alt="img"></p>
<p>网格中的障碍物和空位置分别用 <code>1</code> 和 <code>0</code> 来表示。</p>
<p><strong>说明：</strong>m 和 <em>n</em> 的值均不超过 100。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">[</span><br><span class="line">  [0,0,0],</span><br><span class="line">  [0,1,0],</span><br><span class="line">  [0,0,0]</span><br><span class="line">]</span><br><span class="line">输出: 2</span><br><span class="line">解释:</span><br><span class="line">3x3 网格的正中间有一个障碍物。</span><br><span class="line">从左上角到右下角一共有 2 条不同的路径：</span><br><span class="line">1. 向右 -&gt; 向右 -&gt; 向下 -&gt; 向下</span><br><span class="line">2. 向下 -&gt; 向下 -&gt; 向右 -&gt; 向右</span><br></pre></td></tr></table></figure>
<p>此题相比 <a href="https://leetcode-cn.com/problems/unique-paths/" target="_blank" rel="noopener">不同路径</a> 多了一个障碍物判断。第一行第一列中只要有一个障碍物，后面的路径数全部为 0 。如果位置 <code>(i,j)</code>  上有障碍物，则路径数直接为 0 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(<span class="keyword">int</span>[][] obstacleGrid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = obstacleGrid.length;</span><br><span class="line">        <span class="keyword">int</span> m = obstacleGrid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span>[][] counts = <span class="keyword">new</span> <span class="keyword">int</span>[n][m];</span><br><span class="line">        <span class="comment">//初始化第一列</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(obstacleGrid[i][<span class="number">0</span>] == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                counts[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//初始化第一行</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(obstacleGrid[<span class="number">0</span>][i] == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                counts[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;n; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;m; j++)&#123;</span><br><span class="line">                <span class="comment">//有障碍物直接为 0 </span></span><br><span class="line">                <span class="keyword">if</span>(obstacleGrid[i][j] == <span class="number">1</span>)&#123;</span><br><span class="line">                    counts[i][j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">//dp</span></span><br><span class="line">                    counts[i][j] = counts[i-<span class="number">1</span>][j]+counts[i][j-<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> counts[n-<span class="number">1</span>][m-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度为O(mn)，空间复杂度为 O(mn)。</p>
<p>我们可以继续对空间复杂度优化，可以看出 dp 方程中只与上一行的元素和左边元素有关，我们可以只使用一个一维数组存储数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(<span class="keyword">int</span>[][] obstacleGrid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = obstacleGrid.length, n = obstacleGrid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span>[]counts = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        paths[<span class="number">0</span>] = obstacleGrid[<span class="number">0</span>][<span class="number">0</span>] == <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(obstacleGrid[i][j] == <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(j &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                        counts[j] += counts[j - <span class="number">1</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;<span class="comment">//有障碍物</span></span><br><span class="line">                    counts[j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> counts[n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度为O(mn)，空间复杂度为 O(n)。</p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode Medium</tag>
        <tag>动态规划</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>不同路径</title>
    <url>/2020/07/01/%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<h4 id="62-不同路径"><a href="#62-不同路径" class="headerlink" title="62. 不同路径"></a><a href="https://leetcode-cn.com/problems/unique-paths/" target="_blank" rel="noopener">62. 不同路径</a></h4><p>一个机器人位于一个 <em>m x n</em> 网格的左上角 （起始点在下图中标记为“Start” ）。</p>
<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p>
<p>问总共有多少条不同的路径？</p>
 <a id="more"></a>

<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/ymcKdA4V1LXFkaP.png" alt="img"></p>
<p>例如，上图是一个7 x 3 的网格。有多少可能的路径？</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: m &#x3D; 3, n &#x3D; 2</span><br><span class="line">输出: 3</span><br><span class="line">解释:</span><br><span class="line">从左上角开始，总共有 3 条路径可以到达右下角。</span><br><span class="line">1. 向右 -&gt; 向右 -&gt; 向下</span><br><span class="line">2. 向右 -&gt; 向下 -&gt; 向右</span><br><span class="line">3. 向下 -&gt; 向右 -&gt; 向右</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: m &#x3D; 7, n &#x3D; 3</span><br><span class="line">输出: 28</span><br></pre></td></tr></table></figure>



<p><strong>提示：</strong></p>
<ul>
<li><p><code>1 &lt;= m, n &lt;= 100</code></p>
</li>
<li><p>题目数据保证答案小于等于 <code>2 * 10 ^ 9</code></p>
</li>
</ul>
<p>我们使用 <code>dp[i][j]</code> 来存储到达 <code>(i,j)</code> 的最多路径，由于机器人只能向下或向右，则 <code>dp[i][j] = dp[i-1][j] + dp[i][j-1]</code> 。对于第一行 <code>dp[0][]</code> 和第一列 <code>dp[][0]</code> 只能有一条路径到达，所以它们的值全部为 1 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] counts = <span class="keyword">new</span> <span class="keyword">int</span>[n][m];</span><br><span class="line">        <span class="comment">//第一行和第一列全为 1 </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; ++i)counts[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m; ++i)counts[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;m; j++)&#123;</span><br><span class="line">                <span class="comment">//dp[i][j] = dp[i-1][j] + dp[i][j-1]</span></span><br><span class="line">                counts[i][j] = counts[i-<span class="number">1</span>][j] + counts[i][j-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> counts[n-<span class="number">1</span>][m-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度为O(mn)，空间复杂度为 O(mn)。</p>
<p>优化空间复杂度 为 O(n)</p>
<p>由于只需要<code>dp[i-1][j]</code> 和 <code>dp[i][j-1]</code> ，我们只用使用一个一维数组存储上一行的数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] cur = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        Arrays.fill(cur,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++)&#123;</span><br><span class="line">                <span class="comment">//cur[j] 为 dp[i-1][j]，cur[j-1] 为 dp[i][j-1]。</span></span><br><span class="line">                cur[j] += cur[j-<span class="number">1</span>] ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur[n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度为O(mn)，空间复杂度为 O(n)。</p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode Medium</tag>
        <tag>动态规划</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>丑数II</title>
    <url>/2021/04/11/%E4%B8%91%E6%95%B0II/</url>
    <content><![CDATA[<h4 id="264-丑数-II"><a href="#264-丑数-II" class="headerlink" title="264. 丑数 II"></a><a href="https://leetcode-cn.com/problems/ugly-number-ii/" target="_blank" rel="noopener">264. 丑数 II</a></h4><p>给你一个整数 <code>n</code> ，请你找出并返回第 <code>n</code> 个 <strong>丑数</strong> 。</p>
<p><strong>丑数</strong> 就是只包含质因数 <code>2</code>、<code>3</code> 和/或 <code>5</code> 的正整数。</p>
 <a id="more"></a>

<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 10</span><br><span class="line">输出：12</span><br><span class="line">解释：[1, 2, 3, 4, 5, 6, 8, 9, 10, 12] 是由前 10 个丑数组成的序列。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 1</span><br><span class="line">输出：1</span><br><span class="line">解释：1 通常被视为丑数。</span><br></pre></td></tr></table></figure>

<p> <strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 1690</code></li>
</ul>
<p><strong>方法一：最小堆</strong></p>
<p>初始时堆为空，首先将最小的丑数 1 加入堆，每次取出堆顶元素 x，则 x 是堆中最小的丑数，2x，3x，5x也是丑数，因此将 2x，3x，5x，加入堆中，但这会导致出现重复元素，为了避免出现重复元素，我们使用哈希表去重。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nthUglyNumber</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] factors = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        Set&lt;Long&gt; seen = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        PriorityQueue&lt;Long&gt; heap = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line">        seen.add(<span class="number">1L</span>);</span><br><span class="line">        heap.offer(<span class="number">1L</span>);</span><br><span class="line">        <span class="keyword">int</span> ugly = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">long</span> curr = heap.poll();</span><br><span class="line">            ugly = (<span class="keyword">int</span>) curr;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> factor : factors)&#123;</span><br><span class="line">                <span class="keyword">long</span> next = curr * factor;</span><br><span class="line">                <span class="keyword">if</span>(seen.add(next))&#123; </span><br><span class="line">                    heap.offer(next);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ugly;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度O(nlogn)</li>
<li>空间复杂度O(n)</li>
</ul>
<p><strong>方法二：动态规划</strong></p>
<p>在方法一中，我们存储了较多的丑数，导致空间复杂度较高。我们可以使用三个指针来指向最小的三个丑数。</p>
<p>定义数组 dp，dp[i] 表示第 i 个丑数，第 n 个丑数为 dp[n]，dp[1] = 1。</p>
<p>定义三个指针 p2，p3，p5，下一个丑数是当前指针指向的凑数乘以对应的质因数。下一个丑数分别为，2 * p2, 3 * p3, 5 * p5，我们取这三个数的最小值，然后将使用过的指针加一。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nthUglyNumber</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> p2 = <span class="number">1</span>, p3 = <span class="number">1</span>, p5 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> num2 = dp[p2] * <span class="number">2</span>, num3 = dp[p3] * <span class="number">3</span>, num5 = dp[p5] * <span class="number">5</span>;</span><br><span class="line">            <span class="comment">//取三个数中的最小值</span></span><br><span class="line">            dp[i] = Math.min(Math.min(num2, num3), num5);</span><br><span class="line">            <span class="comment">//将使用过的指针加一</span></span><br><span class="line">            <span class="keyword">if</span>(dp[i] == num2)&#123;</span><br><span class="line">                ++p2;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(dp[i] == num3)&#123;</span><br><span class="line">                ++p3;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(dp[i] == num5)&#123;</span><br><span class="line">                ++p5;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度O(n)</li>
<li>空间复杂度O(n)</li>
</ul>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode Medium</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>两个数组的交集 II</title>
    <url>/2020/07/13/%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86II/</url>
    <content><![CDATA[<h4 id="350-两个数组的交集-II"><a href="#350-两个数组的交集-II" class="headerlink" title="350. 两个数组的交集 II"></a><a href="https://leetcode-cn.com/problems/intersection-of-two-arrays-ii/" target="_blank" rel="noopener">350. 两个数组的交集 II</a></h4><p>给定两个数组，编写一个函数来计算它们的交集。</p>
<a id="more"></a>

<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: nums1 &#x3D; [1,2,2,1], nums2 &#x3D; [2,2]</span><br><span class="line">输出: [2,2]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: nums1 &#x3D; [4,9,5], nums2 &#x3D; [9,4,9,8,4]</span><br><span class="line">输出: [4,9]</span><br></pre></td></tr></table></figure>

<p><strong>说明：</strong></p>
<ul>
<li>输出结果中每个元素出现的次数，应与元素在两个数组中出现的次数一致。</li>
<li>我们可以不考虑输出结果的顺序。</li>
</ul>
<p><strong><em>进阶:</em></strong></p>
<ul>
<li>如果给定的数组已经排好序呢？你将如何优化你的算法？</li>
<li>如果 <em>nums1</em> 的大小比 <em>nums2</em> 小很多，哪种方法更优？</li>
<li>如果 <em>nums2</em> 的元素存储在磁盘上，磁盘内存是有限的，并且你不能一次加载所有的元素到内存中，你该怎么办？</li>
</ul>
<p><strong>方法一：哈希表</strong></p>
<p>我们使用哈希表存储每个数字出现的次数。首先遍历第一个数组，统计所有数字及出现的次数。再遍历第二个数组，如果哈希表中存在这个数字，将其出现的次数减一，并将其加入到结果中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] intersect(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) &#123;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; ansList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums1)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(num))&#123;</span><br><span class="line">                map.put(num, map.get(num) + <span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                map.put(num, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums2)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(num) &amp;&amp; map.get(num) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                ansList.add(num);</span><br><span class="line">                map.put(num, map.get(num) - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> n = ansList.size();</span><br><span class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            ans[i] = ansList.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度O(m + n)，其中 m 和 n 为两个数组的长度。空间复杂度O(max(m, n))。</p>
<p><strong>方法二：排序</strong></p>
<p>如果两个数组是有序的，可以便捷的计算两个数组的交集。首先将两个数组进行排序，然后使用两个指针遍历数组。初始时，两个指针分别指向两个数组的头部，每次比较两个指针指向的两个数组中的数字，如果两个数字相等，将当前数字加入结果中，将两个指针后移；如果两个数字不相等，将较小数字的指针向后移动。当至少一个指针遍历到数组末尾时结束循环。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] intersect(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) &#123;</span><br><span class="line">        Arrays.sort(nums1);</span><br><span class="line">        Arrays.sort(nums2);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] intersection = <span class="keyword">new</span> <span class="keyword">int</span>[Math.min(nums1.length, nums2.length)];</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; nums1.length &amp;&amp; j &lt; nums2.length; )&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums1[i] &lt; nums2[j])&#123;</span><br><span class="line">                ++i;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums1[i] &gt; nums2[j])&#123;</span><br><span class="line">                ++j;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    intersection[index++] = nums1[i];</span><br><span class="line">                    ++i;</span><br><span class="line">                    ++j;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Arrays.copyOfRange(intersection, <span class="number">0</span>, index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度O(mlogm + nlogn)，m 和 n 分别是两个数组的长度。</p>
<p>空间复杂度O(min(m, n))。</p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode Easy</tag>
        <tag>哈希表</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>两数之和 II - 输入有序数组</title>
    <url>/2020/04/09/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C-II---%E8%BE%93%E5%85%A5%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h4 id="167-两数之和-II-输入有序数组"><a href="#167-两数之和-II-输入有序数组" class="headerlink" title="167. 两数之和 II - 输入有序数组"></a><a href="https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/" target="_blank" rel="noopener">167. 两数之和 II - 输入有序数组</a></h4><p>给定一个已按照<strong><em>升序排列\</em></strong> 的有序数组，找到两个数使得它们相加之和等于目标数。</p>
<p>函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2<em>。</em></p>
 <a id="more"></a>

<p><strong>说明:</strong></p>
<ul>
<li>返回的下标值（index1 和 index2）不是从零开始的。</li>
<li>你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。</li>
</ul>
<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: numbers &#x3D; [2, 7, 11, 15], target &#x3D; 9</span><br><span class="line">输出: [1,2]</span><br><span class="line">解释: 2 与 7 之和等于目标数 9 。因此 index1 &#x3D; 1, index2 &#x3D; 2 。</span><br></pre></td></tr></table></figure>

<p>双指针左右向数组中间移动，直到它们的和为 target。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] numbers, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>,j=numbers.length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">        <span class="keyword">if</span>(numbers[j]+numbers[i] &gt;target)&#123;</span><br><span class="line">            --j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(numbers[j]+numbers[i] &lt;target)&#123;</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i+<span class="number">1</span>,j+<span class="number">1</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度O(n)，空间复杂度O(1)。</p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode Easy</tag>
        <tag>双指针</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>两数之和</title>
    <url>/2020/04/09/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<h4 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a><a href="https://leetcode-cn.com/problems/two-sum/" target="_blank" rel="noopener">1. 两数之和</a></h4><p>给定一个整数数组 <code>nums</code> 和一个目标值 <code>target</code>，请你在该数组中找出和为目标值的那 <strong>两个</strong> 整数，并返回他们的数组下标。</p>
<p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。</p>
 <a id="more"></a>

<p> <strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定 nums &#x3D; [2, 7, 11, 15], target &#x3D; 9</span><br><span class="line"></span><br><span class="line">因为 nums[0] + nums[1] &#x3D; 2 + 7 &#x3D; 9</span><br><span class="line">所以返回 [0, 1]</span><br></pre></td></tr></table></figure>
<p>以 num[i] 为 HashMap 的 key，i 为 HashMap 的 value。每遍历到一个新的 nums[i] 判断 HashMap 中是否包含值为 target - nums[i] 的 key，如果包含则取出 key 的 value ，返回。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        Map&lt;Integer,Integer&gt; numMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(numMap.containsKey(target-nums[i]))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i,numMap.get(target-nums[i])&#125;;</span><br><span class="line"></span><br><span class="line">            numMap.put(nums[i],i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时空复杂度均为O(n)</p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode Easy</tag>
        <tag>哈希表</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>两数之和II-输入有序数组</title>
    <url>/2020/07/20/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8CII-%E8%BE%93%E5%85%A5%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h4 id="167-两数之和-II-输入有序数组"><a href="#167-两数之和-II-输入有序数组" class="headerlink" title="167. 两数之和 II - 输入有序数组"></a><a href="https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/" target="_blank" rel="noopener">167. 两数之和 II - 输入有序数组</a></h4><p>给定一个已按照 <strong>升序排列</strong> 的有序数组，找到两个数使得它们相加之和等于目标数。</p>
<p>函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2<em>。</em></p>
<a id="more"></a>

<p><strong>说明:</strong></p>
<ul>
<li>返回的下标值（index1 和 index2）不是从零开始的。</li>
<li>你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。</li>
</ul>
<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: numbers &#x3D; [2, 7, 11, 15], target &#x3D; 9</span><br><span class="line">输出: [1,2]</span><br><span class="line">解释: 2 与 7 之和等于目标数 9 。因此 index1 &#x3D; 1, index2 &#x3D; 2 。</span><br></pre></td></tr></table></figure>

<p>初始化两个指针，左指针指向有序数组第一个元素，右指针指向有序数组最后一个元素，计算两个指针指向的元素之和 sum，若 sum &lt; target，则将左指针右移，尝试获得更大的 sum，若 sum &gt; target，则将右指针左移，尝试获得更小的 sum，当左右指针相遇时结束。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] numbers, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, j = numbers.length - <span class="number">1</span>; i &lt; j; )&#123;</span><br><span class="line">            <span class="keyword">int</span> sum = numbers[i] + numbers[j];</span><br><span class="line">            <span class="keyword">if</span>(sum == target)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i + <span class="number">1</span>, j + <span class="number">1</span>&#125;;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sum &lt; target)&#123;</span><br><span class="line">                ++i;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sum &gt; target)&#123;</span><br><span class="line">                --j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度O(n)，空间复杂度O(1)。</p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode Easy</tag>
        <tag>双指针</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>买卖股票的最佳时机</title>
    <url>/2020/07/01/%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/</url>
    <content><![CDATA[<h4 id="121-买卖股票的最佳时机"><a href="#121-买卖股票的最佳时机" class="headerlink" title="121. 买卖股票的最佳时机"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/" target="_blank" rel="noopener">121. 买卖股票的最佳时机</a></h4><p>给定一个数组，它的第 <em>i</em> 个元素是一支给定股票第 <em>i</em> 天的价格。</p>
<p>如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。</p>
<p>注意：你不能在买入股票前卖出股票。</p>
 <a id="more"></a>

<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [7,1,5,3,6,4]</span><br><span class="line">输出: 5</span><br><span class="line">解释: 在第 2 天（股票价格 &#x3D; 1）的时候买入，在第 5 天（股票价格 &#x3D; 6）的时候卖出，最大利润 &#x3D; 6-1 &#x3D; 5 。</span><br><span class="line">     注意利润不能是 7-1 &#x3D; 6, 因为卖出价格需要大于买入价格。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [7,6,4,3,1]</span><br><span class="line">输出: 0</span><br><span class="line">解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</span><br></pre></td></tr></table></figure>

<p><strong>方法一：暴力</strong></p>
<p>我们需要找出两个数字之间的最大差值，并且第二个数字必须大于第一个数字。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxProfit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prices.length; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; prices.length; j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> profit = prices[j] - prices[i];</span><br><span class="line">                <span class="keyword">if</span>(profit &gt; maxProfit)&#123;</span><br><span class="line">                    maxProfit = profit;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxProfit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度O(N^2)</li>
<li>空间复杂度O(N)</li>
</ul>
<p><strong>方法二：一次遍历</strong></p>
<p>我们买股票肯定希望在历史最低点买入，在最高点卖出。使用 minPrice 记录一个历史最低价格，我们在第 i 天卖出股票的得到的利润为<code>prices[i] -minPrice</code>。我们遍历一次数组，同时维护最大利润 maxProfit 即可得到答案。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(prices.length &lt;= <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> maxProfit = <span class="number">0</span>, minPrice = prices[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; ++i)&#123;</span><br><span class="line">        maxProfit = Math.max(maxProfit, prices[i] - minPrice);</span><br><span class="line">        minPrice = Math.min(prices[i], minPrice);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxProfit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度O(n)</li>
<li>空间复杂度O(1)。</li>
</ul>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode Easy</tag>
        <tag>动态规划</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>买卖股票的最佳时机II</title>
    <url>/2020/11/08/%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAII/</url>
    <content><![CDATA[<h4 id="122-买卖股票的最佳时机-II"><a href="#122-买卖股票的最佳时机-II" class="headerlink" title="122. 买卖股票的最佳时机 II"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/" target="_blank" rel="noopener">122. 买卖股票的最佳时机 II</a></h4><p>给定一个数组，它的第 <em>i</em> 个元素是一支给定股票第 <em>i</em> 天的价格。</p>
<p>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p>
<p><strong>注意：</strong>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
 <a id="more"></a>

<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [7,1,5,3,6,4]</span><br><span class="line">输出: 7</span><br><span class="line">解释: 在第 2 天（股票价格 &#x3D; 1）的时候买入，在第 3 天（股票价格 &#x3D; 5）的时候卖出, 这笔交易所能获得利润 &#x3D; 5-1 &#x3D; 4 。</span><br><span class="line">     随后，在第 4 天（股票价格 &#x3D; 3）的时候买入，在第 5 天（股票价格 &#x3D; 6）的时候卖出, 这笔交易所能获得利润 &#x3D; 6-3 &#x3D; 3 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,2,3,4,5]</span><br><span class="line">输出: 4</span><br><span class="line">解释: 在第 1 天（股票价格 &#x3D; 1）的时候买入，在第 5 天 （股票价格 &#x3D; 5）的时候卖出, 这笔交易所能获得利润 &#x3D; 5-1 &#x3D; 4 。</span><br><span class="line">     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。</span><br><span class="line">     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [7,6,4,3,1]</span><br><span class="line">输出: 0</span><br><span class="line">解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</span><br></pre></td></tr></table></figure>

<p> <strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= prices.length &lt;= 3 * 10 ^ 4</code></li>
<li><code>0 &lt;= prices[i] &lt;= 10 ^ 4</code></li>
</ul>
<p><strong>方法一：动态规划</strong></p>
<p>由于不能同时参与多笔交易，每天交易结束后，手中有股票和没股票两种情况，定义<code>dp[i][0]</code>为第 i 天结束后手中没有股票的最大利润，定义<code>dp[i][1]</code>为第 i 天结束后手中有股票的最大利润。</p>
<p>第 i 天结束时，手中没有股票有两种情况：</p>
<ul>
<li>第 i - 1 天没有股票，第 i 天没有买入；</li>
<li>第 i - 1 天有股票，第 i 天卖出。</li>
</ul>
<p>取两种收益的最大值，我们可以写出 dp 方程：<br>$$<br>dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] + prices[i])<br>$$<br>第 i 天结束时，手中有股票有两种情况：</p>
<ul>
<li>第 i - 1 天有股票，第 i 天没有卖出；</li>
<li>第 i - 1 天没有股票，第 i 天买入。</li>
</ul>
<p>取两种收益的最大值，我们可以写出 dp 方程：<br>$$<br>dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] - prices[i])<br>$$<br>考虑初始状态：第 0 天结束时，手中没有股票，收益为 0 ；第 0 天结束时，手中有股票，此时我们在第 0 天买入了股票，收益为 -prices[0]。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = prices.length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][<span class="number">2</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">            dp[i][<span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度O(N)</li>
<li>空间复杂度O(N)</li>
</ul>
<p>由于第 i 天的状态只与 第 i - 1 天的状态有关，我们可以只用 O(1)空间。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = prices.length;</span><br><span class="line">        <span class="keyword">int</span> dp0 = <span class="number">0</span>, dp1 = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> newdp0 = Math.max(dp0, dp1 + prices[i]);</span><br><span class="line">            <span class="keyword">int</span> newdp1 = Math.max(dp1, dp0 - prices[i]);</span><br><span class="line">            dp0 = newdp0;</span><br><span class="line">            dp1 = newdp1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度O(N)</li>
<li>空间复杂度O(1)</li>
</ul>
<p><strong>方法二：贪心</strong></p>
<p><strong>贪心算法的直觉</strong>：由于不限制交易次数，只要今天股价比昨天高，就交易。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(prices[i] &gt; prices[i - <span class="number">1</span>])&#123;</span><br><span class="line">                ans += prices[i] - prices[i - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度O(N)</li>
<li>空间复杂度O(1)</li>
</ul>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>二分查找</title>
    <url>/2020/07/17/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
    <content><![CDATA[<p>在有序数组种，常用二分查找场景：寻找一个数、寻找左侧边界、寻找右侧边界。在二分查找算法的细节主要有两点：「while 循环中的的不等号是否带等号」，「边界的取值问题」。</p>
<a id="more"></a>

<h3 id="二分查找框架"><a href="#二分查找框架" class="headerlink" title="二分查找框架"></a>二分查找框架</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> left = <span class="number">0</span>, right = ...;</span><br><span class="line">	<span class="keyword">while</span>(...)&#123;</span><br><span class="line">		<span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span>(nums[mid] == target)&#123;</span><br><span class="line">			...;</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target)&#123;</span><br><span class="line">			left = ...;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			right = ...;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>mid = left + (right - left) / 2</code> 是为了避免整数溢出，我们剩下的就是要在省略号的地方填上相应的步骤来实现二分查找。</p>
<h3 id="寻找有序数组"><a href="#寻找有序数组" class="headerlink" title="寻找有序数组"></a>寻找有序数组</h3><p>在有序数组中寻找一个数，如果存在，返回下标，否则返回 -1。</p>
<p>下面我们看一个示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> datastructure;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySearch</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 在有序数组中寻找一个整数</span></span><br><span class="line"><span class="comment">    * @param nums，有序数组</span></span><br><span class="line"><span class="comment">    * @param target，需要寻找的目标</span></span><br><span class="line"><span class="comment">    * @return 找到的数值索引，未找到返回 -1</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearchNum</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>; <span class="comment">// 搜索区间为 [left, right]</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;<span class="comment">//重点：因为左右闭区间，所以当 left == right 时，还有一个值需要判断，需要加上等号</span></span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>; <span class="comment">//搜索区间变成[mid + 1, right]</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>; <span class="comment">//因为右闭区间,搜索区间为[left, mid - 1]</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearchNum2</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length; <span class="comment">// 搜索区间为 [left, right)</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123; <span class="comment">//左闭右开区间，当 left == right 时，区间内已经没有值</span></span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;<span class="comment">//搜索区间变成[mid + 1, right)</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//因为右开区间，搜索区间为[left, mid)，如果为 right = mid - 1，</span></span><br><span class="line">                <span class="comment">//区间为[left, mid - 1)，我们会漏掉 mid - 1位置的值</span></span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] nums = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">2</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">77</span>,<span class="number">44</span>,<span class="number">33</span>,<span class="number">77</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">14</span>,<span class="number">100</span>&#125;;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        System.out.println(Arrays.toString(nums));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">            Random random = <span class="keyword">new</span> Random(i*<span class="number">80</span>);</span><br><span class="line">            <span class="keyword">int</span> num = nums[random.nextInt(<span class="number">14</span>)];</span><br><span class="line">            System.out.println(<span class="string">"left &lt;= right: searching "</span> + num + <span class="string">" index: "</span> + binarySearchNum(nums,num));</span><br><span class="line">            System.out.println(<span class="string">"left &lt; right: searching "</span> + num + <span class="string">" index： "</span> + binarySearchNum2(nums,num));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[1, 2, 2, 2, 3, 3, 4, 5, 14, 33, 44, 77, 77, 100]</span><br><span class="line">left &lt;&#x3D; right: searching 77 index: 12</span><br><span class="line">left &lt; right: searching 77 index： 11</span><br><span class="line">left &lt;&#x3D; right: searching 3 index: 4</span><br><span class="line">left &lt; right: searching 3 index： 5</span><br><span class="line">left &lt;&#x3D; right: searching 100 index: 13</span><br><span class="line">left &lt; right: searching 100 index： 13</span><br><span class="line">left &lt;&#x3D; right: searching 3 index: 4</span><br><span class="line">left &lt; right: searching 3 index： 5</span><br><span class="line">left &lt;&#x3D; right: searching 1 index: 0</span><br><span class="line">left &lt; right: searching 1 index： 0</span><br></pre></td></tr></table></figure>

<p><code>num[mid] == target</code> 时，我们已经找到了一个值的下标，直接返回即可。</p>
<h4 id="关于-left-lt-right-和-left-lt-right"><a href="#关于-left-lt-right-和-left-lt-right" class="headerlink" title="关于 left &lt;= right 和 left &lt; right"></a>关于 left &lt;= right 和 left &lt; right</h4><ul>
<li><p>当初始化 <code>left = 0, right = nums.length - 1</code> 时，搜索区间为<code>[left, right]</code>，当 <code>left == right</code>时，搜索区间内还有一个值 nums[left] 没有判断，循环条件内使用 left &lt;= right，如果使用 left &lt; right 最后需要加一次判断 nums[left] == target ?</p>
</li>
<li><p>当初始化 <code>left = 0, right = nums.length</code> 时，搜索区间为<code>[left, right)</code>，当 <code>left == right</code>时，搜索区间内没有值，循环条件内使用 left &lt; right。</p>
</li>
</ul>
<h4 id="关于left、right-取值问题"><a href="#关于left、right-取值问题" class="headerlink" title="关于left、right 取值问题"></a>关于left、right 取值问题</h4><ul>
<li><p>当初始化 <code>left = 0, right = nums.length - 1</code> 时，搜索区间为<code>[left, right]</code>，<code>mid = (left + right) / 2</code>，如果<code>nums[mid] &lt; target</code>，那么 target 值在 mid 右侧，left = mid + 1，此时搜索区间为<code>[mid + 1,right]</code>，如果<code>nums[mid] &gt; target</code>，那么 target 值在 mid 左侧，right = mid - 1，此时搜索区间为<code>[left, mid - 1]</code>。</p>
</li>
<li><p>当初始化 <code>left = 0, right = nums.length</code> 时，搜索区间为<code>[left, right)</code>，<code>mid = (left + right) / 2</code>，如果<code>nums[mid] &lt; target</code>，那么 target 值在 mid 右侧，left = mid + 1，此时搜索区间为<code>[mid + 1,right)</code>，如果<code>nums[mid] &gt; target</code>，那么 target 值在 mid 左侧，right = mid，此时搜索区间为<code>[left, mid)</code>，如果right =mid - 1，那么搜索区间为<code>[left, mid - 1)</code>，mid -  1 位置的值就不在搜索区间内，这是不对的，会造成错误。</p>
</li>
</ul>
<h3 id="寻找左侧边界"><a href="#寻找左侧边界" class="headerlink" title="寻找左侧边界"></a>寻找左侧边界</h3><p>二分查找数组中从左至右等于 target 的第一个值的下标，没有则返回 -1。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearchLeftBoundNum</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length; <span class="comment">// 搜索区间为 [left, right)</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123; <span class="comment">//左闭右开区间，当 left == right 时，区间内已经没有值</span></span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            right = mid;<span class="comment">//右侧逼近，下一个搜索区间[left, mid)</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;<span class="comment">//搜索区间变成[mid + 1, right]</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//因为右开区间，搜索区间为[left, mid)，如果为 right = mid - 1，</span></span><br><span class="line">            <span class="comment">//区间为[left, mid - 1)，我们会漏掉 mid - 1位置的值</span></span><br><span class="line">            right = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//目前的 nums[left]是从左至右第一个大于等于 target 的值</span></span><br><span class="line">    <span class="keyword">if</span>(left == nums.length)&#123;<span class="comment">//target 大于所有值</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nums[left] == target ? left : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[1, 2, 2, 2, 3, 3, 4, 5, 14, 33, 44, 77, 77, 100]</span><br><span class="line">searching left bound 2 index: 1</span><br><span class="line">searching left bound 77 index: 11</span><br><span class="line">searching left bound 1 index: 0</span><br></pre></td></tr></table></figure>

<p>在找到 target 时，没有立刻返回，而是缩小搜索区间的右侧，从右侧逼近，达到锁定左侧边界的目的。</p>
<h3 id="寻找右侧边界"><a href="#寻找右侧边界" class="headerlink" title="寻找右侧边界"></a>寻找右侧边界</h3><p>二分查找数组中从右至左等于 target 的第一个值的下标，没有则返回 -1。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static int binarySearchRightBoundNum(int[] nums, int target) &#123;</span><br><span class="line">    int left &#x3D; 0, right &#x3D; nums.length; &#x2F;&#x2F; 搜索区间为 [left, right)</span><br><span class="line">    while (left &lt; right) &#123; &#x2F;&#x2F;左闭右开区间，当 left &#x3D;&#x3D; right 时，区间内已经没有值</span><br><span class="line">        int mid &#x3D; left + (right - left) &#x2F; 2;</span><br><span class="line">        if (nums[mid] &#x3D;&#x3D; target) &#123;</span><br><span class="line">            left &#x3D; mid + 1;&#x2F;&#x2F;左侧逼近，下一个搜索区间[mid + 1, right)</span><br><span class="line">        &#125; else if (nums[mid] &lt; target) &#123;</span><br><span class="line">            left &#x3D; mid + 1;&#x2F;&#x2F;搜索区间变成[mid + 1, right]</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F;因为右开区间，搜索区间为[left, mid)，如果为 right &#x3D; mid - 1，</span><br><span class="line">            &#x2F;&#x2F;区间为[left, mid - 1)，我们会漏掉 mid - 1位置的值</span><br><span class="line">            right &#x3D; mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 目前的 nums[left] 左边的部分的值都是大于等于 target</span><br><span class="line">    if(left &#x3D;&#x3D; 0)&#123;&#x2F;&#x2F;target 小于所有值</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        &#x2F;&#x2F;返回最后一个等于 target 值的下标</span><br><span class="line">        return nums[left - 1] &#x3D;&#x3D; target ? left - 1 : -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[1, 2, 2, 2, 3, 3, 4, 5, 14, 33, 44, 77, 77, 100]</span><br><span class="line">searching right bound 2 index: 3</span><br><span class="line">searching right bound 77 index: 12</span><br><span class="line">searching right bound 1 index: 0</span><br></pre></td></tr></table></figure>

<p>在找到 target 时，没有立刻返回，而是缩小搜索区间的左侧，从左侧逼近，达到锁定右侧边界的目的。</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉搜索树中的插入操作</title>
    <url>/2020/10/02/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h4 id="701-二叉搜索树中的插入操作"><a href="#701-二叉搜索树中的插入操作" class="headerlink" title="701. 二叉搜索树中的插入操作"></a><a href="https://leetcode-cn.com/problems/insert-into-a-binary-search-tree/" target="_blank" rel="noopener">701. 二叉搜索树中的插入操作</a></h4><p>给定二叉搜索树（BST）的根节点和要插入树中的值，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据保证，新值和原始二叉搜索树中的任意节点值都不同。</p>
<p>注意，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回任意有效的结果。</p>
 <a id="more"></a>

<p>例如, </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定二叉搜索树:</span><br><span class="line"></span><br><span class="line">        4</span><br><span class="line">       &#x2F; \</span><br><span class="line">      2   7</span><br><span class="line">     &#x2F; \</span><br><span class="line">    1   3</span><br><span class="line"></span><br><span class="line">和 插入的值: 5</span><br></pre></td></tr></table></figure>

<p>你可以返回这个二叉搜索树:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">     4</span><br><span class="line">   &#x2F;   \</span><br><span class="line">  2     7</span><br><span class="line"> &#x2F; \   &#x2F;</span><br><span class="line">1   3 5</span><br></pre></td></tr></table></figure>

<p>或者这个树也是有效的:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">     5</span><br><span class="line">   &#x2F;   \</span><br><span class="line">  2     7</span><br><span class="line"> &#x2F; \   </span><br><span class="line">1   3</span><br><span class="line">     \</span><br><span class="line">      4</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>给定的树上的节点数介于 <code>0</code> 和 <code>10^4</code> 之间</li>
<li>每个节点都有一个唯一整数值，取值范围从 <code>0</code> 到 <code>10^8</code></li>
<li><code>-10^8 &lt;= val &lt;= 10^8</code></li>
<li>新值和原始二叉搜索树中的任意节点值都不同</li>
</ul>
<p>我们把要插入的结点和根结点的值比较：</p>
<ul>
<li>比根节点值大，如果根节点右子结点为空，直接将其插入到根节点的右子结点；如果根节点右子结点不为空，将根节点右子结点设为根节点，重复执行上述操作。</li>
<li>比根节点值小，如果根节点左子结点为空，直接将其插入到根节点的左子结点；如果根节点左子结点不为空，将根节点左子结点设为根节点，重复执行上述操作。</li>
</ul>
<p><strong>方法一：递归</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">insertIntoBST</span><span class="params">(TreeNode root, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(val &gt; root.val)&#123;</span><br><span class="line">            root.right = insertIntoBST(root.right, val);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            root.left = insertIntoBST(root.left, val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法二：迭代</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">insertIntoBST</span><span class="params">(TreeNode root, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode pos = root;</span><br><span class="line">        <span class="keyword">while</span>(pos != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(val &gt; pos.val)&#123;</span><br><span class="line">                <span class="keyword">if</span>(pos.right == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    pos.right = <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    pos = pos.right;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(pos.left == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    pos.left = <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    pos = pos.left;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode Medium</tag>
        <tag>二叉搜索树</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树中的最大路径和</title>
    <url>/2020/07/01/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C/</url>
    <content><![CDATA[<h4 id="124-二叉树中的最大路径和"><a href="#124-二叉树中的最大路径和" class="headerlink" title="124. 二叉树中的最大路径和"></a><a href="https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/" target="_blank" rel="noopener">124. 二叉树中的最大路径和</a></h4><p>给定一个<strong>非空</strong>二叉树，返回其最大路径和。</p>
<p>本题中，路径被定义为一条从树中任意节点出发，达到任意节点的序列。该路径<strong>至少包含一个</strong>节点，且不一定经过根节点。<br> <a id="more"></a><br><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,2,3]</span><br><span class="line"></span><br><span class="line">       1</span><br><span class="line">      &#x2F; \</span><br><span class="line">     2   3</span><br><span class="line"></span><br><span class="line">输出: 6</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [-10,9,20,null,null,15,7]</span><br><span class="line"></span><br><span class="line">   -10</span><br><span class="line">   &#x2F; \</span><br><span class="line">  9  20</span><br><span class="line">    &#x2F;  \</span><br><span class="line">   15   7</span><br><span class="line"></span><br><span class="line">输出: 42</span><br></pre></td></tr></table></figure>

<p>考虑一个二叉树单元</p>
<pre><code>   |
   a
  / \
 b   c
/ \ / \</code></pre><ul>
<li>a 是根结点，与上层得父节点相连（如果存在父节点）</li>
<li>b 和 c 是子结点，与各自子节点中路径最大值得结点相连</li>
<li>所有可能得路径情况：<ul>
<li>「左中右」b + a + c</li>
<li>「左」b + a</li>
<li>「右」c + a</li>
</ul>
</li>
</ul>
<p>选择「左」还是「右」：递归调用计算 b 和 c 的最大贡献值，计算 b + a 和 c + a，选择较大的值为返回值，更新到全局最大和。</p>
<p>选择「左中右」：递归调用计算 b 和 c 的最大贡献值，计算 b + a + c 的值，更新到全局最大和。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxSum = Integer.MIN_VALUE;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        maxGain(root);</span><br><span class="line">        <span class="keyword">return</span> maxSum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxGain</span><span class="params">(TreeNode node)</span></span>&#123;</span><br><span class="line">   		<span class="comment">//结点为空，贡献值为 0 </span></span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//递归计算左右子节点的最大贡献值，只有在最大贡献值大于 0 时，才会选取对应子结点</span></span><br><span class="line">        <span class="keyword">int</span> left = Math.max(maxGain(node.left), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> right = Math.max(maxGain(node.right), <span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">		<span class="comment">//选择左中右，计算贡献值并更新最大贡献值</span></span><br><span class="line">        <span class="keyword">int</span> priceNewPath = node.val + left + right;</span><br><span class="line">        maxSum = Math.max(maxSum, priceNewPath);</span><br><span class="line">        <span class="comment">//选择左或右，选择较大的值返回</span></span><br><span class="line">        <span class="keyword">return</span> node.val + Math.max(left, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度O(N)，其中 N 是二叉树中结点个数。对每个结点访问不超过 2 次。</p>
<p>空间复杂度O(N)，最坏情况下二叉树退化为链表，递归深度为 N。</p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode Hard</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树的中序遍历</title>
    <url>/2020/07/03/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<h4 id="94-二叉树的中序遍历"><a href="#94-二叉树的中序遍历" class="headerlink" title="94. 二叉树的中序遍历"></a><a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/" target="_blank" rel="noopener">94. 二叉树的中序遍历</a></h4><p>给定一个二叉树，返回它的<em>中序</em> 遍历。</p>
 <a id="more"></a>

<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,null,2,3]</span><br><span class="line">   1</span><br><span class="line">    \</span><br><span class="line">     2</span><br><span class="line">    &#x2F;</span><br><span class="line">   3</span><br><span class="line"></span><br><span class="line">输出: [1,3,2]</span><br></pre></td></tr></table></figure>

<p><strong>进阶:</strong> 递归算法很简单，你可以通过迭代算法完成吗？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 中序遍历 “左根右”。需要一个栈来保存根结点。</span></span><br><span class="line"><span class="comment">    * 当访问过树的最左叶子结点后，弹出根结点，访问根结点，继续访问根节点的右子结点。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; s = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//循环条件：栈中元素不为空。树的根结点非空</span></span><br><span class="line">       <span class="keyword">while</span>(root != <span class="keyword">null</span> || ! s.isEmpty())&#123;</span><br><span class="line">           <span class="keyword">if</span>(root != <span class="keyword">null</span>)&#123;</span><br><span class="line">               <span class="comment">//根结点入栈</span></span><br><span class="line">               s.push(root);</span><br><span class="line">               <span class="comment">//继续入栈根结点的左子结点</span></span><br><span class="line">               root = root.left;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span>&#123;</span><br><span class="line">               <span class="comment">//无左子结点，将根结点出栈</span></span><br><span class="line">               root = s.pop();</span><br><span class="line">               <span class="comment">//访问根结点</span></span><br><span class="line">               res.add(root.val);</span><br><span class="line">               <span class="comment">//继续访问根结点的右子结点</span></span><br><span class="line">               root = root.right;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode Medium</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树展开为链表</title>
    <url>/2020/08/02/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%95%E5%BC%80%E4%B8%BA%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h4 id="114-二叉树展开为链表"><a href="#114-二叉树展开为链表" class="headerlink" title="114. 二叉树展开为链表"></a><a href="https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/" target="_blank" rel="noopener">114. 二叉树展开为链表</a></h4><p>给定一个二叉树，<a href="https://baike.baidu.com/item/原地算法/8010757" target="_blank" rel="noopener">原地</a>将它展开为一个单链表。</p>
 <a id="more"></a>

<p>例如，给定二叉树</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    1</span><br><span class="line">   &#x2F; \</span><br><span class="line">  2   5</span><br><span class="line"> &#x2F; \   \</span><br><span class="line">3   4   6</span><br></pre></td></tr></table></figure>

<p>将其展开为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line"> \</span><br><span class="line">  2</span><br><span class="line">   \</span><br><span class="line">    3</span><br><span class="line">     \</span><br><span class="line">      4</span><br><span class="line">       \</span><br><span class="line">        5</span><br><span class="line">         \</span><br><span class="line">          6</span><br></pre></td></tr></table></figure>

<p><strong>方法一：前序遍历</strong></p>
<p>将二叉树展开为单链表后，我们发现链表中元素的顺序和二叉树的先序遍历结果相同， 在二叉树先序遍历时，我们使用一个数组存储遍历到的结点，最后将数组中相邻元素连接起来。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;TreeNode&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        preorderTraversal(root, list);</span><br><span class="line">        <span class="keyword">int</span> size = list.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; size; i++)&#123;</span><br><span class="line">            TreeNode prev = list.get(i - <span class="number">1</span>);</span><br><span class="line">            TreeNode cur = list.get(i);</span><br><span class="line">            <span class="comment">//左结点置空</span></span><br><span class="line">            prev.left = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//右结点连接下一个结点</span></span><br><span class="line">            prev.right = cur;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//递归先序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preorderTraversal</span><span class="params">(TreeNode root, List&lt;TreeNode&gt; list)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="keyword">null</span>)&#123;</span><br><span class="line">            list.add(root);</span><br><span class="line">            preorderTraversal(root.left, list);</span><br><span class="line">            preorderTraversal(root.right, list);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度O(n)，每个结点访问两次。空间复杂度O(n)，数组中存储 n 个结点。</p>
<p><strong>方法二：递归</strong></p>
<p>我们知道前序遍历的顺序为“根 - 左 - 右”，我们反过来先将右子树变为链表，再将左子数变为链表，再将左子树链表的末尾连接上右子树链表的头部，最后将根节点右结点连接到左子树链表头部，将根节点左结点置空。</p>
<p>我们使用一个全局变量 last 来保存已经生成的链表的头部，从链表尾部到头部，递归地生成链表。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> TreeNode last = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//先将右子树转换为链表</span></span><br><span class="line">        flatten(root.right);</span><br><span class="line">        <span class="comment">//再将左子树转换为链表(尾部已经连接上了右子树的头部)</span></span><br><span class="line">        flatten(root.left);</span><br><span class="line">        <span class="comment">//根节点右子树指向链表头部</span></span><br><span class="line">        root.right = last;</span><br><span class="line">        <span class="comment">//根节点左子树置空</span></span><br><span class="line">        root.left = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//更新链表头部</span></span><br><span class="line">        last = root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度O(n)，空间复杂度O(n)。</p>
<p><strong>方法三：寻找前驱结点</strong></p>
<p>我们可以发现前序遍历中，左子树的最右结点下一个结点就为右结点，我们可以将右子树作为左子树前序遍历最后一个结点的右子树，这样就可以保持前序遍历不变。然后再将左子树变成右子树，左子树置空。我们对二叉树中所有结点做这样一个操作，就可以将二叉树变成链表。</p>
<p>以示例为例</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20200802095151550.png" alt="image-20200802095151550"></p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20200802095239234.png" alt="image-20200802095239234"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        TreeNode cur = root;</span><br><span class="line">        <span class="comment">//对链表中的每个结点进行变换操作</span></span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//当前结点有左子树，需要变换</span></span><br><span class="line">            <span class="keyword">if</span>(cur.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="comment">//得到左子树的最右结点</span></span><br><span class="line">                TreeNode leftLast = cur.left;</span><br><span class="line">                <span class="keyword">while</span>(leftLast.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    leftLast = leftLast.right;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//将右子树连接到最右结点</span></span><br><span class="line">                leftLast.right = cur.right;</span><br><span class="line">                <span class="comment">//右子树变为左子树</span></span><br><span class="line">                cur.right = cur.left;</span><br><span class="line">                <span class="comment">//左子树置空</span></span><br><span class="line">                cur.left = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//继续转换链表中下一个结点</span></span><br><span class="line">            cur = cur.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度O(n)，空间复杂度O(1)。</p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode Medium</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树的前序遍历</title>
    <url>/2020/07/03/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<h4 id="144-二叉树的前序遍历"><a href="#144-二叉树的前序遍历" class="headerlink" title="144. 二叉树的前序遍历"></a><a href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/" target="_blank" rel="noopener">144. 二叉树的前序遍历</a></h4><p>给定一个二叉树，返回它的 <em>前序</em> 遍历。</p>
 <a id="more"></a>

<p> <strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,null,2,3]  </span><br><span class="line">   1</span><br><span class="line">    \</span><br><span class="line">     2</span><br><span class="line">    &#x2F;</span><br><span class="line">   3 </span><br><span class="line"></span><br><span class="line">输出: [1,2,3]</span><br></pre></td></tr></table></figure>

<p><strong>进阶:</strong> 递归算法很简单，你可以通过迭代算法完成吗？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 前序遍历 “根左右”。需要一个栈来保存已经访问过的根结点。</span></span><br><span class="line"><span class="comment">    * 当已经访问过树的最左叶子结点后，弹出根结点，继续访问根结点的右子结点。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; s = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">		<span class="comment">//循环条件：栈中元素不为空。树的根节点非空</span></span><br><span class="line">        <span class="keyword">while</span>(root != <span class="keyword">null</span> || ! s.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">if</span>(root != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="comment">//访问根节点</span></span><br><span class="line">                ans.add(root.val);</span><br><span class="line">                <span class="comment">//保存根节点</span></span><br><span class="line">                s.push(root);</span><br><span class="line">                <span class="comment">//访问根结点的左子结点</span></span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//无左子结点，弹出根结点</span></span><br><span class="line">                root = s.pop();</span><br><span class="line">                <span class="comment">//继续访问右子结点</span></span><br><span class="line">                root = root.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode Medium</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树的右视图</title>
    <url>/2020/07/03/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B3%E8%A7%86%E5%9B%BE/</url>
    <content><![CDATA[<h4 id="199-二叉树的右视图"><a href="#199-二叉树的右视图" class="headerlink" title="199. 二叉树的右视图"></a><a href="https://leetcode-cn.com/problems/binary-tree-right-side-view/" target="_blank" rel="noopener">199. 二叉树的右视图</a></h4><p>给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</p>
 <a id="more"></a>

<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,2,3,null,5,null,4]</span><br><span class="line">输出: [1, 3, 4]</span><br><span class="line">解释:</span><br><span class="line"></span><br><span class="line">   1            &lt;---</span><br><span class="line"> &#x2F;   \</span><br><span class="line">2     3         &lt;---</span><br><span class="line"> \     \</span><br><span class="line">  5     4       &lt;---</span><br></pre></td></tr></table></figure>

<p>第一感觉就是用层次遍历，保存每一层的最后一个结点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">rightSideView</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">		<span class="comment">//层次遍历使用的队列</span></span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(! queue.isEmpty())&#123;</span><br><span class="line">            <span class="comment">// len 为层次遍历时每一层的结点个数</span></span><br><span class="line">            <span class="keyword">int</span> len = queue.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; i++)&#123;</span><br><span class="line">                TreeNode t = queue.poll();</span><br><span class="line">                <span class="comment">// 是否为最后一个结点</span></span><br><span class="line">                <span class="keyword">if</span>(i == len-<span class="number">1</span>)&#123;</span><br><span class="line">                res.add(t.val);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//将左右子结点加入队列</span></span><br><span class="line">                <span class="keyword">if</span>(t.left != <span class="keyword">null</span>) queue.add(t.left);</span><br><span class="line">                <span class="keyword">if</span>(t.right != <span class="keyword">null</span>) queue.add(t.right);</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们也可以模仿二叉树遍历，只是先遍历右子结点然后遍历左子结点。同时在遍历的过程中保存每一层的第一个结点值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">rightSideView</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        helper(root, <span class="number">1</span>, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(TreeNode root, <span class="keyword">int</span> level, List&lt;Integer&gt; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            假设二叉树深度为 i ，res 数组的大小为 i。</span></span><br><span class="line"><span class="comment">            当 res.size() 小于当前访问的层数时就代表这是最右侧结点。</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="keyword">if</span>(res.size() &lt; level)&#123;</span><br><span class="line">                res.add(root.val);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//先遍历右子结点</span></span><br><span class="line">            helper(root.right, level+<span class="number">1</span>, res);</span><br><span class="line">            <span class="comment">//后遍历左子结点</span></span><br><span class="line">            helper(root.left, level+<span class="number">1</span>, res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode Medium</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树的后序遍历</title>
    <url>/2020/07/01/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<h4 id="145-二叉树的后序遍历"><a href="#145-二叉树的后序遍历" class="headerlink" title="145. 二叉树的后序遍历"></a><a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/" target="_blank" rel="noopener">145. 二叉树的后序遍历</a></h4><p>给定一个二叉树，返回它的 <em>后序</em> 遍历。</p>
 <a id="more"></a>

<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,null,2,3]  </span><br><span class="line">   1</span><br><span class="line">    \</span><br><span class="line">     2</span><br><span class="line">    &#x2F;</span><br><span class="line">   3 </span><br><span class="line"></span><br><span class="line">输出: [3,2,1]</span><br></pre></td></tr></table></figure>

<p><strong>进阶:</strong> 递归算法很简单，你可以通过迭代算法完成吗？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 后序遍历 “左右根”。需要一个栈来保存根结点，</span></span><br><span class="line"><span class="comment">    * 还需要一个指针来记录上一个访问的结点来判断是否访问过根结点的右子结点。</span></span><br><span class="line"><span class="comment">    * 当访问过树的最右叶子结点后，弹出根结点。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; s = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        TreeNode lastPrintNode = <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">       <span class="keyword">while</span>(root != <span class="keyword">null</span> || ! s.isEmpty())&#123;</span><br><span class="line">           <span class="keyword">if</span>(root != <span class="keyword">null</span>)&#123;</span><br><span class="line">               <span class="comment">//根结点入栈</span></span><br><span class="line">               s.push(root);</span><br><span class="line">               <span class="comment">//继续入栈根结点的左子结点</span></span><br><span class="line">               root = root.left;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span>&#123;</span><br><span class="line">               <span class="comment">//无左子结点，将根结点复制一份</span></span><br><span class="line">               root = s.peek();</span><br><span class="line">               <span class="comment">//查看右子结点是否为空或右子结点已经访问过</span></span><br><span class="line">               <span class="keyword">if</span>(root.right == <span class="keyword">null</span> || root.right == lastPrintNode)&#123;</span><br><span class="line">                   <span class="comment">//根结点出栈</span></span><br><span class="line">                    s.pop(); </span><br><span class="line">                   <span class="comment">//访问根结点</span></span><br><span class="line">                    res.add(root.val); </span><br><span class="line">                   <span class="comment">//更新上一个访问过的结点</span></span><br><span class="line">                    lastPrintNode = root; </span><br><span class="line">                   <span class="comment">//取根结点的根节点访问</span></span><br><span class="line">                    root = <span class="keyword">null</span>;</span><br><span class="line">               &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                   <span class="comment">//右子结点不为空，访问右子结点</span></span><br><span class="line">                   root = root.right;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度O(n)，空间复杂度最坏保存整个树O(n)。</p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode Hard</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树的最大深度</title>
    <url>/2020/07/28/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/</url>
    <content><![CDATA[<h4 id="104-二叉树的最大深度"><a href="#104-二叉树的最大深度" class="headerlink" title="104. 二叉树的最大深度"></a><a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/" target="_blank" rel="noopener">104. 二叉树的最大深度</a></h4><p>给定一个二叉树，找出其最大深度。</p>
<p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p>
<p><strong>说明:</strong> 叶子节点是指没有子节点的节点。</p>
<a id="more"></a>

<p><strong>示例：</strong><br>给定二叉树 <code>[3,9,20,null,null,15,7]</code>，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>

<p>返回它的最大深度 3 。</p>
<p><strong>方法一：递归</strong></p>
<p>当前树的最大深度为左右子树的最大深度加一，左右子树又以同样的方式进行计算。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//根节点为空，返回 0</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//只有根节点，返回 1</span></span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//返回左右子树最大深度加一</span></span><br><span class="line">        <span class="keyword">return</span> Math.max(maxDepth(root.left), maxDepth(root.right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度O(n)，树中的每个结点被访问一次。</p>
<p>空间复杂度O(h)，h 为树的高度。</p>
<p><strong>方法二：层次遍历</strong></p>
<p>我们可以使用层次遍历来计算二叉树的深度。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//队列中保存下一层的结点</span></span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="comment">//获得当前层数结点的个数</span></span><br><span class="line">            <span class="keyword">int</span> size = queue.size();</span><br><span class="line">            <span class="comment">//将当前层每一个结点的子节点入队</span></span><br><span class="line">            <span class="keyword">while</span>(size &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                TreeNode t = queue.poll();</span><br><span class="line">                <span class="keyword">if</span>(t.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    queue.offer(t.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(t.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    queue.offer(t.right);</span><br><span class="line">                &#125;</span><br><span class="line">			<span class="comment">//当前层结点数减一</span></span><br><span class="line">                --size;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//二叉树层数加一</span></span><br><span class="line">            ++ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度O(n)，空间复杂度最坏O(n)。</p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode Easy</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树的层序遍历</title>
    <url>/2020/07/03/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<h4 id="102-二叉树的层序遍历"><a href="#102-二叉树的层序遍历" class="headerlink" title="102. 二叉树的层序遍历"></a><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/" target="_blank" rel="noopener">102. 二叉树的层序遍历</a></h4><p>给你一个二叉树，请你返回其按 <strong>层序遍历</strong> 得到的节点值。 （即逐层地，从左到右访问所有节点）。</p>
  <a id="more"></a>

<p><strong>示例：</strong><br>二叉树：<code>[3,9,20,null,null,15,7]</code>,</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>

<p>返回其层次遍历结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [9,20],</span><br><span class="line">  [15,7]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>采用层次遍历，使用一个队列存储结点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(! queue.isEmpty())&#123;</span><br><span class="line">            <span class="comment">//获取当前层的结点数</span></span><br><span class="line">            <span class="keyword">int</span> len = queue.size();</span><br><span class="line">            List&lt;Integer&gt; level = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i)&#123;</span><br><span class="line">                <span class="comment">//取出队头结点，将其加入当前层的结果中</span></span><br><span class="line">                TreeNode t = queue.poll();</span><br><span class="line">                level.add(t.val);</span><br><span class="line">                <span class="comment">//如果有左右子结点，将它们加入队尾</span></span><br><span class="line">                <span class="keyword">if</span>(t.left != <span class="keyword">null</span>) queue.add(t.left);</span><br><span class="line">                <span class="keyword">if</span>(t.right != <span class="keyword">null</span>) queue.add(t.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//保存每一层的结果</span></span><br><span class="line">            res.add(level);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设树上有 n 个结点，时间复杂度 O(n)，空间复杂度O(n)。</p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode Medium</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树的最近公共祖先</title>
    <url>/2020/07/03/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</url>
    <content><![CDATA[<h4 id="236-二叉树的最近公共祖先"><a href="#236-二叉树的最近公共祖先" class="headerlink" title="236. 二叉树的最近公共祖先"></a><a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/" target="_blank" rel="noopener">236. 二叉树的最近公共祖先</a></h4><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p>
<p><a href="https://baike.baidu.com/item/最近公共祖先/8918834?fr=aladdin" target="_blank" rel="noopener">百度百科</a>中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（<strong>一个节点也可以是它自己的祖先</strong>）。”</p>
 <a id="more"></a>

<p>例如，给定如下二叉树: root = [3,5,1,6,2,0,8,null,null,7,4]</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/binarytree.png" alt="img"></p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &#x3D; 5, q &#x3D; 1</span><br><span class="line">输出: 3</span><br><span class="line">解释: 节点 5 和节点 1 的最近公共祖先是节点 3。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &#x3D; 5, q &#x3D; 4</span><br><span class="line">输出: 5</span><br><span class="line">解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。</span><br></pre></td></tr></table></figure>

<p><strong>说明:</strong></p>
<ul>
<li>所有节点的值都是唯一的。</li>
<li>p、q 为不同节点且均存在于给定的二叉树中。</li>
</ul>
<p>思路一</p>
<p>我们可以遍历所有结点，并判断 p 或 q 是否在它的左右子树上，或者这个结点就是 p 或 q 。定义 fx表示 x 结点的子树中是否包含 p 节点或 q节点。fl 代表 x 结点的左子树上是否有 p 或 q 结点，fr 代表 x 结点的右子树上是否有 p 或 q 结点。我们有两种情况：</p>
<ul>
<li>p 和 q 分别在 x 结点的左右子树上，即 fl &amp;&amp; fr == true</li>
<li>结点 x 就是 p 或 q，此时 x== p || x==q 为true，若在 x 结点的左子树或右子树上找到另一个结点，则 x 就是最近公共祖先。</li>
</ul>
<p>总结判断条件：(f1 &amp;&amp; fr) || [ (x==p || x==q) &amp;&amp; ( fl || fr) ] 。由于是自底向上判断的，在所有满足条件的公共祖先中一定是深度最大的祖先被访问到。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> TreeNode res;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        dfs(root, p, q);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//先判断左右子树，再判断当前结点情况</span></span><br><span class="line">        <span class="keyword">boolean</span> left = dfs(root.left, p, q);</span><br><span class="line">        <span class="keyword">boolean</span> right = dfs(root.right, p, q);</span><br><span class="line">        <span class="comment">//判断条件</span></span><br><span class="line">        <span class="keyword">if</span>((left &amp;&amp; right) || (root.val == p.val || root.val == q.val) &amp;&amp; (left || right))&#123;</span><br><span class="line">            res = root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回 x 结点的左右子树 是否包含 p 或 q 结点</span></span><br><span class="line">        <span class="keyword">return</span> left || right || root.val == p.val || root.val == q.val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode Medium</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树的最小深度</title>
    <url>/2020/08/21/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6/</url>
    <content><![CDATA[<h4 id="111-二叉树的最小深度"><a href="#111-二叉树的最小深度" class="headerlink" title="111. 二叉树的最小深度"></a><a href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/" target="_blank" rel="noopener">111. 二叉树的最小深度</a></h4><p>给定一个二叉树，找出其最小深度。</p>
<p>最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</p>
<a id="more"></a>

<p><strong>说明:</strong> 叶子节点是指没有子节点的节点。</p>
<p><strong>示例:</strong></p>
<p>给定二叉树 <code>[3,9,20,null,null,15,7]</code>,</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>

<p>返回它的最小深度  2.</p>
<p>看到这么简单的题，一顿操作，立马就写出了如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.min(minDepth(root.left), minDepth(root.right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调试发现 [2,9]这个用例不对，我们得到的结果为 1，实际结果为 2。原因在于我们统计了空结点到根节点的深度。</p>
<p>对于每个结点，当只有一个子树时，直接返回子树的最小深度加一；当有两颗子树时，返回左右子树之中的最小深度加一。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="keyword">null</span> &amp;&amp; root.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> minDepth(root.right) + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root.right == <span class="keyword">null</span> &amp;&amp; root.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> minDepth(root.left) + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Math.min(minDepth(root.left), minDepth(root.right)) + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度O(n)，空间复杂度O(h)，h 为树的高度，当二叉树退化为链表时，空间复杂度O(n)。</p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode Easy</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>二维区域和检索-矩阵不可变</title>
    <url>/2021/03/02/%E4%BA%8C%E7%BB%B4%E5%8C%BA%E5%9F%9F%E5%92%8C%E6%A3%80%E7%B4%A2-%E7%9F%A9%E9%98%B5%E4%B8%8D%E5%8F%AF%E5%8F%98/</url>
    <content><![CDATA[<h4 id="304-二维区域和检索-矩阵不可变"><a href="#304-二维区域和检索-矩阵不可变" class="headerlink" title="304. 二维区域和检索 - 矩阵不可变"></a><a href="https://leetcode-cn.com/problems/range-sum-query-2d-immutable/" target="_blank" rel="noopener">304. 二维区域和检索 - 矩阵不可变</a></h4><p>给定一个二维矩阵，计算其子矩形范围内元素的总和，该子矩阵的左上角为 (<em>row</em>1, <em>col</em>1) ，右下角为 (<em>row</em>2, <em>col</em>2)。</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20210302095000679.png" alt="image-20210302095000679"><br>上图子矩阵左上角 (row1, col1) = <strong>(2, 1)</strong> ，右下角(row2, col2) = <strong>(4, 3)，</strong>该子矩形内元素的总和为 8。</p>
<a id="more"></a>

<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定 matrix &#x3D; [</span><br><span class="line">  [3, 0, 1, 4, 2],</span><br><span class="line">  [5, 6, 3, 2, 1],</span><br><span class="line">  [1, 2, 0, 1, 5],</span><br><span class="line">  [4, 1, 0, 1, 7],</span><br><span class="line">  [1, 0, 3, 0, 5]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">sumRegion(2, 1, 4, 3) -&gt; 8</span><br><span class="line">sumRegion(1, 1, 2, 2) -&gt; 11</span><br><span class="line">sumRegion(1, 2, 2, 4) -&gt; 12</span><br></pre></td></tr></table></figure>

<p><strong>说明:</strong></p>
<ol>
<li>你可以假设矩阵不可变。</li>
<li>会多次调用 <em>sumRegion</em> 方法<em>。</em></li>
<li>你可以假设 <em>row</em>1 ≤ <em>row</em>2 且 <em>col</em>1 ≤ <em>col</em>2。</li>
</ol>
<p><strong>方法一：二维前缀和</strong></p>
<p>注意到矩阵不可变，我们可以使用二维数组保存数组的前缀和，然后就可以在O(1)时间复杂度内查到区域和。对于示例中的数组我们建立如下前缀和数组：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0	0	0	0	0	0	</span><br><span class="line">0	3	3	4	8	10	</span><br><span class="line">0	8	14	18	24	27	</span><br><span class="line">0	9	17	21	28	36	</span><br><span class="line">0	13	22	26	34	49	</span><br><span class="line">0	14	23	30	38	58</span><br></pre></td></tr></table></figure>

<p>题中数组下标范围是<code>0 &lt;= row &lt; matrix.length</code>和<code>0 &lt;= col &lt; matrix[0].length</code>。子矩阵左上角(row1,col1)，右下角(row2,col2)。<code>子矩阵和 = sum[row2 + 1][col2 + 1] - sum[row2 + 1][col1] - sum[row1][col2 + 1] + sum[row1][col1]</code>。sum 数组多加一行一列是为了避免计算时下标是否越界判断。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumMatrix</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[][] sum;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NumMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sum = <span class="keyword">new</span> <span class="keyword">int</span>[matrix.length + <span class="number">1</span>][matrix[<span class="number">0</span>].length + <span class="number">1</span>];</span><br><span class="line">		<span class="comment">//计算 sum 数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; sum.length; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; sum[<span class="number">0</span>].length; j++)&#123;</span><br><span class="line">                sum[i][j] = sum[i - <span class="number">1</span>][j] + sum[i][j - <span class="number">1</span>] - sum[i - <span class="number">1</span>][j - <span class="number">1</span>] + matrix[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumRegion</span><span class="params">(<span class="keyword">int</span> row1, <span class="keyword">int</span> col1, <span class="keyword">int</span> row2, <span class="keyword">int</span> col2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sum[row2 + <span class="number">1</span>][col2 + <span class="number">1</span>] - sum[row1][col2 + <span class="number">1</span>] - sum[row2 + <span class="number">1</span>][col1] + sum[row1][col1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your NumMatrix object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * NumMatrix obj = new NumMatrix(matrix);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj.sumRegion(row1,col1,row2,col2);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度，初始化O(mn)，查询O(1)，其中 m 和 n 分别为数组的行数和列数。</li>
<li>空间复杂度O(mn)</li>
</ul>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode Medium</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>交错字符串</title>
    <url>/2020/07/18/%E4%BA%A4%E9%94%99%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<h4 id="97-交错字符串"><a href="#97-交错字符串" class="headerlink" title="97. 交错字符串"></a><a href="https://leetcode-cn.com/problems/interleaving-string/" target="_blank" rel="noopener">97. 交错字符串</a></h4><p>给定三个字符串 <em>s1</em>, <em>s2</em>, <em>s3</em>, 验证 <em>s3</em> 是否是由 <em>s1</em> 和 <em>s2</em> 交错组成的。</p>
<a id="more"></a>

<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: s1 &#x3D; &quot;aabcc&quot;, s2 &#x3D; &quot;dbbca&quot;, s3 &#x3D; &quot;aadbbcbcac&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: s1 &#x3D; &quot;aabcc&quot;, s2 &#x3D; &quot;dbbca&quot;, s3 &#x3D; &quot;aadbbbaccc&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>

<p>首先我们需要理解「交错」这个概念，s3 由 s1 的部分字符 和 s2 的部分字符交错形成，以示例 1 为例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;aadbbcbcac&quot; &#x3D; &quot;aa&quot; + &quot;db&quot; + &quot;bc&quot; + &quot;bca&quot; + &quot;c&quot;</span><br><span class="line">				s1     s2     s1      s2     s1</span><br></pre></td></tr></table></figure>

<p>示例2中，s3 中剩下 “accc” ，s1 剩下 “cc” ，s2 剩下”ca”，”cc” 和 “ca” 无法交错形成 “accc”。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;aadbbbaccc&quot; &#x3D; &quot;aa&quot; + &quot;dbb&quot; + &quot;b&quot; + ...</span><br><span class="line">				s1     s2     s1</span><br></pre></td></tr></table></figure>

<p>可以将其当作不同路径来理解，下图来自<a href="https://leetcode-cn.com/problems/interleaving-string/solution/lei-si-lu-jing-wen-ti-zhao-zhun-zhuang-tai-fang-ch/" target="_blank" rel="noopener">gousiqi</a></p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20200718114829025.png" alt="image-20200718114829025"></p>
<p>首先，s1 和 s2 的长度之和不等于 s3 ，s3 必然不可能为 s1 和 s2 交错形成。我们定义 <code>f(i, j)</code>表示字符串 s1 的前 i 个字符能否与字符串 s2 的前 j 个字符形成字符串 s3 的前 i + j 个字符。如果 s1 的第 i 个字符与 s3 的第 i + j 个字符相等，那么 <code>f(i, j)</code>取决于 s1 的前 i - 1 个字符和 s2 的前 j 个字符能否交错构成 s3 的前 i + j - 1 个字符，表示为<code>f(i - 1, j)</code>。如果 s2 的第 j 个字符与 s3 的第 i + j 个字符相等，那么 <code>f(i, j)</code> 取决于 s1 的前 i 个字符和 s2 的前 j - 1 个字符能否交错构成 s3 的前 i + j - 1个字符，表示为<code>f(i, j - 1)</code>。我们可以得出动态规划方程：<br>$$<br>f(i,j)=[f(i - 1, j)\ and\ s_1[i]=s_3[i+j]]\ or\ [f(i, j - 1)\ and\ s_2[j] = s_3[i+j]]<br>$$<br>边界条件为 <code>f(0, 0) = true</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isInterleave</span><span class="params">(String s1, String s2, String s3)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = s1.length(), n = s2.length(), t = s3.length();</span><br><span class="line">        <span class="keyword">if</span>(m + n != t)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n; j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> p = i + j - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(i &gt; <span class="number">0</span>)&#123;<span class="comment">//注意字符串的下标与公式的区别</span></span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j] &amp;&amp; s1.charAt(i - <span class="number">1</span>) == s3.charAt(p);</span><br><span class="line">                &#125;</span><br><span class="line">				<span class="comment">//两个条件之间是 “或” 的关系</span></span><br><span class="line">                <span class="keyword">if</span>(j &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    dp[i][j] = dp[i][j] || dp[i][j - <span class="number">1</span>] &amp;&amp; s2.charAt(j - <span class="number">1</span>) == s3.charAt(p);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度O(mn)，空间复杂度O(mn)。</p>
<p>我们还可以使用滚动数组来优化空间复杂度。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isInterleave</span><span class="params">(String s1, String s2, String s3)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = s1.length(), n = s2.length(), t = s3.length();</span><br><span class="line">        <span class="keyword">if</span>(m + n != t)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span>[] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[n + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n; j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> p = i + j - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(i &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    dp[j] = dp[j] &amp;&amp; s1.charAt(i - <span class="number">1</span>) == s3.charAt(p);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(j &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    dp[j] = dp[j] || dp[j - <span class="number">1</span>] &amp;&amp; s2.charAt(j - <span class="number">1</span>) == s3.charAt(p);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度O(mn)，空间复杂度O(n)。</p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode Hard</tag>
        <tag>字符串</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>从先序遍历还原二叉树</title>
    <url>/2020/07/01/%E4%BB%8E%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86%E8%BF%98%E5%8E%9F%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h4 id="1028-从先序遍历还原二叉树"><a href="#1028-从先序遍历还原二叉树" class="headerlink" title="1028. 从先序遍历还原二叉树"></a><a href="https://leetcode-cn.com/problems/recover-a-tree-from-preorder-traversal/" target="_blank" rel="noopener">1028. 从先序遍历还原二叉树</a></h4><p>我们从二叉树的根节点 <code>root</code> 开始进行深度优先搜索。</p>
<p>在遍历中的每个节点处，我们输出 <code>D</code> 条短划线（其中 <code>D</code> 是该节点的深度），然后输出该节点的值。（<em>如果节点的深度为 <code>D</code>，则其直接子节点的深度为 <code>D + 1</code>。根节点的深度为 <code>0</code>）。</em></p>
<p>如果节点只有一个子节点，那么保证该子节点为左子节点。</p>
<p>给出遍历输出 <code>S</code>，还原树并返回其根节点 <code>root</code>。</p>
  <a id="more"></a>

<p><strong>示例 1：</strong></p>
<p><strong><img src="https://gitee.com/hoo334/picgo/raw/master//img/LT8BhJfg9tj2P5X.png" alt="img"></strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：&quot;1-2--3--4-5--6--7&quot;</span><br><span class="line">输出：[1,2,5,3,4,6,7]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><strong><img src="https://gitee.com/hoo334/picgo/raw/master//img/34oJMB9tDdrAhim.png" alt="img"></strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：&quot;1-2--3---4-5--6---7&quot;</span><br><span class="line">输出：[1,2,5,3,null,6,null,4,null,7]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/oCQaxYNLmFe2Z3w.png" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：&quot;1-401--349---90--88&quot;</span><br><span class="line">输出：[1,401,null,349,88,90]</span><br></pre></td></tr></table></figure>

<p> <strong>提示：</strong></p>
<ul>
<li>原始树中的节点数介于 <code>1</code> 和 <code>1000</code> 之间。</li>
<li>每个节点的值介于 <code>1</code> 和 <code>10 ^ 9</code> 之间。</li>
</ul>
<p>我们可以依次从字符串 S 中恢复出所有结点，我们每次取出一个结点的值以及它的深度信息：</p>
<ul>
<li>首先读取若干的 <code>-</code> 字符，直到遇到非 <code>-</code> 字符。通过字符 <code>-</code> 的个数可以得到当前结点的深度信息。</li>
<li>再读取若干数字，直到遇到非数字或字符串结束，得到结点的值。</li>
</ul>
<p>得到结点的信息之后，需要考虑当前结点需要放在何处。记当前结点为  <code>t</code>  ，上一个结点为 <code>s</code> ，实际上只有两种情况：</p>
<ol>
<li><code>t</code> 是 <code>s</code> 的<strong>左子结点</strong>；</li>
<li><code>t</code> 是根结点到 <code>s</code> 这一条路径上（不包括 <code>s</code>）某一个结点的右子结点。</li>
</ol>
<p>先序遍历 顺序：”根 – 左 – 右“，结点 <code>s</code> 要在结点 <code>t</code>之前被遍历到，<code>s</code> 可以在 ”根“ 的位置，<code>t</code> 在 ”左“ 的位置； 或者，<code>s</code> 可以在 ”根“ 的位置，<code>t</code> 在 ”右“ 的位置，注意这里 <code>t</code> 并不是 <code>s</code> 的右子结点，而是从树的根结点到结点 <code>s</code> 的路径中一个结点的右子结点，这条路径中不包括结点 <code>s</code> ，因为题目中规定了<strong>如果结点只有一个子结点，那么保证该子节点为左子结点</strong>。</p>
<p>我们可以使用递归来实现，也可以使用一个栈来模拟递归。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">recoverFromPreorder</span><span class="params">(String S)</span> </span>&#123;</span><br><span class="line">        index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> helper(S, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">helper</span><span class="params">(String S, <span class="keyword">int</span> depth)</span></span>&#123;</span><br><span class="line">        <span class="comment">//字符串遍历完</span></span><br><span class="line">        <span class="keyword">if</span>(index &gt; S.length()) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> curDepth = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> k = index;</span><br><span class="line">        <span class="comment">//计算当前结点的深度</span></span><br><span class="line">        <span class="keyword">while</span>(k &lt; S.length() &amp;&amp; S.charAt(k) == <span class="string">'-'</span>)&#123;</span><br><span class="line">            ++curDepth;</span><br><span class="line">            ++k;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//当前结点深度与期望深度不符合，为路径中某结点的右子结点，返回空。</span></span><br><span class="line">        <span class="keyword">if</span>(curDepth != depth)<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        index = k;</span><br><span class="line">        <span class="keyword">int</span> val = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//计算结点数值</span></span><br><span class="line">        <span class="keyword">while</span>(index &lt; S.length() &amp;&amp; Character.isDigit(S.charAt(index)))&#123;</span><br><span class="line">            val = val * <span class="number">10</span> + (S.charAt(index) - <span class="string">'0'</span>);</span><br><span class="line">            ++index;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//建立结点并递归建立该结点的子节点</span></span><br><span class="line">        TreeNode node = <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">        node.left = helper(S, depth + <span class="number">1</span>);</span><br><span class="line">        node.right = helper(S, depth + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度 O(s)，其中 s 是字符串 S 的长度。</p>
<p>空间复杂度 O(h)，其中 h 是二叉树的高度（递归深度）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">recoverFromPreorder</span><span class="params">(String S)</span> </span>&#123;</span><br><span class="line">        Deque&lt;TreeNode&gt; path = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(pos &lt; S.length())&#123;</span><br><span class="line">            <span class="comment">//计算当前结点的深度</span></span><br><span class="line">            <span class="keyword">int</span> level = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(S.charAt(pos) == <span class="string">'-'</span>)&#123;</span><br><span class="line">                ++level;</span><br><span class="line">                ++pos;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//计算当前结点的值</span></span><br><span class="line">            <span class="keyword">int</span> value = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(pos &lt; S.length() &amp;&amp; Character.isDigit(S.charAt(pos)))&#123;</span><br><span class="line">                value = value * <span class="number">10</span> + (S.charAt(pos) - <span class="string">'0'</span>);</span><br><span class="line">                ++pos;</span><br><span class="line">            &#125;</span><br><span class="line">			<span class="comment">//建立结点</span></span><br><span class="line">            TreeNode node = <span class="keyword">new</span> TreeNode(value);</span><br><span class="line">            <span class="comment">//结点深度和路径长度相等，若路径不为空，当前结点为路径末尾结点的左子节点</span></span><br><span class="line">            <span class="keyword">if</span>(level == path.size())&#123;</span><br><span class="line">                <span class="keyword">if</span>(! path.isEmpty())&#123;</span><br><span class="line">                    path.peek().left = node;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="comment">//结点深度与路径长度不等，结点为路径中某结点的右子结点</span></span><br><span class="line">                <span class="comment">//找到路径中的结点</span></span><br><span class="line">                <span class="keyword">while</span>(level != path.size())&#123;</span><br><span class="line">                    path.pop();</span><br><span class="line">                &#125;</span><br><span class="line">                path.peek().right = node;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将结点加入路径</span></span><br><span class="line">            path.push(node);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//取出栈底元素</span></span><br><span class="line">        <span class="keyword">while</span>(path.size() &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            path.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> path.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度和空间复杂度同上。</p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode Hard</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>从前序与中序遍历序列构造二叉树</title>
    <url>/2020/07/03/%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h4 id="105-从前序与中序遍历序列构造二叉树"><a href="#105-从前序与中序遍历序列构造二叉树" class="headerlink" title="105. 从前序与中序遍历序列构造二叉树"></a><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/" target="_blank" rel="noopener">105. 从前序与中序遍历序列构造二叉树</a></h4><p>根据一棵树的前序遍历与中序遍历构造二叉树。</p>
<p><strong>注意:</strong><br>你可以假设树中没有重复的元素。</p>
 <a id="more"></a>

<p>例如，给出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">前序遍历 preorder &#x3D; [3,9,20,15,7]</span><br><span class="line">中序遍历 inorder &#x3D; [9,3,15,20,7]</span><br></pre></td></tr></table></figure>

<p>返回如下的二叉树：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>

<p>在数据结构课程中我们学过通过前序遍历序列和中序遍历序列构造二叉树的方法：</p>
<ol>
<li>从先序遍历序列中拿出一个结点 x 。</li>
<li>建立根结点，在中序遍历序列中找出结点 x 的位置，确定以结点 x 为根结点的左右子树结点数。</li>
<li>重复步骤 1 和步骤 2 递归建立结点 x 的左右子树。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//使用一个 HashMap 存储中序遍历结点的下标，在寻找结点下标时只用常数时间。</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, Integer&gt; indexMap;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = preorder.length;</span><br><span class="line">        indexMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">		<span class="comment">//建立 HashMap</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i)&#123;</span><br><span class="line">            indexMap.put(inorder[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//递归建立二叉树</span></span><br><span class="line">        <span class="keyword">return</span> buildTree(preorder, inorder, <span class="number">0</span>, N - <span class="number">1</span>, <span class="number">0</span>, N - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder, <span class="keyword">int</span> preorder_left, <span class="keyword">int</span> preorder_right, <span class="keyword">int</span> inorder_left, <span class="keyword">int</span> inorder_right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(preorder_left &gt; preorder_right)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//确定二叉树根结点（先序遍历最左结点）</span></span><br><span class="line">        <span class="keyword">int</span> preorder_root = preorder_left;</span><br><span class="line">        <span class="comment">//找到根结点在中序遍历序列中的下标</span></span><br><span class="line">        <span class="keyword">int</span> inorder_root = indexMap.get(preorder[preorder_root]);</span><br><span class="line">		<span class="comment">//建立根结点</span></span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(preorder[preorder_root]);</span><br><span class="line">		<span class="comment">//确定根结点左子树结点的个数</span></span><br><span class="line">        <span class="keyword">int</span> leftSubTreeSize = inorder_root - inorder_left;</span><br><span class="line">		<span class="comment">//递归建立左子树</span></span><br><span class="line">        root.left = buildTree(preorder, inorder, preorder_left + <span class="number">1</span>, preorder_left + leftSubTreeSize, inorder_left, inorder_root - <span class="number">1</span>);</span><br><span class="line">		<span class="comment">//递归建立右子树</span></span><br><span class="line">        root.right = buildTree(preorder, inorder, preorder_left + leftSubTreeSize + <span class="number">1</span>, preorder_right, inorder_root + <span class="number">1</span>, inorder_right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度 O(n)，空间复杂度O(n)。</p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode Medium</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>使用最小花费爬楼梯</title>
    <url>/2020/07/01/%E4%BD%BF%E7%94%A8%E6%9C%80%E5%B0%8F%E8%8A%B1%E8%B4%B9%E7%88%AC%E6%A5%BC%E6%A2%AF/</url>
    <content><![CDATA[<h4 id="746-使用最小花费爬楼梯"><a href="#746-使用最小花费爬楼梯" class="headerlink" title="746. 使用最小花费爬楼梯"></a><a href="https://leetcode-cn.com/problems/min-cost-climbing-stairs/" target="_blank" rel="noopener">746. 使用最小花费爬楼梯</a></h4><p>数组的每个索引做为一个阶梯，第 <code>i</code>个阶梯对应着一个非负数的体力花费值 <code>cost[i]</code>(索引从0开始)。</p>
<p>每当你爬上一个阶梯你都要花费对应的体力花费值，然后你可以选择继续爬一个阶梯或者爬两个阶梯。</p>
<p>您需要找到达到楼层顶部的最低花费。在开始时，你可以选择从索引为 0 或 1 的元素作为初始阶梯。</p>
 <a id="more"></a>

<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: cost &#x3D; [10, 15, 20]</span><br><span class="line">输出: 15</span><br><span class="line">解释: 最低花费是从cost[1]开始，然后走两步即可到阶梯顶，一共花费15。</span><br></pre></td></tr></table></figure>

<p> <strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: cost &#x3D; [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]</span><br><span class="line">输出: 6</span><br><span class="line">解释: 最低花费方式是从cost[0]开始，逐个经过那些1，跳过cost[3]，一共花费6。</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong></p>
<ol>
<li><code>cost</code> 的长度将会在 <code>[2, 1000]</code>。</li>
<li>每一个 <code>cost[i]</code> 将会是一个Integer类型，范围为 <code>[0, 999]</code>。</li>
</ol>
<p>如果我们需要到达第 i 个台阶，我们有两种选择：</p>
<ol>
<li>从第 i-2 个台阶到达第 i 个台阶，花费为到达第 i-2 个台阶的最小花费 + cost[i]；</li>
<li>从第 i-1 个台阶到达第 i 个台阶，花费为到达第 i-2 个台阶的最小花费 + cost[i]；</li>
</ol>
<p>到达第 i 个台阶的最小代价为这两种花费的最小值。</p>
<p>即 <code>cost[i] = min( minPrice[i-1], minPrice[i-2] ) + cost[i]</code>。由于只要使用到前两个台阶的最小代价，所以只用维护两个变量。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minCostClimbingStairs</span><span class="params">(<span class="keyword">int</span>[] cost)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//pre 为前 1 个台阶的最小花费，pre2 为前 2 个台阶的最小花费。</span></span><br><span class="line">        <span class="keyword">int</span> pre = <span class="number">0</span>, pre2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; cost.length ;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> cur = cost[i] + Math.min(pre,pre2);</span><br><span class="line">            pre2 = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Math.min(pre,pre2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度O(n)，空间复杂度O(1)。</p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode Easy</tag>
        <tag>动态规划</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>克隆图</title>
    <url>/2020/08/12/%E5%85%8B%E9%9A%86%E5%9B%BE/</url>
    <content><![CDATA[<h4 id="133-克隆图"><a href="#133-克隆图" class="headerlink" title="133. 克隆图"></a><a href="https://leetcode-cn.com/problems/clone-graph/" target="_blank" rel="noopener">133. 克隆图</a></h4><p>给你无向 <strong><a href="https://baike.baidu.com/item/连通图/6460995?fr=aladdin" target="_blank" rel="noopener">连通</a></strong> 图中一个节点的引用，请你返回该图的 <a href="https://baike.baidu.com/item/深拷贝/22785317?fr=aladdin" target="_blank" rel="noopener"><strong>深拷贝</strong></a>（克隆）。</p>
<a id="more"></a>

<p>图中的每个节点都包含它的值 <code>val</code>（<code>int</code>） 和其邻居的列表（<code>list[Node]</code>）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Node &#123;</span><br><span class="line">    public int val;</span><br><span class="line">    public List&lt;Node&gt; neighbors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <strong>测试用例格式：</strong></p>
<p>简单起见，每个节点的值都和它的索引相同。例如，第一个节点值为 1（<code>val = 1</code>），第二个节点值为 2（<code>val = 2</code>），以此类推。该图在测试用例中使用邻接列表表示。</p>
<p><strong>邻接列表</strong> 是用于表示有限图的无序列表的集合。每个列表都描述了图中节点的邻居集。</p>
<p>给定节点将始终是图中的第一个节点（值为 1）。你必须将 <strong>给定节点的拷贝</strong> 作为对克隆图的引用返回。</p>
<p> <strong>示例 1：</strong></p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20200812092919759.png" alt="image-20200812092919759"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：adjList &#x3D; [[2,4],[1,3],[2,4],[1,3]]</span><br><span class="line">输出：[[2,4],[1,3],[2,4],[1,3]]</span><br><span class="line">解释：</span><br><span class="line">图中有 4 个节点。</span><br><span class="line">节点 1 的值是 1，它有两个邻居：节点 2 和 4 。</span><br><span class="line">节点 2 的值是 2，它有两个邻居：节点 1 和 3 。</span><br><span class="line">节点 3 的值是 3，它有两个邻居：节点 2 和 4 。</span><br><span class="line">节点 4 的值是 4，它有两个邻居：节点 1 和 3 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20200812092941156.png" alt="image-20200812092941156"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：adjList &#x3D; [[]]</span><br><span class="line">输出：[[]]</span><br><span class="line">解释：输入包含一个空列表。该图仅仅只有一个值为 1 的节点，它没有任何邻居。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：adjList &#x3D; []</span><br><span class="line">输出：[]</span><br><span class="line">解释：这个图是空的，它不含任何节点。</span><br></pre></td></tr></table></figure>

<p><strong>示例 4：</strong></p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20200812092954884.png" alt="image-20200812092954884"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：adjList &#x3D; [[2],[1]]</span><br><span class="line">输出：[[2],[1]]</span><br></pre></td></tr></table></figure>

<p> <strong>提示：</strong></p>
<ol>
<li>节点数不超过 100 。</li>
<li>每个节点值 <code>Node.val</code> 都是唯一的，<code>1 &lt;= Node.val &lt;= 100</code>。</li>
<li>无向图是一个<a href="https://baike.baidu.com/item/简单图/1680528?fr=aladdin" target="_blank" rel="noopener">简单图</a>，这意味着图中没有重复的边，也没有自环。</li>
<li>由于图是无向的，如果节点 <em>p</em> 是节点 <em>q</em> 的邻居，那么节点 <em>q</em> 也必须是节点 <em>p</em> 的邻居。</li>
<li>图是连通图，你可以从给定节点访问到所有节点。</li>
</ol>
<p><strong>方法一：DFS</strong></p>
<p>算法：</p>
<ol>
<li><p>使用一个哈希表存储所有已被访问和克隆得结点。哈希表中的 key 是原始图中的结点，value 是克隆图中对应结点。</p>
</li>
<li><p>从给定结点开始遍历图。如果某个结点已经被访问过，则返回其克隆图中的对应结点。</p>
<p>给定无向边 A - B，如果不对访问过的结点做标记，那么会陷入死循环中。</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20200812093915504.png" alt="image-20200812093915504"></p>
</li>
<li><p>如果当前访问结点不在哈希表中，则创建它的克隆结点存储在哈希表中。在进入递归之前，必须先将克隆结点保存在哈希表中。如果不保证这种顺序，可能会导致死循环。</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20200812094048633.png" alt="image-20200812094048633"></p>
</li>
<li><p>递归调用每个结点的邻接点。每一次调用返回其对应邻接点的克隆结点，最终返回这些克隆邻接点的列表，将其放入对应克隆结点的邻接表中。这样就可以克隆给定的结点和其邻接点。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Node, Node&gt; visited = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">cloneGraph</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//如果该结点已经访问过，直接从哈希表中取出对应的克隆结点返回</span></span><br><span class="line">        <span class="keyword">if</span>(visited.containsKey(node))&#123;</span><br><span class="line">            <span class="keyword">return</span> visited.get(node);</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//克隆结点，注意到为了深拷贝，我们不会克隆它的邻接列表</span></span><br><span class="line">        Node cloneNode = <span class="keyword">new</span> Node(node.val, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        <span class="comment">//存储克隆结点</span></span><br><span class="line">        visited.put(node, cloneNode);</span><br><span class="line">		<span class="comment">//遍历该结点的邻居，并更新克隆结点的邻居列表</span></span><br><span class="line">        <span class="keyword">for</span>(Node n : node.neighbors)&#123;</span><br><span class="line">            cloneNode.neighbors.add(cloneGraph(n));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cloneNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度O(n)，空间复杂度O(n)，其中 n 表示结点数量。</p>
<p><strong>方法二：BFS</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">cloneGraph</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Map&lt;Node, Node&gt; visited = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        LinkedList&lt;Node&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="comment">//将给定的结点加入列表</span></span><br><span class="line">        queue.add(node);</span><br><span class="line">        <span class="comment">//克隆第一个结点并存储到哈希表</span></span><br><span class="line">        visited.put(node, <span class="keyword">new</span> Node(node.val, <span class="keyword">new</span> ArrayList&lt;&gt;()));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="comment">//取出队列的头结点</span></span><br><span class="line">            Node n = queue.remove();</span><br><span class="line">            <span class="comment">//遍历该结点的邻居</span></span><br><span class="line">            <span class="keyword">for</span>(Node t : n.neighbors)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!visited.containsKey(t))&#123;</span><br><span class="line">                    <span class="comment">//如果没有访问过，就克隆并存储在哈希表中</span></span><br><span class="line">                    visited.put(t, <span class="keyword">new</span> Node(t.val, <span class="keyword">new</span> ArrayList&lt;&gt;()));</span><br><span class="line">                    <span class="comment">//将邻居结点加入队列中</span></span><br><span class="line">                    queue.add(t);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//更新当前结点的邻居列表</span></span><br><span class="line">                visited.get(n).neighbors.add(visited.get(t));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> visited.get(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度O(n)，空间复杂度O(n)，其中 n 表示结点数量。</p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode Medium</tag>
        <tag>DFS</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title>全排列II</title>
    <url>/2020/09/18/%E5%85%A8%E6%8E%92%E5%88%97II/</url>
    <content><![CDATA[<h4 id="47-全排列-II"><a href="#47-全排列-II" class="headerlink" title="47. 全排列 II"></a><a href="https://leetcode-cn.com/problems/permutations-ii/" target="_blank" rel="noopener">47. 全排列 II</a></h4><p>给定一个可包含重复数字的序列，返回所有不重复的全排列。</p>
<a id="more"></a>

<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,1,2]</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [1,1,2],</span><br><span class="line">  [1,2,1],</span><br><span class="line">  [2,1,1]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p><strong>在搜索前对候选数组排序</strong>，一旦发现某个分支搜索下去可能搜索到重复的元素就停止搜索。</p>
<p>我们可以画出下面的递归图（来自<a href="https://leetcode-cn.com/problems/permutations-ii/solution/hui-su-suan-fa-python-dai-ma-java-dai-ma-by-liwe-2/" target="_blank" rel="noopener">liweiwei</a>）：</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20200918095243920.png" alt="image-20200918095243920"></p>
<p>以[1, 1, 2] 为例，我们需要保证只出现一次 [1, 1, 2]，在上图中有两种情况，搜索的是同一个数字</p>
<ul>
<li>在图中②处，搜索的数和上一次一样，但上一次的<code>1</code>还在使用中。</li>
<li><strong>在图中①处，搜索的数和上一次一样，但上一次的<code>1</code>刚刚被撤销，由于它已经被撤销，有可能后面的搜索还会使用到它，因此会产生重复，需要剪掉它。</strong></li>
</ul>
<p>在<a href="https://leetcode-cn.com/problems/permutations/" target="_blank" rel="noopener">全排列</a>的 DFS 代码中需要添加如下代码来进行剪枝</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] &amp;&amp; !visited[i - <span class="number">1</span>])&#123;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans;</span><br><span class="line">    <span class="keyword">boolean</span>[] visited;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permuteUnique(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        ans = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[len];</span><br><span class="line">		</span><br><span class="line">        <span class="comment">//排序是剪枝的基础</span></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        dfs(nums, <span class="number">0</span>, <span class="keyword">new</span> ArrayDeque&lt;Integer&gt;(len));</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> index, Deque&lt;Integer&gt; path)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">if</span>(index == len)&#123;</span><br><span class="line">            ans.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(visited[i])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">			<span class="comment">// 剪枝条件：i &gt; 0 是为了保证 nums[i - 1] 有意义</span></span><br><span class="line">            <span class="comment">// 写 !used[i - 1] 是因为 nums[i - 1] 在深度优先遍历的过程中刚刚被撤销选择</span></span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] &amp;&amp; !visited[i - <span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            visited[i] = <span class="keyword">true</span>;</span><br><span class="line">            path.addLast(nums[i]);</span><br><span class="line"></span><br><span class="line">            dfs(nums, index + <span class="number">1</span>, path);</span><br><span class="line"></span><br><span class="line">            path.removeLast();</span><br><span class="line">            visited[i] = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode Medium</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>分割数组的最大值</title>
    <url>/2020/07/25/%E5%88%86%E5%89%B2%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/</url>
    <content><![CDATA[<h4 id="410-分割数组的最大值"><a href="#410-分割数组的最大值" class="headerlink" title="410. 分割数组的最大值"></a><a href="https://leetcode-cn.com/problems/split-array-largest-sum/" target="_blank" rel="noopener">410. 分割数组的最大值</a></h4><p>给定一个非负整数数组和一个整数 <em>m</em>，你需要将这个数组分成 <em>m</em> 个非空的连续子数组。设计一个算法使得这 <em>m</em> 个子数组各自和的最大值最小。</p>
<a id="more"></a>

<p><strong>注意:</strong><br>数组长度 <em>n</em> 满足以下条件:</p>
<ul>
<li>1 ≤ <em>n</em> ≤ 1000</li>
<li>1 ≤ <em>m</em> ≤ min(50, <em>n</em>)</li>
</ul>
<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">nums &#x3D; [7,2,5,10,8]</span><br><span class="line">m &#x3D; 2</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line">18</span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line">一共有四种方法将nums分割为2个子数组。</span><br><span class="line">其中最好的方式是将其分为[7,2,5] 和 [10,8]，</span><br><span class="line">因为此时这两个子数组各自的和的最大值为18，在所有情况中最小。</span><br></pre></td></tr></table></figure>

<p><strong>方法一：暴力（超时）</strong></p>
<p>我们要将 nums[0 … n - 1] 分为 m 个非空的子数组，我们可以先将 nums 数组分为 [0 … i)，[i … n  -1]两个数组(1 &lt; i &lt;= n - 1)，再计算 nums[i … n - 1] 分成 m - 1个子数组各自和的最大值最小，可以看出这是一个递归操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">splitArray</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">		<span class="comment">//利用前缀和数组进行优化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            count[i] = count[i - <span class="number">1</span>] + nums[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">// num 数组最多分成 n 个子数组</span></span><br><span class="line">        <span class="keyword">return</span> split(count, m &gt; n ? n : m - <span class="number">1</span>, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">split</span><span class="params">(<span class="keyword">int</span>[] count, <span class="keyword">int</span> m, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="comment">//判断是否还需要切分，否则返回[start, end]范围内的元素之和</span></span><br><span class="line">        <span class="keyword">if</span>(m == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> count[end + <span class="number">1</span>] - count[start];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">        <span class="comment">//枚举每一个切分位置</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start + <span class="number">1</span>; i &lt;= end &amp;&amp; m &gt; <span class="number">0</span>; i++)&#123;</span><br><span class="line">            <span class="comment">//递归地计算[i, end]分割为 m - 1个子数组的最大值的最小值</span></span><br><span class="line">            <span class="keyword">int</span> right = split(count, m - <span class="number">1</span>, i, end);</span><br><span class="line">            <span class="comment">//维护最小值</span></span><br><span class="line">            min = Math.min(min, Math.max(count[i] - count[start], right));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度O(n^m)，空间复杂度O(n)。爆炸！！！</p>
<p><strong>方法二：动态规划</strong></p>
<p>令<code>f[i][j]</code>表示将数组的前 i 个数分割为 j 段所能得到的最大连续子数组和的最小值。我们枚举第 j 段的具体范围，我们可以枚举 k，其中前 k 个数被分割为 j - 1 段，而第 k + 1到第 i 个数为第 j 段。此时，这 j 段子数组中和的最大值就等于 <code>f[k][j - 1]</code>和<code>sub(k + 1, i)</code>中的较大值，其中<code>sub(i, j)</code>表示数组 nums 中下标落在区间[i, j]内的数的和。得到状态转移方程：<br>$$<br>f[i, j] = \min^{i-1}_{k=0}{max(f[k][j - 1],sub(k + 1, i))}<br>$$<br>i 个数最多只能分成 i 段，因此 i &gt;= j 是合法状态，对于不合法的状态(j &gt; i)，由于我们求的是最小值，我们将其初始化为一个很大的值，当我们尝试从不合法的状态转移，得到的结果将是一个很大的数。</p>
<p>我们还需要初始化<code>f[0][0] = 0</code>，最后的结果为 <code>f[n][m]</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">splitArray</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>][m + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">//将 dp 数组全部设为最大值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            Arrays.fill(dp[i], Integer.MAX_VALUE);</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//生成前缀和数组</span></span><br><span class="line">        <span class="keyword">int</span>[] sub = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            sub[i + <span class="number">1</span>] = sub[i] + nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//初始状态</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//从前往后依次计算 dp 数组的值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="comment">//j &lt;= i</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= Math.min(i, m); j++)&#123;</span><br><span class="line">                <span class="comment">//枚举最后一个子数组的切割点</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; i; k++)&#123;</span><br><span class="line">                    dp[i][j] = Math.min(dp[i][j], Math.max(dp[k][j - <span class="number">1</span>], sub[i] - sub[k]));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n][m];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度O(m*n^2)，n 为数组的长度，m 为非空连续子数组的个数。</p>
<p>空间复杂度O(n * m)。</p>
<p><strong>方法三：二分查找</strong></p>
<p>本题中，我们注意到：当我们选定一个值 x，我们可以线性地验证是否存在一种分割方案，满足其最大分割子数组和不超过 x。策略如下：</p>
<blockquote>
<p>贪心地模拟分割的过程，从前到后遍历数组，用 sum 表示当前分割子数组的和，cnt 表示已经分割出的子数组的数量(包括当前子数组)，那么每当 sum 加上当前值超过了 x，我们就把当前取的值作为<strong>新的一段</strong>分割子数组的开头，并将分割出的子数组的数量 cnt 加一。遍历结束后验证是否 cnt 不超过 m。</p>
</blockquote>
<p>我们可以使用二分查找来解决。二分的上界为数组 nums 中所有元素的和，下界为 nums 中所有元素的最大值。通过二分查找，我们可以得到最小的最大分割子数组和。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">splitArray</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">		<span class="comment">// 初始化二分查找上下界</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            right += nums[i];</span><br><span class="line">            <span class="keyword">if</span>(left &lt; nums[i])&#123;</span><br><span class="line">                left = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(check(nums, mid, m))&#123;</span><br><span class="line">                right = mid; <span class="comment">//存在最大分割子数组的和小于 x，将 x 缩小</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;<span class="comment">//不存在最大分割子数组的和小于 x，将 x 增大</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//检查是否存在最大分割子数组的和 小于 x</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> x, <span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="comment">// sum 值大于 x，将当前值作为新的分割子数组的开头</span></span><br><span class="line">            <span class="keyword">if</span>(sum + nums[i] &gt; x)&#123;</span><br><span class="line">                cnt++;</span><br><span class="line">                sum = nums[i];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                sum += nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt &lt;= m;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度O(n * log(sum - maxn))，sum 表示数组 nums 中所有元素的和，maxn表示数组所有元素的最大值，每次二分查找时，需要对数组进行一次遍历。</p>
<p>空间复杂度O(1)。妙啊！！！</p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode Hard</tag>
        <tag>动态规划</tag>
        <tag>贪心</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>全排列</title>
    <url>/2020/09/18/%E5%85%A8%E6%8E%92%E5%88%97/</url>
    <content><![CDATA[<h4 id="46-全排列"><a href="#46-全排列" class="headerlink" title="46. 全排列"></a><a href="https://leetcode-cn.com/problems/permutations/" target="_blank" rel="noopener">46. 全排列</a></h4><p>给定一个 <strong>没有重复</strong> 数字的序列，返回其所有可能的全排列。</p>
<a id="more"></a>

<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,2,3]</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [1,2,3],</span><br><span class="line">  [1,3,2],</span><br><span class="line">  [2,1,3],</span><br><span class="line">  [2,3,1],</span><br><span class="line">  [3,1,2],</span><br><span class="line">  [3,2,1]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>解释图例来自<a href="https://leetcode-cn.com/problems/permutations/solution/hui-su-suan-fa-python-dai-ma-java-dai-ma-by-liweiw/" target="_blank" rel="noopener">liweiwei</a>。</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20200918094821040.png" alt="image-20200918094821040"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans;</span><br><span class="line">    <span class="keyword">boolean</span>[] visited;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        ans = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[len];</span><br><span class="line"></span><br><span class="line">        dfs(nums, <span class="number">0</span>, <span class="keyword">new</span> ArrayDeque&lt;Integer&gt;(len));</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> index, Deque&lt;Integer&gt; path)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">if</span>(index == len)&#123;</span><br><span class="line">            ans.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//没有使用的数字都可以使用</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!visited[i])&#123;</span><br><span class="line">                visited[i] = <span class="keyword">true</span>;</span><br><span class="line">                path.addLast(nums[i]);</span><br><span class="line"></span><br><span class="line">                dfs(nums, index + <span class="number">1</span>, path);</span><br><span class="line"></span><br><span class="line">                path.removeLast();</span><br><span class="line">                visited[i] = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode Medium</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>元素和为目标值的子矩阵数量</title>
    <url>/2021/05/29/%E5%85%83%E7%B4%A0%E5%92%8C%E4%B8%BA%E7%9B%AE%E6%A0%87%E5%80%BC%E7%9A%84%E5%AD%90%E7%9F%A9%E9%98%B5%E6%95%B0%E9%87%8F/</url>
    <content><![CDATA[<h4 id="1074-元素和为目标值的子矩阵数量"><a href="#1074-元素和为目标值的子矩阵数量" class="headerlink" title="1074. 元素和为目标值的子矩阵数量"></a><a href="https://leetcode-cn.com/problems/number-of-submatrices-that-sum-to-target/" target="_blank" rel="noopener">1074. 元素和为目标值的子矩阵数量</a></h4><p>给出矩阵 <code>matrix</code> 和目标值 <code>target</code>，返回元素总和等于目标值的非空子矩阵的数量。</p>
<p>子矩阵 <code>x1, y1, x2, y2</code> 是满足 <code>x1 &lt;= x &lt;= x2</code> 且 <code>y1 &lt;= y &lt;= y2</code> 的所有单元 <code>matrix[x][y]</code> 的集合。</p>
<p>如果 <code>(x1, y1, x2, y2)</code> 和 <code>(x1&#39;, y1&#39;, x2&#39;, y2&#39;)</code> 两个子矩阵中部分坐标不同（如：<code>x1 != x1&#39;</code>），那么这两个子矩阵也不同。</p>
<a id="more"></a>

<p><strong>示例 1：</strong></p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20210529103118283.png" alt="image-20210529103118283"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：matrix &#x3D; [[0,1,0],[1,1,1],[0,1,0]], target &#x3D; 0</span><br><span class="line">输出：4</span><br><span class="line">解释：四个只含 0 的 1x1 子矩阵。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：matrix &#x3D; [[1,-1],[-1,1]], target &#x3D; 0</span><br><span class="line">输出：5</span><br><span class="line">解释：两个 1x2 子矩阵，加上两个 2x1 子矩阵，再加上一个 2x2 子矩阵。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：matrix &#x3D; [[904]], target &#x3D; 0</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure>

<p> <strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= matrix.length &lt;= 100</code></li>
<li><code>1 &lt;= matrix[0].length &lt;= 100</code></li>
<li><code>-1000 &lt;= matrix[i] &lt;= 1000</code></li>
<li><code>-10^8 &lt;= target &lt;= 10^8</code></li>
</ul>
<p><strong>方法一：前缀和</strong></p>
<p>我们枚举 子矩阵的上下边界，并计算该边界内每列元素的和，则原问题转换为：</p>
<blockquote>
<p>给定一个整数数组和一个整数 target，计算该数组中子数组和等于 target 的子数组个数。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numSubmatrixSumTarget</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = matrix.length, n = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123; <span class="comment">// 枚举上边界</span></span><br><span class="line">            <span class="keyword">int</span>[] nums = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; m; j++)&#123; <span class="comment">//枚举下边界</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; n; c++)&#123;</span><br><span class="line">                    nums[c] += matrix[j][c]; <span class="comment">//逐行增加 nums 数组，避免重复计算</span></span><br><span class="line">                &#125;</span><br><span class="line">                ret += subArraySum(nums, target);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//计算子数组和等于 target 的子数组个数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">subArraySum</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="comment">//key 为子数组和，value 为子数组个数</span></span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">//初始化一个子数组和为 0 ，个数为 1</span></span><br><span class="line">        map.put(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// ret 为返回结果，cur 为前缀和变量</span></span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>, cur = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">            cur += num;</span><br><span class="line">            <span class="comment">//判断是否存在一个子数组加上 target 等于当前前缀和 cur，子数组的个数就是 子数组和为target的子数组个数</span></span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(cur - target))&#123;</span><br><span class="line">                ret += map.get(cur - target);</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(cur, map.getOrDefault(cur, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>时间复杂度：O(M^2*n)，其中 m 和 n 分别是矩阵 matrix 的行数和列数。</p>
</li>
<li><p>空间复杂度：O(n)。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode Hard</tag>
        <tag>哈希表</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>划分字母区间</title>
    <url>/2020/10/22/%E5%88%92%E5%88%86%E5%AD%97%E6%AF%8D%E5%8C%BA%E9%97%B4/</url>
    <content><![CDATA[<h4 id="763-划分字母区间"><a href="#763-划分字母区间" class="headerlink" title="763. 划分字母区间"></a><a href="https://leetcode-cn.com/problems/partition-labels/" target="_blank" rel="noopener">763. 划分字母区间</a></h4><p>字符串 <code>S</code> 由小写字母组成。我们要把这个字符串划分为尽可能多的片段，同一个字母只会出现在其中的一个片段。返回一个表示每个字符串片段的长度的列表。</p>
 <a id="more"></a>

<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：S &#x3D; &quot;ababcbacadefegdehijhklij&quot;</span><br><span class="line">输出：[9,7,8]</span><br><span class="line">解释：</span><br><span class="line">划分结果为 &quot;ababcbaca&quot;, &quot;defegde&quot;, &quot;hijhklij&quot;。</span><br><span class="line">每个字母最多出现在一个片段中。</span><br><span class="line">像 &quot;ababcbacadefegde&quot;, &quot;hijhklij&quot; 的划分是错误的，因为划分的片段数较少。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>S</code>的长度在<code>[1, 500]</code>之间。</li>
<li><code>S</code>只包含小写字母 <code>&#39;a&#39;</code> 到 <code>&#39;z&#39;</code> 。</li>
</ul>
<p>同一个字母只能出现在同一片段，同一个字母第一次出现的下标位置和最后一次出现的下标位置必须出现在同一片段。因此，需要遍历字符串，得到每个字母最后一次出现的下标位置。</p>
<p>接下来使用贪心算法和双指针的方法将字符串划分为尽可能多的片段：</p>
<ul>
<li>从左到右遍历字符串，遍历的同时维护当前片段的开始下标 start 和结束下标 end。</li>
<li>对于每个访问到的字母 c，得到当前字母最后一次出现的下标位置 endc，则当前片段的结束下标一定不会小于 endc，end = max(end, endc)。</li>
<li>当访问到下标 end 时，当前片段访问结束，当前判断的长度为 end - start  + 1，将当前片段的长度添加到返回值，然后令 start =  end + 1，继续寻找下一个片段。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">partitionLabels</span><span class="params">(String S)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] last = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; S.length(); i++)&#123;</span><br><span class="line">            last[S.charAt(i) - <span class="string">'a'</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; partition = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>, end = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; S.length(); i++)&#123;</span><br><span class="line">            end = Math.max(end, last[S.charAt(i) - <span class="string">'a'</span>]);</span><br><span class="line">            <span class="keyword">if</span>(i == end)&#123;</span><br><span class="line">                partition.add(end - start + <span class="number">1</span>);</span><br><span class="line">                start = end + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> partition;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度O(n)</li>
<li>空间复杂度O(1)</li>
</ul>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode Medium</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>初探nginx</title>
    <url>/2020/08/26/%E5%88%9D%E6%8E%A2nginx/</url>
    <content><![CDATA[<h3 id="nginx-简介"><a href="#nginx-简介" class="headerlink" title="nginx 简介"></a>nginx 简介</h3><h4 id="nginx概述"><a href="#nginx概述" class="headerlink" title="nginx概述"></a>nginx概述</h4><p>nginx是一款轻量级的Web服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器，在BSD-like 协议下发行。其特点是占有内存少，并发能力强，事实上nginx的并发能力在同类型的网页服务器中表现较好。</p>
<a id="more"></a>

<h4 id="nginx-作为服务器"><a href="#nginx-作为服务器" class="headerlink" title="nginx 作为服务器"></a>nginx 作为服务器</h4><p>nginx作为负载均衡服务：nginx 既可以在内部直接支持 Rails 和 PHP 程序对外进行服务，也可以支持作为 HTTP<a href="https://baike.baidu.com/item/代理服务" target="_blank" rel="noopener">代理服务</a>对外进行服务。nginx采用C进行编写，不论是系统资源开销还是CPU使用效率都比 Perlbal 要好很多。</p>
<p>处理静态文件，索引文件以及自动索引;打开文件描述符缓冲。</p>
<p>无缓存的反向代理加速，简单的负载均衡和容错。</p>
<h4 id="正向代理"><a href="#正向代理" class="headerlink" title="正向代理"></a>正向代理</h4><p>nginx 不仅可以做反向代理，实现负载均衡。还能用作正向代理来进行上网等功能。</p>
<p>客户端  –&gt;  代理服务器 –&gt; Internet</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20200826093023122.png" alt="image-20200826093023122"></p>
<h4 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h4><p>反向代理，其实客户端对代理是无感知的，因为客户端不需要任何配置就可以访问，我们只<br>需要将请求发送到反向代理服务器，由反向代理服务器去选择目标服务器获取数据后，在返<br>回给客户端，此时反向代理服务器和目标服务器对外就是一个服务器，暴露的是代理服务器<br>地址，隐藏了真实服务器 IP 地址。</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20200826093104775.png" alt="image-20200826093104775"></p>
<h4 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h4><p>并发请求过大时，单个服务器不足以支撑，我们增加服务器的数量，然后将请求分发到各个服务器上，将原先请求集中到单个服务器上的情况改为将请求分发到多个服务器上，将负载分发到不同的服务器，也就是我们所说的负载均衡。</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20200826093307366.png" alt="image-20200826093307366"></p>
<h4 id="动静分离"><a href="#动静分离" class="headerlink" title="动静分离"></a>动静分离</h4><p>为了加快网站的解析速度，可以把动态页面和静态页面由不同的服务器来解析，加快解析速<br>度。降低原来单个服务器的压力。</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20200826093345623.png" alt="image-20200826093345623"></p>
<h3 id="CentOS-下安装-nginx"><a href="#CentOS-下安装-nginx" class="headerlink" title="CentOS 下安装 nginx"></a>CentOS 下安装 nginx</h3><h4 id="安装nginx所需依赖"><a href="#安装nginx所需依赖" class="headerlink" title="安装nginx所需依赖"></a>安装nginx所需依赖</h4><p>首先检查是否已经安装依赖，能显示出版本号则可跳过该步骤。</p>
<blockquote>
<p>rpm -qa | grep pcre</p>
<p>rpm -qa | grep zlib</p>
<p>rpm -qa | grep gcc</p>
<p>rpm -qa | grep zlib</p>
</blockquote>
<h5 id="安装-pcre"><a href="#安装-pcre" class="headerlink" title="安装 pcre"></a>安装 pcre</h5><p>下载压缩包</p>
<blockquote>
<p>wget <a href="http://downloads.sourceforge.net/project/pcre/pcre/8.37/pcre-8.37.tar.gz" target="_blank" rel="noopener">http://downloads.sourceforge.net/project/pcre/pcre/8.37/pcre-8.37.tar.gz</a></p>
</blockquote>
<p>找到压缩包所在位置，解压</p>
<blockquote>
<p>tar -xvf pcre-8.37.tar.gz</p>
</blockquote>
<p>进入目录 pcre-8.37，配置并安装</p>
<blockquote>
<p>./configure</p>
<p>make &amp;&amp; make install</p>
</blockquote>
<h5 id="安装-openssl-、zlib-等依赖"><a href="#安装-openssl-、zlib-等依赖" class="headerlink" title="安装 openssl 、zlib 等依赖"></a>安装 openssl 、zlib 等依赖</h5><blockquote>
<p>yum -y install make zlib zlib-devel gcc-c++ libtool openssl openssl-devel</p>
</blockquote>
<h5 id="安装-nginx"><a href="#安装-nginx" class="headerlink" title="安装 nginx"></a>安装 nginx</h5><p>进入<a href="http://nginx.org/en/download.html" target="_blank" rel="noopener">官网</a>，选择 nginx-1.18.0，下载。找到压缩包位置，解压。</p>
<blockquote>
<p>tar -xvf nginx-1.18.0.tar.gz</p>
</blockquote>
<p>进入 nginx-1.18.0 目录</p>
<blockquote>
<p>cd nginx-1.18.0</p>
</blockquote>
<p>配置并安装</p>
<blockquote>
<p>./configure</p>
<p>make &amp;&amp; make install</p>
</blockquote>
<h5 id="防火墙配置（也可以直接关闭防火墙，不推荐这么做）"><a href="#防火墙配置（也可以直接关闭防火墙，不推荐这么做）" class="headerlink" title="防火墙配置（也可以直接关闭防火墙，不推荐这么做）"></a>防火墙配置（也可以直接关闭防火墙，不推荐这么做）</h5><p>查看开放的端口</p>
<blockquote>
<p>firewall-cmd –list-all</p>
</blockquote>
<p>设置开放的端口(开放80端口)</p>
<blockquote>
<p>firewall-cmd –add-service=http –permanent<br>sudo firewall-cmd –add-port=80/tcp –permanent</p>
</blockquote>
<p>重启防火墙</p>
<blockquote>
<p>firewall-cmd –reload</p>
</blockquote>
<h3 id="nginx-常用命令及配置文件说明"><a href="#nginx-常用命令及配置文件说明" class="headerlink" title="nginx 常用命令及配置文件说明"></a>nginx 常用命令及配置文件说明</h3><h4 id="nginx-常用命令"><a href="#nginx-常用命令" class="headerlink" title="nginx 常用命令"></a>nginx 常用命令</h4><p>首先进入sbin目录：</p>
<blockquote>
<p>cd /usr/local/nginx/sbin</p>
</blockquote>
<p>启动</p>
<blockquote>
<p>./nginx</p>
</blockquote>
<p>关闭</p>
<blockquote>
<p>./nginx -s stop</p>
</blockquote>
<p>重新加载</p>
<blockquote>
<p>./nginx -s reload</p>
</blockquote>
<h4 id="nginx-conf-配置文件"><a href="#nginx-conf-配置文件" class="headerlink" title="nginx.conf 配置文件"></a>nginx.conf 配置文件</h4><p>配置文件在 /usr/local/nginx/conf 目录下。</p>
<p>文件中许多都是注释掉的部分，将其精简得到如下内容。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">worker_processes  1;</span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    include       mime.types;</span><br><span class="line">    default_type  application&#x2F;octet-stream;</span><br><span class="line"></span><br><span class="line">    sendfile        on;</span><br><span class="line"></span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        server_name  localhost;</span><br><span class="line"></span><br><span class="line">        location &#x2F; &#123;</span><br><span class="line">            root   html;</span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        error_page   500 502 503 504  &#x2F;50x.html;</span><br><span class="line">        location &#x3D; &#x2F;50x.html &#123;</span><br><span class="line">            root   html;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="nginx-conf-文件三部分"><a href="#nginx-conf-文件三部分" class="headerlink" title="nginx.conf 文件三部分"></a>nginx.conf 文件三部分</h5><h6 id="全局块"><a href="#全局块" class="headerlink" title="全局块"></a>全局块</h6><p>从配置文件开始到 events 块之间的内容，主要会设置一些影响 nginx 服务器整体运行的配置指令，主要包括配<br>置运行 Nginx 服务器的用户（组）、允许生成的 worker process 数，进程 PID 存放路径、日志存放路径和类型以<br>及配置文件的引入等。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">worker_processes  1;</span><br></pre></td></tr></table></figure>

<p>这是 Nginx 服务器并发处理服务的关键配置，worker_processes 值越大，可以支持的并发处理量也越多，但是会受到硬件、软件等设备的制约。</p>
<h6 id="events-块"><a href="#events-块" class="headerlink" title="events 块"></a>events 块</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">events &#123;</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>events 块涉及的指令主要影响 nginx 服务器与用户的网络连接，常用的设置包括是否开启对多 work process<br>下的网络连接进行序列化，是否允许同时接收多个网络连接，选取哪种事件驱动模型来处理连接请求，每个 word<br>process 可以同时支持的最大连接数等。<br>上述例子就表示每个 work process 支持的最大连接数为 1024。这部分的配置对 Nginx 的性能影响较大，在实际中应该灵活配置。</p>
<h6 id="http块"><a href="#http块" class="headerlink" title="http块"></a>http块</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    include       mime.types;</span><br><span class="line">    default_type  application&#x2F;octet-stream;</span><br><span class="line"></span><br><span class="line">    sendfile        on;</span><br><span class="line"></span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        server_name  localhost;</span><br><span class="line"></span><br><span class="line">        location &#x2F; &#123;</span><br><span class="line">            root   html;</span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        error_page   500 502 503 504  &#x2F;50x.html;</span><br><span class="line">        location &#x3D; &#x2F;50x.html &#123;</span><br><span class="line">            root   html;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这算是 Nginx 服务器配置中最频繁的部分，代理、缓存和日志定义等绝大多数功能和第三方模块的配置都在这里。<br>需要注意的是：http 块也可以包括 http 全局块、server 块。</p>
<ol>
<li><p>http 全局块</p>
<p>http 全局块配置的指令包括文件引入、MIME-TYPE 定义、日志自定义、连接超时时间、单链接请求数上限等。</p>
</li>
<li><p>server 块</p>
<p>这块和虚拟主机有密切关系，虚拟主机从用户角度看，和一台独立的硬件主机是完全一样的，该技术的产生是为了节省互联网服务器硬件成本。<br>每个 http 块可以包括多个 server 块，而每个 server 块就相当于一个虚拟主机。而每个 server 块也分为全局 server 块，以及可以同时包含多个 locaton 块。</p>
<ul>
<li><p>全局 server 块</p>
<p>最常见的配置是本虚拟机主机的监听配置和本虚拟主机的名称或 IP 配置。</p>
</li>
<li><p>location 块</p>
<p>一个 server 块可以配置多个 location 块。<br>这块的主要作用是基于 Nginx 服务器接收到的请求字符串（例如 server_name/uri-string），对虚拟主机名称<br>（也可以是 IP 别名）之外的字符串（例如 前面的 /uri-string）进行匹配，对特定的请求进行处理。地址定向、数据缓<br>存和应答控制等功能，还有许多第三方模块的配置也在这里进行。</p>
</li>
</ul>
</li>
</ol>
<h3 id="反向代理实例1"><a href="#反向代理实例1" class="headerlink" title="反向代理实例1"></a>反向代理实例1</h3><p>实现效果：使用 nginx 反向代理，访问 <a href="http://www.123.com" target="_blank" rel="noopener">www.123.com</a> 直接跳转到 tomcat主页面。</p>
<p>首先在服务器安装 tomcat进入<a href="https://tomcat.apache.org/download-70.cgi" target="_blank" rel="noopener">官网</a>下载linux版本。</p>
<p>解压</p>
<blockquote>
<p>tar -xvf apache-tomcat-7.0.70.tar.gz</p>
</blockquote>
<p>启动 tomcat</p>
<blockquote>
<p>cd apache-tomcat-7.0.70/bin</p>
<p>./startup.sh</p>
</blockquote>
<p>没有错误的话，在服务器访问 localhost:8080 可以看到 tomcat 主界面。</p>
<p>同时我们需要开启服务器的 8080 端口，便于客户机访问。</p>
<blockquote>
<p>firewall-cmd –add-port=8080/tcp –permanent<br>firewall-cmd –reload</p>
</blockquote>
<p>在windows 浏览器中输入192.168.1.200:8080（192.168.1.200为服务器 IP）也可以访问到 tomcat 主界面。</p>
<p>在 windows hosts 文件中添加域名映射：</p>
<blockquote>
<p>192.168.1.200   <a href="http://www.123.com" target="_blank" rel="noopener">www.123.com</a></p>
</blockquote>
<p>访问 <a href="http://www.123.com:8080也可以访问到">www.123.com:8080也可以访问到</a> tomcat 主界面。</p>
<p>修改 nginx 配置文件实现反向代理</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20200826105658235.png" alt="image-20200826105658235"></p>
<p>启动 nginx 服务器，访问 <a href="http://www.123.com" target="_blank" rel="noopener">www.123.com</a> 即可看到 tomcat 主界面。</p>
<h3 id="反向代理实例2"><a href="#反向代理实例2" class="headerlink" title="反向代理实例2"></a>反向代理实例2</h3><p>实现效果：使用 nginx 实现反向代理，根据访问路径的不同跳转到不同端口的服务中。</p>
<p>nginx 监听端口为 9001，</p>
<p>访问 192.168.1.200:9001/edu/    跳转到 localhost:8080</p>
<p>访问 192.168.1.200:9001/vod/    跳转到 localhost:8081</p>
<p>我们需要两台 tomcat，直接解压 tomcat 压缩包到两个文件夹。8080 端口的 tomcat 不需要配置，8081 端口的 tomcat 需要更改端口：</p>
<p>进入 tomcat 解压文件夹，进入 conf 文件夹，找到 server.xml</p>
<p>更改如下端口号：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;Server port&#x3D;&quot;8015&quot; shutdown&#x3D;&quot;SHUTDOWN&quot;&gt;  &#x2F;&#x2F; 将默认 8005 改为 8015</span><br><span class="line">&lt;Connector port&#x3D;&quot;8081&quot; protocol&#x3D;&quot;HTTP&#x2F;1.1&quot; &#x2F;&#x2F; 将默认 8080 改为 8081</span><br><span class="line">&lt;Connector port&#x3D;&quot;8019&quot; protocol&#x3D;&quot;AJP&#x2F;1.3&quot; redirectPort&#x3D;&quot;8443&quot; &#x2F;&gt; &#x2F;&#x2F;将默认 8009 改为 8019</span><br></pre></td></tr></table></figure>



<p>进入bin目录，启动两台tomcat</p>
<blockquote>
<p>./startup.sh</p>
</blockquote>
<p>可在虚拟机中访问 localhost:8080 和 localhost:8081 看到 tomcat 主页面。开放防火墙 8080 和 8081 端口后，可在 windows 中访问 192.168.1.200:8080 和 192.168.1.200:8081 都能看到 tomcat 主页面。</p>
<p>接下来我们将两个静态资源分别放入 tomcat 的 webapps 文件夹中。</p>
<p>我们新建两个 html 文件，8080端口的tomcat 中有一个文件夹 edu，文件夹内一个名为a.html，文件内容为<code>&lt;h1&gt;8080&lt;h1&gt;</code>，8081端口的tomcat 中有一个文件夹 vod，文件夹内一个名为a.html，文件内容为<code>&lt;h1&gt;8081&lt;h1&gt;</code>。</p>
<p>windows 访问192.168.1.200:8080/edu/a.html 和 192.168.1.200:8081/vod/a.html 可分别看见 8080 和 8081 字样。</p>
<p>再来继续配置 nginx，打开 nginx.conf，更改如下内容。</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20200826203446684.png" alt="image-20200826203446684"></p>
<p>启动 nginx，我们在 windows 环境下 访问 192.168.1.200:9001/edu/a.html 和 192.168.1.200:9001/vod/a.html 即可看到 8080 和 8081 字样。</p>
<h3 id="负载均衡-1"><a href="#负载均衡-1" class="headerlink" title="负载均衡"></a>负载均衡</h3><p>实现效果：浏览器中输入 192.168.1.200/edu/a.html，可以看到 8080 和 8081 字样不停变换。</p>
<p>我们新建两个 html 文件，8080端口的tomcat 中有一个文件夹 edu，文件夹内一个名为a.html，文件内容为<code>&lt;h1&gt;8080&lt;h1&gt;</code>，8081端口的tomcat 中同样有一个文件夹 edu，文件夹内一个名为a.html，文件内容为<code>&lt;h1&gt;8081&lt;h1&gt;</code>。</p>
<p>windows 访问192.168.1.200:8080/edu/a.html 和 192.168.1.200:8081/edu/a.html 可分别看见 8080 和 8081 字样。</p>
<p>我们在 nginx 配置文件中进行修改：</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20200826204159859.png" alt="image-20200826204159859"></p>
<p>启动 nginx，windows 访问 192.168.1.200/edu/a.html，不停刷新，即可看到 8080 和 8081交替出现（如果不交替出现，可能是浏览器缓存，换 edge 试试）。</p>
<p>负载均衡的集中方式：</p>
<ol>
<li><p>轮询（默认）</p>
<p>每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器 down 掉，能自动剔除。</p>
</li>
<li><p>weight</p>
<p>weight 表示权重，默认为1，权重越高，服务器分配到的客户端越多。指定轮询几率，weight 和访问比率成正比，用于后端服务器性能不均的情况。</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20200826204626473.png" alt="image-20200826204626473"></p>
</li>
<li><p>ip_hash</p>
<p>每个请求按访问 ip 的 hash 结果分配，这样每个访客固定访问一个后端服务器，可以解决 session 的问题。</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20200826204640931.png" alt="image-20200826204640931"></p>
</li>
<li><p>fair</p>
<p>按后端服务器的响应时间来分配请求，响应时间短的优先分配。</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20200826204708191.png" alt="image-20200826204708191"></p>
</li>
</ol>
<h3 id="动静分离-1"><a href="#动静分离-1" class="headerlink" title="动静分离"></a>动静分离</h3><p>nginx 动静分离简单来说就是把动态跟静态请求分开，不能理解成只是单纯的把动态页面和<br>静态页面物理分离。严格意义上说应该是动态请求跟静态请求分开，可以理解成使用 nginx<br>处理静态页面，Tomcat 处理动态页面。</p>
<p>一种是纯粹把静态文件独立成单独的域名，放在独立的服务器上，也是目前主流推崇的方案；<br>另外一种方法就是动态跟静态文件混合在一起发布，通过 nginx 来分开。<br>通过 location 指定不同的后缀名实现不同的请求转发。通过 expires 参数设置，可以使<br>浏览器缓存过期时间，减少与服务器之前的请求和流量。具体 Expires 定义：是给一个资<br>源设定一个过期时间，也就是说无需去服务端验证，直接通过浏览器自身确认是否过期即可，<br>所以不会产生额外的流量。此种方法非常适合不经常变动的资源。（如果经常更新的文件，<br>不建议使用 Expires 来缓存），我这里设置 3d，表示在这 3 天之内访问这个 URL，发送<br>一个请求，比对服务器该文件最后更新时间没有变化，则不会从服务器抓取，返回状态码<br>304，如果有修改，则直接从服务器重新下载，返回状态码 200。</p>
<p>在 linux 系统中准备静态资源：</p>
<blockquote>
<p>cd /</p>
<p>mkdir data</p>
<p>cd data</p>
<p>mkdir www</p>
<p>mkdir image</p>
</blockquote>
<p>在 www 文件夹下放一个 html 文件（名为 a.html），在image 文件夹下放一张图片（1.jpg）。</p>
<p>配置 nginx 实现文件与 web 请求路径的映射。</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20200826205334410.png" alt="image-20200826205334410"></p>
<p>在 windows 访问 192.168.1.200/image/1.jpg即可看到图片，访问 192.168.1.200/www/a.html即可看到页面信息。访问 192.168.1.200/image/ ，你会看到目录下的文件信息，这就是 <code>autoindex on</code> 的作用。</p>
<h3 id="高可用集群（主从模式）"><a href="#高可用集群（主从模式）" class="headerlink" title="高可用集群（主从模式）"></a>高可用集群（主从模式）</h3><p>一般 nginx 都是以集群来工作，增加可用性，我们要实现一主一备 nginx，当主 nginx 挂了，备份nginx 可以继续工作。</p>
<p>我们需要在两台 linux 虚拟机，分别安装 nginx。</p>
<p>我们还需要在两台虚拟机中安装 keepalived：</p>
<blockquote>
<p>yum install keepalived –y</p>
</blockquote>
<p>在/etc 文件夹下，修改主nginx 虚拟机的 keepalived.conf：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> Configuration File for keepalived</span><br><span class="line"></span><br><span class="line">global_defs &#123;</span><br><span class="line">   notification_email &#123;</span><br><span class="line">     acassen@firewall.loc</span><br><span class="line">     failover@firewall.loc</span><br><span class="line">     sysadmin@firewall.loc</span><br><span class="line">   &#125;</span><br><span class="line">   notification_email_from Alexandre.Cassen@firewall.loc</span><br><span class="line">   smtp_server 192.168.1.200</span><br><span class="line">   smtp_connect_timeout 30</span><br><span class="line">   router_id LVS_DEVEL</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vrrp_script chk_http_port &#123;</span><br><span class="line">    script &quot;&#x2F;usr&#x2F;local&#x2F;src&#x2F;nginx_check.sh&quot;   # 检测 nginx 是否活着的脚本</span><br><span class="line"></span><br><span class="line">    interval 2        #（检测脚本执行的间隔）</span><br><span class="line"></span><br><span class="line">    weight 2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vrrp_instance VI_1 &#123;</span><br><span class="line">    state MASTER     # 备份服务器上将 MASTER 改为 BACKUP</span><br><span class="line">    interface ens33  # 网卡</span><br><span class="line">    virtual_router_id 51  # 主、备机的 virtual_router_id 必须相同</span><br><span class="line">    priority 100    # 主、备机取不同的优先级，主机值较大，备份机值较小</span><br><span class="line">    advert_int 1</span><br><span class="line">    authentication &#123;</span><br><span class="line">        auth_type PASS</span><br><span class="line">        auth_pass 1111</span><br><span class="line">    &#125;</span><br><span class="line">    virtual_ipaddress &#123;</span><br><span class="line">        192.168.17.50  #  VRRP H 虚拟地址</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改备份 nginx 虚拟机的 keepalived.conf：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">! Configuration File for keepalived</span><br><span class="line"></span><br><span class="line">global_defs &#123;</span><br><span class="line">   notification_email &#123;</span><br><span class="line">     acassen@firewall.loc</span><br><span class="line">     failover@firewall.loc</span><br><span class="line">     sysadmin@firewall.loc</span><br><span class="line">   &#125;</span><br><span class="line">   notification_email_from Alexandre.Cassen@firewall.loc</span><br><span class="line">   smtp_server 192.168.1.200</span><br><span class="line">   smtp_connect_timeout 30</span><br><span class="line">   router_id LVS_DEVEL</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vrrp_script chk_http_port &#123;</span><br><span class="line">    script &quot;&#x2F;usr&#x2F;local&#x2F;src&#x2F;nginx_check.sh&quot;</span><br><span class="line"></span><br><span class="line">    interval 2</span><br><span class="line"></span><br><span class="line">    weight 2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vrrp_instance VI_1 &#123;</span><br><span class="line">    state BACKUP</span><br><span class="line">    interface ens33</span><br><span class="line">    virtual_router_id 51</span><br><span class="line">    priority 90</span><br><span class="line">    advert_int 1</span><br><span class="line">    authentication &#123;</span><br><span class="line">        auth_type PASS</span><br><span class="line">        auth_pass 1111</span><br><span class="line">    &#125;</span><br><span class="line">    virtual_ipaddress &#123;</span><br><span class="line">        192.168.17.50</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在两台虚拟机的 /usr/local/src 添加检测脚本 nginx_check.sh ：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">A&#x3D;&#96;ps -C nginx –no-header |wc -l&#96;</span><br><span class="line">if [ $A -eq 0 ];then</span><br><span class="line">    &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginx</span><br><span class="line">    sleep 2</span><br><span class="line">    if [ &#96;ps -C nginx --no-header |wc -l&#96; -eq 0 ];then</span><br><span class="line">        killall keepalived</span><br><span class="line">    fi</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<p>把两台服务器上的 nginx 和 keepalived 启动</p>
<blockquote>
<p>nginx sbin 目录下启动 nginx    ./nginx</p>
<p>启动keepalived  systemctl start keepalived.service</p>
</blockquote>
<p>在 windows 浏览器访问 192.168.17.50，即可看见 nginx 主界面，我们将主 nginx 关闭，再次访问，依然能看见 nginx 主界面，说明备份 nginx 工作正常。</p>
<h3 id="nginx-原理"><a href="#nginx-原理" class="headerlink" title="nginx 原理"></a>nginx 原理</h3><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20200826211511134.png" alt="image-20200826211511134"></p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20200826211523072.png" alt="image-20200826211523072"></p>
<p>master -  workers  的机制的好处<br>首先，对于每个 worker 进程来说，由于采用多个相互独立的进程，单一的 worker 进程出问题了，不会影响到 nginx 的全部服务，只是该 worker 上的全部请求失败。</p>
<p><strong>需要设置多少个 worker</strong><br>Nginx 同 redis 类似都采用了 io 多路复用机制，每个 worker 都是一个独立的进程，但每个进<br>程里只有一个主线程，通过异步非阻塞的方式来处理请求， 即使是千上万个请求也不在话<br>下。每个 worker 的线程可以把一个 cpu 的性能发挥到极致。所以 worker 数和服务器的 cpu<br>数相等是最为适宜的。设少了会浪费 cpu，设多了会造成 cpu 频繁切换上下文带来的损耗。</p>
<p><strong>设置 worker  数量</strong></p>
<p>worker_processes 4  </p>
<p>#work 绑定 cpu(4 work 绑定 4cpu)。<br>worker_cpu_affinity 0001 0010 0100 1000  </p>
<p>#work 绑定 cpu (4 work 绑定 8 cpu 中的 4 个) 。<br>worker_cpu_affinity 0000001 00000010 00000100 00001000</p>
<p>连接数 worker_connection 表示每个 worker 进程所能建立连接的最大值。一个 nginx 能建立的最大连接数，应该是 worker_connections * worker_processes。当然，这里说的是最大连接数，对于HTTP 请 求 本 地 资 源 来 说 ， 能 够 支 持 的 最 大 并 发 数 量 是 worker_connections * worker_processes，如果是支持 http1.1 的浏览器每次访问要占两个连接，所以普通的静态访问最大并发数是： worker_connections * worker_processes /2，而如果是 HTTP 作 为反向代理来说，最大并发数量应该是 worker_connections * worker_processes/4。因为作为反向代理服务器，每个并发会建立与客户端的连接和与后端服务的连接，会占用两个连接。</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
  </entry>
  <entry>
    <title>判断二分图</title>
    <url>/2020/07/16/%E5%88%A4%E6%96%AD%E4%BA%8C%E5%88%86%E5%9B%BE/</url>
    <content><![CDATA[<h4 id="785-判断二分图"><a href="#785-判断二分图" class="headerlink" title="785. 判断二分图"></a><a href="https://leetcode-cn.com/problems/is-graph-bipartite/" target="_blank" rel="noopener">785. 判断二分图</a></h4><p>给定一个无向图<code>graph</code>，当这个图为二分图时返回<code>true</code>。</p>
<p>如果我们能将一个图的节点集合分割成两个独立的子集A和B，并使图中的每一条边的两个节点一个来自A集合，一个来自B集合，我们就将这个图称为二分图。</p>
<p><code>graph</code>将会以邻接表方式给出，<code>graph[i]</code>表示图中与节点<code>i</code>相连的所有节点。每个节点都是一个在<code>0</code>到<code>graph.length-1</code>之间的整数。这图中没有自环和平行边： <code>graph[i]</code> 中不存在<code>i</code>，并且<code>graph[i]</code>中没有重复的值。</p>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例 1:</span><br><span class="line">输入: [[1,3], [0,2], [1,3], [0,2]]</span><br><span class="line">输出: true</span><br><span class="line">解释: </span><br><span class="line">无向图如下:</span><br><span class="line">0----1</span><br><span class="line">|    |</span><br><span class="line">|    |</span><br><span class="line">3----2</span><br><span class="line">我们可以将节点分成两组: &#123;0, 2&#125; 和 &#123;1, 3&#125;。</span><br><span class="line">示例 2:</span><br><span class="line">输入: [[1,2,3], [0,2], [0,1,3], [0,2]]</span><br><span class="line">输出: false</span><br><span class="line">解释: </span><br><span class="line">无向图如下:</span><br><span class="line">0----1</span><br><span class="line">| \  |</span><br><span class="line">|  \ |</span><br><span class="line">3----2</span><br><span class="line">我们不能将节点分割成两个独立的子集。</span><br></pre></td></tr></table></figure>

<p><strong>注意:</strong></p>
<ul>
<li><code>graph</code> 的长度范围为 <code>[1, 100]</code>。</li>
<li><code>graph[i]</code> 中的元素的范围为 <code>[0, graph.length - 1]</code>。</li>
<li><code>graph[i]</code> 不会包含 <code>i</code> 或者有重复的值。</li>
<li>图是无向的: 如果<code>j</code> 在 <code>graph[i]</code>里边, 那么 <code>i</code> 也会在 <code>graph[j]</code>里边。</li>
</ul>
<p>对于图中任意两个结点 u 和 v ，如果它们之间有一条边相连，那么 u 和 v 必须属于不同的集合。</p>
<p>如果给定的无向图连通，那么我们就可以任选一个结点开始，给它染成红色，将其所连的所有结点染成绿色，同一种颜色表示它们在同一个集合里，我们再将绿色结点直接相连的未染色结点染成红色。</p>
<p>算法流程：</p>
<ul>
<li><p>任选一个结点开始，将其染成红色，并从该结点开始对整个无向图进行遍历；</p>
</li>
<li><p>在遍历过程中，如果我们通过结点 u 访问到了结点 v （u，v之间有一条边相连），那么会有两种情况：</p>
<ul>
<li>如果 v 未染色，将其染成与 u 不同的颜色，并对 v 直接相连的结点进行遍历；</li>
<li>如果 v 被染色，并且颜色与 u 相同，说明给定的无向图不是二分图，我们直接返回 false；</li>
</ul>
</li>
<li><p>当遍历结束时，说明给定的无向图是二分图，返回 true。</p>
</li>
</ul>
<p>我们可以使用「深度优先搜索」或「广度优先搜索」对无向图进行遍历。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNCOLORED = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RED = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> GREEN = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] color;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> valid;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBipartite</span><span class="params">(<span class="keyword">int</span>[][] graph)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = graph.length;</span><br><span class="line">        color = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        valid = <span class="keyword">true</span>;</span><br><span class="line">        Arrays.fill(color, UNCOLORED);</span><br><span class="line">        <span class="comment">//DFS</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(color[i] == UNCOLORED)&#123;</span><br><span class="line">                dfs(i, RED, graph);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> valid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> node, <span class="keyword">int</span> c, <span class="keyword">int</span>[][] graph)</span></span>&#123;</span><br><span class="line">        color[node] = c;</span><br><span class="line">        <span class="comment">//直接相连结点颜色为当前结点颜色相反</span></span><br><span class="line">        <span class="keyword">int</span> cNei = c == RED ? GREEN : RED;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> neighbor : graph[node])&#123;</span><br><span class="line">            <span class="comment">//相连结点未被染色</span></span><br><span class="line">            <span class="keyword">if</span>(color[neighbor] == UNCOLORED)&#123;</span><br><span class="line">                dfs(neighbor, cNei, graph);</span><br><span class="line">                <span class="keyword">if</span>(!valid)&#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(color[neighbor] != cNei)&#123;<span class="comment">//直接相连结点与当前结点颜色相同</span></span><br><span class="line">                valid = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是 BFS 实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNCOLORED = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RED = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> GREEN = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] color;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBipartite</span><span class="params">(<span class="keyword">int</span>[][] graph)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = graph.length;</span><br><span class="line">        color = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        Arrays.fill(color, UNCOLORED);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(color[i] == UNCOLORED)&#123;</span><br><span class="line">                Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">                queue.offer(i);</span><br><span class="line">                color[i] = RED;</span><br><span class="line">                <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">                    <span class="keyword">int</span> node = queue.poll();</span><br><span class="line">                    <span class="keyword">int</span> cNei = color[node] == RED ? GREEN : RED;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> neighbor : graph[node])&#123;</span><br><span class="line">                        <span class="keyword">if</span>(color[neighbor] == UNCOLORED)&#123;</span><br><span class="line">                            queue.offer(neighbor);</span><br><span class="line">                            color[neighbor] = cNei;</span><br><span class="line">                        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(color[neighbor] != cNei)&#123;</span><br><span class="line">                            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度O(N + M)，其中 N 和 M 分别是无向图的点数和边数。</p>
<p>空间复杂度O(N)，存储结点颜色数组需要 O(N)空间。</p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode Medium</tag>
        <tag>DFS</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title>删除排序数组中的重复项</title>
    <url>/2020/04/09/%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/</url>
    <content><![CDATA[<h4 id="26-删除排序数组中的重复项"><a href="#26-删除排序数组中的重复项" class="headerlink" title="26. 删除排序数组中的重复项"></a><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/" target="_blank" rel="noopener">26. 删除排序数组中的重复项</a></h4><p>给定一个排序数组，你需要在<strong><a href="http://baike.baidu.com/item/原地算法" target="_blank" rel="noopener"> 原地</a></strong> 删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须在 <strong><a href="https://baike.baidu.com/item/原地算法" target="_blank" rel="noopener">原地 </a>修改输入数组</strong> 并在使用 O(1) 额外空间的条件下完成。</p>
  <a id="more"></a>

<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定数组 nums &#x3D; [1,1,2], </span><br><span class="line"></span><br><span class="line">函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 </span><br><span class="line"></span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定 nums &#x3D; [0,0,1,1,1,2,2,3,3,4],</span><br><span class="line"></span><br><span class="line">函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。</span><br><span class="line"></span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure>



<p>我们使用i，j两个二指针， j 在前面走。如果 j 指向的元素等于 i 指向的元素 j 直接向前移，如果 j 指向的元素不等于 i 指向的元素，i 向前移 ，将 j 指向的元素赋给 i ，j向前移。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;nums.length;++j)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[j] != nums[i])&#123;</span><br><span class="line">            <span class="keyword">if</span>(j-i != <span class="number">1</span>)&#123;</span><br><span class="line">                nums[++i]=nums[j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                ++i; <span class="comment">//i，j相邻 直接 ++i</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度O(n)，空间复杂度O(1)。</p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode Easy</tag>
        <tag>双指针</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>判断子序列</title>
    <url>/2020/04/09/%E5%88%A4%E6%96%AD%E5%AD%90%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<h4 id="392-判断子序列"><a href="#392-判断子序列" class="headerlink" title="392. 判断子序列"></a><a href="https://leetcode-cn.com/problems/is-subsequence/" target="_blank" rel="noopener">392. 判断子序列</a></h4><p>给定字符串 <strong>s</strong> 和 <strong>t</strong> ，判断 <strong>s</strong> 是否为 <strong>t</strong> 的子序列。</p>
<p>你可以认为 <strong>s</strong> 和 <strong>t</strong> 中仅包含英文小写字母。字符串 <strong>t</strong> 可能会很长（长度 ~= 500,000），而 <strong>s</strong> 是个短字符串（长度 &lt;=100）。</p>
<p>字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，<code>&quot;ace&quot;</code>是<code>&quot;abcde&quot;</code>的一个子序列，而<code>&quot;aec&quot;</code>不是）。</p>
 <a id="more"></a>

<p><strong>示例 1:</strong><br><strong>s</strong> = <code>&quot;abc&quot;</code>, <strong>t</strong> = <code>&quot;ahbgdc&quot;</code></p>
<p>返回 <code>true</code>.</p>
<p><strong>示例 2:</strong><br><strong>s</strong> = <code>&quot;axc&quot;</code>, <strong>t</strong> = <code>&quot;ahbgdc&quot;</code></p>
<p>返回 <code>false</code>.</p>
<p>最直观的办法就是维护两个指针，判断子序列中的所有字符是否在原始字符串中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSubsequence</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>, j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(;i&lt;t.length() &amp;&amp; j&lt;s.length();++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(t.charAt(i) == s.charAt(j))&#123;</span><br><span class="line">                ++j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//子字符串被全部匹配</span></span><br><span class="line">        <span class="keyword">return</span> j == s.length();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度O(n)，空间复杂度O(1)。</p>
<p>双指针解法中有大量的时间用于在 t 中找到下一个匹配字符。我们预处理出对于 t 的每一个位置，从该位置开始往后的<strong>每种字符</strong>第一次出现的位置。</p>
<p>  令<code>f[i][j]</code>表示字符串 t 从位置 i 开始往后字符 j 第一次出现的位置。在进行状态转移时，如果 t 中位置 i 的字符就是 j ，那么<code>f[i][j] = i</code>，否则 j 出现在位置 i + 1开始往后，即<code>f[i][j] = f[i + 1][j]</code>，我们从后往前进行动态规划，得到状态转移方程：<br>$$<br>f[i][j] = i,\ \ \ t[i] = j<br>$$</p>
<p>$$<br>f[i][j] = f[i+1][j],\ \ \ t[i] \neq j<br>$$</p>
<p>假设下标从 0 开始，那么 <code>f[i][j]</code>中有 0 &lt;= i &lt;= m - 1，对于边界条件 <code>f[m - 1][...]</code>，我们置 <code>f[m][...] = m</code>，让<code>f[m - 1][...]</code>进行正常转移。</p>
<p>我们利用 f 数组，每次O(1)地跳转到下一个位置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSubsequence</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length(), m = t.length();</span><br><span class="line">        <span class="keyword">int</span>[][] f = <span class="keyword">new</span> <span class="keyword">int</span>[m + <span class="number">1</span>][<span class="number">26</span>];</span><br><span class="line">        <span class="comment">//边界条件</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)&#123;</span><br><span class="line">            f[m][i] = m;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//生成 dp 数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = m - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">26</span>; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(t.charAt(i) == j + <span class="string">'a'</span>)</span><br><span class="line">                    f[i][j] = i;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    f[i][j] = f[i + <span class="number">1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//从头部开始查看 s 是是 t 的子序列</span></span><br><span class="line">        <span class="keyword">int</span> add = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(f[add][s.charAt(i) - <span class="string">'a'</span>] == m)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            add = f[add][s.charAt(i) - <span class="string">'a'</span>] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度O(m * 26 + n)，其中 n 为 s 的长度，m 为 t 的长度。</p>
<p>空间复杂度O(m * 26)。</p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode Easy</tag>
        <tag>动态规划</tag>
        <tag>双指针</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>利用线结构光测距</title>
    <url>/2020/04/04/%E5%88%A9%E7%94%A8%E7%BA%BF%E7%BB%93%E6%9E%84%E5%85%89%E8%BF%9B%E8%A1%8C%E4%B8%89%E7%BB%B4%E9%87%8D%E6%9E%84%EF%BC%88%E6%B5%8B%E8%B7%9D%EF%BC%89/</url>
    <content><![CDATA[<h1 id="利用线结构光测距"><a href="#利用线结构光测距" class="headerlink" title="利用线结构光测距"></a>利用线结构光测距</h1><p>通过线激光器扫描物体，同时用摄像机对其拍照得到带有结构光的图片，提取结构光上的点的三维坐标，激光器扫描整个物体就可求出所有点的三维坐标实现物体表面的三维重构，即可测量物体表面任意两点距离。</p>
<p>准备知识：</p>
<h6 id="四个坐标系的转换"><a href="#四个坐标系的转换" class="headerlink" title="四个坐标系的转换"></a><strong>四个坐标系的转换</strong></h6><p> <img src="https://gitee.com/hoo334/picgo/raw/master//img/p89aGLJcBtxC2Ue.png" alt="img"></p>
<p>世界坐标系–摄像机坐标系</p>
<p>将摄像机光心定位摄像机坐标原点Oc，摄像机的光轴定位摄像机坐标系的Zc轴，Xc轴，Yc轴分别与图像坐标系的x轴y轴平行。</p>
<p> <img src="https://gitee.com/hoo334/picgo/raw/master//img/P2C6DvWYxsRJT5V.png" alt="img"></p>
<p>R为3阶正交单位矩阵，t为平移向量，均为相机外参数</p>
<p>物理坐标系–像素坐标系</p>
<p>图像的x，y轴分别和像素的u，v轴平行</p>
<p> u=x/dx+u0, v=y/dy+v0</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/Ilu6D3qhcsMX4UO.png" alt="img"></p>
<p> <img src="https://gitee.com/hoo334/picgo/raw/master//img/VlbA4hwG7qt2ROo.png" alt="img"></p>
<p>物理坐标系–摄像机坐标系</p>
<p> <img src="https://gitee.com/hoo334/picgo/raw/master//img/mgvBA8ErOCYePVJ.png" alt="img"></p>
<p>像素坐标系–世界坐标系</p>
<p>fx，fy，u0，v0为摄像机内部参数，R，t，为外部参数</p>
<p> <img src="https://gitee.com/hoo334/picgo/raw/master//img/TiGvFomXtY936S5.png" alt="img"></p>
<h6 id="系统测量模型"><a href="#系统测量模型" class="headerlink" title="系统测量模型"></a><strong>系统测量模型</strong></h6><p> <img src="https://gitee.com/hoo334/picgo/raw/master//img/HVvfTClZKQSAtcG.png" alt="img"></p>
<p>P点既在OP’直线上又在光平面上（由结构光投射器与物体表面结构光构成的平面），摄像机和结构光投射器相对位置不变，光平面方程不变，设摄像机下光平面方程为</p>
<p> <img src="https://gitee.com/hoo334/picgo/raw/master//img/45ZKk7HxFvrwQPf.png" alt="img"></p>
<p>设点P’在摄像机坐标系下的图像坐标（x，y，1）P点坐标为（Xc，Yc，Zc）则直线OcP直线方程为</p>
<p> <img src="https://gitee.com/hoo334/picgo/raw/master//img/R2ev3rwy9G1KZIO.png" alt="img"></p>
<p>联立可得</p>
<p> <img src="https://gitee.com/hoo334/picgo/raw/master//img/CIZWnvPmlJoe4kb.png" alt="img"></p>
<p>求空间点在摄像机坐标系下的空间三维坐标需要光平面方程，P’点的图像坐标，求解P’的坐标需要摄像机内参数，所以需要摄像机标定和光平面标定。</p>
<h6 id="系统实现方案"><a href="#系统实现方案" class="headerlink" title="系统实现方案"></a><strong>系统实现方案</strong></h6><p>固定摄像机和激光器，移动器棋盘格拍摄带有结构光和不带结构光的图片，需要不同角度拍摄。</p>
<p>通过harris角点提取图片中角点像素坐标</p>
<p>运用张正友标定思想完成相机标定</p>
<p>提取线结构光方程，与图像角点直线方程结合，求角点直线和结构光的交点坐标</p>
<p>通过角点的像素坐标和角点与结构光的交点坐标运用交比不变性得到结构光上一系列交点的摄像机坐标，通过最小二乘拟合得到摄像机坐标系下的光平面方程</p>
<p>运用光平面方程，可得到结构光上任意一点的相机坐标</p>
<h6 id="相机标定和光平面实现"><a href="#相机标定和光平面实现" class="headerlink" title="相机标定和光平面实现"></a><strong>相机标定和光平面实现</strong></h6><p>Qt+openCV</p>
<p>cameraCalibrate函数原型</p>
<p>calibrateCamera(InputArrayOfArrays objectPoints,</p>
<p>InputArrayOfArrays imagePoints,</p>
<p> Size imageSize,</p>
<p>InputOutputArray cameraMatrix,</p>
<p>InputOutputArray distCoeffs,</p>
<p> OutputArrayOfArrays rvecs,</p>
<p> OutputArrayOfArrays tvecs,</p>
<p> int flags=0 );</p>
<p>参数 ：</p>
<p>objectPoints  初始化世界坐标系的所有角点的三维坐标点</p>
<p>应输入  vector&lt;vector<Point3f>&gt; objectPoints</p>
<p> imagePoints 与其对应的像素坐标系的所有角点的二维坐标点</p>
<p>应输入 vector&lt; vector&lt; Point2f&gt;&gt; imagePoints</p>
<p> imageSize   图像大小</p>
<p>   cameraMatrix  相机内参数矩阵  </p>
<p> 输入一个cv::Mat cameraMatrix即可。</p>
<p>​     distCoeffs  为畸变矩阵。输入一个cv::Mat distCoeffs即可</p>
<p>rvecs  为旋转向量 应输入一个vector<a href="cv::Mat">cv::Mat</a></p>
<p>tvecs  为平移向量 应输入一个vector<a href="cv::Mat">cv::Mat</a></p>
<p>​     flags为标定是所采用的算法。可如下某个或者某几个参数：</p>
<p>CV_CALIB_USE_INTRINSIC_GUESS：使用该参数时，在cameraMatrix矩阵中应该有fx,fy,cx,cy的估计值。否则的话，将初始化(cx,cy）图像的中心点，使用最小二乘估算出fx，fy。如果内参数矩阵和畸变居中已知的时候，应该标定模块中的solvePnP()函数计算外参数矩阵。</p>
<p>CV_CALIB_FIX_PRINCIPAL_POINT：在进行优化时会固定光轴点。当CV_CALIB_USE_INTRINSIC_GUESS参数被设置，光轴点将保持在中心或者某个输入的值。</p>
<p>CV_CALIB_FIX_ASPECT_RATIO：固定fx/fy的比值，只将fy作为可变量，进行优化计算。当CV_CALIB_USE_INTRINSIC_GUESS没有被设置，fx和fy将会被忽略。只有fx/fy的比值在计算中会被用到。</p>
<p>CV_CALIB_ZERO_TANGENT_DIST：设定切向畸变参数（p1,p2）为零。</p>
<p>CV_CALIB_FIX_K1,…,CV_CALIB_FIX_K6：对应的径向畸变在优化中保持不变。如果设置了CV_CALIB_USE_INTRINSIC_GUESS参数，</p>
<p>CV_CALIB_RATIONAL_MODEL：计算k4，k5，k6三个畸变参数。如果没有设置，则只计算其它5个畸变参数。</p>
<p>摄像机标定需要角点的世界坐标棋盘格表面为x-y轴，所以棋盘格角点z坐标全为0，已知两角点的实际距离就可求出所有角点的世界坐标</p>
<p>摄像机标定还需角点的像素坐标</p>
<p>利用openCV库函数findChessboardCorners()可以提取到。</p>
<p>带入这两个参数到cameraCalibrate函数即可求出相机内参数和每幅图对应的外参数</p>
<h6 id="光平面标定"><a href="#光平面标定" class="headerlink" title="光平面标定"></a><strong>光平面标定</strong></h6><p>1、提取线结构光中心线方程，结构光处像素值为255利用二值化原理提取只含结构光的图像，利用goodFeaturesToTrack()取得结构光上的点，将这些点代入fitline()，拟合得到线结构光方程。</p>
<p>2、拟合角点直线方程，结合线结构光中心线方程，求两直线交点可得一系列光条上的点的像素坐标。</p>
<p>3、通过角点世界坐标，结合相机所求每一幅图的相机外参数，求出每幅图的角点摄像机坐标</p>
<p>4、通过摄像机内参数，将角点图像坐标转换为角点物理坐标</p>
<p> <img src="https://gitee.com/hoo334/picgo/raw/master//img/C72pjYhcAKlILbJ.png" alt="img"></p>
<p>5、已知A B C 角点 D 为角点直线与结构光角点直线的交点，A’ B ‘ C’ D’为成像点,</p>
<p>  已知A’ B ‘ C’ D’四点物理坐标或像素坐标，A B C三点相机坐标可求出D的相机坐标。</p>
<p> <img src="https://gitee.com/hoo334/picgo/raw/master//img/FOMiBtnzeWGHqT6.png" alt="img"></p>
<p>6、对于多幅图求出物体表面结构光与角点直线的交点坐标运用最小二乘拟合得到光平面方程</p>
<h6 id="运用光平面方程求距离"><a href="#运用光平面方程求距离" class="headerlink" title="运用光平面方程求距离"></a><strong>运用光平面方程求距离</strong></h6><p>鼠标点击结构光上任意两点获取两点的像素坐标通过公式</p>
<p> <img src="https://gitee.com/hoo334/picgo/raw/master//img/SegV9TcBWxjmXoP.png" alt="img"></p>
<p>其中1/dx=fx，1/dy=fy，fx，fy均为摄像机内参数</p>
<p>然后物理坐标转为摄像机坐标</p>
<p> <img src="https://gitee.com/hoo334/picgo/raw/master//img/NQ5HjtidSL7exXu.png" alt="img"></p>
<p>运用两点间距离公式可求出结构光上两点实际距离。</p>
<p> <img src="https://gitee.com/hoo334/picgo/raw/master//img/AbThzSE4KXNVe8M.png" alt="img"></p>
<p>附：</p>
<p>最小二乘拟合平面</p>
<p>CvMat*points_mat = cvCreateMat(X_vector.size(), 3, CV_32FC1);</p>
<p>//定义用来存储需要拟合点的矩阵大小N*3； </p>
<p>for (int i=0;i &lt; X_vector.size(); ++i)</p>
<p>{</p>
<p>points_mat-&gt;data.fl[i*3+0] = X_vector[i];</p>
<p>//矩阵的值进行初始化  X的坐标值</p>
<p>points_mat-&gt;data.fl[i * 3 + 1] = Y_vector[i];</p>
<p>// Y的坐标值</p>
<p>points_mat-&gt;data.fl[i * 3 + 2] = Z_vector[i];</p>
<p>//<span style="font-family: Arial, Helvetica, sans-serif;"></p>
<p>// Z的坐标值</span></p>
<p>}</p>
<p>float plane12[4] = { 0 };//定义用来储存平面参数的数组 </p>
<p>cvFitPlane(points_mat, plane12);//调用方程 </p>
<p>​    </p>
<p>// 其中 Plane12[4]   数组中对应ABCD；</p>
<p> //Ax+by+cz=D</p>
<p>​    void cvFitPlane(const CvMat* points, float* plane){</p>
<p>​      // Estimate geometric centroid.</p>
<p>​      int nrows = points-&gt;rows;</p>
<p>​      int ncols = points-&gt;cols;</p>
<p>​      int type = points-&gt;type;</p>
<p>​      CvMat* centroid = cvCreateMat(1, ncols, type);</p>
<p>​      cvSet(centroid, cvScalar(0));</p>
<p>​      for (int c = 0; c&lt;ncols; c++){</p>
<p>​        for (int r = 0; r &lt; nrows; r++)</p>
<p>​        {</p>
<p>​        centroid-&gt;data.fl[c] += points-&gt;data.fl[ncols*r + c];</p>
<p>​        }</p>
<p>​        centroid-&gt;data.fl[c] /= nrows;</p>
<p>​      }</p>
<p>​      // Subtract geometric centroid from each point.</p>
<p>​      CvMat* points2 = cvCreateMat(nrows, ncols, type);</p>
<p>​      for (int r = 0; r&lt;nrows; r++)</p>
<p>​        for (int c = 0; c&lt;ncols; c++)</p>
<p>​          points2-&gt;data.fl[ncols<em>r + c] = points-&gt;data.fl[ncols</em>r + c] - centroid-&gt;data.fl[c];</p>
<p>​      // Evaluate SVD of covariance matrix.</p>
<p>​      CvMat* A = cvCreateMat(ncols, ncols, type);</p>
<p>​      CvMat* W = cvCreateMat(ncols, ncols, type);</p>
<p>​      CvMat* V = cvCreateMat(ncols, ncols, type);</p>
<p>​      cvGEMM(points2, points, 1, NULL, 0, A, CV_GEMM_A_T);</p>
<p>​      cvSVD(A, W, NULL, V, CV_SVD_V_T);</p>
<p>​      // Assign plane coefficients by singular vector corresponding to smallest singular value.</p>
<p>​      plane[ncols] = 0;</p>
<p>​      for (int c = 0; c&lt;ncols; c++){</p>
<p>​        plane[c] = V-&gt;data.fl[ncols*(ncols - 1) + c];</p>
<p>​        plane[ncols] += plane[c] * centroid-&gt;data.fl[c];</p>
<p>​      }</p>
<p>​      // Release allocated resources.</p>
<p>​      //cvReleaseMat(¢roid);</p>
<p>​      cvReleaseMat(&amp;points2);</p>
<p>​      cvReleaseMat(&amp;A);</p>
<p>​      cvReleaseMat(&amp;W);</p>
<p>​      cvReleaseMat(&amp;V);</p>
<p>​    }</p>
<p>最小二乘拟合线：</p>
<p>函数原型如下：</p>
<p>void fitLine( InputArray points,</p>
<p>  OutputArray line,</p>
<p>  int distType,</p>
<p>  double param,</p>
<p>  double reps,</p>
<p>double aeps );</p>
<p>distType 指定拟合函数的类型，可以取 CV_DIST_L2</p>
<p>param 就是 CV_DIST_FAIR、CV_DIST_WELSCH、CV_DIST_HUBER 公式中的C。如果取 0，则程序自动选取合适的值。</p>
<p>reps 表示直线到原点距离的精度，建议取 0.01。<br>aeps 表示直线角度的精度，建议取 0.01。</p>
<p>计算出的直线信息存放在 line 中，为 cv::Vec4f 类型。line[0]、line[1] 存放的是直线的方向向量。line[2]、line[3] 存放的是直线上一个点的坐标。</p>
<p>如果直线用 y=kx+by=kx+b 来表示，那么 k = line[1]/line[0]，b = line[3] - k * line[2]</p>
<p>附部分源码</p>
<p>其中部分为ui设计和对特定图片写的去结构光的算法不可生搬硬套！</p>
<p>#ifndef MAINWINDOW_H</p>
<p>#define MAINWINDOW_H</p>
<p>#include <QMainWindow></p>
<p>#include <iostream></p>
<p>#include <fstream></p>
<p>#include<QFileDialog></p>
<p>#include<QString></p>
<p>#include<QImage></p>
<p>#include<QPixmap></p>
<p>#include <QWidget></p>
<p>#include<QMouseEvent></p>
<p>#include<QEvent></p>
<p>#include<QDebug></p>
<p>#include<QMessageBox></p>
<p>#include “opencv2/core/core.hpp”</p>
<p>#include “opencv2/imgproc/imgproc.hpp”</p>
<p>#include “opencv2/calib3d/calib3d.hpp”</p>
<p>#include “opencv2/highgui/highgui.hpp”</p>
<p>#include &lt;opencv2\imgproc\types_c.h&gt;</p>
<p>using namespace cv;</p>
<p>using namespace std;</p>
<p>#define IMGCOUNT 14</p>
<p>namespace Ui {</p>
<p>class MainWindow;</p>
<p>}</p>
<p>class MainWindow : public QMainWindow</p>
<p>{</p>
<p>  Q_OBJECT</p>
<p>public:</p>
<p>  explicit MainWindow(QWidget *parent = 0);</p>
<p>  ~<strong><em>MainWindow\</em></strong>();</p>
<p>private slots:</p>
<p>  void <strong>cameraCalibrate</strong>();//无结构光摄像机标定</p>
<p>  void <strong>squareCalibrate</strong>();//有结构光摄像机标定和光平面标定</p>
<p>  Point2f <strong>getcrosspoint</strong>(Vec4f lineA,Vec4f lineB);//找出两条直线的交点</p>
<p>  void <strong>GetCrossPointAll</strong>();//找出所有图片的结构光交点</p>
<p>  void <strong>calMatrix_M</strong>();//计算世界坐标系与摄像机坐标系的关系矩阵M</p>
<p>  void <strong>calCameraCornerPoints</strong>();//计算摄像机坐标系下的角点坐标</p>
<p>  void <strong>calCameraCrossPoints</strong>();//计算摄像机坐标下的结构光交点坐标</p>
<p>  void <strong>calCornersInCamera</strong>(Point2f A,Point2f B,Point2f C,Point2f D,Mat A_,Mat B_,Mat C_);</p>
<p>  void <strong>fitting_light_surface</strong>();</p>
<p>  void <strong>cvFitPlane</strong>(const CvMat* points, float* plane);</p>
<p>  void <strong>calDistance</strong>();</p>
<p>  void <strong>pushbutton1</strong>();</p>
<p>public slots:</p>
<p>  void <strong>open</strong>();</p>
<p>protected:</p>
<p>  void <strong><em>mousePressEvent\</em></strong>(QMouseEvent *m);//重载mousePressEvent函数</p>
<p>private:</p>
<p>  double zoom=1;</p>
<p>  vector<Point2f> mousePoint;</p>
<p>  QString path;</p>
<p>private:</p>
<p>  Ui::MainWindow *ui;</p>
<p>  int imageCount;</p>
<p>  string file;</p>
<p>  Size image_size;//图像的尺寸</p>
<p>  Size board_size;   //标定板上每列，行的角点数7 size.width 代表列数 size.height 代表 行数</p>
<p>  vector<Point2f> image_points_buf; //缓存每幅图像上检测到的角点</p>
<p>  vector&lt;vector<Point3f>&gt; object_points; //保存标定板上角点的三维坐标,为标定函数的第一个参数</p>
<p>  vector&lt;vector<Point2f>&gt; image_points_seq; //保存检测到的所有角点</p>
<p>  Size square_size;//实际测量得到的标定板上每个棋盘格的大小，这里其实没测，就假定了一个值，</p>
<p>  Mat cameraMatrix;//摄像机内参数</p>
<p>  Mat distCoeffs;//畸变系数</p>
<p>  vector<Mat> tvecsMat;//每幅图像的旋转向量</p>
<p>  vector<Mat> R_matrix;//每幅图的旋转矩阵</p>
<p>  vector<Mat> rvecsMat;//每幅图像的平移向量</p>
<p>  vector<Point2f>corners;//结构光上的点</p>
<p>  Vec4f line_para; //输出的直线</p>
<p>  vector<Mat> M;//摄像机坐标 世界坐标 转换系数</p>
<p>  vector&lt;vector<Mat>&gt;corners_in_camera;//角点在相机坐标系下的坐标</p>
<p>  vector&lt;vector<Point2f>&gt;crossPointAll;//所有图像的结构光与角点直线的坐标</p>
<p>  //拟合点的三维坐标</p>
<p>  vector<double>X_vector;</p>
<p>  vector<double>Y_vector;</p>
<p>  vector<double>Z_vector;</p>
<p>  float plane12[4] = { 0 };//定义用来储存平面参数的数组</p>
<p>};</p>
<p>#endif // MAINWINDOW_H</p>
<p>#include “mainwindow.h”</p>
<p>#include “ui_mainwindow.h”</p>
<p>MainWindow::<strong>MainWindow</strong>(QWidget *parent) :</p>
<p>  QMainWindow(parent),</p>
<p>  ui(new Ui::MainWindow)</p>
<p>{</p>
<p>  ui-&gt;setupUi(this);</p>
<p>   connect(ui-&gt;actioncalibrateCamera,SIGNAL(triggered()),this,SLOT(cameraCalibrate()));</p>
<p>   connect(ui-&gt;pushButton,SIGNAL(clicked()),this,SLOT(pushbutton1()));</p>
<p>   connect(ui-&gt;pushButton_2,SIGNAL(clicked()),this,SLOT(open()));</p>
<p>   ui-&gt;rows-&gt;setValue(7);ui-&gt;cols-&gt;setValue(7);</p>
<p>   ui-&gt;filename-&gt;setText(“D:\QT projects\PIC\struct_image_copy”);</p>
<p>   ui-&gt;dis-&gt;setValue(10);</p>
<p>   ui-&gt;pic-&gt;setValue(11);</p>
<p>}</p>
<p>MainWindow::~<strong><em>MainWindow\</em></strong>()</p>
<p>{</p>
<p>  delete ui;</p>
<p>}</p>
<p>void MainWindow::<strong>cameraCalibrate</strong>()</p>
<p>{</p>
<p>​      board_size.width=ui-&gt;cols-&gt;value();board_size.height=ui-&gt;rows-&gt;value();</p>
<p>​      QString f=”D:\QT projects\PIC\cal_image_copy”;</p>
<p>​      for (int image_num = 1; image_num &lt;= IMGCOUNT; image_num++)</p>
<p>​      {</p>
<p>​        QString n(“\%1.bmp”);n=n.arg(image_num);</p>
<p>​        QString m=f+n;</p>
<p>​        string file=string((const char *)m.toLocal8Bit());</p>
<p>​        Mat imageInput = imread(file);</p>
<p>​        if (!findChessboardCorners(imageInput, board_size, image_points_buf))</p>
<p>​           {</p>
<p>​             cout &lt;&lt; “can not find chessboard corners!\n”;//找不到角点</p>
<p>​             return;</p>
<p>​           }</p>
<p>​           else</p>
<p>​           {</p>
<p>​             Mat view_gray;//灰度图</p>
<p>​             cvtColor(imageInput, view_gray, CV_RGB2GRAY);</p>
<p>​             /<em>亚像素精确化</em>/</p>
<p>​             find4QuadCornerSubpix(view_gray, image_points_buf, Size(5, 5));//对粗提取的角点进行精确化</p>
<p>​             drawChessboardCorners(view_gray, board_size, image_points_buf, true);//用于在图片中标记角点</p>
<p>​             image_points_seq.push_back(image_points_buf);//保存亚像素角点</p>
<p>​             imshow(“Camera Calibration”, view_gray);//显示图片</p>
<p>​             waitKey(500);//停半秒</p>
<p>​           }</p>
<p>​           image_size.width = imageInput.cols;</p>
<p>​           image_size.height = imageInput.rows;</p>
<p>​           imageInput.release();</p>
<p>​      }</p>
<p>/<em>相机标定</em>/</p>
<p>​           for (int t = 0; t&lt;IMGCOUNT; t++)</p>
<p>​             {</p>
<p>​                 vector<Point3f> tempPointSet; //世界坐标点</p>
<p>​               for (int i = 0; i&lt;board_size.width; i++)//每列 size.width代表图像的宽度 即列数</p>
<p>​               {</p>
<p>​                 for (int j = 0; j&lt;board_size.height; j++)//每行</p>
<p>​                 {</p>
<p>​                   Point3f realPoint;</p>
<p>​                   //假设标定板放在世界坐标系中z=0的平面上</p>
<p>​                   realPoint.x = j*square_size.width;</p>
<p>​                   realPoint.y = i*square_size.height;</p>
<p>​                   realPoint.z = 0;</p>
<p>​                   tempPointSet.push_back(realPoint);</p>
<p>​                 }</p>
<p>​               }</p>
<p>​               object_points.push_back(tempPointSet);</p>
<p>​             }</p>
<p>​           //内外参数对象</p>
<p>​             cameraMatrix = Mat(3, 3,CV_32FC1, Scalar::all(0));//摄像机内参数矩阵</p>
<p>​            // vector<int> point_counts;// 每幅图像中角点的数量</p>
<p>​             distCoeffs = Mat(1, 5, CV_64F, Scalar::all(0));//摄像机的5个畸变系数：k1,k2,p1,p2,k3</p>
<p>​             calibrateCamera(object_points, image_points_seq, image_size, cameraMatrix, distCoeffs, rvecsMat, tvecsMat, 0);//相机标定</p>
<p>/<em>保存内外参数</em>/</p>
<p>​               ofstream fout(“caliberation_result.txt”);//保存标定结果的文件</p>
<p>​               fout &lt;&lt; “相机内参数矩阵：” &lt;&lt; endl;</p>
<p>​               fout &lt;&lt; cameraMatrix &lt;&lt; endl &lt;&lt; endl;</p>
<p>​               fout &lt;&lt; “畸变系数：\n”;</p>
<p>​               fout &lt;&lt; distCoeffs &lt;&lt; endl &lt;&lt; endl &lt;&lt; endl;</p>
<p>​               waitKey(0);//停半秒</p>
<p>}</p>
<p>void MainWindow::<strong>squareCalibrate</strong>()</p>
<p>{</p>
<p>  object_points.clear();image_points_seq.clear();</p>
<p> for (int image_num = 1; image_num &lt;= imageCount; image_num++)</p>
<p> {</p>
<p>   QString n(“\%1.bmp”);n=n.arg(image_num);</p>
<p>   QString m=path+n;</p>
<p>​    file=string((const char *)m.toLocal8Bit());</p>
<p>   //sprintf(filenames, “D:\QT projects\PIC\struct_image_copy\%d.bmp”, image_num);</p>
<p>​    Mat origin_image = imread(file);</p>
<p>​      Mat grey_image;</p>
<p>​      cvtColor(origin_image, grey_image, CV_RGB2GRAY);</p>
<p>​      CV_Assert(grey_image.depth() != sizeof(uchar));</p>
<p>​      int row=grey_image.rows;</p>
<p>​      int col=grey_image.cols;</p>
<p>​      uchar*p;</p>
<p>/<em>阶段去除高亮部分</em>/</p>
<p>​      for(int i=0;i&lt;row;i++)</p>
<p>​      {</p>
<p>​        p=grey_image.ptr<uchar>(i);</p>
<p>​        for(int j=0;j&lt;col;j++)</p>
<p>​        {</p>
<p>​          if(p[j]&gt;250)p[j]-=100;</p>
<p>​          if(p[j]&gt;220)p[j]-=70;</p>
<p>​          if(p[j]&gt;190)p[j]-=30;</p>
<p>​          if(p[j]&gt;170)p[j]-=10;</p>
<p>​        }</p>
<p>​      }</p>
<p>/<em>去除黑方格上的亮点</em>/</p>
<p>​      for(int i=0;i&lt;row;i++)</p>
<p>​      {</p>
<p>​        p=grey_image.ptr<uchar>(i);</p>
<p>​        for(int j=0;j&lt;col;j++)</p>
<p>​        {</p>
<p>​          if(p[j]&gt;140){</p>
<p>​            if(j&lt;15&amp;&amp;p[j+15]&lt;100)</p>
<p>​            p[j]=p[j+15];</p>
<p>​            if((j&gt;15)&amp;&amp;(j&lt;col-15))</p>
<p>​            {if(p[j+15]&lt;100)p[j]=p[j+15];</p>
<p>​            if(p[j+15]&lt;100)p[j]=p[j-15];</p>
<p>​            }</p>
<p>​            if(j&gt;col-15&amp;&amp;p[j+15]&lt;100)</p>
<p>​              p[j]=p[j-15];</p>
<p>​          }</p>
<p>​        }</p>
<p>​      }</p>
<p>/<em>腐蚀进一步消除</em>/</p>
<p>​      Mat ele = getStructuringElement(MORPH_RECT,Size(4,4));</p>
<p>​      Mat ele2 = getStructuringElement(MORPH_RECT,Size(2,2));</p>
<p>​       erode(grey_image,grey_image,ele);//erode函数直接进行腐蚀操作</p>
<p>​       dilate(grey_image,grey_image,ele2);//膨胀增加精确度</p>
<p>​       // imshow(“after erode operation”,grey_image);</p>
<p>​       Mat imageInput=grey_image.clone();</p>
<p>​       if (!findChessboardCorners(imageInput, board_size, image_points_buf,CV_CALIB_CB_FILTER_QUADS))</p>
<p>​           {</p>
<p>​             cout &lt;&lt; “can not find chessboard corners!\n”;//找不到角点</p>
<p>​             return;</p>
<p>​           }</p>
<p>​           else</p>
<p>​           {</p>
<p>​             Mat view_gray=grey_image.clone();</p>
<p>​             /<em>亚像素精确化</em>/</p>
<p>​             find4QuadCornerSubpix(view_gray, image_points_buf, Size(5, 5));//对粗提取的角点进行精确化</p>
<p>​             drawChessboardCorners(view_gray, board_size, image_points_buf, true);//用于在图片中标记角点</p>
<p>​             image_points_seq.push_back(image_points_buf);//保存亚像素角点</p>
<p>​            // imshow(“Camera Calibration”, view_gray);//显示图片</p>
<p>​             waitKey(100);</p>
<p>​           }</p>
<p>​           image_size.width = imageInput.cols;</p>
<p>​           image_size.height = imageInput.rows;</p>
<p>​           imageInput.release();</p>
<p> }</p>
<p>/<em>相机标定</em>/</p>
<p>​          for (int t = 0; t&lt;imageCount; t++)</p>
<p>​            {</p>
<p>​             vector<Point3f> tempPointSet;</p>
<p>​              for (int i = 0; i&lt;board_size.width; i++)//每列</p>
<p>​              {</p>
<p>​                for (int j = 0; j&lt;board_size.height; j++)//每行</p>
<p>​                {</p>
<p>​                  Point3f realPoint;</p>
<p>​                  //假设标定板放在世界坐标系中z=0的平面上</p>
<p>​                  realPoint.x = j*square_size.width;//小方格的宽度</p>
<p>​                  realPoint.y = i*square_size.height;</p>
<p>​                  realPoint.z = 0;</p>
<p>​                  tempPointSet.push_back(realPoint);</p>
<p>​                }</p>
<p>​              }</p>
<p>​              object_points.push_back(tempPointSet);</p>
<p>​            }</p>
<p>​           //内外参数对象</p>
<p>​            cameraMatrix = Mat(3, 3, CV_32FC1, Scalar::all(0));//摄像机内参数矩阵</p>
<p>​            //int point_counts;// 每幅图像中角点的数量</p>
<p>​            distCoeffs = Mat(1, 5, CV_32FC1, Scalar::all(0));//摄像机的5个畸变系数：k1,k2,p1,p2,k3</p>
<p>​            calibrateCamera(object_points, image_points_seq, image_size, cameraMatrix, distCoeffs, rvecsMat, tvecsMat, 0);//相机标定</p>
<p>/<em>二值化</em>/</p>
<p>​                   Mat origin_image=imread(file);//</p>
<p>​                   Mat grey_image;</p>
<p>​                   cvtColor(origin_image, grey_image, CV_RGB2GRAY);</p>
<p>​                   // imshow(“origin”,origin_image);</p>
<p>​                   // imshow(“grey”,grey_image);</p>
<p>​                   //waitKey(100);</p>
<p>​                   Mat binary_image;</p>
<p>​                   threshold(grey_image,binary_image,240, 255, CV_THRESH_BINARY);</p>
<p>​                   //imshow(“binary”,binary_image);</p>
<p>​                   //寻找二值化图像上的角点并保存</p>
<p>​                   goodFeaturesToTrack(binary_image,corners,18,0.01,10,Mat());</p>
<p>​                   for(unsigned int i=0;i&lt;corners.size();i++)</p>
<p>​                     {</p>
<p>​                       circle(origin_image,corners[i],2,Scalar(255,0,0),2);</p>
<p>​                     }</p>
<p>​                   // imshow(“binary points”,origin_image);</p>
<p>/<em>直线拟合</em>/</p>
<p>​                     fitLine(corners, line_para, cv::DIST_L2, 0, 1e-2, 1e-2);</p>
<p>​                     cv::Point point0;</p>
<p>​                     point0.x = line_para[2];</p>
<p>​                     point0.y = line_para[3];</p>
<p>​                     double k = line_para[1] / line_para[0];</p>
<p>​                     //计算直线的端点(y = k(x - x0) + y0)</p>
<p>​                     Point point1, point2;</p>
<p>​                     point1.x = 0;</p>
<p>​                     point1.y = k * (0 - point0.x) + point0.y;</p>
<p>​                     point2.x = origin_image.cols;</p>
<p>​                     point2.y = k * (origin_image.cols - point0.x) + point0.y;</p>
<p>​                     cv::line(origin_image, point1, point2, cv::Scalar(255, 255, 0), 2, 8, 0);</p>
<p>​                    // cv::imshow(“image”, origin_image);</p>
<p>/<em>获取结构光与角点直线坐标</em>/</p>
<p>​                     GetCrossPointAll();</p>
<p>/<em>将旋转向量转换成旋转矩阵</em>/         for(int i=0;i&lt;imageCount;i++)</p>
<p>​                     {  Mat temp;</p>
<p>​                       Rodrigues(rvecsMat[i],temp );</p>
<p>​                       R_matrix.push_back(temp);</p>
<p>​                     }</p>
<p>/<em>求M矩阵</em>/</p>
<p>​                     calMatrix_M();</p>
<p>/<em>求角点的摄像机坐标</em>/</p>
<p>​                     calCameraCornerPoints();</p>
<p>/<em>交比不变求结构光与角点直线的摄像机坐标</em>/</p>
<p>​                     calCameraCrossPoints();</p>
<p>/<em>拟合光平面</em>/</p>
<p>​                     fitting_light_surface();</p>
<p>/<em>保存内外参数</em>/</p>
<p>​              ofstream fout(“struct_caliberation_result.txt”);//保存标定结果的文件</p>
<p>​              fout &lt;&lt; “相机内参数矩阵：” &lt;&lt; endl;</p>
<p>​              fout &lt;&lt; cameraMatrix &lt;&lt; endl &lt;&lt; endl;</p>
<p>​              fout &lt;&lt; “畸变系数：\n”;</p>
<p>​              fout&lt;&lt;distCoeffs&lt;&lt;endl;</p>
<p>​              fout&lt;&lt;”第一幅图角点像素坐标”&lt;&lt;endl&lt;&lt;image_points_seq[0]&lt;&lt;endl;</p>
<p>​              fout&lt;&lt;”第一幅图角点世界坐标”&lt;&lt;endl&lt;&lt;object_points[0]&lt;&lt;endl;</p>
<p>​              fout&lt;&lt;”第一幅图交点像素坐标”&lt;&lt;endl&lt;&lt;crossPointAll[0]&lt;&lt;endl;</p>
<p>​              fout&lt;&lt;”a b c d”&lt;&lt;image_points_seq[10][0]&lt;&lt;endl&lt;&lt;image_points_seq[10][3]&lt;&lt;endl&lt;&lt;image_points_seq[10][6]&lt;&lt;endl&lt;&lt;crossPointAll[1][0]&lt;&lt;endl;</p>
<p>​              fout&lt;&lt;”camera”&lt;&lt;endl&lt;&lt;corners_in_camera[6][0]&lt;&lt;endl&lt;&lt;corners_in_camera[6][3]&lt;&lt;endl&lt;&lt;corners_in_camera[6][6]&lt;&lt;endl;</p>
<p>​              fout&lt;&lt;plane12[0]&lt;&lt;”  “&lt;&lt;plane12[1]&lt;&lt;”  “&lt;&lt;plane12[2]&lt;&lt;”  “&lt;&lt;plane12[3]&lt;&lt;endl;</p>
<p>​              for(int i=0;i&lt;50;i++)</p>
<p>​              fout&lt;&lt;”X_vector”&lt;&lt;” “&lt;&lt;X_vector[i]&lt;&lt;”  “&lt;&lt;”Y_vector”&lt;&lt;” “&lt;&lt;Y_vector[i]&lt;&lt;”  “&lt;&lt;”Z_vector”&lt;&lt;” “&lt;&lt;Z_vector[i]&lt;&lt;endl;</p>
<p>​               waitKey(0);//停半秒</p>
<p>}</p>
<p>Point2f MainWindow:: <strong>getcrosspoint</strong>(Vec4f lineA,Vec4f lineB)</p>
<p>  { //求两条直线角点</p>
<p>​    double ka=lineA[1]/lineA[0];</p>
<p>​    double kb=lineB[1]/lineB[0];</p>
<p>​    Point2f cross_point;</p>
<p>​    cross_point.x=(lineB[3]-lineA[3]+ka<em>lineA[2]-kb</em>lineB[2])/(ka-kb);</p>
<p>​    cross_point.y=ka*(cross_point.x-lineA[2])+lineA[3];</p>
<p>​    return cross_point;</p>
<p>  }</p>
<p>void MainWindow:: <strong>GetCrossPointAll</strong>()</p>
<p> {</p>
<p>   for(int i=0;i&lt;imageCount;i++)//11幅图</p>
<p>   {</p>
<p>​     vector<Point2f>crossPointPerPic;</p>
<p>​     for(int j=0;j&lt;board_size.height;j++)//遍历每行</p>
<p>​     {</p>
<p>​       vector<Point2f>temp;//取每行角点</p>
<p>​       for(int m=0;m&lt;board_size.width;m++)</p>
<p>​         temp.push_back(image_points_seq[i][j*7+m]);</p>
<p>​       Vec4f para;</p>
<p>​       fitLine(temp,para,DIST_L2,0,1e-2,1e-2);//拟合每行角点直线</p>
<p>​       Point2f temp_point=getcrosspoint(para,line_para);//得出角点直线与结构光交点</p>
<p>​       crossPointPerPic.push_back(temp_point);</p>
<p>​     }</p>
<p>​     crossPointAll.push_back(crossPointPerPic);</p>
<p>   }</p>
<p> }</p>
<p>void MainWindow::<strong>calMatrix_M</strong>()</p>
<p>{</p>
<p>//利用旋转矩阵和平移向量求得摄像机坐标系和世界坐标系之间的关系矩阵M</p>
<p>  for(int k=0;k&lt;imageCount;k++)</p>
<p>  { Mat temp(4,4,CV_32F);</p>
<p>​    for(int i=0;i&lt;3;i++)</p>
<p>​     for(int j=0;j&lt;3;j++)</p>
<p>​     {temp.at<float>(i,j)=R_matrix[k].at<double>(i,j);</p>
<p>​     temp.at<float>(0,3)=tvecsMat[k].at<double>(0);</p>
<p>​     temp.at<float>(1,3)=tvecsMat[k].at<double>(1);</p>
<p>​     temp.at<float>(2,3)=tvecsMat[k].at<double>(2);</p>
<p>​     temp.at<float>(3,0)=0;temp.at<float>(3,1)=0;temp.at<float>(3,2)=0;temp.at<float>(3,3)=1;</p>
<p>​     }</p>
<p>   M.push_back(temp);</p>
<p>  }</p>
<p>}</p>
<p>void MainWindow::<strong>calCameraCornerPoints</strong>()</p>
<p>{//求出摄像机坐标系下的角点</p>
<p>for(int i=0;i&lt;imageCount;i++)</p>
<p>{</p>
<p>  vector<Mat>temp;</p>
<p>  for(int j=0;j&lt;board_size.height;j++)</p>
<p>​    for(int k=0;k&lt;board_size.width;k++)</p>
<p>​    { Mat temp2(4,1,CV_32F);</p>
<p>​      Mat world(4,1,CV_32F);world.at<float>(0)=object_points[i][j*7+k].x;//取出世界坐标系下的角点</p>
<p>​      world.at<float>(1)=object_points[i][j<em>7+k].y;world.at<float>(2)=object_points[i][j</em>7+k].z;</p>
<p>​      world.at<float>(3)=1;</p>
<p>​      temp2=M[i]*world;//转换为摄像机坐标系</p>
<p>​      temp.push_back(temp2);</p>
<p>​    }</p>
<p>  corners_in_camera.push_back(temp);</p>
<p>}</p>
<p>}</p>
<p>void MainWindow::<strong>calCameraCrossPoints</strong>()</p>
<p>{</p>
<p>  for(int i=0;i&lt;imageCount;i++)</p>
<p>  {</p>
<p>​    for(int j=0;j&lt;board_size.height;j++)</p>
<p>​    {   //每行取三个角点</p>
<p>​        Point2f A=image_points_seq[i][j*7];//找到每行的第1，4，7个角点</p>
<p>​        Point2f B=image_points_seq[i][j*7+3];</p>
<p>​        Point2f C=image_points_seq[i][j*7+6];</p>
<p>​        Point2f D=crossPointAll[i][j];//每行的结构光交点</p>
<p>​        Mat A_=corners_in_camera[i][j*7];//找到对应角点在摄像机坐标下的坐标</p>
<p>​        Mat B_=corners_in_camera[i][j*7+3];</p>
<p>​        Mat C_=corners_in_camera[i][j*7+6];</p>
<p>​        calCornersInCamera(A,B,C,D,A_,B_,C_);//将角点坐标转换为摄像机坐标</p>
<p>​    }</p>
<p>  }</p>
<p>}</p>
<p> void MainWindow::<strong>calCornersInCamera</strong>(Point2f A,Point2f B,Point2f C,Point2f D,Mat A_,Mat B_,Mat C_)</p>
<p> {</p>
<p>​    double CR=(D.x-B.x)<em>(A.x-C.x)/((A.x-B.x)</em>(D.x-C.x));//求出交比</p>
<p>​    //利用像素坐标系下求得的交比，利用交比不变性求出结构光点在摄像机下的坐标，已知，A，B,C,D像素坐标和A_,B_,C_,摄像机坐标可求D_坐标</p>
<p>​    //由于像素坐标系与物理坐标系是线性关系，可省略像素坐标系转图像坐标系这一步，在像素坐标系下求得的交比与在图像坐标系下求得的交比一样</p>
<p>​    double m=CR*(A_.at<float>(0)-B_.at<float>(0))/(A_.at<float>(0)-C_.at<float>(0));</p>
<p>​    double x=(B_.at<float>(0)-m*C_.at<float>(0))/(1-m);</p>
<p>​    double y=(B_.at<float>(1)-m*C_.at<float>(1))/(1-m);</p>
<p>​    double z=(B_.at<float>(2)-m*C_.at<float>(2))/(1-m);</p>
<p>​    X_vector.push_back(x); Y_vector.push_back(y); Z_vector.push_back(z);</p>
<p> }</p>
<p> void MainWindow::<strong>fitting_light_surface</strong>()</p>
<p> {</p>
<p>   CvMat*points_mat = cvCreateMat(X_vector.size(), 3, CV_32FC1);</p>
<p>   //定义用来存储需要拟合点的矩阵大小N*3；</p>
<p>   for (unsigned int i=0;i &lt; X_vector.size(); ++i)</p>
<p>​       {</p>
<p>​       points_mat-&gt;data.fl[i*3+0] = X_vector[i];</p>
<p>​        //矩阵的值进行初始化  X的坐标值</p>
<p>​       points_mat-&gt;data.fl[i * 3 + 1] = Y_vector[i];</p>
<p>​       // Y的坐标值</p>
<p>​       points_mat-&gt;data.fl[i * 3 + 2] = Z_vector[i];</p>
<p>​       //<span style="font-family: Arial, Helvetica, sans-serif;"></p>
<p>​       // Z的坐标值</span></p>
<p>   }</p>
<p>​       cvFitPlane(points_mat, plane12);//调用方程</p>
<p> }</p>
<p> void MainWindow::<strong>cvFitPlane</strong>(const CvMat* points, float* plane)</p>
<p> {</p>
<p>   int nrows = points-&gt;rows;</p>
<p>   int ncols = points-&gt;cols;</p>
<p>   int type = points-&gt;type;</p>
<p>   CvMat* centroid = cvCreateMat(1, ncols, type);</p>
<p>   cvSet(centroid, cvScalar(0));</p>
<p>   for (int c = 0; c&lt;ncols; c++)</p>
<p>   {</p>
<p>   for (int r = 0; r &lt; nrows; r++)</p>
<p>​     {</p>
<p>​      centroid-&gt;data.fl[c] += points-&gt;data.fl[ncols*r + c];</p>
<p>​     }</p>
<p>   centroid-&gt;data.fl[c] /= nrows;</p>
<p>   }</p>
<p>   // Subtract geometric centroid from each point.</p>
<p>   CvMat* points2 = cvCreateMat(nrows, ncols, type);</p>
<p>   for (int r = 0; r&lt;nrows; r++)</p>
<p>​     for (int c = 0; c&lt;ncols; c++)</p>
<p>​       points2-&gt;data.fl[ncols<em>r + c] = points-&gt;data.fl[ncols</em>r + c] - centroid-&gt;data.fl[c];</p>
<p>  // Evaluate SVD of covariance matrix.</p>
<p>  CvMat* A = cvCreateMat(ncols, ncols, type);</p>
<p>  CvMat* W = cvCreateMat(ncols, ncols, type);</p>
<p>  CvMat* V = cvCreateMat(ncols, ncols, type);</p>
<p>  cvGEMM(points2, points, 1, NULL, 0, A, CV_GEMM_A_T);</p>
<p>  cvSVD(A, W, NULL, V, CV_SVD_V_T);</p>
<p>  // Assign plane coefficients by singular vector corresponding to smallest singular value.</p>
<p>  plane[ncols] = 0;</p>
<p>  for (int c = 0; c&lt;ncols; c++){</p>
<p>  plane[c] = V-&gt;data.fl[ncols*(ncols - 1) + c];</p>
<p>  plane[ncols] += plane[c] * centroid-&gt;data.fl[c];</p>
<p>  }</p>
<p>  // Release allocated resources.</p>
<p>  //cvReleaseMat(¢roid);</p>
<p>  cvReleaseMat(&amp;points2);</p>
<p>  cvReleaseMat(&amp;A);</p>
<p>  cvReleaseMat(&amp;W);</p>
<p>  cvReleaseMat(&amp;V);</p>
<p> }</p>
<p> void MainWindow::<strong><em>mousePressEvent\</em></strong>(QMouseEvent *e)</p>
<p> {</p>
<p>​    static int i=0;</p>
<p>   if(i&lt;2)</p>
<p>   {</p>
<p>​     if(i==0){ui-&gt;x1-&gt;setText(QString::number(0));ui-&gt;y1-&gt;setText(QString::number(0));</p>
<p>​          ui-&gt;x2-&gt;setText(QString::number(0));ui-&gt;y2-&gt;setText(QString::number(0));</p>
<p>​          ui-&gt;realdis-&gt;setText(QString::number(0));}</p>
<p>​     Point2f temp;</p>
<p>​     temp.x = e-&gt;x();</p>
<p>​     temp.y = e-&gt;y()-34;//纵坐标应减去MainWindow上方空白的长度</p>
<p>​     if(i==0){ui-&gt;x1-&gt;setText(QString::number(temp.x));ui-&gt;y1-&gt;setText(QString::number(temp.y));}</p>
<p>​     if(i==1){ui-&gt;x2-&gt;setText(QString::number(temp.x));ui-&gt;y2-&gt;setText(QString::number(temp.y));}</p>
<p>​     mousePoint.push_back(temp);</p>
<p>​     ++i;</p>
<p>   }</p>
<p>   else</p>
<p>   {   //收集到两个点之后再次点击鼠标计算距离并清空mousePoint</p>
<p>​     if(image_points_seq.size()!=0)</p>
<p>​     {      calDistance();</p>
<p>​       i-=2;mousePoint.pop_back();mousePoint.pop_back();</p>
<p>​     }</p>
<p>​     else</p>
<p>​     QMessageBox::warning( this, tr(“warning”),</p>
<p>​              tr(“未标定摄像机和光平面”</p>
<p>​                  “”)</p>
<p>​                 );</p>
<p>   }</p>
<p> }</p>
<p> void::MainWindow::<strong>open</strong>()</p>
<p> {</p>
<p>   QString path = QFileDialog::getOpenFileName(</p>
<p>​             this,</p>
<p>​             “文件对话框”,</p>
<p>​             “../“,//上一级路径</p>
<p>​             “Image(*.bmp *.jpg *.png)”</p>
<p>​            );</p>
<p>  QImage* image=new QImage(path);</p>
<p>   if(image-&gt;width()&gt;1500)zoom=(double)image-&gt;width()/1500;//宽度大于1500像素进行缩放 zoom为缩放比</p>
<p>   int width = image-&gt;width()/zoom;//缩放后的宽度</p>
<p>   int height = image-&gt;height()/zoom;//缩放后的高度</p>
<p>   //QPixmap fitpixmap = pixmap.scaled(width, height,Qt::KeepAspectRatio Qt::IgnoreAspectRatio, Qt::SmoothTransformation); // 饱满填充</p>
<p>  QPixmap pixmap = QPixmap::fromImage(*image);</p>
<p>  QPixmap fitpixmap = pixmap.scaled(width, height, Qt::IgnoreAspectRatio, Qt::SmoothTransformation); // 按比例缩放</p>
<p>   //重新设置label的面积使图片充满整个label区域</p>
<p>   ui-&gt;label-&gt;resize(width,height);</p>
<p>   ui-&gt;label-&gt;setPixmap(fitpixmap);</p>
<p> }</p>
<p>void MainWindow::<strong>calDistance</strong>()</p>
<p>{</p>
<p>  //获取需要的数据</p>
<p>  //double fx=7079.108034043226;  double fy=7138.477799905151;</p>
<p>  //double u0=1385.469717666468; double v0=1009.67646851548;</p>
<p>  //double a=0.999773;double b=-0.0105343;double c= 0.0185257;double d= -19.9609;</p>
<p>  double fx= cameraMatrix.at<double>(0,0);</p>
<p>  double fy= cameraMatrix.at<double>(1,1);</p>
<p>  double u0=cameraMatrix.at<double>(0,2);</p>
<p>  double v0=cameraMatrix.at<double>(1,2);</p>
<p>  double a=(double)plane12[0];double b=(double)plane12[1];double c=(double)plane12[2];double d=(double)plane12[3];</p>
<p>  Mat physic_to_pixel(3,3,CV_32F);//归一化坐标和像素坐标之间的关系矩阵</p>
<p>  physic_to_pixel.at<float>(0,0)=(double)fx;physic_to_pixel.at<float>(0,1)=0;physic_to_pixel.at<float>(0,2)=u0;</p>
<p>  physic_to_pixel.at<float>(1,0)=0;physic_to_pixel.at<float>(1,1)=(double)fy;physic_to_pixel.at<float>(1,2)=v0;</p>
<p>  physic_to_pixel.at<float>(2,0)=0;physic_to_pixel.at<float>(2,1)=0;physic_to_pixel.at<float>(2,2)=1;</p>
<p>  //两个点的像素，摄像机，归一化物理坐标</p>
<p>  Mat pixel1(3,1,CV_32F);Mat pixel2(3,1,CV_32F);</p>
<p>  Mat camera1(3,1,CV_32F);Mat camera2(3,1,CV_32F);</p>
<p>  Mat physic1(3,1,CV_32F);Mat physic2(3,1,CV_32F);</p>
<p>  //赋值 计算</p>
<p>  pixel1.at<float>(0)=mousePoint[0].x<em>zoom;pixel1.at<float>(1)=mousePoint[0].y</em>zoom;pixel1.at<float>(2)=1;</p>
<p>  pixel2.at<float>(0)=mousePoint[1].x<em>zoom;pixel2.at<float>(1)=mousePoint[1].y</em>zoom;pixel2.at<float>(2)=1;</p>
<p>  physic1=physic_to_pixel.inv()<em>pixel1;physic2=physic_to_pixel.inv()</em>pixel2;</p>
<p>  camera1.at<float>(0)=(d/(a<em>physic1.at<float>(0)+b</em>physic1.at<float>(1)+c))<em>physic1.at<float>(0); camera1.at<float>(1)=(d/(a</em>physic1.at<float>(0)+b<em>physic1.at<float>(1)+c))</em>physic1.at<float>(1); camera1.at<float>(2)=(d/(a<em>physic1.at<float>(0)+b</em>physic1.at<float>(1)+c))*physic1.at<float>(2);</p>
<p>  camera2.at<float>(0)=(d/(a<em>physic2.at<float>(0)+b</em>physic2.at<float>(1)+c))<em>physic2.at<float>(0);camera2.at<float>(1)=(d/(a</em>physic2.at<float>(0)+b<em>physic2.at<float>(1)+c))</em>physic2.at<float>(1);camera2.at<float>(2)=(d/(a<em>physic2.at<float>(0)+b</em>physic2.at<float>(1)+c))*physic2.at<float>(2);</p>
<p>  //得到两点在摄像机坐标下得距离</p>
<p>  double dis=sqrt((camera1.at<float>(0)-camera2.at<float>(0))<em>(camera1.at<float>(0)-camera2.at<float>(0))+(camera1.at<float>(1)-camera2.at<float>(1))</em>(camera1.at<float>(1)-camera2.at<float>(1))+(camera1.at<float>(2)-camera2.at<float>(2))*(camera1.at<float>(2)-camera2.at<float>(2)));</p>
<p>   ui-&gt;realdis-&gt;setText(QString::number(dis));</p>
<p>}</p>
<p>void MainWindow::<strong>pushbutton1</strong>()</p>
<p>{</p>
<p>  path=ui-&gt;filename-&gt;toPlainText();</p>
<p>  board_size.width=ui-&gt;cols-&gt;value();board_size.height=ui-&gt;rows-&gt;value();</p>
<p>  square_size.width=square_size.height=ui-&gt;dis-&gt;value();</p>
<p>  imageCount=ui-&gt;pic-&gt;value();</p>
<p>  squareCalibrate();</p>
<p>  QString text(“%1x+%2y+%3z\n=%4”);text=text.arg(plane12[0]).arg(plane12[1]).arg(plane12[2]).arg(plane12[3]);</p>
<p>  ui-&gt;surface-&gt;setText(text);</p>
<p>}</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
  </entry>
  <entry>
    <title>区域和检索 - 数组不可变</title>
    <url>/2020/04/09/%E5%8C%BA%E5%9F%9F%E5%92%8C%E6%A3%80%E7%B4%A2---%E6%95%B0%E7%BB%84%E4%B8%8D%E5%8F%AF%E5%8F%98/</url>
    <content><![CDATA[<h4 id="303-区域和检索-数组不可变"><a href="#303-区域和检索-数组不可变" class="headerlink" title="303. 区域和检索 - 数组不可变"></a><a href="https://leetcode-cn.com/problems/range-sum-query-immutable/" target="_blank" rel="noopener">303. 区域和检索 - 数组不可变</a></h4><p>给定一个整数数组  <em>nums*，求出数组从索引 *i</em> 到 <em>j</em> (<em>i</em> ≤ <em>j</em>) 范围内元素的总和，包含 <em>i, j</em> 两点。</p>
 <a id="more"></a>

<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定 nums &#x3D; [-2, 0, 3, -5, 2, -1]，求和函数为 sumRange()</span><br><span class="line"></span><br><span class="line">sumRange(0, 2) -&gt; 1</span><br><span class="line">sumRange(2, 5) -&gt; -1</span><br><span class="line">sumRange(0, 5) -&gt; -3</span><br></pre></td></tr></table></figure>

<p><strong>说明:</strong></p>
<ol>
<li>你可以假设数组不可变。</li>
<li>会多次调用 <em>sumRange</em> 方法。</li>
</ol>
<p>注意到 “假设数组不可变” 这个条件，我们可以自然地想到直接将一些区域和存储起来，多次调用 <em>sumRange</em> 方法时只用 O(1) 时间复杂度就可以得到结果。</p>
<p>在数组初始化的时候生成一个前 n 项和的数组。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumArray</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] sum;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NumArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    sum = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;++i)&#123;</span><br><span class="line">     <span class="comment">//sum[i] 代表前 i (i&gt;=1) 个元素的和      </span></span><br><span class="line">     sum[i+<span class="number">1</span>] = sum[i] + nums[i];</span><br><span class="line">    &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumRange</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//第i+1个 到 j+1个元素的和</span></span><br><span class="line">     <span class="keyword">return</span> sum[j+<span class="number">1</span>] - sum[i];   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your NumArray object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * NumArray obj = new NumArray(nums);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj.sumRange(i,j);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<p>时间复杂度O(n)，空间复杂度O(n)。</p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode Easy</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>单词接龙 II</title>
    <url>/2020/04/20/%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99%20II/</url>
    <content><![CDATA[<h4 id="126-单词接龙-II"><a href="#126-单词接龙-II" class="headerlink" title="126. 单词接龙 II"></a><a href="https://leetcode-cn.com/problems/word-ladder-ii/" target="_blank" rel="noopener">126. 单词接龙 II</a></h4><p>给定两个单词（<em>beginWord</em> 和 <em>endWord<em>）和一个字典 *wordList</em>，找出所有从 *beginWord</em> 到 <em>endWord</em> 的最短转换序列。转换需遵循如下规则：</p>
<ol>
<li><p>每次转换只能改变一个字母。</p>
</li>
<li><p>转换过程中的中间单词必须是字典中的单词。</p>
<a id="more"></a>

</li>
</ol>
<p><strong>说明:</strong></p>
<ul>
<li>如果不存在这样的转换序列，返回一个空列表。</li>
<li>所有单词具有相同的长度。</li>
<li>所有单词只由小写字母组成。</li>
<li>字典中不存在重复的单词。</li>
<li>你可以假设 <em>beginWord</em> 和 <em>endWord</em> 是非空的，且二者不相同。</li>
</ul>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">beginWord &#x3D; &quot;hit&quot;,</span><br><span class="line">endWord &#x3D; &quot;cog&quot;,</span><br><span class="line">wordList &#x3D; [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [&quot;hit&quot;,&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;cog&quot;],</span><br><span class="line">  [&quot;hit&quot;,&quot;hot&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">beginWord &#x3D; &quot;hit&quot;</span><br><span class="line">endWord &#x3D; &quot;cog&quot;</span><br><span class="line">wordList &#x3D; [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;]</span><br><span class="line"></span><br><span class="line">输出: []</span><br><span class="line"></span><br><span class="line">解释: endWord &quot;cog&quot; 不在字典中，所以不存在符合要求的转换序列。</span><br></pre></td></tr></table></figure>

<p> 本题要求的是最短转换序列，看到最短首先想到的就是<strong>BFS</strong> 。想到 BFS 就能想到图。我们需要建立图的模型：将每个单词抽象为一个点，如果两个单词可以只改变一个字母进行转换，那么说明它们之间有一条双向边。因此只要把满足转换条件的点相连，就形成了一张图。如下图（来自<a href="https://leetcode-cn.com/problems/word-ladder-ii/solution/dan-ci-jie-long-ii-by-leetcode-solution/" target="_blank" rel="noopener">Leetcode</a>）</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/z5qoG1lrcUI78LP.png" alt="image-20200607171920249"></p>
<p>有了上图我们以 <code>hit</code> 为图的起点，以<code>cog</code> 为终点进行广度优先搜索，寻找 hit 到 cog 的最短路径。</p>
<p>方便起见，我们先给每一个单词标号，即给每个单词分配一个 id。创建一个由单词 word到 id 对应的映射 wordId，并将 beginWord 与 wordList 中所有的单词都加入这个映射中。之后我们检查 endWord 是否在该映射内，若不存在，则输入无解。我们可以使用哈希表实现上面的映射关系。</p>
<p>同理我们可以创建一个由对应 id 到 word 的映射 idWord，方便最后输出结果。由于 id 实际上是整数且连续，所以这个映射用数组实现即可。</p>
<p>接下来我们将 idWord 中的单词两两匹配，检查它们是否可以通过改变一个字母进行互相转换。如果可以，则在这两个点之间建一条双向边。</p>
<p>为了保留相同长度的多条路径，我们采用 cost 数组，其中 cost[i] 表示 beginWord 对应的点到第 i 个点的代价（即转换次数）。初始情况下其所有元素初始化为无穷大。</p>
<p>接下来将起点加入队列开始广度优先搜索，队列的每一个节点中保存从起点开始的所有路径。</p>
<p>对于每次取出的节点 now，每个节点都是一个数组，数组中的最后一个元素为当前路径的最后节点 last :</p>
<ul>
<li>若该节点为终点，则将其路径转换为对应的单词存入答案;</li>
<li>若该节点不为终点，则遍历和它连通的节点（假设为 to ）中满足 cost[to] &gt;= cost[now] + 1cost[to]&gt;=cost[now]+1 的加入队列，并更新 cost[to] = cost[now] + 1cost[to]=cost[now]+1。如果 cost[to] &lt; cost[now] + 1cost[to]&lt;cost[now]+1，说明这个节点已经被访问过，不需要再考虑。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INF = <span class="number">1</span> &lt;&lt; <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Integer&gt; wordId; <span class="comment">//单词到 id 的映射</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; idWord; <span class="comment">//id到单词的映射</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt;[] edges; <span class="comment">//图的边</span></span><br><span class="line"></span><br><span class="line">    Solution()&#123;</span><br><span class="line">        wordId = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        idWord = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; findLadders(String beginWord, String endWord, List&lt;String&gt; wordList) &#123;</span><br><span class="line">        <span class="keyword">int</span> id = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 将 wordList 所有单词加入 wordId 中 相同的只保留一个，并为每个单词分配一个 id。</span></span><br><span class="line">        <span class="keyword">for</span>(String word : wordList)&#123;</span><br><span class="line">            <span class="keyword">if</span>(! wordId.containsKey(word))&#123;</span><br><span class="line">                wordId.put(word, id++ );</span><br><span class="line">                idWord.add(word);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//若 endWord 不在 wordList 中则无解</span></span><br><span class="line">        <span class="keyword">if</span>(! wordId.containsKey(endWord))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//把 beginWord 也加入 wordId 中</span></span><br><span class="line">        <span class="keyword">if</span>(! wordId.containsKey(beginWord))&#123;</span><br><span class="line">            wordId.put(beginWord, id++);</span><br><span class="line">            idWord.add(beginWord);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始化存储边的数组</span></span><br><span class="line">        edges = <span class="keyword">new</span> ArrayList[idWord.size()];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; idWord.size(); i++)&#123;</span><br><span class="line">            edges[i] = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//添加边</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; idWord.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; idWord.size(); j++)&#123;</span><br><span class="line">                <span class="comment">//如果两者可以通过转换得到 则在它们间建一条无向边</span></span><br><span class="line">                <span class="keyword">if</span>(transformCheck(idWord.get(i), idWord.get(j)))&#123;</span><br><span class="line">                    edges[i].add(j);</span><br><span class="line">                    edges[j].add(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> dest = wordId.get(endWord); <span class="comment">//目的 id</span></span><br><span class="line">        List&lt;List&lt;String&gt;&gt; res  = <span class="keyword">new</span> ArrayList&lt;&gt;();<span class="comment">//存答案</span></span><br><span class="line">        <span class="keyword">int</span>[] cost = <span class="keyword">new</span> <span class="keyword">int</span>[id];<span class="comment">//到每个点的代价</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; id; i++)&#123;</span><br><span class="line">            cost[i] = INF;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将起点加入队列，并将其cost 设置为 0 </span></span><br><span class="line">        Queue&lt;ArrayList&lt;Integer&gt;&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        ArrayList&lt;Integer&gt; tmpBegin = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        tmpBegin.add(wordId.get(beginWord));</span><br><span class="line">        q.add(tmpBegin);</span><br><span class="line">        cost[wordId.get(beginWord)] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//广度优先搜索</span></span><br><span class="line">    <span class="keyword">while</span>(! q.isEmpty())&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; now = q.poll();</span><br><span class="line">        <span class="keyword">int</span> last = now.get(now.size() - <span class="number">1</span>);<span class="comment">//最近访问的点</span></span><br><span class="line">        <span class="keyword">if</span>(last == dest)&#123;<span class="comment">//若该点为终点则将其存入答案 res 中</span></span><br><span class="line">            ArrayList&lt;String&gt; tmp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> index : now)&#123;</span><br><span class="line">                tmp.add(idWord.get(index));</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(tmp);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//该点不为终点 继续搜索</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; edges[last].size(); i++)&#123;</span><br><span class="line">                <span class="keyword">int</span> to = edges[last].get(i);</span><br><span class="line">                <span class="comment">//此处 &lt;= 目的在于把代价相同的不同路径全部保存下来</span></span><br><span class="line">                <span class="keyword">if</span>(cost[last] + <span class="number">1</span> &lt;= cost[to])&#123;</span><br><span class="line">                    cost[to] = cost[last] + <span class="number">1</span>;</span><br><span class="line">                    <span class="comment">//把 to 加入路径中</span></span><br><span class="line">                    ArrayList&lt;Integer&gt; tmp = <span class="keyword">new</span> ArrayList&lt;&gt;(now); tmp.add(to);</span><br><span class="line">                    q.add(tmp);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">transformCheck</span><span class="params">(String str1, String str2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> diff = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str1.length() &amp;&amp; diff &lt; <span class="number">2</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(str1.charAt(i) != str2.charAt(i))&#123;</span><br><span class="line">                diff++ ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> diff == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(N^2<em>C)<em>。其中 N 为 <code>wordList</code> 的长度，</em>C</em> 为列表中单词的长度。空间复杂度：O(N^2)。</p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode Hard</tag>
        <tag>DFS</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title>单词拆分</title>
    <url>/2020/07/01/%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86/</url>
    <content><![CDATA[<h4 id="139-单词拆分"><a href="#139-单词拆分" class="headerlink" title="139. 单词拆分"></a><a href="https://leetcode-cn.com/problems/word-break/" target="_blank" rel="noopener">139. 单词拆分</a></h4><p>给定一个<strong>非空</strong>字符串 <em>s</em> 和一个包含<strong>非空</strong>单词列表的字典 <em>wordDict*，判定 *s</em> 是否可以被空格拆分为一个或多个在字典中出现的单词。</p>
 <a id="more"></a>

<p><strong>说明：</strong></p>
<ul>
<li>拆分时可以重复使用字典中的单词。</li>
<li>你可以假设字典中没有重复的单词。</li>
</ul>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: s &#x3D; &quot;leetcode&quot;, wordDict &#x3D; [&quot;leet&quot;, &quot;code&quot;]</span><br><span class="line">输出: true</span><br><span class="line">解释: 返回 true 因为 &quot;leetcode&quot; 可以被拆分成 &quot;leet code&quot;。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: s &#x3D; &quot;applepenapple&quot;, wordDict &#x3D; [&quot;apple&quot;, &quot;pen&quot;]</span><br><span class="line">输出: true</span><br><span class="line">解释: 返回 true 因为 &quot;applepenapple&quot; 可以被拆分成 &quot;apple pen apple&quot;。</span><br><span class="line">     注意你可以重复使用字典中的单词。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: s &#x3D; &quot;catsandog&quot;, wordDict &#x3D; [&quot;cats&quot;, &quot;dog&quot;, &quot;sand&quot;, &quot;and&quot;, &quot;cat&quot;]</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>

<p>我们定义 dp[i] 表示字符串 s 前 i 个字符组成s的字符串 s[0…i - 1] 是否能被空格拆分成若干个字典中出现的单词。对于字符串 s[0 … i - 1]，我们需要枚举每一个分割点，位置为 j ，将其分为两个字符串，得到 s[0 … j - 1]，s[j … i - 1]，如果两个字符串均合法，那么将其拼接起来的字符串同样合法。由于计算 dp[i] 时已经计算出了 dp[0 … i - 1] 的值，因此字符串 s[0 … j - 1] 是否合法由 dp[j] 可知，剩下的我们只用看 s[j … i - 1] 是否合法，因此得到如下转移方程：<br>$$<br>dp[i]=dp[j] &amp; &amp; checks(s[j…i-1])<br>$$<br>其中 checks(s[j…i-1]) 表示子串 s[j … i - 1] 是否出现在字典中。初始化dp[0] = true;</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> </span>&#123;</span><br><span class="line">        Set&lt;String&gt; set = <span class="keyword">new</span> HashSet(wordDict);</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="comment">//dp[i] 表示 s 中 以 下标 i-1 结尾的字符串可否被 wordDict 拆分</span></span><br><span class="line">        <span class="keyword">boolean</span>[] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[n+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; ++i)&#123;</span><br><span class="line">            <span class="comment">//利用下标 j 将 下标为 0 ~ i-1 的字符串分割成两个字符串,依次判断所有情况。</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;i; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dp[j] &amp;&amp; set.contains(s.substring(j,i)) )&#123;</span><br><span class="line">                    dp[i] = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度 O(n^2)，空间复杂度O(n)</p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode Medium</tag>
        <tag>字符串</tag>
        <tag>动态规划</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>制作m束花所需的最少天数</title>
    <url>/2021/05/09/%E5%88%B6%E4%BD%9Cm%E6%9D%9F%E8%8A%B1%E6%89%80%E9%9C%80%E7%9A%84%E6%9C%80%E5%B0%91%E5%A4%A9%E6%95%B0/</url>
    <content><![CDATA[<h4 id="1482-制作-m-束花所需的最少天数"><a href="#1482-制作-m-束花所需的最少天数" class="headerlink" title="1482. 制作 m 束花所需的最少天数"></a><a href="https://leetcode-cn.com/problems/minimum-number-of-days-to-make-m-bouquets/" target="_blank" rel="noopener">1482. 制作 m 束花所需的最少天数</a></h4><p>给你一个整数数组 <code>bloomDay</code>，以及两个整数 <code>m</code> 和 <code>k</code> 。</p>
<p>现需要制作 <code>m</code> 束花。制作花束时，需要使用花园中 <strong>相邻的 <code>k</code> 朵花</strong> 。</p>
<p>花园中有 <code>n</code> 朵花，第 <code>i</code> 朵花会在 <code>bloomDay[i]</code> 时盛开，<strong>恰好</strong> 可以用于 <strong>一束</strong> 花中。</p>
<p>请你返回从花园中摘 <code>m</code> 束花需要等待的最少的天数。如果不能摘到 <code>m</code> 束花则返回 <strong>-1</strong> 。</p>
 <a id="more"></a>

<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：bloomDay &#x3D; [1,10,3,10,2], m &#x3D; 3, k &#x3D; 1</span><br><span class="line">输出：3</span><br><span class="line">解释：让我们一起观察这三天的花开过程，x 表示花开，而 _ 表示花还未开。</span><br><span class="line">现在需要制作 3 束花，每束只需要 1 朵。</span><br><span class="line">1 天后：[x, _, _, _, _]   &#x2F;&#x2F; 只能制作 1 束花</span><br><span class="line">2 天后：[x, _, _, _, x]   &#x2F;&#x2F; 只能制作 2 束花</span><br><span class="line">3 天后：[x, _, x, _, x]   &#x2F;&#x2F; 可以制作 3 束花，答案为 3</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：bloomDay &#x3D; [1,10,3,10,2], m &#x3D; 3, k &#x3D; 2</span><br><span class="line">输出：-1</span><br><span class="line">解释：要制作 3 束花，每束需要 2 朵花，也就是一共需要 6 朵花。而花园中只有 5 朵花，无法满足制作要求，返回 -1 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：bloomDay &#x3D; [7,7,7,7,12,7,7], m &#x3D; 2, k &#x3D; 3</span><br><span class="line">输出：12</span><br><span class="line">解释：要制作 2 束花，每束需要 3 朵。</span><br><span class="line">花园在 7 天后和 12 天后的情况如下：</span><br><span class="line">7 天后：[x, x, x, x, _, x, x]</span><br><span class="line">可以用前 3 朵盛开的花制作第一束花。但不能使用后 3 朵盛开的花，因为它们不相邻。</span><br><span class="line">12 天后：[x, x, x, x, x, x, x]</span><br><span class="line">显然，我们可以用不同的方式制作两束花。</span><br></pre></td></tr></table></figure>

<p><strong>示例 4：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：bloomDay &#x3D; [1000000000,1000000000], m &#x3D; 1, k &#x3D; 1</span><br><span class="line">输出：1000000000</span><br><span class="line">解释：需要等 1000000000 天才能采到花来制作花束</span><br></pre></td></tr></table></figure>

<p><strong>示例 5：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：bloomDay &#x3D; [1,10,2,9,3,8,4,7,5,6], m &#x3D; 4, k &#x3D; 2</span><br><span class="line">输出：9</span><br></pre></td></tr></table></figure>

<p> <strong>提示：</strong></p>
<ul>
<li><code>bloomDay.length == n</code></li>
<li><code>1 &lt;= n &lt;= 10^5</code></li>
<li><code>1 &lt;= bloomDay[i] &lt;= 10^9</code></li>
<li><code>1 &lt;= m &lt;= 10^6</code></li>
<li><code>1 &lt;= k &lt;= n</code></li>
</ul>
<p><strong>方法一：二分查找</strong></p>
<p>为了计算制作花束的最少天数，首先需要实现一个辅助函数用于判断在给定的天数内能否制作出指定数量的花束。我们可以遍历数组 bloomDay，计算其中的长度为 k 且最大元素不超过 days 的补充和的连续子数组额数量，如果符合要求的不重合连续子数组的数量大于或等于 m 则返回 True，否则返回 false。</p>
<p>当 days 很小时，辅助函数总是返回 false，引文天数太少不能收齐 m 个花束；当 days 很大的时候辅助函数总是返回 true，如果给定的序列可以制作出 m 个花束。在 days 慢慢变大的过程中，辅助函数的返回值会从false变为 true，所以我们可以认为这个辅助函数是关于 days 递增的，于是可以通过二分查找得到最少天数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDays</span><span class="params">(<span class="keyword">int</span>[] bloomDay, <span class="keyword">int</span> m, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(k * m &gt; bloomDay.length)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">1</span>, high = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> length = bloomDay.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++)&#123;</span><br><span class="line">            high = Math.max(high, bloomDay[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(low &lt; high)&#123;</span><br><span class="line">            <span class="keyword">int</span> days = (high - low) / <span class="number">2</span> + low;</span><br><span class="line">            <span class="keyword">if</span>(canMake(bloomDay, days, m, k))&#123;</span><br><span class="line">                high = days;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="comment">//从左向右逼近</span></span><br><span class="line">                low = days + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> low;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">canMake</span><span class="params">(<span class="keyword">int</span>[] bloomDay, <span class="keyword">int</span> days, <span class="keyword">int</span> m, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> bouquets = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> flowers = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> length = bloomDay.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length &amp;&amp; bouquets &lt; m; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(bloomDay[i] &lt;= days)&#123;</span><br><span class="line">                flowers++;</span><br><span class="line">                <span class="keyword">if</span>(flowers == k)&#123;</span><br><span class="line">                    bouquets++;</span><br><span class="line">                    flowers = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                flowers = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bouquets &gt;= m;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度 <em>O</em>(<em>n</em>log<em>h</em>) ，n 是数组 bloomDay 的长度，h 是数组 bloomDay 中的最大值。</li>
<li>空间复杂度O(1)</li>
</ul>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode Medium</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划总结</title>
    <url>/2021/07/31/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h3 id="坐标型动态规划"><a href="#坐标型动态规划" class="headerlink" title="坐标型动态规划"></a>坐标型动态规划</h3><p>是最简单的动态规划类型，通常给定一个序列或网格，记为 A。需要找到序列中某个/些子序列或网格中的某条路径</p>
<ol>
<li>某种性质最大/最小</li>
<li>计数</li>
<li>存在性</li>
</ol>
<a id="more"></a>

<p>动态规划方程 <code>f[i]</code>中的下标 <code>i</code>表示以<code>A[i]</code>为结尾的满足条件的子序列性质，<code>f[i][j]</code>中的下标<code>i, j</code>表示以<code>A[i][j]</code>为结尾的满足条件的路径的性质。这些性质可能是：</p>
<ul>
<li>最大值/最小值</li>
<li>个数</li>
<li>是否存在</li>
</ul>
<p>坐标型动态规划的初始条件<code>f[0]</code>就是指以<code>A[0]</code>为结尾的子序列的性质，对于网格，初始条件<code>f[0][0]</code>就是以<code>A[0][0]</code>为结尾的子序列的性质。</p>
<p><a href="https://leetcode-cn.com/problems/longest-continuous-increasing-subsequence/" target="_blank" rel="noopener">674. 最长连续递增序列</a></p>
<p><a href="https://leetcode-cn.com/problems/minimum-path-sum/" target="_blank" rel="noopener">64. 最小路径和</a></p>
<p><a href="https://www.lintcode.com/problem/553/" target="_blank" rel="noopener">553 · 炸弹袭击 - LintCode</a></p>
<h3 id="序列型动态规划"><a href="#序列型动态规划" class="headerlink" title="序列型动态规划"></a>序列型动态规划</h3><p>给定一个序列，动态规划方程 <code>f[i]</code>中的下标 <code>i</code>表示前 <code>i</code>个元素 A[0], A[1], …, A[i - 1]的某种性质，初始化时<code>f[0]</code>表示空序列的性质。</p>
<p><a href="https://www.lintcode.com/problem/516/" target="_blank" rel="noopener">516 · 房屋染色 II - LintCode</a></p>
<p><a href="https://www.lintcode.com/problem/392/" target="_blank" rel="noopener">392 · 打劫房屋 - LintCode</a></p>
<p><a href="https://www.lintcode.com/problem/534/" target="_blank" rel="noopener">534 · 打劫房屋 II - LintCode</a></p>
<p><a href="https://www.lintcode.com/problem/149/" target="_blank" rel="noopener">149 · 买卖股票的最佳时机 - LintCode</a></p>
<p><a href="https://www.lintcode.com/problem/150/" target="_blank" rel="noopener">150 · 买卖股票的最佳时机 II - LintCode</a></p>
<p><a href="https://www.lintcode.com/problem/151/" target="_blank" rel="noopener">151 · 买卖股票的最佳时机 III - LintCode</a></p>
<p><a href="https://www.lintcode.com/problem/393/" target="_blank" rel="noopener">393 · 买卖股票的最佳时机 IV - LintCode</a></p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20210803154845696.png" alt="image-20210803154845696"></p>
<h3 id="最长序列型动态规划"><a href="#最长序列型动态规划" class="headerlink" title="最长序列型动态规划"></a>最长序列型动态规划</h3><p>给定一个序列，要求找出符合条件的最长子序列</p>
<p>方法：</p>
<ul>
<li>记录以每个元素 i 结尾的最长子序列的长度</li>
<li>计算时，在 i 之前枚举子序列的上一个元素</li>
</ul>
<p><a href="https://www.lintcode.com/problem/397/" target="_blank" rel="noopener">397 · 最长上升连续子序列 - LintCode</a></p>
<p><a href="https://www.lintcode.com/problem/76/" target="_blank" rel="noopener">76 · 最长上升子序列 - LintCode</a></p>
<p><a href="https://www.lintcode.com/problem/602/" target="_blank" rel="noopener">602 · 俄罗斯套娃信封 - LintCode</a></p>
<h3 id="划分型动态规划"><a href="#划分型动态规划" class="headerlink" title="划分型动态规划"></a>划分型动态规划</h3><p><a href="https://www.lintcode.com/problem/513" target="_blank" rel="noopener">513 · 完美平方 - LintCode</a></p>
<p><a href="https://www.lintcode.com/problem/108/" target="_blank" rel="noopener">108 · 分割回文串（二） - LintCode</a></p>
<p><a href="https://www.lintcode.com/problem/437/" target="_blank" rel="noopener">437 · 书籍复印 - LintCode</a></p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20210803155745658.png" alt="image-20210803155745658"></p>
<h3 id="博弈型动态规划"><a href="#博弈型动态规划" class="headerlink" title="博弈型动态规划"></a>博弈型动态规划</h3><p><a href="https://www.lintcode.com/problem/394/" target="_blank" rel="noopener">394 · 硬币排成线 - LintCode</a></p>
<h3 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h3><p><a href="https://www.lintcode.com/problem/92/" target="_blank" rel="noopener">92 · 背包问题 - LintCode</a></p>
<p><a href="https://www.lintcode.com/problem/563/" target="_blank" rel="noopener">563 · 背包问题 V - LintCode</a></p>
<p><a href="https://www.lintcode.com/problem/564/" target="_blank" rel="noopener">564 · 组合总和 IV - LintCode</a></p>
<p><a href="https://www.lintcode.com/problem/125/" target="_blank" rel="noopener">125 · 背包问题（二） - LintCode</a></p>
<p><a href="https://www.lintcode.com/problem/440/" target="_blank" rel="noopener">440 · 背包问题 III - LintCode</a></p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20210805110903881.png" alt="image-20210805110903881"></p>
<h3 id="区间型动态规划"><a href="#区间型动态规划" class="headerlink" title="区间型动态规划"></a>区间型动态规划</h3><p>给定一个序列/字符串，进行一些操作，最后一步将序列/字符串去头去尾， 剩下的会是一个区间<code>[i, j]</code>，状态自然定义为 <code>f[i][j]</code>，表示面对子序列<code>[i, ..., j]</code>时的最优性质。</p>
<p>  <a href="https://www.lintcode.com/problem/667/" target="_blank" rel="noopener">667 · 最长的回文序列 - LintCode</a></p>
<p><a href="https://www.lintcode.com/problem/396/" target="_blank" rel="noopener">396 · 硬币排成线 III - LintCode</a></p>
<p><a href="https://www.lintcode.com/problem/430/" target="_blank" rel="noopener">430 · 攀爬字符串 - LintCode</a></p>
<p><a href="https://www.lintcode.com/problem/168/" target="_blank" rel="noopener">168 · 吹气球 - LintCode</a></p>
<h3 id="双序列型动态规划"><a href="#双序列型动态规划" class="headerlink" title="双序列型动态规划"></a>双序列型动态规划</h3><p><a href="https://www.lintcode.com/problem/77" target="_blank" rel="noopener">77 · 最长公共子序列 - LintCode</a></p>
<p><a href="https://www.lintcode.com/problem/29" target="_blank" rel="noopener">29 · 交叉字符串 - LintCode</a></p>
<p><a href="https://www.lintcode.com/problem/119" target="_blank" rel="noopener">119 · 编辑距离 - LintCode</a></p>
<p><a href="https://www.lintcode.com/problem/118/" target="_blank" rel="noopener">118 · 不同的子序列 - LintCode</a></p>
<p><a href="https://www.lintcode.com/problem/154/" target="_blank" rel="noopener">154 · 正则表达式匹配 - LintCode</a></p>
<p><a href="https://www.lintcode.com/problem/192/" target="_blank" rel="noopener">192 · 通配符匹配 - LintCode</a></p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20210808203541323.png" alt="image-20210808203541323"></p>
<p><a href="https://www.lintcode.com/problem/668/" target="_blank" rel="noopener">668 · 一和零 - LintCode</a></p>
<p><a href="https://www.lintcode.com/problem/91/" target="_blank" rel="noopener">91 · 最小调整代价 - LintCode</a></p>
<p><a href="https://www.lintcode.com/problem/622/" target="_blank" rel="noopener">622 · 青蛙跳 - LintCode</a></p>
<p><a href="https://www.lintcode.com/problem/436/" target="_blank" rel="noopener">436 · 最大正方形 - LintCode</a></p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>只出现一次的数字</title>
    <url>/2020/04/09/%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<h4 id="136-只出现一次的数字"><a href="#136-只出现一次的数字" class="headerlink" title="136. 只出现一次的数字"></a><a href="https://leetcode-cn.com/problems/single-number/" target="_blank" rel="noopener">136. 只出现一次的数字</a></h4><p>给定一个<strong>非空</strong>整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p>
 <a id="more"></a>

<p><strong>说明：</strong></p>
<p>你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [2,2,1]</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [4,1,2,1,2]</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure>

<p>使用异或，2^2 = 0，0 ^ n = n。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; ++i)&#123;</span><br><span class="line">            res ^= nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度O(n)，空间复杂度O(1)。</p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode Easy</tag>
        <tag>数组</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>和为K的子数组</title>
    <url>/2020/08/10/%E5%92%8C%E4%B8%BAK%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h4 id="560-和为K的子数组"><a href="#560-和为K的子数组" class="headerlink" title="560. 和为K的子数组"></a><a href="https://leetcode-cn.com/problems/subarray-sum-equals-k/" target="_blank" rel="noopener">560. 和为K的子数组</a></h4><p>给定一个整数数组和一个整数 <strong>k，</strong>你需要找到该数组中和为 <strong>k</strong> 的连续的子数组的个数。</p>
<a id="more"></a>

<p><strong>示例 1 :</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:nums &#x3D; [1,1,1], k &#x3D; 2</span><br><span class="line">输出: 2 , [1,1] 与 [1,1] 为两种不同的情况。</span><br></pre></td></tr></table></figure>

<p><strong>说明 :</strong></p>
<ol>
<li>数组的长度为 [1, 20,000]。</li>
<li>数组中元素的范围是 [-1000, 1000] ，且整数 <strong>k</strong> 的范围是 [-1e7, 1e7]。</li>
</ol>
<p><strong>方法一：暴力</strong></p>
<p>考虑以 i 结尾和为 k 的连续子数组个数，我们需要统计符合条件的下标 j 的个数，其中 <code>0 &lt;= j &lt;= i</code>，且<code>[j...i]</code>这个子数组的和恰好为 k。我们可以枚举 j 的值，然后再使用 O(n)的时间复杂度来求和，那样就达到O(n^3) 时间复杂度。如果我们知道<code>[j, i]</code>子数组的和，就能在O(1)时间求出<code>[j - 1, i]</code>子数组的和，因此我们初始时令 j = i，在循环中使 j 变小，同时维护一个数组和 sum。我们就能在O(1)时间内得到子数组<code>[j...i]</code>的和。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">subarraySum</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &gt;= <span class="number">0</span>; --j)&#123;</span><br><span class="line">                sum += nums[j];</span><br><span class="line">                <span class="keyword">if</span>(sum == k)&#123;</span><br><span class="line">                    ++count;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度O(n^2)，空间复杂度O(1)。</p>
<p><strong>方法二：前缀和+哈希表优化</strong></p>
<p>我们定义 pre[i] 为 [0 … i] 内所有数的和，则有：<br>$$<br>pre[i] = pre[i - 1] + nums[i]<br>$$<br>那么 [j … i]子数组为 k ，这个条件可以转化为：<br>$$<br>pre[i] - pre[j - 1] == k<br>$$<br>简单移项得到：<br>$$<br>pre[j - 1] == pre[i] - k<br>$$<br>我们考虑 以 i 结尾的和为 k 的连续子数组时，只要统计有多少个前缀和为 pre[i] - k 的 pre[j] 即可。我们建立哈希表 map，使用和为键，出现的次数为相应的值，记录pre[i] 出现的次数，从左至右边更新 map，同时维护一个前缀和变量 pre，这样在计算 pre[i]时直接使用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">subarraySum</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>, pre = <span class="number">0</span>;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">//初始值，和为 0 的子数组个数为 1</span></span><br><span class="line">        map.put(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; ++i)&#123;</span><br><span class="line">            <span class="comment">//计算 pre[i]</span></span><br><span class="line">            pre += nums[i];</span><br><span class="line">            <span class="comment">//找到和为 pre[i] - k 子数组个数 </span></span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(pre - k))&#123;</span><br><span class="line">                count += map.get(pre - k);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//更新 pre[i] 和的个数</span></span><br><span class="line">            map.put(pre, map.getOrDefault(pre, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度O(n)，空间复杂度O(n)。</p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode Medium</tag>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title>和可被 K 整除的子数组</title>
    <url>/2020/07/01/%E5%92%8C%E5%8F%AF%E8%A2%AB-K-%E6%95%B4%E9%99%A4%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h4 id="974-和可被-K-整除的子数组"><a href="#974-和可被-K-整除的子数组" class="headerlink" title="974. 和可被 K 整除的子数组"></a><a href="https://leetcode-cn.com/problems/subarray-sums-divisible-by-k/" target="_blank" rel="noopener">974. 和可被 K 整除的子数组</a></h4><p>给定一个整数数组 <code>A</code>，返回其中元素之和可被 <code>K</code> 整除的（连续、非空）子数组的数目。</p>
 <a id="more"></a>

<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：A &#x3D; [4,5,0,-2,-3,1], K &#x3D; 5</span><br><span class="line">输出：7</span><br><span class="line">解释：</span><br><span class="line">有 7 个子数组满足其元素之和可被 K &#x3D; 5 整除：</span><br><span class="line">[4, 5, 0, -2, -3, 1], [5], [5, 0], [5, 0, -2, -3], [0], [0, -2, -3], [-2, -3]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ol>
<li><code>1 &lt;= A.length &lt;= 30000</code></li>
<li><code>-10000 &lt;= A[i] &lt;= 10000</code></li>
<li><code>2 &lt;= K &lt;= 10000</code></li>
</ol>
<p>暴力解法：使用两个循环枚举子数组的起点和终点，统计子数组的和并判断是否整除 k 。时间复杂度 O(n^3) 空间复杂度 O(1)。</p>
<p>暴力解法优化：使用一个数组存储前缀和 p[i] 表示[0…i]的数字之和，p[j] - p[i] 表示一个子数组的和。时间复杂度 O(n^2) 空间复杂度 O(n)。</p>
<p>哈希表：使用哈希表存储，以前缀和模 K 的值为键，其值出现的次数为值。在遍历数组的同时更新。我们需要对哈希表初始化，即余数为 0 出现的次数为 1 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">subarraysDivByK</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; record = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        record.put(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> e : A)&#123;</span><br><span class="line">            sum += e;</span><br><span class="line">            <span class="comment">//Java 负数取模产生负数，需要纠正</span></span><br><span class="line">            <span class="keyword">int</span> mod = (sum % K + K) % K;</span><br><span class="line">            <span class="comment">//得到前缀和模 K 的值出现的次数</span></span><br><span class="line">            <span class="keyword">int</span> times = record.getOrDefault(mod, <span class="number">0</span>);</span><br><span class="line">            <span class="comment">//更新结果和以 mod 为余数的前缀和出现的次数</span></span><br><span class="line">            ans += times;</span><br><span class="line">            record.put(mod, times + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度 O(n) 遍历一次数组，空间复杂度 O( min (n, k) ) 模 k 得到的余数最多有 k 个。</p>
<p>我们还可以先生成哈希表，得到前缀和模 k 的值出现的次数 n，对于这个值，和可被 k 整除的子数组的个数为 n(n-1)/2，类似于冒泡排序的两两比较。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">subarraysDivByK</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; record = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">        record.put(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> e : A)&#123;</span><br><span class="line">            sum += e;</span><br><span class="line">            <span class="comment">//Java 负数取模产生负数，需要纠正</span></span><br><span class="line">            <span class="keyword">int</span> mod = (sum % K + K) % K;</span><br><span class="line">            record.put(mod, record.getOrDefault(mod, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;Integer, Integer&gt; entry : record.entrySet())&#123;</span><br><span class="line">            ans += entry.getValue() * (entry.getValue() - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度和空间复杂度同上。</p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode Medium</tag>
        <tag>哈希表</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>四数相加II</title>
    <url>/2020/11/27/%E5%9B%9B%E6%95%B0%E7%9B%B8%E5%8A%A0II/</url>
    <content><![CDATA[<h4 id="454-四数相加-II"><a href="#454-四数相加-II" class="headerlink" title="454. 四数相加 II"></a><a href="https://leetcode-cn.com/problems/4sum-ii/" target="_blank" rel="noopener">454. 四数相加 II</a></h4><p>给定四个包含整数的数组列表 A , B , C , D ,计算有多少个元组 <code>(i, j, k, l)</code> ，使得 <code>A[i] + B[j] + C[k] + D[l] = 0</code>。</p>
<p>为了使问题简单化，所有的 A, B, C, D 具有相同的长度 N，且 0 ≤ N ≤ 500 。所有整数的范围在 -2^28 到 2^28 - 1 之间，最终结果不会超过 2^31 - 1 。</p>
<a id="more"></a>

<p><strong>例如:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">A &#x3D; [ 1, 2]</span><br><span class="line">B &#x3D; [-2,-1]</span><br><span class="line">C &#x3D; [-1, 2]</span><br><span class="line">D &#x3D; [ 0, 2]</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line">2</span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line">两个元组如下:</span><br><span class="line">1. (0, 0, 0, 1) -&gt; A[0] + B[0] + C[0] + D[1] &#x3D; 1 + (-2) + (-1) + 2 &#x3D; 0</span><br><span class="line">2. (1, 1, 0, 0) -&gt; A[1] + B[1] + C[0] + D[0] &#x3D; 2 + (-1) + (-1) + 0 &#x3D; 0</span><br></pre></td></tr></table></figure>

<p><strong>方法一：哈希表</strong></p>
<p>我们首先将数组 A 和 B 的每个元素组合<code>A[i] + A[j]</code>出现次数加入哈希表，然后计算数组 C 和数组 D的组合<code>C[m] + D[n]</code>，如果哈希表中包含<code>-(C[m] + D[n])</code>，将哈希表中出现的次数加入结果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fourSumCount</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span>[] B, <span class="keyword">int</span>[] C, <span class="keyword">int</span>[] D)</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; countAB = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> n : A)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> m : B)&#123;</span><br><span class="line">                countAB.put(n + m, countAB.getOrDefault(n + m, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> n : C)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> m : D)&#123;</span><br><span class="line">                <span class="keyword">if</span>(countAB.containsKey(- n - m))&#123;</span><br><span class="line">                    ans += countAB.get(-n -m);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度O(n^2)</li>
<li>空间复杂度O(n^2)</li>
</ul>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode Medium</tag>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title>回文子串</title>
    <url>/2020/08/19/%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/</url>
    <content><![CDATA[<h4 id="647-回文子串"><a href="#647-回文子串" class="headerlink" title="647. 回文子串"></a><a href="https://leetcode-cn.com/problems/palindromic-substrings/" target="_blank" rel="noopener">647. 回文子串</a></h4><p>给定一个字符串，你的任务是计算这个字符串中有多少个回文子串。</p>
<p>具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。</p>
 <a id="more"></a>

<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：&quot;abc&quot;</span><br><span class="line">输出：3</span><br><span class="line">解释：三个回文子串: &quot;a&quot;, &quot;b&quot;, &quot;c&quot;</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：&quot;aaa&quot;</span><br><span class="line">输出：6</span><br><span class="line">解释：6个回文子串: &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;aa&quot;, &quot;aa&quot;, &quot;aaa&quot;</span><br></pre></td></tr></table></figure>

<p> <strong>提示：</strong></p>
<ul>
<li>输入的字符串长度不会超过 1000 。</li>
</ul>
<p>我们枚举每一个可能的回文中心，然后用两个指针分别向左右两边拓展，当两个指针指向的元素相同时就拓展，否则就停止拓展。</p>
<p>当回文长度为奇数时，回文中心就是一个字符；当回文长度为偶数时，回文中心为两个字符。一个长度为 n 的字符串，可能的回文中心有 2n - 1 个。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countSubstrings</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>, n = s.length();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; n; index++)&#123;</span><br><span class="line">            <span class="comment">//回文长度为奇数</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = index, k = index; j &gt;= <span class="number">0</span> &amp;&amp; k &lt; n; j--, k++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s.charAt(j) == s.charAt(k))&#123;</span><br><span class="line">                    ++count;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">			<span class="comment">//回文长度为偶数</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = index, k = index + <span class="number">1</span>; j &gt;= <span class="number">0</span> &amp;&amp; k &lt; n; j--, k++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s.charAt(j) == s.charAt(k))&#123;</span><br><span class="line">                    ++count;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以将回文长度为奇数和偶数的两种情况合在一起，我们令 <code>0 &lt;= index &lt; 2n - 1</code>，回文中心<code>(j, k)</code>，其中<code>j = index / 2, k = j + (index mod 2)</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countSubstrings</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>, n = s.length();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; <span class="number">2</span> * n - <span class="number">1</span>; index++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = index / <span class="number">2</span>, k = index / <span class="number">2</span> + index % <span class="number">2</span>; j &gt;= <span class="number">0</span> &amp;&amp; k &lt; n; j--, k++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s.charAt(j) == s.charAt(k))&#123;</span><br><span class="line">                    ++count;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度O(n^2)，空间复杂度O(1)。</p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode Medium</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>在圆内随机生成点</title>
    <url>/2020/07/28/%E5%9C%A8%E5%9C%86%E5%86%85%E9%9A%8F%E6%9C%BA%E7%94%9F%E6%88%90%E7%82%B9/</url>
    <content><![CDATA[<h4 id="478-在圆内随机生成点"><a href="#478-在圆内随机生成点" class="headerlink" title="478. 在圆内随机生成点"></a><a href="https://leetcode-cn.com/problems/generate-random-point-in-a-circle/" target="_blank" rel="noopener">478. 在圆内随机生成点</a></h4><p>给定圆的半径和圆心的 x、y 坐标，写一个在圆中产生均匀随机点的函数 <code>randPoint</code> 。</p>
<p>说明:</p>
<ol>
<li>输入值和输出值都将是<a href="https://baike.baidu.com/item/浮点数/6162520" target="_blank" rel="noopener">浮点数</a>。</li>
<li>圆的半径和圆心的 x、y 坐标将作为参数传递给类的构造函数。</li>
<li>圆周上的点也认为是在圆中。</li>
<li><code>randPoint</code> 返回一个包含随机点的x坐标和y坐标的大小为2的数组。</li>
</ol>
<a id="more"></a>

<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: </span><br><span class="line">[&quot;Solution&quot;,&quot;randPoint&quot;,&quot;randPoint&quot;,&quot;randPoint&quot;]</span><br><span class="line">[[1,0,0],[],[],[]]</span><br><span class="line">输出: [null,[-0.72939,-0.65505],[-0.78502,-0.28626],[-0.83119,-0.19803]]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: </span><br><span class="line">[&quot;Solution&quot;,&quot;randPoint&quot;,&quot;randPoint&quot;,&quot;randPoint&quot;]</span><br><span class="line">[[10,5,-7.5],[],[],[]]</span><br><span class="line">输出: [null,[11.52438,-8.33273],[2.46992,-16.21705],[11.13430,-12.42337]]</span><br></pre></td></tr></table></figure>

<p><strong>输入语法说明：</strong></p>
<p>输入是两个列表：调用成员函数名和调用的参数。<code>Solution</code> 的构造函数有三个参数，圆的半径、圆心的 x 坐标、圆心的 y 坐标。<code>randPoint</code> 没有参数。输入参数是一个列表，即使参数为空，也会输入一个 [] 空列表。</p>
<p><strong>方法一：拒绝采样</strong></p>
<p>在矩形中随机生成一个点的方法：随机选取一个 0 ~ 1的浮点数，乘以矩形的边长。使用该方法生成随机点的横纵坐标。我们可以得到第一种在圆内生成随机点的方法，即在这个圆外画一个外接矩形，在矩形内生成随机点，拒绝掉那些落在圆外的点，得到结果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> xc, yc, rad;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Solution</span><span class="params">(<span class="keyword">double</span> radius, <span class="keyword">double</span> x_center, <span class="keyword">double</span> y_center)</span> </span>&#123;</span><br><span class="line">        xc = x_center;</span><br><span class="line">        yc = y_center;</span><br><span class="line">        rad = radius;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">double</span>[] randPoint() &#123;</span><br><span class="line">        <span class="comment">//获得坐标原点的坐标(矩形的一个角的坐标)</span></span><br><span class="line">        <span class="keyword">double</span> x0 = xc - rad;</span><br><span class="line">        <span class="keyword">double</span> y0 = yc - rad;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="comment">//在矩形中生成随机点(xr, yr)</span></span><br><span class="line">            <span class="keyword">double</span> xr = x0 + Math.random() * rad * <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">double</span> yr = y0 + Math.random() * rad * <span class="number">2</span>;</span><br><span class="line">            <span class="comment">//拒绝掉不在圆内的随机点</span></span><br><span class="line">            <span class="keyword">if</span>(Math.sqrt(Math.pow(xr - xc, <span class="number">2</span>) + Math.pow(yr - yc, <span class="number">2</span>)) &lt; rad)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">double</span>[]&#123;xr, yr&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Solution object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * Solution obj = new Solution(radius, x_center, y_center);</span></span><br><span class="line"><span class="comment"> * double[] param_1 = obj.randPoint();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<p>期望时间复杂度O(1)，最坏的情况是一直被拒绝，时间复杂度为O(n)。</p>
<p>空间复杂度为O(1)。</p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>Leetcode Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>图像渲染</title>
    <url>/2020/08/16/%E5%9B%BE%E5%83%8F%E6%B8%B2%E6%9F%93/</url>
    <content><![CDATA[<h4 id="733-图像渲染"><a href="#733-图像渲染" class="headerlink" title="733. 图像渲染"></a><a href="https://leetcode-cn.com/problems/flood-fill/" target="_blank" rel="noopener">733. 图像渲染</a></h4><p>有一幅以二维整数数组表示的图画，每一个整数表示该图画的像素值大小，数值在 0 到 65535 之间。</p>
<p>给你一个坐标 <code>(sr, sc)</code> 表示图像渲染开始的像素值（行 ，列）和一个新的颜色值 <code>newColor</code>，让你重新上色这幅图像。</p>
<p>为了完成上色工作，从初始坐标开始，记录初始坐标的上下左右四个方向上像素值与初始坐标相同的相连像素点，接着再记录这四个方向上符合条件的像素点与他们对应四个方向上像素值与初始坐标相同的相连像素点，……，重复该过程。将所有有记录的像素点的颜色值改为新的颜色值。</p>
<p>最后返回经过上色渲染后的图像。</p>
<a id="more"></a>

<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: </span><br><span class="line">image &#x3D; [[1,1,1],[1,1,0],[1,0,1]]</span><br><span class="line">sr &#x3D; 1, sc &#x3D; 1, newColor &#x3D; 2</span><br><span class="line">输出: [[2,2,2],[2,2,0],[2,0,1]]</span><br><span class="line">解析: </span><br><span class="line">在图像的正中间，(坐标(sr,sc)&#x3D;(1,1)),</span><br><span class="line">在路径上所有符合条件的像素点的颜色都被更改成2。</span><br><span class="line">注意，右下角的像素没有更改为2，</span><br><span class="line">因为它不是在上下左右四个方向上与初始点相连的像素点。</span><br></pre></td></tr></table></figure>

<p><strong>注意:</strong></p>
<ul>
<li><code>image</code> 和 <code>image[0]</code> 的长度在范围 <code>[1, 50]</code> 内。</li>
<li>给出的初始点将满足 <code>0 &lt;= sr &lt; image.length</code> 和 <code>0 &lt;= sc &lt; image[0].length</code>。</li>
<li><code>image[i][j]</code> 和 <code>newColor</code> 表示的颜色值在范围 <code>[0, 65535]</code>内。</li>
</ul>
<p><strong>方法一：DFS</strong></p>
<p>我们从起点开始进行深度优先搜索，每搜索到一个方格时，如果它的颜色与初始位置的方格颜色相同，我们就将其颜色改为新的颜色，并继续搜索。</p>
<p><strong>注意</strong>：在初始颜色和新颜色相同的情况下会造成死循环，仔细思考，这种情况不需要任何改变，直接返回。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m, n;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] floodFill(<span class="keyword">int</span>[][] image, <span class="keyword">int</span> sr, <span class="keyword">int</span> sc, <span class="keyword">int</span> newColor) &#123;</span><br><span class="line">        m = image.length;</span><br><span class="line">        n = image[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(image[sr][sc] != newColor)&#123;</span><br><span class="line">            fill(image, image[sr][sc], newColor, sr, sc);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> image;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fill</span><span class="params">(<span class="keyword">int</span>[][] image, <span class="keyword">int</span> originColor, <span class="keyword">int</span> newColor, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x &lt; <span class="number">0</span> || x &gt;= m || y &lt; <span class="number">0</span> || y &gt;= n || image[x][y] != originColor)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        image[x][y] = newColor;</span><br><span class="line">        fill(image, originColor, newColor, x + <span class="number">1</span>, y);</span><br><span class="line">        fill(image, originColor, newColor, x - <span class="number">1</span>, y);</span><br><span class="line">        fill(image, originColor, newColor, x, y + <span class="number">1</span>);</span><br><span class="line">        fill(image, originColor, newColor, x, y - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度O(mn)，空间复杂度O(mn)。m 和 n 为图像的长宽。</p>
<p><strong>方法二：BFS</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] dx = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span>[] dy = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] floodFill(<span class="keyword">int</span>[][] image, <span class="keyword">int</span> sr, <span class="keyword">int</span> sc, <span class="keyword">int</span> newColor) &#123;</span><br><span class="line">        <span class="keyword">int</span> originColor = image[sr][sc];</span><br><span class="line">        <span class="keyword">if</span>(originColor == newColor)&#123;</span><br><span class="line">            <span class="keyword">return</span> image;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> m = image.length, n = image[<span class="number">0</span>].length;</span><br><span class="line">        Queue&lt;<span class="keyword">int</span>[]&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;sr, sc&#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span>[] point = queue.poll();</span><br><span class="line">            image[point[<span class="number">0</span>]][point[<span class="number">1</span>]] = newColor;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)&#123;</span><br><span class="line">                <span class="keyword">int</span> mx = point[<span class="number">0</span>] + dx[i];</span><br><span class="line">                <span class="keyword">int</span> my = point[<span class="number">1</span>] + dy[i];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(mx &gt;= <span class="number">0</span> &amp;&amp; mx &lt; m &amp;&amp; my &gt;= <span class="number">0</span> &amp;&amp; my &lt; n &amp;&amp; image[mx][my] == originColor)&#123;</span><br><span class="line">                    queue.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;mx, my&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> image;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度O(mn)，空间复杂度O(mn)。m 和 n 为图像的长宽。</p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode Easy</tag>
        <tag>DFS</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title>基本计算器</title>
    <url>/2021/03/10/%E5%9F%BA%E6%9C%AC%E8%AE%A1%E7%AE%97%E5%99%A8/</url>
    <content><![CDATA[<h4 id="224-基本计算器"><a href="#224-基本计算器" class="headerlink" title="224. 基本计算器"></a><a href="https://leetcode-cn.com/problems/basic-calculator/" target="_blank" rel="noopener">224. 基本计算器</a></h4><p>实现一个基本的计算器来计算一个简单的字符串表达式 <code>s</code> 的值。</p>
 <a id="more"></a>

<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;1 + 1&quot;</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot; 2-1 + 2 &quot;</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;(1+(4+5+2)-3)+(6+8)&quot;</span><br><span class="line">输出：23</span><br></pre></td></tr></table></figure>

<p> <strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 3 * 105</code></li>
<li><code>s</code> 由数字、<code>&#39;+&#39;</code>、<code>&#39;-&#39;</code>、<code>&#39;(&#39;</code>、<code>&#39;)&#39;</code>、和 <code>&#39; &#39;</code> 组成</li>
<li><code>s</code> 表示一个有效的表达式</li>
</ul>
<p><strong>方法一：栈</strong></p>
<p>基本计算器只包含加减法，括号对一个数只影响其正负。以示例三为例：</p>
<ul>
<li>数字 1 前面没有符号，记为 +1</li>
<li>数字 4 前面有一个 + 号，记为 +4</li>
<li>数字 5 和 数字 2 前面有两个 + 号，记为 +5，+2</li>
<li>数字 3 前面有一个 + 号（<strong>不包括（4 + 5 + 2）里的 + 号</strong>）和一个 - 号，记为 -3</li>
<li>数字 6 前面有一个 + 号，记为 +6</li>
<li>数字 8 前面有两个 + 号，记为 + 8</li>
</ul>
<p>将这些数字加起来，我们得到最终结果 23。</p>
<p>我们使用一个栈 ops 来记录当前位置所处的每个括号所共同形成的符号，同时使用 sign 来表示当前的符号（sign 为 1 代表正数）。</p>
<p>如果当前遇到了 + 号，当前符号为 ops.peek()；如果当前遇到了 - 号，当前符号为 - ops.peek()。</p>
<p>每当遇到 ( 时，都要将当前 sign 取值压入栈中；每当遇到 ）时，都从栈中弹出一个元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculate</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        Deque&lt;Integer&gt; ops = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">        ops.push(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> sign = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == <span class="string">' '</span>) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s.charAt(i) == <span class="string">'+'</span>) &#123;</span><br><span class="line">                sign = ops.peek();</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s.charAt(i) == <span class="string">'-'</span>) &#123;</span><br><span class="line">                sign = -ops.peek();</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s.charAt(i) == <span class="string">'('</span>) &#123;</span><br><span class="line">                ops.push(sign);</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s.charAt(i) == <span class="string">')'</span>) &#123;</span><br><span class="line">                ops.pop();</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">//遇到一个数，直接加入结果</span></span><br><span class="line">                <span class="keyword">long</span> num = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span> (i &lt; n &amp;&amp; Character.isDigit(s.charAt(i))) &#123;</span><br><span class="line">                    num = num * <span class="number">10</span> + s.charAt(i) - <span class="string">'0'</span>;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                ret += sign * num;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度O(n)</li>
<li>空间复杂度O(n)</li>
</ul>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode Hard</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>地下城游戏</title>
    <url>/2020/07/12/%E5%9C%B0%E4%B8%8B%E5%9F%8E%E6%B8%B8%E6%88%8F/</url>
    <content><![CDATA[<h4 id="174-地下城游戏"><a href="#174-地下城游戏" class="headerlink" title="174. 地下城游戏"></a><a href="https://leetcode-cn.com/problems/dungeon-game/" target="_blank" rel="noopener">174. 地下城游戏</a></h4><p>一些恶魔抓住了公主（<strong>P</strong>）并将她关在了地下城的右下角。地下城是由 M x N 个房间组成的二维网格。我们英勇的骑士（<strong>K</strong>）最初被安置在左上角的房间里，他必须穿过地下城并通过对抗恶魔来拯救公主。</p>
<p>骑士的初始健康点数为一个正整数。如果他的健康点数在某一时刻降至 0 或以下，他会立即死亡。</p>
<p>有些房间由恶魔守卫，因此骑士在进入这些房间时会失去健康点数（若房间里的值为<em>负整数</em>，则表示骑士将损失健康点数）；其他房间要么是空的（房间里的值为 <em>0</em>），要么包含增加骑士健康点数的魔法球（若房间里的值为<em>正整数</em>，则表示骑士将增加健康点数）。</p>
<p>为了尽快到达公主，骑士决定每次只向右或向下移动一步。</p>
 <a id="more"></a>

<p><strong>编写一个函数来计算确保骑士能够拯救到公主所需的最低初始健康点数。</strong></p>
<p>例如，考虑到如下布局的地下城，如果骑士遵循最佳路径 <code>右 -&gt; 右 -&gt; 下 -&gt; 下</code>，则骑士的初始健康点数至少为 <strong>7</strong>。</p>
<table>
<thead>
<tr>
<th>-2 (K)</th>
<th>-3</th>
<th>3</th>
</tr>
</thead>
<tbody><tr>
<td>-5</td>
<td>-10</td>
<td>1</td>
</tr>
<tr>
<td>10</td>
<td>30</td>
<td>-5 (P)</td>
</tr>
</tbody></table>
<p> <strong>说明:</strong></p>
<ul>
<li>骑士的健康点数没有上限。</li>
<li>任何房间都可能对骑士的健康点数造成威胁，也可能增加骑士的健康点数，包括骑士进入的左上角房间以及公主被监禁的右下角房间。</li>
</ul>
<p>很容易想到使用动态规划，我们先尝试从左上到右下的顺序进行动态规划，对于每一条路径，我们需要同时记录两个值。第一个是「从出发点到当前点的路径和」，第二个是「从出发点到当前点所需的最小初始值」，这两个值的重要程度相同。</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/uTlo1kQfOin2vp3.png" alt="image-20200712115157247"></p>
<ul>
<li>绿色路径，「从出发点到当前点的路径和」为 1 ，「从出发点到当前点所需的最小初始值」为 3。</li>
<li>蓝色路径，「从出发点到当前点的路径和」为 -1 ，「从出发点到当前点所需的最小初始值」为 2。</li>
</ul>
<p>我们应该选择绿色路径，因为蓝色路径的路径和太小，需要初始值为 4 才能到达终点 -2，而绿色路径只需要初始值为 3 即可到达终点 -2 。如果我们将终点 -2 换为 0，我们就应该选择蓝色路径，蓝色路径需要初始值为 2 ，绿色路径需要初始值为 3。</p>
<p>如果从左上到右下进行动态规划，我们无法确定到达(1, 2) 的方案，这样的动态规划是不满足「无后效性」的。</p>
<p>我们考虑从右下到左上进行动态规划。令<code>dp[i][j]</code>表示从坐标<code>(i, j)</code>到终点所需的最小初始值。当在坐标<code>(i, j)</code>时，如果此时路径和不小于<code>dp[i][j]</code>，我们就能到达终点。这样一来，我们就无需关心路径和，只需关注最小初始值。对于 <code>dp[i][j]</code>，我们只要关心<code>dp[i][j + 1]</code>和<code>dp[i + 1][j]</code>的最小值 <code>minn</code>。记当前格子的值为 <code>dungeon(i, j)</code>，那么在坐标<code>(i, j)</code>的初始值只要达到 <code>minn - dungeon(i, j)</code>即可。同时，初始值还必须大于 1 ，得到状态转移方程：<br>$$<br>dp[i][j] = max(min(dp[i + 1][j], dp[i][j + 1]) - dungeon(i, j), 1)<br>$$<br>最终答案为 <code>dp[0][0]</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculateMinimumHP</span><span class="params">(<span class="keyword">int</span>[][] dungeon)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> m = dungeon.length,  n = dungeon[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">//dp 边界无效值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; i++)&#123;</span><br><span class="line">            Arrays.fill(dp[i], Integer.MAX_VALUE);</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//初始条件，最小初始值为 1</span></span><br><span class="line">        dp[m][n - <span class="number">1</span>] = dp[m - <span class="number">1</span>][n] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = m - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = n - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--)&#123;</span><br><span class="line">                <span class="comment">//找出能到达终点的最小初始值</span></span><br><span class="line">                <span class="keyword">int</span> minn = Math.min(dp[i + <span class="number">1</span>][j], dp[i][j + <span class="number">1</span>]);</span><br><span class="line">                <span class="comment">//计算 dp[i][j] 的最小初始值</span></span><br><span class="line">                dp[i][j] = Math.max(minn - dungeon[i][j], <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度O(mn)，空间复杂度O(mn)。</p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode Hard</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>基本计算器II</title>
    <url>/2021/03/11/%E5%9F%BA%E6%9C%AC%E8%AE%A1%E7%AE%97%E5%99%A8II/</url>
    <content><![CDATA[<h4 id="227-基本计算器-II"><a href="#227-基本计算器-II" class="headerlink" title="227. 基本计算器 II"></a><a href="https://leetcode-cn.com/problems/basic-calculator-ii/" target="_blank" rel="noopener">227. 基本计算器 II</a></h4><p>给你一个字符串表达式 <code>s</code> ，请你实现一个基本计算器来计算并返回它的值。</p>
<p>整数除法仅保留整数部分。</p>
 <a id="more"></a>

<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;3+2*2&quot;</span><br><span class="line">输出：7</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot; 3&#x2F;2 &quot;</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot; 3+5 &#x2F; 2 &quot;</span><br><span class="line">输出：5</span><br></pre></td></tr></table></figure>

<p> <strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 3 * 105</code></li>
<li><code>s</code> 由整数和算符 <code>(&#39;+&#39;, &#39;-&#39;, &#39;*&#39;, &#39;/&#39;)</code> 组成，中间由一些空格隔开</li>
<li><code>s</code> 表示一个 <strong>有效表达式</strong></li>
<li>表达式中的所有整数都是非负整数，且在范围 <code>[0, 231 - 1]</code> 内</li>
<li>题目数据保证答案是一个 <strong>32-bit 整数</strong></li>
</ul>
<p>此题没有括号，乘除优先于加减计算，不妨先进行所有的乘除运算，并将这些乘除运算后的整数放回原来的位置，之后整个表达式的值，就等于一系列整数加减后的值。</p>
<p>我们可以使用一个栈来保存进行乘除运算后的整数的值。对于加减号后的数字，直接压入栈中；对于乘除号后的数字，直接与栈顶元素计算，并替换栈顶元素为计算后的结果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculate</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        Deque&lt;Integer&gt; stack = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">        <span class="comment">//第一个数字前的符号设置为 + ，直接将第一个数入栈</span></span><br><span class="line">        <span class="keyword">char</span> preSign = <span class="string">'+'</span>;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="comment">//将连续的数字字符转换为整数</span></span><br><span class="line">            <span class="keyword">if</span>(Character.isDigit(s.charAt(i)))&#123;</span><br><span class="line">                num = num * <span class="number">10</span> + s.charAt(i) - <span class="string">'0'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//当前字符不是数字或空格，或者当前是最后一个字符，计算最后结果	</span></span><br><span class="line">            <span class="keyword">if</span>(!Character.isDigit(s.charAt(i)) &amp;&amp; s.charAt(i) != <span class="string">' '</span> || i == n - <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">switch</span> (preSign) &#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">'+'</span>: stack.push(num); <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">'-'</span>: stack.push(-num); <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">'*'</span>: stack.push(stack.pop() * num); <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">'/'</span>: stack.push(stack.pop() / num); <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="comment">//更新符号和数字</span></span><br><span class="line">            num = <span class="number">0</span>;</span><br><span class="line">            preSign = s.charAt(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//将所有数字相加，得到最后结果</span></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">            ans += stack.pop();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode Medium</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>填充每个节点的下一个右侧节点指针</title>
    <url>/2020/10/15/%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8F%B3%E4%BE%A7%E8%8A%82%E7%82%B9%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<h4 id="116-填充每个节点的下一个右侧节点指针"><a href="#116-填充每个节点的下一个右侧节点指针" class="headerlink" title="116. 填充每个节点的下一个右侧节点指针"></a><a href="https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/" target="_blank" rel="noopener">116. 填充每个节点的下一个右侧节点指针</a></h4><p>给定一个<strong>完美二叉树</strong>，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct Node &#123;</span><br><span class="line">  int val;</span><br><span class="line">  Node *left;</span><br><span class="line">  Node *right;</span><br><span class="line">  Node *next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 <code>NULL</code>。</p>
<p>初始状态下，所有 next 指针都被设置为 <code>NULL</code>。</p>
<a id="more"></a>

<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20201015085236630.png" alt=""></p>
<p><strong>方法一：层次遍历</strong></p>
<p>在遍历每层时将同一层的结点连接起来。</p>
<ul>
<li>时间复杂度O(n)</li>
<li>空间复杂度O(n)</li>
</ul>
<p><strong>方法二：使用已建立的 next 指针</strong></p>
<p>我们使用 nextHead 指针保存下一层的头节点，nextTail 保存下一层的尾结点。使用 ptr 指针遍历当前层的结点，同时将下一层的结点连接成链表。令 ptr = nextHead，即可遍历下一层结点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Node nextHead = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> Node nextTail = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">connect</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        Node ptr = root;</span><br><span class="line">        <span class="keyword">while</span>(ptr != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//当前层开始访问时将下一层信息清空</span></span><br><span class="line">            nextHead = <span class="keyword">null</span>;</span><br><span class="line">            nextTail = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//连接</span></span><br><span class="line">            <span class="keyword">while</span>(ptr != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(ptr.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    helper(ptr.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(ptr.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    helper(ptr.right);</span><br><span class="line">                &#125;</span><br><span class="line">                ptr = ptr.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//进入下一层</span></span><br><span class="line">            ptr = nextHead;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(Node nextNode)</span></span>&#123;</span><br><span class="line">        <span class="comment">//维护下一层的头节点和尾结点</span></span><br><span class="line">        <span class="keyword">if</span>(nextHead == <span class="keyword">null</span>)&#123;</span><br><span class="line">        nextHead = nextNode;</span><br><span class="line">        nextTail = nextHead;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        nextTail.next = nextNode;</span><br><span class="line">        nextTail = nextTail.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度O(n)</li>
<li>空间复杂度O(1)</li>
</ul>
<p>注意到题目中的<strong><em>完美二叉树</em></strong>条件，我们可以更加简单地使用 next 指针。</p>
<p>对于结点的连接只有两种情况：</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20201015090455731.png" alt=""></p>
<ol>
<li>左右子节点相连</li>
<li>当前结点的右子结点和下一个结点的左子结点相连</li>
</ol>
<p>下一层的头节点就是当前层头节点的左子结点（任何一个结点都有左右子节点）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">connect</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Node leftmost = root;</span><br><span class="line">        <span class="keyword">while</span>(leftmost.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">            Node head = leftmost;</span><br><span class="line">            <span class="keyword">while</span>(head != <span class="keyword">null</span>)&#123;</span><br><span class="line">                head.left.next = head.right;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(head.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    head.right.next = head.next.left;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                head = head.next;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            leftmost = leftmost.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度O(n)</li>
<li>空间复杂度O(1)</li>
</ul>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>链表</tag>
        <tag>Leetcode Medium</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>在D天内送达包裹的能力</title>
    <url>/2021/04/28/%E5%9C%A8D%E5%A4%A9%E5%86%85%E9%80%81%E8%BE%BE%E5%8C%85%E8%A3%B9%E7%9A%84%E8%83%BD%E5%8A%9B/</url>
    <content><![CDATA[<h4 id="1011-在-D-天内送达包裹的能力"><a href="#1011-在-D-天内送达包裹的能力" class="headerlink" title="1011. 在 D 天内送达包裹的能力"></a><a href="https://leetcode-cn.com/problems/capacity-to-ship-packages-within-d-days/" target="_blank" rel="noopener">1011. 在 D 天内送达包裹的能力</a></h4><p>传送带上的包裹必须在 D 天内从一个港口运送到另一个港口。</p>
<p>传送带上的第 <code>i</code> 个包裹的重量为 <code>weights[i]</code>。每一天，我们都会按给出重量的顺序往传送带上装载包裹。我们装载的重量不会超过船的最大运载重量。</p>
<p>返回能在 <code>D</code> 天内将传送带上的所有包裹送达的船的最低运载能力。</p>
 <a id="more"></a>

<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：weights &#x3D; [1,2,3,4,5,6,7,8,9,10], D &#x3D; 5</span><br><span class="line">输出：15</span><br><span class="line">解释：</span><br><span class="line">船舶最低载重 15 就能够在 5 天内送达所有包裹，如下所示：</span><br><span class="line">第 1 天：1, 2, 3, 4, 5</span><br><span class="line">第 2 天：6, 7</span><br><span class="line">第 3 天：8</span><br><span class="line">第 4 天：9</span><br><span class="line">第 5 天：10</span><br><span class="line"></span><br><span class="line">请注意，货物必须按照给定的顺序装运，因此使用载重能力为 14 的船舶并将包装分成 (2, 3, 4, 5), (1, 6, 7), (8), (9), (10) 是不允许的。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：weights &#x3D; [3,2,2,4,1,4], D &#x3D; 3</span><br><span class="line">输出：6</span><br><span class="line">解释：</span><br><span class="line">船舶最低载重 6 就能够在 3 天内送达所有包裹，如下所示：</span><br><span class="line">第 1 天：3, 2</span><br><span class="line">第 2 天：2, 4</span><br><span class="line">第 3 天：1, 4</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：weights &#x3D; [1,2,3,1,1], D &#x3D; 4</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">第 1 天：1</span><br><span class="line">第 2 天：2</span><br><span class="line">第 3 天：3</span><br><span class="line">第 4 天：1, 1</span><br></pre></td></tr></table></figure>

<p> <strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= D &lt;= weights.length &lt;= 5 * 104</code></li>
<li><code>1 &lt;= weights[i] &lt;= 500</code></li>
</ul>
<p><strong>方法一：二分查找转化为判定问题</strong></p>
<p>假设当船的运载能力为 x 时，我们可以在 D 天内送完所有包裹，那么只要运载能力大于 x，我们同样可以在 D 天内运送完所有包裹，我们只需使用运载能力为 x 的运送方法即可。</p>
<p>在二分查找过程中，我们需要解决一个判定问题：给定船的运载能力 x，我们是否可以在 D 天内运送完所有包裹？这可以通过贪心来解决：</p>
<blockquote>
<p>由于我们必须按照数组 weights 中包裹的顺序进行运送，将连续的包裹都安排在同一天进行运送，当这批包裹重量大于 x 时，我们需要将最后一个包裹安排在下一天运送。当遍历完整个数组后，就得到了最少需要运送的天数。</p>
</blockquote>
<p>我们将在「最少需要运送的天数」与 D 比较，当其小于 D 时，证明我们的运载能力较强，可以适当减少，因此我们忽略二分的右半区间。当其大于 D 时，证明我们的运载能力较弱，需要增加，我们忽略二分的左半区间。</p>
<p>二分初始边界：</p>
<p>对于左边界而言，由于我们不能拆分一个包裹，因此船的运载能力不能小于包裹中最重的包裹，即左边界为 weights 数组中元素的最大值</p>
<p>对于右边界而言，船的运载能力也不会超过所有包裹的重量之和，即右边界为数组 weights 中元素的和。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">shipWithinDays</span><span class="params">(<span class="keyword">int</span>[] weights, <span class="keyword">int</span> D)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 确定二分查找左右边界</span></span><br><span class="line">        <span class="keyword">int</span> left = Arrays.stream(weights).max().getAsInt(), right = Arrays.stream(weights).sum();</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="comment">//判断运载能力为 mid 时，需要的天数</span></span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">// need 为需要运送的天数</span></span><br><span class="line">            <span class="comment">// cur 为当前这一天已经运送的包裹重量之和</span></span><br><span class="line">            <span class="keyword">int</span> need = <span class="number">1</span>, cur = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> weight : weights) &#123;</span><br><span class="line">                <span class="keyword">if</span> (cur + weight &gt; mid) &#123;</span><br><span class="line">                    ++need;</span><br><span class="line">                    cur = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                cur += weight;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//需要的天数小于 D，运载能力较强，舍弃右半区间</span></span><br><span class="line">            <span class="keyword">if</span> (need &lt;= D) &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">//需要的天数大于 D，运载能力较弱，舍弃左半区间</span></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>时间复杂度：<img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20210428111123523.png" alt="image-20210428111123523"></p>
</li>
<li><p>空间复杂度O(1)</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode Medium</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>多数元素</title>
    <url>/2020/04/09/%E5%A4%9A%E6%95%B0%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<h4 id="169-多数元素"><a href="#169-多数元素" class="headerlink" title="169. 多数元素"></a><a href="https://leetcode-cn.com/problems/majority-element/" target="_blank" rel="noopener">169. 多数元素</a></h4><p>给定一个大小为 <em>n</em> 的数组，找到其中的多数元素。多数元素是指在数组中出现次数<strong>大于</strong> <code>⌊ n/2 ⌋</code> 的元素。</p>
<p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p>
  <a id="more"></a>

<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [3,2,3]</span><br><span class="line">输出: 3</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [2,2,1,1,1,2,2]</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure>

<p>由于多数元素出现的次数比其他元素出现次数的总和还要多，我们可以设置一个计数 count 和 返回结果 majority ，</p>
<p>当出现的元素和 majority 相同时 count 加一， 当出现的元素和 majority 不同时 count 减一， 当 count 为 0 时更换 majority 为当前遍历的值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> majority = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;nums.length;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(count==<span class="number">0</span>)&#123;</span><br><span class="line">                majority = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(nums[i] == majority)&#123;</span><br><span class="line">            ++count;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            --count;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> majority;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度O(n)，空间复杂度O(1)。</p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode Easy</tag>
        <tag>双指针</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>填充每个节点的下一个右侧节点指针II</title>
    <url>/2020/10/02/%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8F%B3%E4%BE%A7%E8%8A%82%E7%82%B9%E6%8C%87%E9%92%88II/</url>
    <content><![CDATA[<h4 id="117-填充每个节点的下一个右侧节点指针-II"><a href="#117-填充每个节点的下一个右侧节点指针-II" class="headerlink" title="117. 填充每个节点的下一个右侧节点指针 II"></a><a href="https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node-ii/" target="_blank" rel="noopener">117. 填充每个节点的下一个右侧节点指针 II</a></h4><p>给定一个二叉树</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct Node &#123;</span><br><span class="line">  int val;</span><br><span class="line">  Node *left;</span><br><span class="line">  Node *right;</span><br><span class="line">  Node *next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 <code>NULL</code>。</p>
<p>初始状态下，所有 next 指针都被设置为 <code>NULL</code>。</p>
 <a id="more"></a>

<p><strong>进阶：</strong></p>
<ul>
<li><p>你只能使用常量级额外空间。</p>
</li>
<li><p>使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。</p>
<p><strong>示例：</strong></p>
</li>
</ul>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20201002091021913.png" alt="image-20201002091021913"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：root &#x3D; [1,2,3,4,5,null,7]</span><br><span class="line">输出：[1,#,2,3,#,4,5,7,#]</span><br><span class="line">解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。</span><br></pre></td></tr></table></figure>

<p> <strong>提示：</strong></p>
<ul>
<li>树中的节点数小于 <code>6000</code></li>
<li><code>-100 &lt;= node.val &lt;= 100</code></li>
</ul>
<p><strong>方法一：层次遍历</strong></p>
<p>我们可以想到层次遍历，将每一层的结点串起来。这样时间复杂度为O(n)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">connect</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Queue&lt;Node&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        q.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> n = q.size();</span><br><span class="line">            <span class="comment">//保存上一个结点指针</span></span><br><span class="line">            Node last = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//将每层结点链接起来</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">                Node t = q.poll();</span><br><span class="line">                <span class="keyword">if</span>(t.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    q.offer(t.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(t.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    q.offer(t.right);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(i != <span class="number">0</span>)&#123;</span><br><span class="line">                    last.next = t;</span><br><span class="line">                &#125;</span><br><span class="line">                last = t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度O(n)</li>
<li>空间复杂度O(n)</li>
</ul>
<p><strong>方法二：使用已建立的 Next 指针</strong></p>
<p>对于第一层的第一个元素，它的第一个孩子结点就是下一层的起始结点，我们使用一个指针<code>nextStart</code>维护这个结点。将当前层的所有结点的子节点链接起来，在遍历到下一层时，将<code>nextStart</code>置为当前层的首结点就可以访问到当前层的所有结点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Node last = <span class="keyword">null</span>, nextStart = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">connect</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//当前层的第一个结点</span></span><br><span class="line">        Node start = root;</span><br><span class="line">        <span class="keyword">while</span>(start != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//将当前层的前一个结点和下一层的首结点置空</span></span><br><span class="line">            last = <span class="keyword">null</span>;</span><br><span class="line">            nextStart = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//对于当前层的每个结点，如果存在子节点，则将其链接起来，并维护下一层的起始结点</span></span><br><span class="line">            <span class="keyword">for</span>(Node p = start; p != <span class="keyword">null</span>; p = p.next)&#123;</span><br><span class="line">                <span class="keyword">if</span>(p.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    handle(p.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(p.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    handle(p.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将下一层结点设置为当前层的起始结点</span></span><br><span class="line">            start = nextStart;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(Node p)</span></span>&#123;</span><br><span class="line">        <span class="comment">//下一层的起始结点为空</span></span><br><span class="line">        <span class="keyword">if</span>(nextStart == <span class="keyword">null</span>)&#123;</span><br><span class="line">            nextStart = p;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//将前一个结点连接到当前结点</span></span><br><span class="line">        <span class="keyword">if</span>(last != <span class="keyword">null</span>)&#123;</span><br><span class="line">            last.next = p;</span><br><span class="line">        &#125;</span><br><span class="line">        last = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度O(n)</li>
<li>空间复杂度O(1)</li>
</ul>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode Medium</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>子集II</title>
    <url>/2021/04/01/%E5%AD%90%E9%9B%86II/</url>
    <content><![CDATA[<h4 id="90-子集-II"><a href="#90-子集-II" class="headerlink" title="90. 子集 II"></a><a href="https://leetcode-cn.com/problems/subsets-ii/" target="_blank" rel="noopener">90. 子集 II</a></h4><p>给你一个整数数组 <code>nums</code> ，其中可能包含重复元素，请你返回该数组所有可能的子集（幂集）。</p>
<p>解集 <strong>不能</strong> 包含重复的子集。返回的解集中，子集可以按 <strong>任意顺序</strong> 排列。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [1,2,2]</span><br><span class="line">输出：[[],[1],[1,2],[1,2,2],[2],[2,2]]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [0]</span><br><span class="line">输出：[[],[0]]</span><br></pre></td></tr></table></figure>

 <a id="more"></a>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 10</code></li>
<li><code>-10 &lt;= nums[i] &lt;= 10</code></li>
</ul>
<p><strong>方法一：回溯</strong></p>
<p>在阅读此题解前可查看前置问题<a href="https://hoo334.github.io/2020/09/20/%E5%AD%90%E9%9B%86/">子集</a>。</p>
<p>以数组<code>[1,2,3]</code>为例，在子集问题中我们的搜索路径如下图所示：</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20210401094806671.png" alt="image-20210401094806671"></p>
<p>类似的，我们画出数组<code>[1,2,2]</code>的搜索路径：</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20210401095255560.png" alt="image-20210401095255560"></p>
<p>可以看到[1,2] 和 [2] 出现了两次，我们在搜索的过程中需要剪枝。并且，nums 数组必须排序才能保证相同的解只出现在同一层。</p>
<p>下面以不排序的数组 <code>[2,3,2]</code>为例，画出搜索路径：</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20210401100627492.png" alt="image-20210401100627492"></p>
<p>在遍历到第二个<code>[2,3]</code>时，我们发现不了前面是否遍历过<code>[2,3]</code>这个子集，排序后搜索路径为：</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20210401100510220.png" alt="image-20210401100510220"></p>
<p>我们只用保存前一个遍历过的数字，再后续的遍历过程中，如果遇到相同的数字直接跳过即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        dfs(nums, <span class="number">0</span>, <span class="keyword">new</span> ArrayDeque&lt;Integer&gt;());</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, Deque&lt;Integer&gt; path)</span></span>&#123;</span><br><span class="line">        ans.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(path));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> pre = -<span class="number">10</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] != pre)&#123;</span><br><span class="line">                path.addLast(nums[i]);</span><br><span class="line">                dfs(nums, i + <span class="number">1</span>, path);</span><br><span class="line">                path.removeLast();</span><br><span class="line">                pre = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度O(n * 2 ^ n)</li>
<li>空间复杂度O(n)</li>
</ul>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode Medium</tag>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>子集</title>
    <url>/2020/09/20/%E5%AD%90%E9%9B%86/</url>
    <content><![CDATA[<h4 id="78-子集"><a href="#78-子集" class="headerlink" title="78. 子集"></a><a href="https://leetcode-cn.com/problems/subsets/" target="_blank" rel="noopener">78. 子集</a></h4><p>给定一组<strong>不含重复元素</strong>的整数数组 <em>nums</em>，返回该数组所有可能的子集（幂集）。</p>
<p><strong>说明：</strong>解集不能包含重复的子集。</p>
<a id="more"></a>

<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: nums &#x3D; [1,2,3]</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [1],</span><br><span class="line">  [2],</span><br><span class="line">  [1,2,3],</span><br><span class="line">  [1,3],</span><br><span class="line">  [2,3],</span><br><span class="line">  [1,2],</span><br><span class="line">  []</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p><strong>方法一：回溯搜索</strong></p>
<p>执行一次深度优先搜索，一条路走到底，走不通的是否，返回回来，继续执行，一直递归，直到回到起点。</p>
<p>我们可以画出搜索路径。</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20210401094806671.png" alt=""></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsets(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        </span><br><span class="line">        dfs(nums, <span class="number">0</span>, <span class="keyword">new</span> ArrayDeque&lt;Integer&gt;());</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, Deque&lt;Integer&gt; path)</span></span>&#123;</span><br><span class="line">        ans.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(path));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt; nums.length; i++)&#123;</span><br><span class="line">            path.addLast(nums[i]);</span><br><span class="line">            dfs(nums, i + <span class="number">1</span>, path);</span><br><span class="line">            path.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法二：位运算</strong></p>
<p>对于数组 nums 中的每个数来说，有<code>选</code>和<code>不选</code>两种选择，我们可以使用二进制位来代替。”1“代表选中，”0“代表不选中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsets(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">1</span> &lt;&lt; len;</span><br><span class="line">		<span class="comment">//[0, n) 的二进制代表了所有的组合</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            List&lt;Integer&gt; cur = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="comment">//判断每一位是否为 1 ，若为 1 将当前位对应的数字加入结果</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>( ((i &gt;&gt; j) &amp; <span class="number">1</span>) == <span class="number">1</span> )&#123;</span><br><span class="line">                    cur.add(nums[j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans.add(cur);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode Medium</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>复原IP地址</title>
    <url>/2020/08/09/%E5%A4%8D%E5%8E%9FIP%E5%9C%B0%E5%9D%80/</url>
    <content><![CDATA[<h4 id="93-复原IP地址"><a href="#93-复原IP地址" class="headerlink" title="93. 复原IP地址"></a><a href="https://leetcode-cn.com/problems/restore-ip-addresses/" target="_blank" rel="noopener">93. 复原IP地址</a></h4><p>给定一个只包含数字的字符串，复原它并返回所有可能的 IP 地址格式。</p>
<p>有效的 IP 地址正好由四个整数（每个整数位于 0 到 255 之间组成），整数之间用 <code>&#39;.&#39;</code>分隔。</p>
 <a id="more"></a>

<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;25525511135&quot;</span><br><span class="line">输出: [&quot;255.255.11.135&quot;, &quot;255.255.111.35&quot;]</span><br></pre></td></tr></table></figure>

<p><strong>方法一：暴力</strong></p>
<p>我们枚举三个切割点，将每一段转换为数字，如果都满足 0 ~ 255 则保存最后结果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">restoreIpAddresses</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        StringBuffer ip = <span class="keyword">new</span> StringBuffer();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> a = <span class="number">1</span>; a &lt; <span class="number">4</span>; a++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> b = <span class="number">1</span>; b &lt; <span class="number">4</span>; b++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> c = <span class="number">1</span>; c &lt; <span class="number">4</span>; c++)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> d = <span class="number">1</span>; d &lt; <span class="number">4</span>; d++)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(a + b + c + d == s.length())&#123;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">int</span> n1 = Integer.parseInt(s.substring(<span class="number">0</span>, a));</span><br><span class="line">                        <span class="keyword">int</span> n2 = Integer.parseInt(s.substring(a, a + b));</span><br><span class="line">                        <span class="keyword">int</span> n3 = Integer.parseInt(s.substring(a + b, a + b + c));</span><br><span class="line">                        <span class="keyword">int</span> n4 = Integer.parseInt(s.substring(a + b + c));</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span>(n1 &lt;= <span class="number">255</span> &amp;&amp; n2 &lt;= <span class="number">255</span> &amp;&amp; n3 &lt;= <span class="number">255</span> &amp;&amp; n4 &lt;= <span class="number">255</span>)&#123;</span><br><span class="line">                            ip.append(n1).append(<span class="string">'.'</span>).append(n2).append(<span class="string">'.'</span>).append(n3).append(<span class="string">'.'</span>).append(n4);</span><br><span class="line">                            <span class="keyword">if</span>(ip.length() == s.length() + <span class="number">3</span>) res.add(ip.toString());</span><br><span class="line">                            ip.delete(<span class="number">0</span>, ip.length());</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                         </span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法二：回溯</strong></p>
<p>我们使用递归函数 <code>dfs(segId, segStart)</code>表示我们正在从 <code>s[segStart]</code>的位置开始，搜索地址中的 segId 段，其中 segId 取值为 {0, 1, 2, 3}。由于 IP 地址每一段范围为 0 ~ 255 ，我们从 s[segStart] 开始，从小到大枚举这一段 IP 地址的结束位置 segEnd。如果满足要求则进行下一段搜索，递归调用 dfs(segId + 1, segEnd + 1)。</p>
<p>如果某一段中 s[segStart] = ‘0’ ，那么这一段只能为 0。</p>
<p>在递归搜索中，如果四段 IP 地址已经全部得到且遍历完了整个字符串，那么保存结果；如果还没有找到四段 IP 地址但已经遍历完了整个字符串，结束搜索，提前回溯。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SEG_COUNT = <span class="number">4</span>;</span><br><span class="line">    List&lt;String&gt; ans = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    <span class="keyword">int</span>[] segments = <span class="keyword">new</span> <span class="keyword">int</span>[SEG_COUNT];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">restoreIpAddresses</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        dfs(s, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(String s, <span class="keyword">int</span> segId, <span class="keyword">int</span> segStart)</span></span>&#123;</span><br><span class="line">        <span class="comment">//找到 4 段 ip 地址，并且遍历完了字符串，这就是一种答案</span></span><br><span class="line">        <span class="keyword">if</span>(segId == SEG_COUNT)&#123;</span><br><span class="line">            <span class="keyword">if</span>(segStart == s.length())&#123;</span><br><span class="line">                StringBuffer ip = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SEG_COUNT; i++)&#123;</span><br><span class="line">                    ip.append(segments[i]);</span><br><span class="line">                    <span class="keyword">if</span>(i != SEG_COUNT - <span class="number">1</span>)&#123;</span><br><span class="line">                        ip.append(<span class="string">'.'</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                ans.add(ip.toString());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果还没找到四段 ip 地址就已经遍历完了字符串，那么提前 回溯</span></span><br><span class="line">        <span class="keyword">if</span>(segStart == s.length())&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果当前数字为 0 ，那么这段 IP 只能为 0</span></span><br><span class="line">        <span class="keyword">if</span>(s.charAt(segStart) == <span class="string">'0'</span>)&#123;</span><br><span class="line">            segments[segId] = <span class="number">0</span>;</span><br><span class="line">            dfs(s, segId + <span class="number">1</span>, segStart + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//一般情况</span></span><br><span class="line">        <span class="keyword">int</span> addr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> segEnd = segStart; segEnd &lt; s.length(); ++segEnd)&#123;</span><br><span class="line">            addr = addr * <span class="number">10</span> + (s.charAt(segEnd) - <span class="string">'0'</span>);</span><br><span class="line">            <span class="keyword">if</span>(addr &gt; <span class="number">0</span> &amp;&amp; addr &lt;= <span class="number">0xFF</span>)&#123;</span><br><span class="line">                segments[segId] = addr;</span><br><span class="line">                dfs(s, segId + <span class="number">1</span>, segEnd + <span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode Medium</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>字典树</title>
    <url>/2020/07/09/%E5%AD%97%E5%85%B8%E6%A0%91/</url>
    <content><![CDATA[<h3 id="Trie-字典树"><a href="#Trie-字典树" class="headerlink" title="Trie 字典树"></a>Trie 字典树</h3><p>Trie 字典树主要用于存储字符串，Trie 的每个 Node 保存一个字符。用链表来描述的话，一个字符串就是一个链表。每个 Node 都保存了它的所有子结点。</p>
<a id="more"></a>

<p>下图为 see、pain、panda、dog构成的字典树</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/qdBE8bhZ1YWNljX.png" alt="image-20200716101933071"></p>
<h4 id="结点设置"><a href="#结点设置" class="headerlink" title="结点设置"></a>结点设置</h4><ol>
<li>是否存在以该结点为最后字符的单词，标识位 isEnd；</li>
<li>当前结点的所有子节点，使用Map存储，当字符串中全为小写字母时可以用数组代替。</li>
</ol>
<h4 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h4><h5 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h5><p>将一个单词的每一个字符从头到尾插入字典树，并将最后一个字符的 idEnd 标志位设为 true。</p>
<h5 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h5><p>从根结点开始遍历字典树，判断查找的字符串是否存在于某一条路径中，且字符串最后一个字符对应的字典树中的结点 isEnd 标志位必须为 true，代表这个结点后面没有字符。例如字典树中存在单词 panda 查找 pan 就要返回false，因为 pan 中的字符 n 对应字典树中的结点 isEnd 标志位为 false。</p>
<h5 id="前缀查找"><a href="#前缀查找" class="headerlink" title="前缀查找"></a>前缀查找</h5><p>与查找类似，对最后一个字符对应字典树的结点标志位没有限制。也就是字典树中存在单词 panda，查找 pan 前缀返回true。</p>
<h5 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h5><p>删除操作分为三种情况：</p>
<ol>
<li>要删除的单词位另一个单词的前缀，将最后一个字符对应字典树结点的 isEnd 标志位改为 false；</li>
<li>要删除的单词对应字典树中的<strong>所有</strong>结点<strong>都</strong>没有分支，直接删除整个链表。</li>
<li>要删除的单词对应字典树中的结点有分支，删除单词对应字典树链表上的最后一个分支结点到末尾结点。</li>
</ol>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/n83K4Jy1CehpM2k.png" alt="第一种情况"></p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/e9UgSvrRf7ZcCL5.png" alt="第二种情况"></p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/wpfGd5lLsO82yQI.png" alt="第三种情况"></p>
<p>第一张图中存在 panda、pan 两个单词，我们需要删除 pan ，直接将 字母 n 的 isEnd 标志位设为false。</p>
<p>第二张图中存在 see 这个单词，并且其链表路径上没有任何分支，直接删除整个链表。</p>
<p>第三张图中存在 pain、panda、pad三个单词，这三个单词在字母 a 处分叉，要删除 pad ，直接将 字符串 pad 中 a 后的字符（d）删除。</p>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> datastructure;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.TreeMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Trie</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node root;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Trie</span><span class="params">()</span></span>&#123;</span><br><span class="line">        root = <span class="keyword">new</span> Node();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 插入单词</span></span><br><span class="line"><span class="comment">    * @param word 需要插入的单词</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(String word)</span></span>&#123;</span><br><span class="line">        Node current = root;</span><br><span class="line">        <span class="keyword">char</span>[] str = word.toCharArray();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c : str)&#123;</span><br><span class="line">            <span class="comment">//获取下一个结点</span></span><br><span class="line">            Node next = current.next.get(c);</span><br><span class="line">            <span class="keyword">if</span>(next == <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="comment">//结点为空</span></span><br><span class="line">                current.next.put(c, <span class="keyword">new</span> Node());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//继续向下</span></span><br><span class="line">            current = current.next.get(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果当前单词已经存在，则不需要增加size</span></span><br><span class="line">        <span class="keyword">if</span>(!current.isEnd)&#123;</span><br><span class="line">            size++;</span><br><span class="line">            current.isEnd = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 查询字典树中是否存在单词</span></span><br><span class="line"><span class="comment">    * @param word 需要查询的单词</span></span><br><span class="line"><span class="comment">    * @return 存在单词返回 true，否则返回 false</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(String word)</span></span>&#123;</span><br><span class="line">        Node current = root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">char</span> c = word.charAt(i);</span><br><span class="line">            Node node = current.next.get(c);</span><br><span class="line">            <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            current = node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 字典树中有 panda，查询 pan 返回 false</span></span><br><span class="line">        <span class="keyword">return</span> current.isEnd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 查询字典树中是否存在某个前缀</span></span><br><span class="line"><span class="comment">    * @param prefix 一个字符串前缀</span></span><br><span class="line"><span class="comment">    * @return 存在前缀返回 true，否则返回 false</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsPrefix</span><span class="params">(String prefix)</span></span>&#123;</span><br><span class="line">        Node current = root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prefix.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">char</span> c = prefix.charAt(i);</span><br><span class="line">            Node node = current.next.get(c);</span><br><span class="line">            <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            current = node;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 字典树中有 panda，查询 pan这个前缀，返回 true</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(String word)</span></span>&#123;</span><br><span class="line">        Node multiChildNode = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> multiChildNodeIndex = -<span class="number">1</span>;</span><br><span class="line">        Node current = root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.length(); i++)&#123;</span><br><span class="line">            Node child = current.next.get(word.charAt(i));</span><br><span class="line">            <span class="keyword">if</span>(child == <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="comment">//字典树中不存在这个单词</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//维护最后一个分叉结点</span></span><br><span class="line">            <span class="keyword">if</span>(child.next.size() &gt; <span class="number">1</span>)&#123;</span><br><span class="line">                multiChildNodeIndex = i;</span><br><span class="line">                multiChildNode = child;</span><br><span class="line">            &#125;</span><br><span class="line">            current = child;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果单词后面还有子节点,证明该单词是某个单词的前缀</span></span><br><span class="line">        <span class="keyword">if</span>(current.next.size() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(current.isEnd)&#123;</span><br><span class="line">                <span class="comment">//将其单词标识改为false</span></span><br><span class="line">                current.isEnd = <span class="keyword">false</span>;</span><br><span class="line">                <span class="comment">//单词树减一</span></span><br><span class="line">                size-- ;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//不存在该单词，该单词只是前缀</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果单词的所有字母都没有多个分支，删除整个单词</span></span><br><span class="line">        <span class="keyword">if</span>(multiChildNodeIndex == -<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">//移除单词的第一个字母（移除整个单词）</span></span><br><span class="line">            root.next.remove(word.charAt(<span class="number">0</span>));</span><br><span class="line">            size-- ;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果单词除了最后一个字母，其他的字母有分支</span></span><br><span class="line">        <span class="keyword">if</span>(multiChildNodeIndex != word.length() - <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">//移除掉分叉结点后的所有结点</span></span><br><span class="line">            multiChildNode.next.remove(word.charAt(multiChildNodeIndex + <span class="number">1</span>));</span><br><span class="line">            size-- ;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">boolean</span> isEnd;<span class="comment">//是否存在以该结点为末尾的单词</span></span><br><span class="line">        <span class="keyword">public</span> Map&lt;Character, Node&gt; next;<span class="comment">//子节点</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">()</span></span>&#123;</span><br><span class="line">            next = <span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">boolean</span> isEnd)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.isEnd = isEnd;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Trie tree = <span class="keyword">new</span> Trie();</span><br><span class="line">        tree.add(<span class="string">"panda"</span>);</span><br><span class="line">        tree.add(<span class="string">"pan"</span>);</span><br><span class="line">        tree.add(<span class="string">"pad"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(tree.contains(<span class="string">"pad"</span>));</span><br><span class="line">        System.out.println(tree.contains(<span class="string">"pand"</span>));</span><br><span class="line">        System.out.println(<span class="string">"Size: "</span> + tree.size());</span><br><span class="line">        System.out.println(tree.remove(<span class="string">"pad"</span>));</span><br><span class="line">        System.out.println(<span class="string">"Size: "</span> + tree.size());</span><br><span class="line">        System.out.println(tree.remove(<span class="string">"pan"</span>));</span><br><span class="line">        System.out.println(<span class="string">"Size: "</span> + tree.size());</span><br><span class="line">        System.out.println(tree.remove(<span class="string">"panz"</span>));</span><br><span class="line">        System.out.println(<span class="string">"Size: "</span> + tree.size());</span><br><span class="line">        System.out.println(tree.remove(<span class="string">"panda"</span>));</span><br><span class="line">        System.out.println(<span class="string">"Size: "</span> + tree.size());</span><br><span class="line">        tree.add(<span class="string">"panz"</span>);</span><br><span class="line">        System.out.println(tree.contains(<span class="string">"panz"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>字典树</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串相加</title>
    <url>/2020/08/03/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%8A%A0/</url>
    <content><![CDATA[<h4 id="415-字符串相加"><a href="#415-字符串相加" class="headerlink" title="415. 字符串相加"></a><a href="https://leetcode-cn.com/problems/add-strings/" target="_blank" rel="noopener">415. 字符串相加</a></h4><p>给定两个字符串形式的非负整数 <code>num1</code> 和<code>num2</code> ，计算它们的和。</p>
<a id="more"></a>

<p><strong>注意：</strong></p>
<ol>
<li><code>num1</code> 和<code>num2</code> 的长度都小于 5100.</li>
<li><code>num1</code> 和<code>num2</code> 都只包含数字 <code>0-9</code>.</li>
<li><code>num1</code> 和<code>num2</code> 都不包含任何前导零。</li>
<li><strong>你不能使用任何內建 BigInteger 库， 也不能直接将输入的字符串转换为整数形式。</strong></li>
</ol>
<p>使用两个指针从字符串尾部开始依次相加，同时维护进位位。使用 StringBuffer 存储，最后再将结果翻转。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">addStrings</span><span class="params">(String num1, String num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = num1.length() - <span class="number">1</span>, j = num2.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">while</span>(i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span> || carry == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> x = i &gt;= <span class="number">0</span> ? num1.charAt(i--) - <span class="string">'0'</span> : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> y = j &gt;= <span class="number">0</span> ? num2.charAt(j--) - <span class="string">'0'</span> : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> num = x + y + carry;</span><br><span class="line">            carry = num / <span class="number">10</span>;</span><br><span class="line">            sb.append(num % <span class="number">10</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.reverse().toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度O(max(len1, len2))，len1 和 len2 为两个字符串的长度。</p>
<p>空间复杂度O(1)，除了存储答案的空间，只使用了O(1)的空间。</p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode Easy</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串相乘</title>
    <url>/2020/08/13/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E4%B9%98/</url>
    <content><![CDATA[<h4 id="43-字符串相乘"><a href="#43-字符串相乘" class="headerlink" title="43. 字符串相乘"></a><a href="https://leetcode-cn.com/problems/multiply-strings/" target="_blank" rel="noopener">43. 字符串相乘</a></h4><p>给定两个以字符串形式表示的非负整数 <code>num1</code> 和 <code>num2</code>，返回 <code>num1</code> 和 <code>num2</code> 的乘积，它们的乘积也表示为字符串形式。</p>
<a id="more"></a>

<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: num1 &#x3D; &quot;2&quot;, num2 &#x3D; &quot;3&quot;</span><br><span class="line">输出: &quot;6&quot;</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: num1 &#x3D; &quot;123&quot;, num2 &#x3D; &quot;456&quot;</span><br><span class="line">输出: &quot;56088&quot;</span><br></pre></td></tr></table></figure>

<p><strong>说明：</strong></p>
<ol>
<li><code>num1</code> 和 <code>num2</code> 的长度小于110。</li>
<li><code>num1</code> 和 <code>num2</code> 只包含数字 <code>0-9</code>。</li>
<li><code>num1</code> 和 <code>num2</code> 均不以零开头，除非是数字 0 本身。</li>
<li><strong>不能使用任何标准库的大数类型（比如 BigInteger）</strong>或<strong>直接将输入转换为整数来处理</strong>。</li>
</ol>
<p>我们可以模拟竖式计算来得到最后的结果。</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20200813101253597.png" alt="image-20200813101253597"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">multiply</span><span class="params">(String num1, String num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(num1.equals(<span class="string">"0"</span>) || num2.equals(<span class="string">"0"</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"0"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//使用 num1 的每一位乘 num2</span></span><br><span class="line">        <span class="keyword">int</span> len1 = num1.length(), len2 = num2.length();</span><br><span class="line">        String ans = <span class="string">"0"</span>;</span><br><span class="line">        <span class="comment">//从 num1 的最后一位开始</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = len1 - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">            <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//添加尾部的 0 </span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = len1 - <span class="number">1</span>; j &gt; i; j--)&#123;</span><br><span class="line">                sb.append(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//计算乘积</span></span><br><span class="line">            <span class="keyword">int</span> x = num1.charAt(i) - <span class="string">'0'</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = len2 - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--)&#123;</span><br><span class="line">                <span class="keyword">int</span> y = num2.charAt(j) - <span class="string">'0'</span>;</span><br><span class="line">                <span class="keyword">int</span> num = x * y + carry;</span><br><span class="line">                sb.append(num % <span class="number">10</span>);</span><br><span class="line">                carry = num / <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">			<span class="comment">//如果最后有进位，就将结果加入</span></span><br><span class="line">            <span class="keyword">if</span>(carry != <span class="number">0</span>)&#123;</span><br><span class="line">                sb.append(carry % <span class="number">10</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//结果相加</span></span><br><span class="line">            ans = addStrings(ans, sb.reverse().toString());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//字符串相加</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">addStrings</span><span class="params">(String num1, String num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = num1.length() - <span class="number">1</span>, j = num2.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">while</span>(i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span> || carry == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> x = i &gt;= <span class="number">0</span> ? num1.charAt(i--) - <span class="string">'0'</span> : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> y = j &gt;= <span class="number">0</span> ? num2.charAt(j--) - <span class="string">'0'</span> : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> num = x + y + carry;</span><br><span class="line">            carry = num / <span class="number">10</span>;</span><br><span class="line">            sb.append(num % <span class="number">10</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.reverse().toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度O(mn)，空间复杂度O(m + n)。</p>
<p>我们可以优化竖式计算，num1 位数为 m，num2 位数为 n，num1 * num2 的最大总位数为 m * n。num1[i] * num2[j] 的结果为 tmp（可能为一位或者两位数），第一位位于 res[i + j]，第二位位于 res[i + j + 1]。</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20200813102303621.png" alt="image-20200813102303621"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">multiply</span><span class="params">(String num1, String num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(num1.equals(<span class="string">"0"</span>) || num2.equals(<span class="string">"0"</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"0"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[num1.length() + num2.length()];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = num1.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">int</span> x = num1.charAt(i) - <span class="string">'0'</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = num2.length() - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--)&#123;</span><br><span class="line">                <span class="keyword">int</span> y = num2.charAt(j) - <span class="string">'0'</span>;</span><br><span class="line">                <span class="keyword">int</span> num = x * y + res[i + j + <span class="number">1</span>];</span><br><span class="line">                res[i + j + <span class="number">1</span>] = num % <span class="number">10</span>;</span><br><span class="line">                res[i + j] += num / <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        StringBuffer ans = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; res.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">0</span> &amp;&amp; res[i] == <span class="number">0</span>) <span class="keyword">continue</span>;<span class="comment">//第一位如果为 0，去掉第一位的 0</span></span><br><span class="line">            ans.append(res[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度O(mn)，空间复杂度O(m + n)。</p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode Medium</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串解码</title>
    <url>/2020/07/01/%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A7%A3%E7%A0%81/</url>
    <content><![CDATA[<h4 id="394-字符串解码"><a href="#394-字符串解码" class="headerlink" title="394. 字符串解码"></a><a href="https://leetcode-cn.com/problems/decode-string/" target="_blank" rel="noopener">394. 字符串解码</a></h4><p>给定一个经过编码的字符串，返回它解码后的字符串。</p>
<p>编码规则为: <code>k[encoded_string]</code>，表示其中方括号内部的 <em>encoded_string</em> 正好重复 <em>k</em> 次。注意 <em>k</em> 保证为正整数。</p>
 <a id="more"></a>

<p>你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。</p>
<p>此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 <em>k</em> ，例如不会出现像 <code>3a</code> 或 <code>2[4]</code> 的输入。</p>
<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">s &#x3D; &quot;3[a]2[bc]&quot;, 返回 &quot;aaabcbc&quot;.</span><br><span class="line">s &#x3D; &quot;3[a2[c]]&quot;, 返回 &quot;accaccacc&quot;.</span><br><span class="line">s &#x3D; &quot;2[abc]3[cd]ef&quot;, 返回 &quot;abcabccdcdcdef&quot;.</span><br></pre></td></tr></table></figure>

<p>在此题中可能出现括号嵌套的情况，比如 <code>3[a2[c]]</code>，这种情况下我们先转化为<code>2[abcbc]</code>，再转化成<code>abcbcabcbc</code>。我们可以使用栈或递归来实现。使用栈的具体做法是：</p>
<ol>
<li>如果当前字符为数字，则取出一个数字（连续的多个数位）并进栈。</li>
<li>如果当前字符为字母或左括号，直接进栈。</li>
<li>如果当前字符为右括号，开始出栈，直到出现左括号，此时栈顶元素为已经出栈的字符串重复出现的次数。</li>
</ol>
<p>重复以上操作，直到遍历到字符串末尾。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//访问字符的下标</span></span><br><span class="line">    <span class="keyword">int</span> ptr;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">decodeString</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        LinkedList&lt;String&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        ptr = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(ptr &lt; s.length())&#123;</span><br><span class="line">            <span class="keyword">char</span> cur = s.charAt(ptr);</span><br><span class="line">            <span class="keyword">if</span>(Character.isDigit(cur))&#123;</span><br><span class="line">                <span class="comment">//获取数字并将字符串进栈</span></span><br><span class="line">                String digits = getDigits(s);</span><br><span class="line">                stack.addLast(digits);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>((Character.isLetter(cur) || cur == <span class="string">'['</span>))&#123;</span><br><span class="line">                <span class="comment">//获取一个字母并进栈</span></span><br><span class="line">                stack.addLast(String.valueOf(s.charAt(ptr++)));</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//跳过右括号</span></span><br><span class="line">                ++ptr;</span><br><span class="line">                LinkedList&lt;String&gt; sub = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">                <span class="comment">//将栈内字符串保存，直到遇到左括号</span></span><br><span class="line">                <span class="keyword">while</span>(! <span class="string">"["</span>.equals(stack.peekLast()))&#123;</span><br><span class="line">                    sub.addLast(stack.removeLast());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//将字符串顺序转换回来</span></span><br><span class="line">                Collections.reverse(sub);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//左括号出栈</span></span><br><span class="line">                stack.removeLast();</span><br><span class="line">                <span class="comment">//此时栈顶元素为括号内字符串重复的次数，将字符串解析为数字</span></span><br><span class="line">                <span class="keyword">int</span> repTime = Integer.parseInt(stack.removeLast());</span><br><span class="line">                <span class="comment">//生成字符串</span></span><br><span class="line">                StringBuffer t = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">                String o = getString(sub);</span><br><span class="line">                <span class="keyword">while</span>(repTime-- &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    t.append(o);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//将字符串添加到栈顶</span></span><br><span class="line">                stack.addLast(t.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> getString(stack);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getDigits</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        <span class="comment">//获取数字</span></span><br><span class="line">        StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">while</span>(Character.isDigit(s.charAt(ptr)))&#123;</span><br><span class="line">            sb.append(s.charAt(ptr++));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getString</span><span class="params">(LinkedList&lt;String&gt; v)</span></span>&#123;</span><br><span class="line">        <span class="comment">//整合结果</span></span><br><span class="line">        StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">for</span>(String s : v)&#123;</span><br><span class="line">            sb.append(s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>渐进时间复杂度为 O(S)，渐进空间复杂度为 O(S)。</p>
<p>我们还可以使用递归来完成此题。使用递归的具体做法是：</p>
<ol>
<li><p>如果当前位置为数字位，那么后面一定包含一个用方括号表示的字符串<code>k[...]</code>。</p>
<ul>
<li>我们可以先解析数字，然后递归解析后面的内容，遇到对应的右括号则可以根据解析的数字x 和字符串 s’  构造一个新的字符串 x * s’。</li>
<li>在解析完一个<code>k[...]</code>后，再次调用递归函数，解析右括号右边的内容。</li>
</ul>
</li>
<li><p>如果当前位置是字母位，直接解析当前字母，然后递归向下解析这个字母后面的内容。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ptr;</span><br><span class="line">    String src;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">decodeString</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        src = s;</span><br><span class="line">        ptr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> getString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//结束处理</span></span><br><span class="line">        <span class="keyword">if</span>(ptr == src.length() || src.charAt(ptr) == <span class="string">']'</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">char</span> cur = src.charAt(ptr);</span><br><span class="line">        <span class="keyword">int</span> repTime = <span class="number">1</span>;</span><br><span class="line">        String ret=<span class="string">""</span>;</span><br><span class="line">		</span><br><span class="line">        <span class="keyword">if</span>(Character.isDigit(cur))&#123;<span class="comment">//当前位置是数字</span></span><br><span class="line">            <span class="comment">//解析Digit</span></span><br><span class="line">            repTime = getDigits();</span><br><span class="line">            <span class="comment">//过滤左括号</span></span><br><span class="line">            ++ptr;</span><br><span class="line">            <span class="comment">//解析String</span></span><br><span class="line">            String str = getString();</span><br><span class="line">            <span class="comment">//过滤右括号</span></span><br><span class="line">            ++ptr;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//构造字符串</span></span><br><span class="line">            <span class="keyword">while</span>(repTime-- &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                ret += str;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(Character.isLetter(cur))&#123;<span class="comment">//当前位置是字母</span></span><br><span class="line">            ret = String.valueOf(src.charAt(ptr++));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//再次调用递归函数，解析右括号右边的内容</span></span><br><span class="line">        <span class="keyword">return</span> ret + getString();</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//从字符串中解析数字</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getDigits</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(ptr &lt; src.length() &amp;&amp; Character.isDigit(src.charAt(ptr)))&#123;</span><br><span class="line">            ret = ret * <span class="number">10</span> + src.charAt(ptr++) - <span class="string">'0'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>渐进时间复杂度为 O(S)，渐进空间复杂度为 O(S)。</p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode Medium</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>完全平方数</title>
    <url>/2020/07/01/%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0/</url>
    <content><![CDATA[<h4 id="279-完全平方数"><a href="#279-完全平方数" class="headerlink" title="279. 完全平方数"></a><a href="https://leetcode-cn.com/problems/perfect-squares/" target="_blank" rel="noopener">279. 完全平方数</a></h4><p>给定正整数 <em>n</em>，找到若干个完全平方数（比如 <code>1, 4, 9, 16, ...</code>）使得它们的和等于 <em>n</em>。你需要让组成和的完全平方数的个数最少。</p>
 <a id="more"></a>

<p>动态转移方程为：<code>dp[i] = MIN(dp[i], dp[i - j * j] + 1)</code>，<code>i</code>表示当前数字，<code>j*j</code>表示平方数。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: n &#x3D; 12</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 12 &#x3D; 4 + 4 + 4.</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: n &#x3D; 13</span><br><span class="line">输出: 2</span><br><span class="line">解释: 13 &#x3D; 4 + 9.</span><br></pre></td></tr></table></figure>
<p>使用 dp 数组来保存以当前下标为和的完全平方数的个数。依次对每个数判断是否可以使用之前的dp数组中的值加一个较大的完全平方数得到。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; ++i)&#123;</span><br><span class="line">            <span class="comment">//最坏的情况，全部由 1 相加得到</span></span><br><span class="line">            dp[i] = i;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; i-j*j&gt;=<span class="number">0</span>; ++j)&#123;</span><br><span class="line">                <span class="comment">//尝试由 i-1, i-4, i-9 ...得到 i </span></span><br><span class="line">                dp[i] = Math.min(dp[i], dp[i-j*j]+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度为O(n*sqrt(n))，空间复杂度为 O(n)。</p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode Medium</tag>
        <tag>动态规划</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>完全二叉树的节点个数</title>
    <url>/2020/11/24/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9%E4%B8%AA%E6%95%B0/</url>
    <content><![CDATA[<h4 id="222-完全二叉树的节点个数"><a href="#222-完全二叉树的节点个数" class="headerlink" title="222. 完全二叉树的节点个数"></a><a href="https://leetcode-cn.com/problems/count-complete-tree-nodes/" target="_blank" rel="noopener">222. 完全二叉树的节点个数</a></h4><p>给出一个<strong>完全二叉树</strong>，求出该树的节点个数。</p>
<a id="more"></a>

<p><strong>说明：</strong></p>
<p><a href="https://baike.baidu.com/item/完全二叉树/7773232?fr=aladdin" target="_blank" rel="noopener">完全二叉树</a>的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2h 个节点。</p>
<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: </span><br><span class="line">    1</span><br><span class="line">   &#x2F; \</span><br><span class="line">  2   3</span><br><span class="line"> &#x2F; \  &#x2F;</span><br><span class="line">4  5 6</span><br><span class="line"></span><br><span class="line">输出: 6</span><br></pre></td></tr></table></figure>

<p><strong>方法一：暴力</strong></p>
<p>:) 年轻人不讲码德，暴力就完事了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countNodes</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> countNodes(root.left) + countNodes(root.right) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度O(N)</li>
<li>空间复杂度O(logN)</li>
</ul>
<p><strong>方法二：二分查找 + 位运算</strong></p>
<p>规定根节点位于第 0 层，完全二叉树的最大层数为 h。根据二叉树的性质，最后一层的结点数最少为 1，最多为 2^h。对于最大层数为 h 的完全二叉树，结点个数在 [2^h, 2^(h + 1) - 1]范围内，可以在该范围内使用二分查找来得到完全二叉树的结点个数。</p>
<p>根据结点个数范围的上下界得到当前需要判断的结点个数 k，如果第 k 个结点存在，则结点个数一定 大于等于 k，如果第 k 个结点不存在，则结点个数一定小于 k，因此可以将查找的范围缩小一半。</p>
<p>如何判断第 k 个结点是否存在，如果第 k 个结点位于第 h 层，则 k 的二进制表示包含 h + 1 位，其中最高位为 1，其余各位从高到低表示根节点到第 k 个结点的路径 ，0 表示移动到左子结点，1表示移动到右子结点。</p>
<p>例如数字 12 二进制表示 1100，则从根节点开始向下判断 右，左，左结点是否存在。</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20201124094205904.png" alt="image-20201124094205904"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countNodes</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> level =  <span class="number">0</span>;</span><br><span class="line">        TreeNode node = root;</span><br><span class="line">        <span class="keyword">while</span>(node.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">            ++level;</span><br><span class="line">            node = node.left;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">1</span> &lt;&lt; level, high = (<span class="number">1</span> &lt;&lt; (level + <span class="number">1</span>)) - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(low &lt; high)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = low +(high - low + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(exists(root, level, mid))&#123;</span><br><span class="line">                low = mid;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                high = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> low;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">exists</span><span class="params">(TreeNode root, <span class="keyword">int</span> level, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> bits = <span class="number">1</span> &lt;&lt; (level - <span class="number">1</span>);</span><br><span class="line">        TreeNode node = root;</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="keyword">null</span> &amp;&amp; bits &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> ((bits &amp; k) == <span class="number">0</span>)&#123;</span><br><span class="line">                node = node.left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">                node = node.right;</span><br><span class="line">            &#125;</span><br><span class="line">            bits &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node != <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20201124094629941.png" alt="image-20201124094629941"></p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode Medium</tag>
        <tag>二分查找</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>对称二叉树</title>
    <url>/2020/05/31/%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h4 id="101-对称二叉树"><a href="#101-对称二叉树" class="headerlink" title="101. 对称二叉树"></a><a href="https://leetcode-cn.com/problems/symmetric-tree/" target="_blank" rel="noopener">101. 对称二叉树</a></h4><p>给定一个二叉树，检查它是否是镜像对称的。<br> <a id="more"></a></p>
<p>例如，二叉树 <code>[1,2,2,3,4,4,3]</code> 是对称的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    1</span><br><span class="line">   &#x2F; \</span><br><span class="line">  2   2</span><br><span class="line"> &#x2F; \ &#x2F; \</span><br><span class="line">3  4 4  3</span><br></pre></td></tr></table></figure>

<p> 但是下面这个 <code>[1,2,2,null,3,null,3]</code> 则不是镜像对称的:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  1</span><br><span class="line"> &#x2F; \</span><br><span class="line">2   2</span><br><span class="line"> \   \</span><br><span class="line"> 3    3</span><br></pre></td></tr></table></figure>

<p><strong>进阶：</strong></p>
<p>你可以运用递归和迭代两种方法解决这个问题吗？</p>
<p>如果一个二叉树的左右子树镜像对称，那么这个树镜像对称。两个子树镜像对称有如下性质：</p>
<ul>
<li><p>左右两个子树根结点值相等</p>
</li>
<li><p>每个树的右子树与另一个子树的左子树镜像对称</p>
</li>
</ul>
<p>我们可以使用两个指针 p  和 q ，它们最开始都指向根结点，p 右移时， q 左移，p 左移时，q 右移，同时判断 p 和 q 的值是否相等并递归判断它们的子树是否镜像对称。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> check(root, root);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(TreeNode p, TreeNode q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p == <span class="keyword">null</span> &amp;&amp; q == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p == <span class="keyword">null</span> || q == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> p.val == q.val &amp;&amp; check(p.left, q.right) &amp;&amp; check(p.right, q.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每个结点遍历一次，时间复杂度 O(n)。递归层数不超过 n 层，渐进空间复杂度为 O(n)。</p>
<p>我们还可以使用一个队列来模拟递归，每次进队列两个二叉树的镜像结点，依次判断它们的值是否相等，直到队列为空。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> check(root, root);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(TreeNode u, TreeNode v)</span></span>&#123;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(u);</span><br><span class="line">        queue.offer(v);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            u = queue.poll();</span><br><span class="line">            v = queue.poll();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(u == <span class="keyword">null</span> &amp;&amp; v == <span class="keyword">null</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>((u ==<span class="keyword">null</span> || v == <span class="keyword">null</span>) || (u.val != v.val)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">            queue.offer(u.left);</span><br><span class="line">            queue.offer(v.right);</span><br><span class="line"></span><br><span class="line">            queue.offer(u.right);</span><br><span class="line">            queue.offer(v.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每个结点遍历一次，时间复杂度 O(n)。每个结点入队一次，队列中最多 n 个结点，渐进空间复杂度为O(n)。</p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode Easy</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>寻找旋转排序数组中的最小值</title>
    <url>/2020/07/22/%E5%AF%BB%E6%89%BE%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC/</url>
    <content><![CDATA[<h4 id="153-寻找旋转排序数组中的最小值"><a href="#153-寻找旋转排序数组中的最小值" class="headerlink" title="153. 寻找旋转排序数组中的最小值"></a><a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/" target="_blank" rel="noopener">153. 寻找旋转排序数组中的最小值</a></h4><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。</p>
<p>( 例如，数组 <code>[0,1,2,4,5,6,7]</code> 可能变为 <code>[4,5,6,7,0,1,2]</code> )。</p>
<p>请找出其中最小的元素。</p>
<p>你可以假设数组中不存在重复元素。</p>
<a id="more"></a>

<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [3,4,5,1,2]</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [4,5,6,7,0,1,2]</span><br><span class="line">输出: 0</span><br></pre></td></tr></table></figure>

<p>使用二分查找，需要始终保持目标值在搜索范围内，并不断缩小左右边界。</p>
<p>我们得到的旋转数组类似于下图，为两段单调递增的序列构成，且右边序列最大值小于左边序列最小值。</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20200722142442327.png" alt="image-20200722142442327"></p>
<p>在二分查找过程中，我们有以下几种情况：</p>
<ol>
<li><p>左值 &lt; 中值，中值 &lt; 右值，最小值在左边，[中，右]范围内的值不可能为最小值，可以收缩右边界。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">		右</span><br><span class="line">	中</span><br><span class="line">左</span><br></pre></td></tr></table></figure>
</li>
<li><p>左值 &lt; 中值，中值 &gt; 右值，最小值在右边，[左，中]范围内的值不可能为最小值，可以收缩左边界。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">	中</span><br><span class="line">左</span><br><span class="line">		右</span><br></pre></td></tr></table></figure>
</li>
<li><p>左值 &gt; 中值，中值 &lt; 右值，最小值在左边界，<strong>(中，右]</strong>范围内的值不可能为最小值，可以收缩右边界。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">左</span><br><span class="line">		右</span><br><span class="line">	中</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>情况 1，3 是一类，情况 2 是另一类：</p>
<ul>
<li>如果中值 &lt; 右值，<strong>(中，右]</strong>范围内的值不可能为最小值，可以收缩右边界。</li>
<li>如果中值 &gt; 右值，[左，中]范围内的值不可能为最小值，可以收缩左边界。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = nums.length - <span class="number">1</span>; <span class="comment">//左闭右闭区间，用右开区间不方便判断右值</span></span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)&#123;<span class="comment">// left == right 结束</span></span><br><span class="line">            <span class="keyword">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt; nums[r])&#123;</span><br><span class="line">                l = mid + <span class="number">1</span>; <span class="comment">//中值 &gt; 右值，中值不可能为最小值，左边界跳过mid</span></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; nums[r])&#123;</span><br><span class="line">                r = mid;<span class="comment">//中值 &lt; 右值，中值可能为最小值，右边界只能取到 mid</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[l];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度O(log n)，空间复杂度O(1)。</p>
<p>参考：<a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/solution/er-fen-cha-zhao-wei-shi-yao-zuo-you-bu-dui-cheng-z/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/solution/er-fen-cha-zhao-wei-shi-yao-zuo-you-bu-dui-cheng-z/</a></p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode Medium</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>寻找两个正序数组的中位数</title>
    <url>/2020/04/27/%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/</url>
    <content><![CDATA[<h4 id="4-寻找两个正序数组的中位数"><a href="#4-寻找两个正序数组的中位数" class="headerlink" title="4. 寻找两个正序数组的中位数"></a><a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/" target="_blank" rel="noopener">4. 寻找两个正序数组的中位数</a></h4><p>给定两个大小为 m 和 n 的正序（从小到大）数组 <code>nums1</code> 和 <code>nums2</code>。</p>
<p>请你找出这两个正序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。</p>
<p>你可以假设 <code>nums1</code> 和 <code>nums2</code> 不会同时为空。</p>
  <a id="more"></a>

<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nums1 &#x3D; [1, 3]</span><br><span class="line">nums2 &#x3D; [2]</span><br><span class="line"></span><br><span class="line">则中位数是 2.0</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nums1 &#x3D; [1, 2]</span><br><span class="line">nums2 &#x3D; [3, 4]</span><br><span class="line"></span><br><span class="line">则中位数是 (2 + 3)&#x2F;2 &#x3D; 2.5</span><br></pre></td></tr></table></figure>

<p>先考虑一个有序数组中查找中位数的情况：当数组元素为奇数时，取最中间的一个元素；当数组元素为偶数时，取最中间的两个元素的平均值。</p>
<p>有两个有序数组时我们先计算出总数组的长度，在两个数组中间画一条分割线，当两条分割线左侧的元素个数为总数组长度的一半时，在分割线左右的四个元素则是构成中位数的元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums1.length &gt; nums2.length)&#123;</span><br><span class="line">            <span class="keyword">return</span> findMedianSortedArrays(nums2, nums1);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> m = nums1.length;</span><br><span class="line">        <span class="keyword">int</span> n = nums2.length;</span><br><span class="line">        <span class="comment">//分割线左边的所有元素需要满足的个数(m + n + 1) / 2</span></span><br><span class="line">        <span class="keyword">int</span> totalLeft = (m + n + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">//在 nums1 的区间 [0, m]里查找恰当的分割线</span></span><br><span class="line">        <span class="comment">//使得 nums1[i - 1] &lt;= nums2[j] &amp;&amp; nums2[j - 1] &lt;= nums1[i]</span></span><br><span class="line">        <span class="comment">//在较小长度的数组使用二分查找</span></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = m;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="comment">//向上取整</span></span><br><span class="line">            <span class="keyword">int</span> i = left + (right - left + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> j = totalLeft - i;</span><br><span class="line">            <span class="comment">//搜索分割线位置</span></span><br><span class="line">            <span class="keyword">if</span>(nums1[i - <span class="number">1</span>] &gt; nums2[j])&#123;<span class="comment">//不满足交叉小于的情况</span></span><br><span class="line">                <span class="comment">//下一轮搜索区间 [left, i - 1]</span></span><br><span class="line">                right = i - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//下一轮搜索区间 [i, right]</span></span><br><span class="line">                left = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i = left;</span><br><span class="line">        <span class="keyword">int</span> j = totalLeft - i;</span><br><span class="line">        <span class="keyword">int</span> nums1LeftMax = i == <span class="number">0</span> ? Integer.MIN_VALUE : nums1[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> nums1RightMin = i == m ? Integer.MAX_VALUE : nums1[i];</span><br><span class="line">        <span class="keyword">int</span> nums2LeftMax = j == <span class="number">0</span> ? Integer.MIN_VALUE : nums2[j - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> nums2RightMIn = j == n ? Integer.MAX_VALUE : nums2[j];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>((m + n) % <span class="number">2</span> == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> Math.max(nums1LeftMax, nums2LeftMax);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">double</span>)((Math.max(nums1LeftMax,nums2LeftMax) + Math.min(nums1RightMin, nums2RightMIn))) / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度是 O( log( min(<em>m</em>,n) ) )，空间复杂度：O(1)。</p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode Hard</tag>
        <tag>二分查找</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>寻找旋转排序数组中的最小值II</title>
    <url>/2020/07/22/%E5%AF%BB%E6%89%BE%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BCII/</url>
    <content><![CDATA[<h4 id="154-寻找旋转排序数组中的最小值-II"><a href="#154-寻找旋转排序数组中的最小值-II" class="headerlink" title="154. 寻找旋转排序数组中的最小值 II"></a><a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/" target="_blank" rel="noopener">154. 寻找旋转排序数组中的最小值 II</a></h4><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。</p>
<p>( 例如，数组 <code>[0,1,2,4,5,6,7]</code> 可能变为 <code>[4,5,6,7,0,1,2]</code> )。</p>
<p>请找出其中最小的元素。</p>
<p>注意数组中可能存在重复的元素。</p>
<a id="more"></a>

<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,3,5]</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [2,2,2,0,1]</span><br><span class="line">输出: 0</span><br></pre></td></tr></table></figure>

<p><strong>说明：</strong></p>
<ul>
<li>这道题是 <a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/description/" target="_blank" rel="noopener">寻找旋转排序数组中的最小值</a> 的延伸题目。</li>
<li>允许重复会影响算法的时间复杂度吗？会如何影响，为什么？</li>
</ul>
<p>我们得到的旋转数组类似于下图，由两段单调递增的序列构成，右边序列的最大值小于等于左边序列的最小值。</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20200722142620638.png" alt="image-20200722142620638"></p>
<p>在二分查找过程中，我们有以下几种情况：</p>
<ol>
<li><p>左值 &lt; 中值，中值 &lt; 右值，最小值在左边，[中，右]范围内的值不可能为最小值，可以收缩右边界。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">		右</span><br><span class="line">	中</span><br><span class="line">左</span><br></pre></td></tr></table></figure>
</li>
<li><p>左值 &lt; 中值，中值 &gt; 右值，最小值在右边，[左，中]范围内的值不可能为最小值，可以收缩左边界。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">	中</span><br><span class="line">左</span><br><span class="line">		右</span><br></pre></td></tr></table></figure>
</li>
<li><p>左值 &gt; 中值，中值 &lt; 右值，最小值在左边界，<strong>(中，右]</strong>范围内的值不可能为最小值，可以收缩右边界。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">左</span><br><span class="line">		右</span><br><span class="line">	中</span><br></pre></td></tr></table></figure>
</li>
<li><p>中值 = 右值，最小值在左边界，右值重复(中值有可能不重复，例如 [3, 1, 1]，分别为左中右，收缩右边界变为 [3, 1])，可以收缩右边界。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">左</span><br><span class="line">	中   右</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>情况 1，3是一类，情况 2 是一类，情况 4 是一类：</p>
<ul>
<li>如果中值 &lt; 右值，<strong>(中，右]</strong>范围内的值不可能为最小值，可以收缩右边界。</li>
<li>如果中值 &gt; 右值，[左，中]范围内的值不可能为最小值，可以收缩左边界。</li>
<li>如果中值 = 右值，右值重复，可以收缩右边界。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = nums.length - <span class="number">1</span>; <span class="comment">//左闭右闭区间，用右开区间不方便判断右值</span></span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)&#123;<span class="comment">// left == right 结束</span></span><br><span class="line">            <span class="keyword">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt; nums[r])&#123;</span><br><span class="line">                l = mid + <span class="number">1</span>; <span class="comment">//中值 &gt; 右值，中值不可能为最小值，左边界跳过mid</span></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; nums[r])&#123;</span><br><span class="line">                r = mid;<span class="comment">//中值 &lt; 右值，中值可能为最小值，右边界只能取到 mid</span></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] == nums[r])&#123;</span><br><span class="line">                --r;<span class="comment">//中值 = 右值，右值重复，右边界左移</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[l];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>平均时间复杂度O(log n)，当数组中数字全部相等时，最坏时间复杂度O(n)。</p>
<p>空间复杂度O(1)。</p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode Hard</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>寻找重复数</title>
    <url>/2020/04/27/%E5%AF%BB%E6%89%BE%E9%87%8D%E5%A4%8D%E6%95%B0/</url>
    <content><![CDATA[<h4 id="287-寻找重复数"><a href="#287-寻找重复数" class="headerlink" title="287. 寻找重复数"></a><a href="https://leetcode-cn.com/problems/find-the-duplicate-number/" target="_blank" rel="noopener">287. 寻找重复数</a></h4><p>给定一个包含 <em>n</em> + 1 个整数的数组 <em>nums*，其数字都在 1 到 *n</em> 之间（包括 1 和 <em>n</em>），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。</p>
 <a id="more"></a>

<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,3,4,2,2]</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [3,1,3,4,2]</span><br><span class="line">输出: 3</span><br></pre></td></tr></table></figure>

<p><strong>说明：</strong></p>
<ol>
<li><strong>不能</strong>更改原数组（假设数组是只读的）。</li>
<li>只能使用额外的 <em>O</em>(1) 的空间。</li>
<li>时间复杂度小于 <em>O</em>(<em>n</em>2) 。</li>
<li>数组中只有一个重复的数字，但它可能不止重复出现一次。</li>
</ol>
<p>方法一： 二分查找</p>
<p>定义 cnt[i] 表示 nums 数组中小于等于 i 的数有多少个，假设重复的数是 target，那么[1, target-1]里的所有数满足cnt[i] &lt; i，[target, n]里的所有数满足 cnt[i] &gt; i。</p>
<p>以示例 1 为例，列出 cnt 的值</p>
<table>
<thead>
<tr>
<th>nums</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
</tr>
</thead>
<tbody><tr>
<td>cnt</td>
<td>1</td>
<td>3</td>
<td>4</td>
<td>5</td>
</tr>
</tbody></table>
<p>示例中重复的整数是2，[1, 1]中的数满足 cnt[i] &lt;= i， [2,4]中的数满足cnt[i] &gt;= i。</p>
<p>由于只有一个整数重复了两次以上，我们考虑 target 整数出现了 2 次和 3 次及以上的情况：</p>
<ul>
<li>target 出现了两次 [1, target -1]范围内满足 cnt[i] = i</li>
<li>target 出现了三次及以上，代表[1,n]范围内有整数没有出现，当没有出现的整数 i 小于 target 则[i, target]的cnt 值减一，满足条件。当没有出现的整数 j 大于 target 则[target, j-1]的cnt 值均加一，满足条件。</li>
</ul>
<p>那么我们怎么利用 cnt 数组来找到重复出现的数字呢？</p>
<p>由于 nums 数组是有序的，我们可以想到使用二分查找，在二分查找的过程中统计 cnt 的值，根据 cnt 的值来判断重复的数字在[left, mid - 1] 或[mid + 1, right]区间中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>, ans = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">            <span class="comment">//统计cnt</span></span><br><span class="line">            <span class="keyword">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n ; ++i)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] &lt;= mid)&#123;</span><br><span class="line">                    cnt++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">			<span class="comment">//cnt[i] &lt;= mid，重复的数字在[mid + 1, r]区间</span></span><br><span class="line">            <span class="keyword">if</span>(cnt &lt;= mid)&#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//cnt[i] &gt; mid，重复的数字在[l, mid - 1]</span></span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">                <span class="comment">//当 l &gt; r时，mid 为重复的数字 </span></span><br><span class="line">                ans = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度O(nlogn) 空间复杂度O(1)</p>
<p>方法二：快慢指针</p>
<p>快慢指针通常用来判断链表中是否有环，我们可以对 nums 数组建图每个位置 i 连一条 i -&gt; nums[i]的边，由于存在重复的数字target，target 位置至少有两条指向它的边，因此存在环，就转换为找环的入口问题。</p>
<p>以示例 1 为例我们建立得到的图如下</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/O28ubKGxAYr14n7.png" alt="image-20200526115632169"></p>
<p>我们可以先使用快慢指针走进环中，再将慢指针放到起点，快慢指针一起走，直到快慢指针相遇就是结果。</p>
<p>为什么将慢指针放到起点一起走，直到快慢指针相遇就是结果呢？。</p>
<p>假设环长为 <em>L</em>，从起点到环的入口的步数是 <em>a</em>，从环的入口继续走 <em>b</em> 步到达相遇位置，从相遇位置继续走 <em>c</em> 步回到环的入口。快指针比慢指针多走了 <em>k</em> 圈。表示为 2(<em>a</em>+<em>b</em>)=<em>a</em>+<em>b</em>+<em>k</em> <em>L</em>。进而得到 <em>a</em>=(<em>k</em>−1)<em>L</em>+(<em>L</em>−<em>b</em>)=(<em>k</em>−1)<em>L</em>+<em>c</em></p>
<p>如果慢指针从起点出发，快指针从相遇位置出发，每次两个指针都移动一步，则慢指针走了 a 步之后到达环的入口，快指针在环里走了 k−1 圈之后又走了 c 步，由于从相遇位置继续走 c 步即可回到环的入口，因此快指针也到达环的入口。两个指针在环的入口相遇，相遇点就是答案。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> slow = <span class="number">0</span>, fast = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//快慢指针相遇</span></span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            slow = nums[slow];</span><br><span class="line">            fast = nums[nums[fast]];</span><br><span class="line">        &#125;<span class="keyword">while</span>(slow != fast);</span><br><span class="line">		<span class="comment">//慢指针从头开始走，快慢指针相遇时得到环的入口点</span></span><br><span class="line">        slow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(slow != fast)&#123;</span><br><span class="line">            slow = nums[slow];</span><br><span class="line">            fast = nums[fast];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度O(n) 空间复杂度O(1)</p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode Medium</tag>
        <tag>二分查找</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>山脉数组中查找目标值</title>
    <url>/2020/04/27/%E5%B1%B1%E8%84%89%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E7%9B%AE%E6%A0%87%E5%80%BC/</url>
    <content><![CDATA[<h4 id="1095-山脉数组中查找目标值"><a href="#1095-山脉数组中查找目标值" class="headerlink" title="1095. 山脉数组中查找目标值"></a><a href="https://leetcode-cn.com/problems/find-in-mountain-array/" target="_blank" rel="noopener">1095. 山脉数组中查找目标值</a></h4><p>（这是一个 <strong>交互式问题</strong> ）</p>
<p>给你一个 <strong>山脉数组</strong> <code>mountainArr</code>，请你返回能够使得 <code>mountainArr.get(index)</code> <strong>等于</strong> <code>target</code> <strong>最小</strong> 的下标 <code>index</code> 值。</p>
<p>如果不存在这样的下标 <code>index</code>，就请返回 <code>-1</code>。</p>
<p>何为山脉数组？如果数组 <code>A</code> 是一个山脉数组的话，那它满足如下条件：</p>
<p><strong>首先</strong>，<code>A.length &gt;= 3</code></p>
<p><strong>其次</strong>，在 <code>0 &lt; i &lt; A.length - 1</code> 条件下，存在 <code>i</code> 使得：</p>
<ul>
<li><code>A[0] &lt; A[1] &lt; ... A[i-1] &lt; A[i]</code></li>
<li><code>A[i] &gt; A[i+1] &gt; ... &gt; A[A.length - 1]</code></li>
</ul>
<p>你将 <strong>不能直接访问该山脉数组</strong>，必须通过 <code>MountainArray</code> 接口来获取数据：</p>
<ul>
<li><code>MountainArray.get(k)</code> - 会返回数组中索引为<code>k</code> 的元素（下标从 0 开始）</li>
<li><code>MountainArray.length()</code> - 会返回该数组的长度</li>
</ul>
<p><strong>注意：</strong></p>
<p>对 <code>MountainArray.get</code> 发起超过 <code>100</code> 次调用的提交将被视为错误答案。此外，任何试图规避判题系统的解决方案都将会导致比赛资格被取消。</p>
<p>为了帮助大家更好地理解交互式问题，我们准备了一个样例 “<strong>答案</strong>”：<a href="https://leetcode-cn.com/playground/RKhe3ave，请注意这" target="_blank" rel="noopener">https://leetcode-cn.com/playground/RKhe3ave，请注意这</a> <strong>不是一个正确答案</strong>。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：array &#x3D; [1,2,3,4,5,3,1], target &#x3D; 3</span><br><span class="line">输出：2</span><br><span class="line">解释：3 在数组中出现了两次，下标分别为 2 和 5，我们返回最小的下标 2。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：array &#x3D; [0,1,2,4,2,1], target &#x3D; 3</span><br><span class="line">输出：-1</span><br><span class="line">解释：3 在数组中没有出现，返回 -1。</span><br></pre></td></tr></table></figure>



<p><strong>提示：</strong></p>
<ul>
<li><code>3 &lt;= mountain_arr.length() &lt;= 10000</code></li>
<li><code>0 &lt;= target &lt;= 10^9</code></li>
<li><code>0 &lt;= mountain_arr.get(index) &lt;= 10^9</code></li>
</ul>
<p>山脉数组表示数组中间存在一个最大的数，它左边的数都是单调递增，右边的数都是单调递减。如果是已经排序的数组我们可以想到二分查找，那么山脉数组能不能也使用二分查找呢？</p>
<p>答案是可以，只要我们找到最高点的下标，将山脉数组分成左边一个单调递增的数组，右边分为一个单调递减的数组，然后分别对这两个数组进行二分查找。</p>
<p>问题的关键是如何找到最高点的下标，常规的做法是直接遍历一遍数组找到最大值的下标。更巧妙的方法是使用类似二分查找的方法来找到最高点的下标。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">	<span class="comment">//计算中间点的下标</span></span><br><span class="line">	<span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//mountainArr[mid] &lt; mountainArr[mid+1] </span></span><br><span class="line">	<span class="comment">//mountainArr[mid+1]比其左侧的值都大,其左侧的值不可能为最高点</span></span><br><span class="line">	<span class="keyword">if</span>(mountainArr.get(mid) &lt; mountainArr.get(mid + <span class="number">1</span>))&#123;</span><br><span class="line">		<span class="comment">//下一轮搜索区间[mid+1, right]</span></span><br><span class="line">		left = mid + <span class="number">1</span>;</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123; <span class="comment">//mountainArr[mid] &gt;= mountainArr[mid+1] </span></span><br><span class="line">		   <span class="comment">//mountainArr[mid]比其左侧的值都大,其右侧的值不可能为最高点</span></span><br><span class="line">		<span class="comment">//下一轮搜索区间[left, mid]</span></span><br><span class="line">		right = mid;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>找到了最高点后，先在左边递增的部分寻找目标</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">      <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">      <span class="keyword">if</span>(mountainArr.get(mid) &lt; target)&#123;</span><br><span class="line">          <span class="comment">//target 比 mountainArr[mid+1]左侧的值都大,其左侧的值不可能为target</span></span><br><span class="line">          <span class="comment">//下一轮搜索区间[mid+1, right]</span></span><br><span class="line">          left = mid + <span class="number">1</span>;</span><br><span class="line">       &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">          <span class="comment">//target 比 mountainArr[mid]右侧的值都小,其右侧的值不可能为target</span></span><br><span class="line">          <span class="comment">//下一轮搜索区间[left, mid]</span></span><br><span class="line">          right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果没找到就在右边递减的部分寻找</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">      <span class="keyword">int</span> mid = left + (right - left + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">      <span class="keyword">if</span>(mountainArr.get(mid) &lt; target)&#123;</span><br><span class="line">          <span class="comment">//target 比 mountainArr[mid-1]右侧的值都大,其右侧的值不可能为target</span></span><br><span class="line">      	  <span class="comment">//下一轮搜索区间[left, mid - 1]</span></span><br><span class="line">      	  right = mid - <span class="number">1</span>;</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">         <span class="comment">//target 比 mountainArr[mid]左侧的值都小,其左侧的值不可能为target</span></span><br><span class="line">      	 <span class="comment">//下一轮搜索区间[mid, right]</span></span><br><span class="line">         <span class="comment">//[left(mid), right] --&gt; [left, right(mid)] 将下取整改为上取整</span></span><br><span class="line">         <span class="comment">//否则为死循环</span></span><br><span class="line">      left = mid;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后将整合所有部分</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * // This is MountainArray's API interface.</span></span><br><span class="line"><span class="comment"> * // You should not implement it, or speculate about its implementation</span></span><br><span class="line"><span class="comment"> * interface MountainArray &#123;</span></span><br><span class="line"><span class="comment"> *     public int get(int index) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     public int length() &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findInMountainArray</span><span class="params">(<span class="keyword">int</span> target, MountainArray mountainArr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = mountainArr.length();</span><br><span class="line">        <span class="keyword">int</span> peekIndex = findPeekIndex(mountainArr, <span class="number">0</span>, len-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(mountainArr.get(peekIndex) == target)&#123;</span><br><span class="line">            <span class="keyword">return</span> peekIndex;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> res = findSortedArray(target, mountainArr, <span class="number">0</span>, peekIndex - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(res != -<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> findReverseArray(target, mountainArr, peekIndex + <span class="number">1</span>, len - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">findPeekIndex</span><span class="params">(MountainArray mountainArr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(mountainArr.get(mid) &lt; mountainArr.get(mid + <span class="number">1</span>))&#123;</span><br><span class="line">                <span class="comment">//下一轮搜索区间[mid+1, right]</span></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//下一轮搜索区间[left, mid]</span></span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// left == right</span></span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">findSortedArray</span><span class="params">(<span class="keyword">int</span> target, MountainArray mountainArr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(mountainArr.get(mid) &lt; target)&#123;</span><br><span class="line">                <span class="comment">//下一轮搜索区间[mid+1, right]</span></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//下一轮搜索区间[left, mid]</span></span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(mountainArr.get(left) == target)&#123;</span><br><span class="line">            <span class="keyword">return</span> left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">findReverseArray</span><span class="params">(<span class="keyword">int</span> target, MountainArray mountainArr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(mountainArr.get(mid) &lt; target)&#123;</span><br><span class="line">                <span class="comment">//下一轮搜索区间[left, mid - 1]</span></span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//下一轮搜索区间[mid, right]</span></span><br><span class="line">                <span class="comment">//[left(mid), right] --&gt; [left, right(mid)] 将下取整改为上取整</span></span><br><span class="line">                left = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(mountainArr.get(left) == target)&#123;</span><br><span class="line">            <span class="keyword">return</span> left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode Hard</tag>
        <tag>二分查找</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>将有序数组转换为二叉搜索树</title>
    <url>/2020/07/03/%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
    <content><![CDATA[<h4 id="108-将有序数组转换为二叉搜索树"><a href="#108-将有序数组转换为二叉搜索树" class="headerlink" title="108. 将有序数组转换为二叉搜索树"></a><a href="https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/" target="_blank" rel="noopener">108. 将有序数组转换为二叉搜索树</a></h4><p>将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。</p>
<p>本题中，一个高度平衡二叉树是指一个二叉树<em>每个节点</em> 的左右两个子树的高度差的绝对值不超过 1。</p>
<a id="more"></a>

<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定有序数组: [-10,-3,0,5,9],</span><br><span class="line"></span><br><span class="line">一个可能的答案是：[0,-3,9,-10,null,5]，它可以表示下面这个高度平衡二叉搜索树：</span><br><span class="line"></span><br><span class="line">      0</span><br><span class="line">     &#x2F; \</span><br><span class="line">   -3   9</span><br><span class="line">   &#x2F;   &#x2F;</span><br><span class="line"> -10  5</span><br></pre></td></tr></table></figure>

<p>二叉搜索树的中序遍历是升序遍历，题目给定的数组是按照升序排序的有序数组，因此可以确保数组是二叉搜索树的中序遍历序列。</p>
<p>给定二叉树的中序遍历不能唯一地确定二叉搜索树。要求二叉搜索树地高度平衡，是否能唯一地确定二叉树？答案是否定地。以下图片来自<a href="https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/solution/jiang-you-xu-shu-zu-zhuan-huan-wei-er-cha-sou-s-33/" target="_blank" rel="noopener">Leetcode</a>。</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/vxlZRYqzG6DCByJ.png" alt="image-20200703102523749"></p>
<p>我们选取中间数字作为二叉搜索树地根结点，这样分给左右子树地数字个数相同或只相差 1 ，可以使树保持平衡。</p>
<p>确定根结点后，递归地创建左右子树。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">sortedArrayToBST</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> build(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">build</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="comment">//递归终点</span></span><br><span class="line">        <span class="keyword">if</span>(left &gt; right)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//选取范围内的中间结点作为根结点</span></span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(nums[mid]);</span><br><span class="line">        <span class="comment">//递归地建立左右子树</span></span><br><span class="line">        root.left = build(nums, left, mid - <span class="number">1</span>);</span><br><span class="line">        root.right = build(nums, mid + <span class="number">1</span>, right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度O(n)，访问数组中所有元素。</p>
<p>空间复杂度O(log n)，递归深度 log n。</p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode Easy</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>左叶子之和</title>
    <url>/2020/09/19/%E5%B7%A6%E5%8F%B6%E5%AD%90%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<h4 id="404-左叶子之和"><a href="#404-左叶子之和" class="headerlink" title="404. 左叶子之和"></a><a href="https://leetcode-cn.com/problems/sum-of-left-leaves/" target="_blank" rel="noopener">404. 左叶子之和</a></h4><p>计算给定二叉树的所有左叶子之和。</p>
<a id="more"></a>

<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    3</span><br><span class="line">   &#x2F; \</span><br><span class="line">  9  20</span><br><span class="line">    &#x2F;  \</span><br><span class="line">   15   7</span><br><span class="line"></span><br><span class="line">在这个二叉树中，有两个左叶子，分别是 9 和 15，所以返回 24</span><br></pre></td></tr></table></figure>

<p>我们可以很快写出所有叶子之和的递归代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumOfLeftLeaves</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>)&#123;</span><br><span class="line">			<span class="keyword">return</span> root.val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sumOfLeftLeaves(root.left) + sumOfLeftLeaves(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个叶子是否为左叶子只有它的父节点知道，我们使用 father 来维护父节点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//父结点指针</span></span><br><span class="line">    TreeNode father = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumOfLeftLeaves</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//判断当前叶子是否为左叶子</span></span><br><span class="line">            <span class="keyword">if</span>(father != <span class="keyword">null</span> &amp;&amp; father.left == root)&#123;</span><br><span class="line">                <span class="keyword">return</span> root.val;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//更新父节点</span></span><br><span class="line">        father = root;</span><br><span class="line">        <span class="keyword">return</span> sumOfLeftLeaves(root.left) + sumOfLeftLeaves(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode Easy</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>平方数之和</title>
    <url>/2020/07/29/%E5%B9%B3%E6%96%B9%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<h4 id="633-平方数之和"><a href="#633-平方数之和" class="headerlink" title="633. 平方数之和"></a><a href="https://leetcode-cn.com/problems/sum-of-square-numbers/" target="_blank" rel="noopener">633. 平方数之和</a></h4><p>给定一个非负整数 <code>c</code> ，你要判断是否存在两个整数 <code>a</code> 和 <code>b</code>，使得 a^2 + b^2 = c。</p>
<a id="more"></a>

<p><strong>示例1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 5</span><br><span class="line">输出: True</span><br><span class="line">解释: 1 * 1 + 2 * 2 &#x3D; 5</span><br></pre></td></tr></table></figure>

<p> <strong>示例2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 3</span><br><span class="line">输出: False</span><br></pre></td></tr></table></figure>

<p>我们直接使用暴力法，这里使用了一点技巧。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">judgeSquareSum</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">long</span> i = <span class="number">0</span>; i * i &lt;= c; i++)&#123;</span><br><span class="line">            <span class="keyword">double</span> b = Math.sqrt(c - i * i);</span><br><span class="line">            <span class="comment">//如果 b 为一个数的平方，代表找到</span></span><br><span class="line">            <span class="keyword">if</span>(b == (<span class="keyword">int</span>)b)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度O(√c)，空间复杂度O(1)。</p>
<p>最近做 DP 都快 PTSD 了，看到这题居然第一时间想到 DP，人傻了！！</p>
]]></content>
      <tags>
        <tag>数学</tag>
        <tag>Leetcode Easy</tag>
      </tags>
  </entry>
  <entry>
    <title>岛屿数量</title>
    <url>/2020/04/20/%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F/</url>
    <content><![CDATA[<h4 id="200-岛屿数量"><a href="#200-岛屿数量" class="headerlink" title="200. 岛屿数量"></a><a href="https://leetcode-cn.com/problems/number-of-islands/" target="_blank" rel="noopener">200. 岛屿数量</a></h4><p>给你一个由 <code>&#39;1&#39;</code>（陆地）和 <code>&#39;0&#39;</code>（水）组成的的二维网格，请你计算网格中岛屿的数量。</p>
<p>岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。</p>
<p>此外，你可以假设该网格的四条边均被水包围。<br> <a id="more"></a></p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">11110</span><br><span class="line">11010</span><br><span class="line">11000</span><br><span class="line">00000</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">11000</span><br><span class="line">11000</span><br><span class="line">00100</span><br><span class="line">00011</span><br><span class="line">输出: 3</span><br><span class="line">解释: 每座岛屿只能由水平和&#x2F;或竖直方向上相邻的陆地连接而成。</span><br></pre></td></tr></table></figure>

<p>我们可以将二维网格看成一个无向图，竖直或水平相邻的 1 之间有边相连。为了求出岛屿的数量，我们可以扫描整个二维网格。如果一个位置为 1 ，则以其为起始结点开始进行深度优先搜索。在深度优先搜索的过程中，每个搜索到的 1 都会被重新标记为 0。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="keyword">char</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rows = grid.length;</span><br><span class="line">        <span class="keyword">if</span>(rows == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> cols = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//对网格中的每个 1 都做深度优先搜索</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;rows; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;cols; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="string">'1'</span>)&#123;</span><br><span class="line">                    <span class="comment">//发现一个岛屿</span></span><br><span class="line">                    ++ count;</span><br><span class="line">                    <span class="comment">//将该 1 相连的 1 全部置为 0</span></span><br><span class="line">                    dfs(grid, i, j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] grid, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rows = grid.length;</span><br><span class="line">        <span class="keyword">int</span> cols = grid[<span class="number">0</span>].length;</span><br><span class="line">		<span class="comment">//将第 r 行，第 c 列的 1 相邻的 1 全部置为 0</span></span><br><span class="line">        grid[r][c] = <span class="string">'0'</span>;</span><br><span class="line">        <span class="keyword">if</span>(r-<span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[r-<span class="number">1</span>][c] == <span class="string">'1'</span>) dfs(grid, r-<span class="number">1</span>, c);</span><br><span class="line">        <span class="keyword">if</span>(r+<span class="number">1</span> &lt;rows &amp;&amp; grid[r+<span class="number">1</span>][c] == <span class="string">'1'</span>) dfs(grid, r+<span class="number">1</span>, c);</span><br><span class="line">        <span class="keyword">if</span>(c-<span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[r][c-<span class="number">1</span>] == <span class="string">'1'</span>)dfs(grid, r, c-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(c+<span class="number">1</span> &lt; cols &amp;&amp; grid[r][c+<span class="number">1</span>] == <span class="string">'1'</span>)dfs(grid, r, c+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="keyword">char</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rows = grid.length;</span><br><span class="line">        <span class="keyword">if</span>(rows == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> cols = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;rows; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;cols; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="string">'1'</span>)&#123;</span><br><span class="line">                    <span class="comment">//发现一个岛屿</span></span><br><span class="line">                    grid[i][j] = <span class="string">'0'</span>;</span><br><span class="line">                    ++count;</span><br><span class="line">                    </span><br><span class="line">                    Queue&lt;Integer&gt; neighbors = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">                    neighbors.add(i*cols+j);</span><br><span class="line">                    <span class="comment">//BFS</span></span><br><span class="line">                    <span class="keyword">while</span>(! neighbors.isEmpty())&#123;</span><br><span class="line">                        <span class="comment">//得到保存的行列信息</span></span><br><span class="line">                        <span class="keyword">int</span> id = neighbors.remove();</span><br><span class="line">                        <span class="keyword">int</span> r = id / cols;</span><br><span class="line">                        <span class="keyword">int</span> c = id % cols;</span><br><span class="line">                        </span><br><span class="line">                        <span class="comment">//将第 i 行，第 j 列的 1 相邻的 1 全部置为 0</span></span><br><span class="line">                        <span class="keyword">if</span>(r-<span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[r-<span class="number">1</span>][c] == <span class="string">'1'</span>)&#123;</span><br><span class="line">                            neighbors.add((r-<span class="number">1</span>)*cols+c);</span><br><span class="line">                            grid[r-<span class="number">1</span>][c] = <span class="string">'0'</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span>(r+<span class="number">1</span> &lt;rows &amp;&amp; grid[r+<span class="number">1</span>][c] == <span class="string">'1'</span>)&#123;</span><br><span class="line">                            neighbors.add((r+<span class="number">1</span>)*cols+c);</span><br><span class="line">                            grid[r+<span class="number">1</span>][c] = <span class="string">'0'</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span>(c-<span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[r][c-<span class="number">1</span>] == <span class="string">'1'</span>)&#123;</span><br><span class="line">                            neighbors.add(r*cols + c - <span class="number">1</span>);</span><br><span class="line">                            grid[r][c-<span class="number">1</span>] = <span class="string">'0'</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span>(c+<span class="number">1</span> &lt; cols &amp;&amp; grid[r][c+<span class="number">1</span>] == <span class="string">'1'</span>)&#123;</span><br><span class="line">                            neighbors.add(r*cols + c + <span class="number">1</span>);</span><br><span class="line">                            grid[r][c+<span class="number">1</span>] = <span class="string">'0'</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode Medium</tag>
        <tag>DFS</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title>微机原理</title>
    <url>/2020/05/09/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h3 id="计算机工作原理"><a href="#计算机工作原理" class="headerlink" title="计算机工作原理"></a>计算机工作原理</h3><p>冯诺依曼计算机体系结构：输入设备、输出设备、存储器、运算器和控制器。</p>
<h3 id="8086"><a href="#8086" class="headerlink" title="8086"></a>8086</h3><p>共 20 根地址线，16根数据线。地址线 20 根代表可寻址的空间为 1MB，数据线为 16 根代表处理器字长为 16位。</p>
<h4 id="地址线和数据线"><a href="#地址线和数据线" class="headerlink" title="地址线和数据线"></a>地址线和数据线</h4><ul>
<li>AD0 — AD7 低 8 位地址和低 8 位数据信号分时复用，传递地址信号位单向，传送数据信号时为双向。</li>
<li>A16 — A19 高 4 位地址信号，与状态信号分时复用。</li>
<li>A8 — A15  8 位地址信号。</li>
</ul>
<h4 id="控制信号和状态信号"><a href="#控制信号和状态信号" class="headerlink" title="控制信号和状态信号"></a>控制信号和状态信号</h4><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/SEzlOaAqhcmHfRM.png" alt="image-20200509141827458"></p>
<h4 id="内部寄存器"><a href="#内部寄存器" class="headerlink" title="内部寄存器"></a>内部寄存器</h4><p>含 14 个 16 位寄存器，按功能可分为三类：8 个通用寄存器、4 个段寄存器和 2 个控制寄存器。</p>
<h5 id="通用寄存器"><a href="#通用寄存器" class="headerlink" title="通用寄存器"></a>通用寄存器</h5><ul>
<li><p>数据寄存器：AX、BX、CX、DX。</p>
</li>
<li><p>地址指针寄存器：SP、BP。</p>
</li>
<li><p>变址寄存器：SI、DI。</p>
</li>
</ul>
<p>AX：累加器。所有 I/O 指令都通过 AX 与接口传送信息，中间运算结果也多放于 AX 中。</p>
<p>BX：基址寄存器。在间接寻址中用于存放基地址。</p>
<p>CX：计数寄存器。用于在循环或串操作指令中存放计数值。</p>
<p>DX：数据寄存器。在间接寻址的 I/O 指令中存放 I/O 端口地址，在 32 位乘除法运算时，存放高 16 位数。</p>
<p>SP：堆栈指针寄存器，其内容为栈顶的偏移地址。</p>
<p>BP：基址指针寄存器，常用于在访问内存时存放内存单元的偏移地址。</p>
<p>BX 用于数据段，BP 用于堆栈段。</p>
<p>SI：源变址寄存器</p>
<p>DI：目标变址寄存器</p>
<h5 id="控制寄存器"><a href="#控制寄存器" class="headerlink" title="控制寄存器"></a>控制寄存器</h5><ul>
<li>CF 进位标志位；</li>
<li>PF 奇偶标志位；</li>
<li>AF 辅助进位位；</li>
<li>ZF 零标志位，当运算结果为零时置 1 ；</li>
<li>SF 符号标志位，运算结果最高位为 1 时，SF = 1；</li>
<li>OF 溢出标志位。</li>
<li></li>
</ul>
<h5 id="段寄存器"><a href="#段寄存器" class="headerlink" title="段寄存器"></a>段寄存器</h5><ul>
<li>CS 代码段寄存器，存放代码段的段基地址。</li>
<li>DS 数据段寄存器，存放数据段的段基地址。</li>
<li>ES 附加段寄存器，存放数据段的段基地址。</li>
<li>SS 堆栈段寄存器，存放堆栈段的段基地址。</li>
</ul>
<h3 id="寻址方式"><a href="#寻址方式" class="headerlink" title="寻址方式"></a>寻址方式</h3><h4 id="立即寻址"><a href="#立即寻址" class="headerlink" title="立即寻址"></a>立即寻址</h4><p>例如 MOV AX，1200H。仅适合于源操作数。</p>
<h4 id="寄存器寻址"><a href="#寄存器寻址" class="headerlink" title="寄存器寻址"></a>寄存器寻址</h4><p>例如 MOV AX，BX。参加操作的操作数在 CPU 的通用寄存器中。</p>
<h4 id="直接寻址"><a href="#直接寻址" class="headerlink" title="直接寻址"></a>直接寻址</h4><p>例如 MOV AX，[1200H]。指令中直接给出操作数的偏移地址。</p>
<h4 id="寄存器间接寻址"><a href="#寄存器间接寻址" class="headerlink" title="寄存器间接寻址"></a>寄存器间接寻址</h4><p>例如 MOV AX，[BX]。参加操作的操作数放在内存中，其偏移地址为指令中寄存器的内容。</p>
<p>存放偏移地址的寄存器称为间址寄存器，它们分别是 BX，BP，SI，DI。</p>
<p>操作数的段地址取决于选择哪一个间址寄存器。当选择 BX，SI，DI 时默认在数据段。当选择 BP 时默认在堆栈段。</p>
<h4 id="寄存器相对寻址"><a href="#寄存器相对寻址" class="headerlink" title="寄存器相对寻址"></a>寄存器相对寻址</h4><p>例如 MOV AX，[BX+DATA]。操作数的偏移地址为寄存器的内容加上一个位移量。</p>
<p>基址寄存器为 BX 时默认在数据段；基址寄存器为 BP 时，默认在堆栈段。</p>
<h4 id="基址变址寻址"><a href="#基址变址寻址" class="headerlink" title="基址变址寻址"></a>基址变址寻址</h4><p>例如 MOV AX，[BP+DI+DATA]。操作数的偏移地址为基址寄存器内容+变址寄存器内容+位移量。操作数的段地址由选择的基址寄存器决定。</p>
<h3 id="8086-指令系统"><a href="#8086-指令系统" class="headerlink" title="8086 指令系统"></a>8086 指令系统</h3><p>从功能上包括六大类：</p>
<p>数据传送、算术运算、逻辑运算和移位、串操作、程序控制和处理器控制。</p>
<h4 id="数据传送指令"><a href="#数据传送指令" class="headerlink" title="数据传送指令"></a>数据传送指令</h4><p>包括通用数据传送、输入输出、地址传送和标志位操作。</p>
<h5 id="通用数据传送"><a href="#通用数据传送" class="headerlink" title="通用数据传送"></a>通用数据传送</h5><p><strong>该类指令的执行对标志位不产生影响。</strong></p>
<p>mov 指令</p>
<p>MOV dest,   src</p>
<p>两操作数 字长必须相同，两操作数<strong>不允许同时为存储器操作数</strong>、不允许同时为段寄存器，在源操作数是立即数时，目标操作数不能是段寄存器。</p>
<p>入栈/出栈指令</p>
<p>PUSH oprd </p>
<p>POP oprd</p>
<p>oprd 为 16 位寄存器或存储器两单元，不能为立即数。</p>
<p>交换指令</p>
<p>XCHG REG, MEM/REG</p>
<p>两个操作数必须有一个是寄存器操作数，不允许使用段寄存器。</p>
<p>查表指令</p>
<p>XLAT</p>
<p>用 BX 的内容代表表格首地址，AL 内容为表内位移量，BX+AL得到要查找元素的偏移地址。将 BX+AL 所指单元的内容送 AL。</p>
<h5 id="输入输出指令"><a href="#输入输出指令" class="headerlink" title="输入输出指令"></a>输入输出指令</h5><p>输入指令：IN acc，PORT</p>
<p>输出指令：OUT PORT，acc</p>
<p>根据端口地址码的长度，指令有两种不同的端口地址表现形式。</p>
<ul>
<li>直接寻址。端口地址为 8 位时，指令中直接给出 8 位端口地址，寻址 256 个端口。</li>
<li>间接寻址。端口地址为 16 位时，指令中的端口地址必须由 DX 指定；可寻址 64K 个端口。</li>
</ul>
<h5 id="地址传送指令"><a href="#地址传送指令" class="headerlink" title="地址传送指令"></a>地址传送指令</h5><p>取偏移地址指令 LEA。计算 MEM 相对于 REG 的偏移地址。</p>
<p>LEA REG,   MEM</p>
<p>将变量的 16 位偏移地址取出送目标寄存器。源操作数必须是一个存储器操作数，目标操作数通常是间址寄存器。</p>
<h4 id="算术运算指令"><a href="#算术运算指令" class="headerlink" title="算术运算指令"></a>算术运算指令</h4><p>算术运算指令的执行大多对状态标志位会产生影响。</p>
<h5 id="加法指令"><a href="#加法指令" class="headerlink" title="加法指令"></a>加法指令</h5><p>普通加法指令 </p>
<p>ADD oprd1,oprd2 </p>
<p>oprd1 = oprd1 + oprd2</p>
<p>带进位的加法指令 </p>
<p>ADC oprd1,oprd2 </p>
<p>oprd1 = oprd1+oprd2+CF</p>
<p>自增指令</p>
<p>INC oprd</p>
<p>oprd += 1</p>
<h5 id="减法指令"><a href="#减法指令" class="headerlink" title="减法指令"></a>减法指令</h5><p>普通减法指令</p>
<p>SUB oprd1, oprd2</p>
<p>oprd1 = oprd1 - oprd2</p>
<p>考虑借位的减法指令</p>
<p>SBB oprd1, oprd2</p>
<p>oprd1 = oprd1 - oprd2 - CF</p>
<p>自减指令</p>
<p>DEC oprd</p>
<p>oprd -= 1</p>
<p>取反指令</p>
<p>NEG oprd</p>
<p>oprd = 0-oprd</p>
<p>比较指令</p>
<p>CMP oprd1, oprd2</p>
<p>oprd1 - oprd2</p>
<p><strong>影响标志位</strong> 如果 oprd1 &gt; oprd2 则 CF = 0 </p>
<h5 id="乘法指令"><a href="#乘法指令" class="headerlink" title="乘法指令"></a>乘法指令</h5><p>无符号乘法指令 MUL</p>
<p>MUL oprd</p>
<p>oprd 为字节数   AX = AL * oprd</p>
<p>oprd 为 16 位数 DX AX = AX * oprd</p>
<h5 id="除法指令"><a href="#除法指令" class="headerlink" title="除法指令"></a>除法指令</h5><p>DIV oprd</p>
<p>若 oprd 是字节数 执行 AL / oprd。结果 AL 为商， AH 为余数</p>
<p>若 oprd 是双字节数执行 DX AX / oprd。结果 AX 为商，DX 为余数。</p>
<h4 id="逻辑运算和移位指令"><a href="#逻辑运算和移位指令" class="headerlink" title="逻辑运算和移位指令"></a>逻辑运算和移位指令</h4><h5 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h5><p>AND oprd1, oprd2</p>
<p>OR oprd1, oprd2</p>
<p>NOT oprd 操作数按位取反再送回原地址，操作数不能为立即数，指令的执行对标志位无影响。</p>
<p>XOR oprd1, oprd2 两操作数异或，结果送目标地址</p>
<p>TEST oprd1, oprd2 将执行 “与” 操作，但运算的结果不送回目标地址。</p>
<h5 id="移位指令"><a href="#移位指令" class="headerlink" title="移位指令"></a>移位指令</h5><p>逻辑左移 SHL 、逻辑右移 SHR：将移动的位补 0 ，移除的位到 CF。</p>
<p>算术左移SAL、算术右移SAR：符号位不动，移动的位补 0 ，移除的位到 CF 。</p>
<p>不带进位循环左移ROL、不带进位循环右移ROR：将移除的位同时加到 CF 和被移动的位。</p>
<p>带进位循环左移 RCL、带进位循环右移 RCR：CF 参与循环移位，向左循环移位则 CF 在最左边（向右循环则 CF 在最右边）。</p>
<h4 id="程序控制指令"><a href="#程序控制指令" class="headerlink" title="程序控制指令"></a>程序控制指令</h4><h5 id="转移指令"><a href="#转移指令" class="headerlink" title="转移指令"></a>转移指令</h5><p>无条件转移指令 JMP oprd 。oprd 是 16 位偏移地址。</p>
<p>条件转移指令</p>
<p>JC/JNC、JZ/JNZ、JO/JNO、JP/JPE分别判断 CF、ZF、OF、PF 是否为 1 /为 0 。</p>
<h5 id="循环控制指令"><a href="#循环控制指令" class="headerlink" title="循环控制指令"></a>循环控制指令</h5><p>LOOP 循环次数由 CX 决定。用法 LOOP Label</p>
<h5 id="过程调用和返回"><a href="#过程调用和返回" class="headerlink" title="过程调用和返回"></a>过程调用和返回</h5><p>调用 CALL PROC</p>
<p>返回 RET，一般位于子程序的最后</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
  </entry>
  <entry>
    <title>平衡二叉树</title>
    <url>/2020/08/17/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h4 id="110-平衡二叉树"><a href="#110-平衡二叉树" class="headerlink" title="110. 平衡二叉树"></a><a href="https://leetcode-cn.com/problems/balanced-binary-tree/" target="_blank" rel="noopener">110. 平衡二叉树</a></h4><p>给定一个二叉树，判断它是否是高度平衡的二叉树。</p>
<p>本题中，一棵高度平衡二叉树定义为：</p>
<blockquote>
<p>一个二叉树<em>每个节点</em> 的左右两个子树的高度差的绝对值不超过1。</p>
</blockquote>
<a id="more"></a>

<p><strong>示例 1:</strong></p>
<p>给定二叉树 <code>[3,9,20,null,null,15,7]</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>

<p>返回 <code>true</code> 。</p>
<p><strong>示例 2:</strong></p>
<p>给定二叉树 <code>[1,2,2,3,3,null,null,4,4]</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">      1</span><br><span class="line">     &#x2F; \</span><br><span class="line">    2   2</span><br><span class="line">   &#x2F; \</span><br><span class="line">  3   3</span><br><span class="line"> &#x2F; \</span><br><span class="line">4   4</span><br></pre></td></tr></table></figure>

<p>返回 <code>false</code> 。</p>
<p>一颗树是平衡二叉树，当且仅当所有子树都是二叉平衡树，我们可以使用递归的方式来判断二叉树是否为平衡二叉树。</p>
<p>我们使用 height 函数来求树的最大高度，如果左右子树的高度不超过 1 ，再分别递归地遍历左右子节点，并判断左右子树是否为平衡二叉树。这是一个自顶向下的过程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBalanced</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Math.abs(length(root.left) - length(root.right)) &lt;= <span class="number">1</span> &amp;&amp; isBalanced(root.left) &amp;&amp; isBalanced(root.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">length</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Math.max(length(root.left), length(root.right)) + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度O(n^2)，最坏情况下，二叉树为链表，遍历所有结点时间复杂度O(n)，计算高度时间复杂度为O(n)。</p>
<p>空间复杂度O(n)。</p>
<p>我们可以递归地判断当前结点的左右子树是否平衡，再判断以当前结点为根的树是否平衡，如果平衡，返回其高度（不小于 0 ），否则返回 - 1，代表不是平衡二叉树。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBalanced</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> length(root) &gt;= <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">length</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> leftLength = length(root.left);</span><br><span class="line">        <span class="keyword">int</span> rightLength = length(root.right);</span><br><span class="line">        <span class="keyword">if</span>(leftLength == -<span class="number">1</span> || rightLength == -<span class="number">1</span> || Math.abs(leftLength - rightLength) &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Math.max(leftLength, rightLength) + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度O(n)，空间复杂度O(n)。</p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode Easy</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>恢复空格</title>
    <url>/2020/07/09/%E6%81%A2%E5%A4%8D%E7%A9%BA%E6%A0%BC/</url>
    <content><![CDATA[<h4 id="面试题-17-13-恢复空格"><a href="#面试题-17-13-恢复空格" class="headerlink" title="面试题 17.13. 恢复空格"></a><a href="https://leetcode-cn.com/problems/re-space-lcci/" target="_blank" rel="noopener">面试题 17.13. 恢复空格</a></h4><p>哦，不！你不小心把一个长篇文章中的空格、标点都删掉了，并且大写也弄成了小写。像句子<code>&quot;I reset the computer. It still didn’t boot!&quot;</code>已经变成了<code>&quot;iresetthecomputeritstilldidntboot&quot;</code>。在处理标点符号和大小写之前，你得先把它断成词语。当然了，你有一本厚厚的词典<code>dictionary</code>，不过，有些词没在词典里。假设文章用<code>sentence</code>表示，设计一个算法，把文章断开，要求未识别的字符最少，返回未识别的字符数。</p>
<a id="more"></a>

<p><strong>注意：</strong>本题相对原题稍作改动，只需返回未识别的字符数</p>
<p> <strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">dictionary &#x3D; [&quot;looked&quot;,&quot;just&quot;,&quot;like&quot;,&quot;her&quot;,&quot;brother&quot;]</span><br><span class="line">sentence &#x3D; &quot;jesslookedjustliketimherbrother&quot;</span><br><span class="line">输出： 7</span><br><span class="line">解释： 断句后为&quot;jess looked just like tim her brother&quot;，共7个未识别字符。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= len(sentence) &lt;= 1000</code></li>
<li><code>dictionary</code>中总字符数不超过 150000。</li>
<li>你可以认为<code>dictionary</code>和<code>sentence</code>中只包含小写字母。</li>
</ul>
<p>创建一个数组 dp 来记录结果，dp[i]表示句子中前 i 个字符中最少的未识别字符数。dp[0] = 0 代表空字符串时2没有未识别的字符。</p>
<p>对于句子中前 i 个字符，有两种情况：</p>
<ul>
<li>可能由前面的 [0, j) 字符串加上一个单词构成；dp[i] = min(dp[i], dp[j])；</li>
<li>前 i - 1 个字符加上第 i 个字符 ,dp[i] = dp[i - 1] + 1。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">respace</span><span class="params">(String[] dictionary, String sentence)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//将单词添加到 HashSet</span></span><br><span class="line">        Set&lt;String&gt; dic = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(String s : dictionary)&#123;</span><br><span class="line">            dic.add(s);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> n = sentence.length();</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="comment">//默认前面没有单词</span></span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++)&#123;</span><br><span class="line">                <span class="comment">//构成单词</span></span><br><span class="line">                <span class="keyword">if</span>(dic.contains(sentence.substring(j, i)))&#123;</span><br><span class="line">                    dp[i] = Math.min(dp[i], dp[j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度O(n^3)，contains 方法时间复杂度O(1)，substring 方法时间复杂度O(n)。空间复杂度O(n)。</p>
<p>时间复杂度较高的地方就是如何快速判断子串是否存在于词典中，这里使用「字典树 Trie」来进行优化，Trie 时是一种最大程度利用多个字符串前缀信息的数据结构，它可以在 O(w)时间复杂度内判断一个字符串是否是一个字符串集合中某个字符串的前缀，其中 w 代表字符串的长度。</p>
<p>我们将所有单词「反序」插入到字典树中，然后在每次判断子串末尾是否是一个单词时，从子串末尾i 开始遍历，同时在 Trie 上从根结点开始出发，当走到sentence[j] 在 Trie 上没有相应的位置，说明 sentence[j…i - 1]不是一个单词，退出循环。对于判断字典树结点是否为叶子结点，我们在单词末尾的结点上打上一个 isEnd 的标记。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Trie[] next;<span class="comment">//next结点数组</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> isEnd;<span class="comment">//结点是否为叶子结点</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Trie</span><span class="params">()</span></span>&#123;</span><br><span class="line">        next = <span class="keyword">new</span> Trie[<span class="number">26</span>];<span class="comment">//一个结点最多有 26 个字母</span></span><br><span class="line">        isEnd = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//将字符串 s 倒序插入字典树</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        Trie curPos = <span class="keyword">this</span>;</span><br><span class="line">		</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = s.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">int</span> t = s.charAt(i) - <span class="string">'a'</span>;</span><br><span class="line">            <span class="keyword">if</span>(curPos.next[t] == <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="comment">//新建结点</span></span><br><span class="line">                curPos.next[t] = <span class="keyword">new</span> Trie();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//向下移动</span></span><br><span class="line">            curPos = curPos.next[t];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最后一个结点 isEnd 设为 true</span></span><br><span class="line">        curPos.isEnd = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">respace</span><span class="params">(String[] dictionary, String sentence)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = sentence.length();</span><br><span class="line">        <span class="comment">//生成字典树</span></span><br><span class="line">        Trie root = <span class="keyword">new</span> Trie();</span><br><span class="line">        <span class="keyword">for</span>(String word : dictionary)&#123;</span><br><span class="line">            root.insert(word);</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//初始化 dp 数组</span></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        Arrays.fill(dp, Integer.MAX_VALUE);</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="comment">//默认子串最后没有单词</span></span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            Trie curPos = root;</span><br><span class="line">            <span class="comment">//逐个判断子串末尾的字符是否在字典树中</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &gt;= <span class="number">1</span>; j--)&#123;</span><br><span class="line">                <span class="keyword">int</span> t = sentence.charAt(j - <span class="number">1</span>) - <span class="string">'a'</span>;</span><br><span class="line">                <span class="keyword">if</span>(curPos.next[t] == <span class="keyword">null</span>)&#123;<span class="comment">//有一个字符不在字典树的路径中</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(curPos.next[t].isEnd)&#123;<span class="comment">//到达字典树末尾</span></span><br><span class="line">                    dp[i] = Math.min(dp[i], dp[j - <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(dp[i] == <span class="number">0</span>)&#123;<span class="comment">// 0 为最小值，直接退出循环</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//继续判断子串中前一个字符</span></span><br><span class="line">                curPos = curPos.next[t];</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度O(n^2)。空间复杂度O(n)。</p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>动态规划</tag>
        <tag>字典树</tag>
      </tags>
  </entry>
  <entry>
    <title>戳气球</title>
    <url>/2020/07/19/%E6%88%B3%E6%B0%94%E7%90%83/</url>
    <content><![CDATA[<h4 id="312-戳气球"><a href="#312-戳气球" class="headerlink" title="312. 戳气球"></a><a href="https://leetcode-cn.com/problems/burst-balloons/" target="_blank" rel="noopener">312. 戳气球</a></h4><p>有 <code>n</code> 个气球，编号为<code>0</code> 到 <code>n-1</code>，每个气球上都标有一个数字，这些数字存在数组 <code>nums</code> 中。</p>
<p>现在要求你戳破所有的气球。如果你戳破气球 <code>i</code> ，就可以获得 <code>nums[left] * nums[i] * nums[right]</code> 个硬币。 这里的 <code>left</code> 和 <code>right</code> 代表和 <code>i</code> 相邻的两个气球的序号。注意当你戳破了气球 <code>i</code> 后，气球 <code>left</code> 和气球 <code>right</code> 就变成了相邻的气球。</p>
<p>求所能获得硬币的最大数量。</p>
<a id="more"></a>

<p><strong>说明:</strong></p>
<ul>
<li>你可以假设 <code>nums[-1] = nums[n] = 1</code>，但注意它们不是真实存在的所以并不能被戳破。</li>
<li>0 ≤ <code>n</code> ≤ 500, 0 ≤ <code>nums[i]</code> ≤ 100</li>
</ul>
<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [3,1,5,8]</span><br><span class="line">输出: 167 </span><br><span class="line">解释: nums &#x3D; [3,1,5,8] --&gt; [3,5,8] --&gt;   [3,8]   --&gt;  [8]  --&gt; []</span><br><span class="line">     coins &#x3D;  3*1*5      +  3*5*8    +  1*3*8      + 1*8*1   &#x3D; 167</span><br></pre></td></tr></table></figure>

<p>为了避免讨论边界情况，我们将 nums 数组首尾各加上 一个 数字 1 ，将这个新数组叫做 val。</p>
<p><strong>方法一：记忆化搜索</strong></p>
<p>戳气球这个操作会使两个气球从不相邻变为相邻，使得后续操作难以进行，我们倒过来看这些操作，将全过程看作是每次添加一个气球。</p>
<p>定义方法 solve，令 <code>solve(i, j)</code>表示开区间<code>(i, j)</code>内位置全部填满能够得到的最多硬币数。由于是开区间，因此区间两端的气球编号就是 i 和 j，对应 val[i] 和 val[j]。</p>
<ul>
<li>当 <code>i &gt;= j - 1</code> 时，开区间中没有气球，<code>solve(i, j)</code>的值为 0 。</li>
<li>当<code>i &lt; j - 1</code> 时，我们枚举开区间<code>(i, j)</code>内的全部位置 mid，令 mid 为当前区间第一个添加的气球，此时，区间中只有 三个值 val[i]，val[mid]，val[j]，能得到的硬币数为这三个值的积。mid 将开区间<code>(i, j)</code>分为<code>(i, mid)</code>和<code>(mid, j)</code>两部分，我们递归地计算这两个部分对 <code>solve(i, j)</code>的贡献。</li>
</ul>
<p>$$<br>solve(i, j) = \max^{j-1}_{mid=i+1}{val[i]\times val[mid]\times val[j] + solve(i,mid) + solve(mid,j) }\ \  {i &lt; j - 1}<br>$$</p>
<p>$$<br>solve(i, j)  = 0 \ \  {i \geq j - 1}<br>$$</p>
<p>为了避免重复计算，我们储存 solve 的结果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[][] rec;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] val;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxCoins</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        val = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            val[i] = nums[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        val[<span class="number">0</span>] = val[n + <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        rec = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">2</span>][n + <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n + <span class="number">2</span>; i++)&#123;</span><br><span class="line">            Arrays.fill(rec[i], -<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> solve(<span class="number">0</span>, n + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left &gt;= right - <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(rec[left][right] != -<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> rec[left][right];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = left + <span class="number">1</span>; i &lt; right; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> sum = val[left] * val[i] * val[right];</span><br><span class="line">            sum += solve(left, i) + solve(i, right);</span><br><span class="line">            rec[left][right] = Math.max(rec[left][right], sum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rec[left][right];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度O(n^3)，空间复杂度O(n^2)。</p>
<p><strong>方法二：动态规划</strong></p>
<p>我们可以将自顶向下的记忆化搜索变为自底向上的动态规划，令 <code>dp[i][j]</code>表示填满开区间<code>(i, j)</code>能得到的最多硬币数，边界条件为 i &gt;= j - 1，此时<code>dp[i][j] = 0</code>。<br>$$<br>dp[i][j]=\max^{j-1}_{k=i+1}{val[i]\times val[k]\times val[j] + solve(i,k) + solve(k,j) }\ \   {i &lt; j - 1}<br>$$<br>$$<br>dp[i][j]  = 0 \ \  {i \geq j - 1}<br>$$</p>
<p>最终答案为<code>dp[0][n + 1]</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxCoins</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span>[][] rec = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">2</span>][n + <span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span>[] val = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">2</span>];</span><br><span class="line">        val[<span class="number">0</span>] = val[n + <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            val[i] = nums[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//从数组尾部开始自底向上动态规划</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;<span class="comment">//枚举左边界</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">2</span>; j &lt;= n + <span class="number">1</span>; j++)&#123;<span class="comment">//枚举右边界</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = i + <span class="number">1</span>; k &lt; j; k++)&#123;<span class="comment">//枚举开区间(i, j)中的全部位置</span></span><br><span class="line">                    <span class="keyword">int</span> sum = val[i] * val[k] * val[j];</span><br><span class="line">                    sum += rec[i][k] + rec[k][j];</span><br><span class="line">                    rec[i][j] = Math.max(rec[i][j], sum);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> rec[<span class="number">0</span>][n + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度O(n^3)，空间复杂度O(n^2)。</p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode Hard</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>恢复二叉搜索树</title>
    <url>/2020/08/08/%E6%81%A2%E5%A4%8D%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
    <content><![CDATA[<h4 id="99-恢复二叉搜索树"><a href="#99-恢复二叉搜索树" class="headerlink" title="99. 恢复二叉搜索树"></a><a href="https://leetcode-cn.com/problems/recover-binary-search-tree/" target="_blank" rel="noopener">99. 恢复二叉搜索树</a></h4><p>二叉搜索树中的两个节点被错误地交换。</p>
<p>请在不改变其结构的情况下，恢复这棵树。</p>
<a id="more"></a>

<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,3,null,null,2]</span><br><span class="line"></span><br><span class="line">   1</span><br><span class="line">  &#x2F;</span><br><span class="line"> 3</span><br><span class="line">  \</span><br><span class="line">   2</span><br><span class="line"></span><br><span class="line">输出: [3,1,null,null,2]</span><br><span class="line"></span><br><span class="line">   3</span><br><span class="line">  &#x2F;</span><br><span class="line"> 1</span><br><span class="line">  \</span><br><span class="line">   2</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [3,1,4,null,null,2]</span><br><span class="line"></span><br><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">1   4</span><br><span class="line">   &#x2F;</span><br><span class="line">  2</span><br><span class="line"></span><br><span class="line">输出: [2,1,4,null,null,3]</span><br><span class="line"></span><br><span class="line">  2</span><br><span class="line"> &#x2F; \</span><br><span class="line">1   4</span><br><span class="line">   &#x2F;</span><br><span class="line">  3</span><br></pre></td></tr></table></figure>

<p><strong>进阶:</strong></p>
<ul>
<li>使用 O(<em>n</em>) 空间复杂度的解法很容易实现。</li>
<li>你能想出一个只使用常数空间的解决方案吗？</li>
</ul>
<p><strong>方法一：显式中序遍历</strong></p>
<p>我们知道 BST 的中序遍历是有序的，我们可以使用一个数组存储中序遍历的结点。在交换了两个结点之后的数组，如果我们将其画成折线图，我们会发现存在一段或两段 “下降” 的折线。下面看几个示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">交换两个结点后的中序遍历序列:</span><br><span class="line">[1, 3, 2, 4], 存在一段下降的折线[3, 2]，我们交换 “3” 和 “2” 即可</span><br><span class="line">[1, 5, 3 ,4 ,2 ,6], 存在两段下降的折线[5, 3] 和[4, 2]，我们交换左边折线的结点“5” 和右边折线的结点 “2” 即可。</span><br><span class="line">总结：我们只需要找到一个下降折线的左边结点和一个下降折线的右边结点，而不管折线有一根和两根折线。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recoverTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;TreeNode&gt; nodes = <span class="keyword">new</span> ArrayList&lt;TreeNode&gt;();</span><br><span class="line">        <span class="comment">//存储中序遍历得到的结点</span></span><br><span class="line">        inOrder(root, nodes);</span><br><span class="line">        <span class="keyword">int</span> n = nodes.size(); </span><br><span class="line">		<span class="comment">//寻找“下降”折线的左侧结点</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(; i &lt; n - <span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nodes.get(i).val &gt; nodes.get(i + <span class="number">1</span>).val)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//寻找“下降”折线的右侧结点</span></span><br><span class="line">        <span class="keyword">for</span>(; j &gt; <span class="number">0</span>; j--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nodes.get(j).val &lt; nodes.get(j - <span class="number">1</span>).val)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//交换结点的值</span></span><br><span class="line">        TreeNode n1 = nodes.get(i);</span><br><span class="line">        TreeNode n2 = nodes.get(j);</span><br><span class="line">        <span class="keyword">int</span> temp = n1.val;</span><br><span class="line">        n1.val = n2.val;</span><br><span class="line">        n2.val = temp;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(TreeNode root, List&lt;TreeNode&gt; nodes)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        inOrder(root.left, nodes);</span><br><span class="line">        nodes.add(root);</span><br><span class="line">        inOrder(root.right, nodes);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>空间复杂度O(n)，时间复杂度O(n)。</p>
<p><strong>方法二：隐式中序遍历</strong></p>
<p>在方法一中，我们使用了一个数组来保存中序遍历的结点，我们可以在中序遍历的过程中找到两个交换的结点，从而避免了存储中序遍历的结点。</p>
<p>我们使用 pre 来指向前一个遍历的结点，pre.val &gt; root.val 代表这是一段下降的折线，那我们可以先保存折线左侧的结点，然后再保存折线右侧的结点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    TreeNode x = <span class="keyword">null</span>;</span><br><span class="line">    TreeNode y = <span class="keyword">null</span>;</span><br><span class="line">    TreeNode pre = <span class="keyword">new</span> TreeNode(Integer.MIN_VALUE);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recoverTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        inOrder(root);</span><br><span class="line">        <span class="comment">//交换结点的值</span></span><br><span class="line">        <span class="keyword">int</span> temp = x.val;</span><br><span class="line">        x.val = y.val;</span><br><span class="line">        y.val = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        inOrder(root.left);</span><br><span class="line">        <span class="comment">//第一个结点</span></span><br><span class="line">        <span class="keyword">if</span>(x == <span class="keyword">null</span> &amp;&amp; pre.val &gt; root.val)&#123;</span><br><span class="line">            x = pre;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//第一个结点不为空才保存第二个结点</span></span><br><span class="line">        <span class="keyword">if</span>(x != <span class="keyword">null</span> &amp;&amp; pre.val &gt; root.val)&#123;</span><br><span class="line">            y = root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//更新前一个遍历的结点 pre</span></span><br><span class="line">        pre = root;</span><br><span class="line">        inOrder(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>空间复杂度O(h)，h 为二叉树的高度。时间复杂度O(n)。</p>
<p><strong>方法三：Morris 中序遍历</strong></p>
<p>Morris 非递归中序遍历空间复杂度可以降为O(1)。</p>
<p>Morris 遍历算法步骤如下（假设当前遍历到的结点为 x ）：</p>
<ol>
<li>如果 x 无左孩子，则访问 x 的右孩子， 即 x = x.right。</li>
<li>如果 x 有左孩子，则找到 x 左子树上的最右结点（即左子树中序遍历的最后一个结点，x 在中序遍历的前驱结点），记为 predecessor。根据 predecessor的右孩子是否为空，进行如下操作：<ul>
<li>如果 predecessor的右孩子为空，将其右孩子指向 x ，然后访问 x 的左孩子，即 x = x.left。</li>
<li>如果 predecessor的右孩子不为空，则此时其右孩子指向 x ，说明我们已经遍历完 x 的左子树，我们将 predecessor的右孩子置空，然后访问 x 的右孩子，即 x = x.right。</li>
</ul>
</li>
</ol>
<p>重复上述操作，直至访问完整棵树。</p>
<p>整个过程我们只多做一步：将当前结点左子树中的最右边的结点指向它，这样在左子树遍历完成后，我们可以通过这个指针回到 x，且能通过这个知道我们已经遍历完成了左子树，省去了栈的空间。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recoverTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        TreeNode x = <span class="keyword">null</span>, y = <span class="keyword">null</span>, pred = <span class="keyword">null</span>, predecessor = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(root != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(root.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="comment">//寻找 predecessor 结点(root 结点中序遍历前一个结点)</span></span><br><span class="line">                predecessor = root.left;</span><br><span class="line">                <span class="keyword">while</span>(predecessor.right != <span class="keyword">null</span> &amp;&amp; predecessor.right != root)&#123;</span><br><span class="line">                    predecessor = predecessor.right;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//让 predecessor 的右指针指向 root，继续遍历左子树</span></span><br><span class="line">                <span class="keyword">if</span>(predecessor.right == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    predecessor.right = root;</span><br><span class="line">                    root = root.left;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//左子树已经访问完了，我们需要断开连接</span></span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(pred != <span class="keyword">null</span> &amp;&amp; root.val &lt; pred.val)&#123;</span><br><span class="line">                        y = root;</span><br><span class="line">                        <span class="keyword">if</span>(x == <span class="keyword">null</span>)&#123;</span><br><span class="line">                            x = pred;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//更新前一个遍历的结点 pred</span></span><br><span class="line">                    pred = root;</span><br><span class="line">                    <span class="comment">//断开连接</span></span><br><span class="line">                    predecessor.right = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="comment">//继续遍历右子树</span></span><br><span class="line">                    root = root.right;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果没有左孩子，直接访问右孩子</span></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(pred != <span class="keyword">null</span> &amp;&amp; root.val &lt; pred.val)&#123;</span><br><span class="line">                    y = root;</span><br><span class="line">                    <span class="keyword">if</span>(x == <span class="keyword">null</span>)&#123;</span><br><span class="line">                        x = pred;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                pred = root;</span><br><span class="line">                root = root.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//交换 x 和 y 的值</span></span><br><span class="line">        <span class="keyword">int</span> temp = x.val;</span><br><span class="line">        x.val = y.val;</span><br><span class="line">        y.val = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度O(n)，空间复杂度O(1)。</p>
<p>参见<a href="https://leetcode-cn.com/problems/recover-binary-search-tree/solution/san-chong-jie-fa-xiang-xi-tu-jie-99-hui-fu-er-cha-/" target="_blank" rel="noopener">王尼玛的幻灯片</a>更好地理解算法过程。</p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode Hard</tag>
        <tag>二叉搜索树</tag>
      </tags>
  </entry>
  <entry>
    <title>打家劫舍</title>
    <url>/2020/07/01/%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D/</url>
    <content><![CDATA[<h4 id="198-打家劫舍"><a href="#198-打家劫舍" class="headerlink" title="198. 打家劫舍"></a><a href="https://leetcode-cn.com/problems/house-robber/" target="_blank" rel="noopener">198. 打家劫舍</a></h4><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong>。</p>
<p>给定一个代表每个房屋存放金额的非负整数数组，计算你<strong>在不触动警报装置的情况下，</strong>能够偷窃到的最高金额。</p>
 <a id="more"></a>

<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,2,3,1]</span><br><span class="line">输出: 4</span><br><span class="line">解释: 偷窃 1 号房屋 (金额 &#x3D; 1) ，然后偷窃 3 号房屋 (金额 &#x3D; 3)。</span><br><span class="line">     偷窃到的最高金额 &#x3D; 1 + 3 &#x3D; 4 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [2,7,9,3,1]</span><br><span class="line">输出: 12</span><br><span class="line">解释: 偷窃 1 号房屋 (金额 &#x3D; 2), 偷窃 3 号房屋 (金额 &#x3D; 9)，接着偷窃 5 号房屋 (金额 &#x3D; 1)。</span><br><span class="line">     偷窃到的最高金额 &#x3D; 2 + 9 + 1 &#x3D; 12 。</span><br></pre></td></tr></table></figure>

<p>以示例 2 为例：</p>
<ol>
<li>当只有一个数 2 时我们只能偷2；</li>
<li>当有两个数 2，7 时我们选择偷 7 ；</li>
<li>当有2，7，9 时，我们比较 2+9 和7 谁大就取谁，偷 2+9 =11；</li>
<li>当有2，7，9，3 时我们有 11 和（3+7）比较 选择 11 ；</li>
<li>当2，7，9，3，1 时 11 和 11 +1 我们选择 12。</li>
</ol>
<p>设 f(n) 为偷盗前 n 个房屋的最高金额，则 f(n) = max( f(n-1), f(n-2) + num)。即偷盗前 n 个房屋可以有偷第 n 个房屋和不偷第 n 个房屋两种选择，取其中金额最大的一个。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> preMax = <span class="number">0</span>, curMax = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x : nums)&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = curMax;</span><br><span class="line">        curMax = Math.max(preMax + x , curMax);</span><br><span class="line">        preMax = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> curMax;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度O(n)，空间复杂度O(1)。</p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode Easy</tag>
        <tag>动态规划</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>打家劫舍III</title>
    <url>/2020/08/05/%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8DIII/</url>
    <content><![CDATA[<h4 id="337-打家劫舍-III"><a href="#337-打家劫舍-III" class="headerlink" title="337. 打家劫舍 III"></a><a href="https://leetcode-cn.com/problems/house-robber-iii/" target="_blank" rel="noopener">337. 打家劫舍 III</a></h4><p>在上次打劫完一条街道之后和一圈房屋后，小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为“根”。 除了“根”之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。</p>
<p>计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。</p>
<a id="more"></a>

<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [3,2,3,null,3,null,1]</span><br><span class="line"></span><br><span class="line">     3</span><br><span class="line">    &#x2F; \</span><br><span class="line">   2   3</span><br><span class="line">    \   \ </span><br><span class="line">     3   1</span><br><span class="line"></span><br><span class="line">输出: 7 </span><br><span class="line">解释: 小偷一晚能够盗取的最高金额 &#x3D; 3 + 3 + 1 &#x3D; 7.</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [3,4,5,1,3,null,1]</span><br><span class="line"></span><br><span class="line">     3</span><br><span class="line">    &#x2F; \</span><br><span class="line">   4   5</span><br><span class="line">  &#x2F; \   \ </span><br><span class="line"> 1   3   1</span><br><span class="line"></span><br><span class="line">输出: 9</span><br><span class="line">解释: 小偷一晚能够盗取的最高金额 &#x3D; 4 + 5 &#x3D; 9.</span><br></pre></td></tr></table></figure>

<p>很显然，对于每个房子，我们有偷和不偷两种状态，我们取的是这两种状态偷盗的金额的最大值。</p>
<p>我们用 <code>f(o)</code>表示选择结点 o 的情况下，o 结点的子树上被选择的结点的最大权值和；<code>g(o)</code>表示不选择结点 o 的情况下，o 结点的子树上被选择的结点的最大权值和；l 和 r 代表 o 的左右孩子。</p>
<ul>
<li>当 o 被选中时，l 和 r 都不能选中，<code>f(o) = f(l) + f(r)</code>;</li>
<li>当 o 不被选中时，l 和 r 都能被选中或<strong>不被选择</strong>，<code>g(o) = max(f(l), g(l)) + max(f(r), g(r))</code>;</li>
</ul>
<p>第二种情况：二叉树[4,1,null,2,null,3] 的偷盗最大金额为 7 ，选中 4 之后，不能选择子节点 1 ， 对于子节点 1 ，可以有选择 2 和 不选择 2 两种选择，选择 2 得到最后金额 6 ，不选择 2 得到最大金额 7 。即对于一个未选择的根节点，继续不选择子节点有可能会有更好的结果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Map&lt;TreeNode, Integer&gt; f = <span class="keyword">new</span> HashMap&lt;&gt;(); <span class="comment">// 存储不选择结点的金额</span></span><br><span class="line">    Map&lt;TreeNode, Integer&gt; g = <span class="keyword">new</span> HashMap&lt;&gt;(); <span class="comment">//存储选择结点的金额</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="comment">//返回选择根节点和不选择根节点的最大值</span></span><br><span class="line">        <span class="keyword">return</span> Math.max(f.getOrDefault(root, <span class="number">0</span>), g.getOrDefault(root, <span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dfs(root.left);</span><br><span class="line">        dfs(root.right);</span><br><span class="line">		<span class="comment">//选择根节点</span></span><br><span class="line">        f.put(root, root.val + g.getOrDefault(root.left, <span class="number">0</span>) + g.getOrDefault(root.right, <span class="number">0</span>));</span><br><span class="line">        <span class="comment">//不选择根节点</span></span><br><span class="line">        g.put(root, Math.max(f.getOrDefault(root.left, <span class="number">0</span>), g.getOrDefault(root.left, <span class="number">0</span>)) + </span><br><span class="line">            Math.max(f.getOrDefault(root.right, <span class="number">0</span>), g.getOrDefault(root.right, <span class="number">0</span>)) );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度O(n)，对二叉树做了一次后序遍历。</p>
<p>空间复杂度O(n)，栈空间O(n)，哈希表O(n)。</p>
<p>我们还可以对空间复杂度进行优化，可以看出，对于 <code>f(o)</code>或<code>g(o)</code>，它们的取值只与<code>f(l)</code>、<code>f(r)</code>、<code>g(l)</code>、<code>g(r)</code>有关，我们在递归返回时返回一个数组，这样就可以不适用哈希表。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] rootStatus = dfs(root);</span><br><span class="line">        <span class="keyword">return</span> Math.max(rootStatus[<span class="number">0</span>], rootStatus[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] dfs(TreeNode root)&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//l[0] 代表选择结点 l得到的金额，l[1] 代表不选择结点 l 得到的金额。</span></span><br><span class="line">        <span class="keyword">int</span>[] l = dfs(root.left);</span><br><span class="line">        <span class="keyword">int</span>[] r = dfs(root.right);</span><br><span class="line">        <span class="keyword">int</span> selected = root.val + l[<span class="number">1</span>] + r[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> notSelected = Math.max(l[<span class="number">0</span>], l[<span class="number">1</span>]) + Math.max(r[<span class="number">0</span>], r[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;selected, notSelected&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度O(n)，对二叉树做了一次后序遍历。</p>
<p>空间复杂度O(n)，栈空间O(n)。</p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode Medium</tag>
        <tag>动态规划</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>托普利茨矩阵</title>
    <url>/2021/02/22/%E6%89%98%E6%99%AE%E5%88%A9%E8%8C%A8%E7%9F%A9%E9%98%B5/</url>
    <content><![CDATA[<h4 id="766-托普利茨矩阵"><a href="#766-托普利茨矩阵" class="headerlink" title="766. 托普利茨矩阵"></a><a href="https://leetcode-cn.com/problems/toeplitz-matrix/" target="_blank" rel="noopener">766. 托普利茨矩阵</a></h4><p>给你一个 <code>m x n</code> 的矩阵 <code>matrix</code> 。如果这个矩阵是托普利茨矩阵，返回 <code>true</code> ；否则，返回 <code>false</code> <em>。</em></p>
<p>如果矩阵上每一条由左上到右下的对角线上的元素都相同，那么这个矩阵是 <strong>托普利茨矩阵</strong> 。</p>
 <a id="more"></a>

<p><strong>示例 1：</strong></p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20210222081038267.png" alt="image-20210222081038267"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：matrix &#x3D; [[1,2,3,4],[5,1,2,3],[9,5,1,2]]</span><br><span class="line">输出：true</span><br><span class="line">解释：</span><br><span class="line">在上述矩阵中, 其对角线为: </span><br><span class="line">&quot;[9]&quot;, &quot;[5, 5]&quot;, &quot;[1, 1, 1]&quot;, &quot;[2, 2, 2]&quot;, &quot;[3, 3]&quot;, &quot;[4]&quot;。 </span><br><span class="line">各条对角线上的所有元素均相同, 因此答案是 True 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20210222081059141.png" alt="image-20210222081059141"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：matrix &#x3D; [[1,2],[2,2]]</span><br><span class="line">输出：false</span><br><span class="line">解释：</span><br><span class="line">对角线 &quot;[1, 2]&quot; 上的元素不同。</span><br></pre></td></tr></table></figure>

<p> <strong>提示：</strong></p>
<ul>
<li><p><code>m == matrix.length</code></p>
</li>
<li><p><code>n == matrix[i].length</code></p>
</li>
<li><p><code>1 &lt;= m, n &lt;= 20</code></p>
</li>
<li><p><code>0 &lt;= matrix[i][j] &lt;= 99</code></p>
<p><strong>进阶：</strong></p>
</li>
<li><p>如果矩阵存储在磁盘上，并且内存有限，以至于一次最多只能将矩阵的一行加载到内存中，该怎么办？</p>
</li>
<li><p>如果矩阵太大，以至于一次只能将不完整的一行加载到内存中，该怎么办？</p>
</li>
</ul>
<p><strong>方法一：遍历</strong></p>
<p>可以发现，托普利兹矩阵中每一个元素都和它左上角的元素相等，我们直接比较当前元素和左上角元素是否相等。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isToeplitzMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = matrix.length;</span><br><span class="line">        <span class="keyword">int</span> n = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(matrix[i][j] != matrix[i - <span class="number">1</span>][j - <span class="number">1</span>])&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度O(mn)，m 和 n 分别是数组的长宽</li>
<li>空间复杂度O(1)</li>
</ul>
<p>进阶问题一：将每一行从硬盘复制到内存中的一个连续数组中，在读取下一行时，直接与内存中的数据进行比较。</p>
<p>进阶问题二：将数组竖直切分为若干个子矩阵，保证两个相邻的子矩阵至少有一行或一列是重合 的，判断子矩阵是否符合要求。</p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode Easy</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>扫雷游戏</title>
    <url>/2020/08/20/%E6%89%AB%E9%9B%B7%E6%B8%B8%E6%88%8F/</url>
    <content><![CDATA[<h4 id="529-扫雷游戏"><a href="#529-扫雷游戏" class="headerlink" title="529. 扫雷游戏"></a><a href="https://leetcode-cn.com/problems/minesweeper/" target="_blank" rel="noopener">529. 扫雷游戏</a></h4><p>让我们一起来玩扫雷游戏！</p>
<p>给定一个代表游戏板的二维字符矩阵。 <strong>‘M’</strong> 代表一个<strong>未挖出的</strong>地雷，<strong>‘E’</strong> 代表一个<strong>未挖出的</strong>空方块，<strong>‘B’</strong> 代表没有相邻（上，下，左，右，和所有4个对角线）地雷的<strong>已挖出的</strong>空白方块，<strong>数字</strong>（’1’ 到 ‘8’）表示有多少地雷与这块<strong>已挖出的</strong>方块相邻，<strong>‘X’</strong> 则表示一个<strong>已挖出的</strong>地雷。</p>
<p>现在给出在所有<strong>未挖出的</strong>方块中（’M’或者’E’）的下一个点击位置（行和列索引），根据以下规则，返回相应位置被点击后对应的面板：</p>
<ol>
<li><p>如果一个地雷（’M’）被挖出，游戏就结束了- 把它改为 <strong>‘X’</strong>。</p>
</li>
<li><p>如果一个<strong>没有相邻地雷</strong>的空方块（’E’）被挖出，修改它为（’B’），并且所有和其相邻的<strong>未挖出</strong>方块都应该被递归地揭露。</p>
</li>
<li><p>如果一个<strong>至少与一个地雷相邻</strong>的空方块（’E’）被挖出，修改它为数字（’1’到’8’），表示相邻地雷的数量。</p>
</li>
<li><p>如果在此次点击中，若无更多方块可被揭露，则返回面板。</p>
<a id="more"></a>

</li>
</ol>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: </span><br><span class="line"></span><br><span class="line">[[&#39;E&#39;, &#39;E&#39;, &#39;E&#39;, &#39;E&#39;, &#39;E&#39;],</span><br><span class="line"> [&#39;E&#39;, &#39;E&#39;, &#39;M&#39;, &#39;E&#39;, &#39;E&#39;],</span><br><span class="line"> [&#39;E&#39;, &#39;E&#39;, &#39;E&#39;, &#39;E&#39;, &#39;E&#39;],</span><br><span class="line"> [&#39;E&#39;, &#39;E&#39;, &#39;E&#39;, &#39;E&#39;, &#39;E&#39;]]</span><br><span class="line"></span><br><span class="line">Click : [3,0]</span><br><span class="line"></span><br><span class="line">输出: </span><br><span class="line"></span><br><span class="line">[[&#39;B&#39;, &#39;1&#39;, &#39;E&#39;, &#39;1&#39;, &#39;B&#39;],</span><br><span class="line"> [&#39;B&#39;, &#39;1&#39;, &#39;M&#39;, &#39;1&#39;, &#39;B&#39;],</span><br><span class="line"> [&#39;B&#39;, &#39;1&#39;, &#39;1&#39;, &#39;1&#39;, &#39;B&#39;],</span><br><span class="line"> [&#39;B&#39;, &#39;B&#39;, &#39;B&#39;, &#39;B&#39;, &#39;B&#39;]]</span><br><span class="line"></span><br><span class="line">解释:</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: </span><br><span class="line"></span><br><span class="line">[[&#39;B&#39;, &#39;1&#39;, &#39;E&#39;, &#39;1&#39;, &#39;B&#39;],</span><br><span class="line"> [&#39;B&#39;, &#39;1&#39;, &#39;M&#39;, &#39;1&#39;, &#39;B&#39;],</span><br><span class="line"> [&#39;B&#39;, &#39;1&#39;, &#39;1&#39;, &#39;1&#39;, &#39;B&#39;],</span><br><span class="line"> [&#39;B&#39;, &#39;B&#39;, &#39;B&#39;, &#39;B&#39;, &#39;B&#39;]]</span><br><span class="line"></span><br><span class="line">Click : [1,2]</span><br><span class="line"></span><br><span class="line">输出: </span><br><span class="line"></span><br><span class="line">[[&#39;B&#39;, &#39;1&#39;, &#39;E&#39;, &#39;1&#39;, &#39;B&#39;],</span><br><span class="line"> [&#39;B&#39;, &#39;1&#39;, &#39;X&#39;, &#39;1&#39;, &#39;B&#39;],</span><br><span class="line"> [&#39;B&#39;, &#39;1&#39;, &#39;1&#39;, &#39;1&#39;, &#39;B&#39;],</span><br><span class="line"> [&#39;B&#39;, &#39;B&#39;, &#39;B&#39;, &#39;B&#39;, &#39;B&#39;]]</span><br><span class="line"></span><br><span class="line">解释:</span><br></pre></td></tr></table></figure>

<p> <strong>注意：</strong></p>
<ol>
<li>输入矩阵的宽和高的范围为 [1,50]。</li>
<li>点击的位置只能是未被挖出的方块 (‘M’ 或者 ‘E’)，这也意味着面板至少包含一个可点击的方块。</li>
<li>输入面板不会是游戏结束的状态（即有地雷已被挖出）。</li>
<li>简单起见，未提及的规则在这个问题中可被忽略。例如，当游戏结束时你不需要挖出所有地雷，考虑所有你可能赢得游戏或标记方块的情况。</li>
</ol>
<p>对于我们点击的每一个方块，有两种情况：</p>
<ul>
<li>当前点击的方块是未挖出的地雷，将其值改为 X；</li>
<li>当前点击的是为未挖出的空方块，我们需要统计它周围相邻的方块里地雷的数量cnt（即M 的数量）。如果 cnt 为 0 ，则将其改为 B，且递归地处理周围<strong>八个</strong>未挖出地方块，如果 cnt 不为 0 ，将其改为数字即可。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] dx = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span>[] dy = &#123;<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">char</span>[][] updateBoard(<span class="keyword">char</span>[][] board, <span class="keyword">int</span>[] click) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = click[<span class="number">0</span>], y = click[<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//判断当前方块是否为地雷</span></span><br><span class="line">        <span class="keyword">if</span>(board[x][y] == <span class="string">'M'</span>)&#123;</span><br><span class="line">            board[x][y] = <span class="string">'X'</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            dfs(board, x, y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> board;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//统计当前空方块周围地雷数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> tx = x + dx[i];</span><br><span class="line">            <span class="keyword">int</span> ty = y + dy[i];</span><br><span class="line">            <span class="keyword">if</span>(tx &lt; <span class="number">0</span> || tx &gt;= board.length || ty &lt; <span class="number">0</span> || ty &gt;= board[<span class="number">0</span>].length)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(board[tx][ty] == <span class="string">'M'</span>)&#123;</span><br><span class="line">                ++cnt;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//地雷数大于零，直接修改当前方块为地雷数</span></span><br><span class="line">        <span class="keyword">if</span>(cnt &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            board[x][y] = (<span class="keyword">char</span>) (cnt + <span class="string">'0'</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//周围没有地雷，递归地对周围八个方块进行搜索</span></span><br><span class="line">            board[x][y] = <span class="string">'B'</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i)&#123;</span><br><span class="line">                <span class="keyword">int</span> tx = x + dx[i];</span><br><span class="line">                <span class="keyword">int</span> ty = y + dy[i];</span><br><span class="line">                <span class="comment">//碰到边界或者不是未挖出的方块时返回</span></span><br><span class="line">                <span class="keyword">if</span>(tx &lt; <span class="number">0</span> || tx &gt;= board.length || ty &lt; <span class="number">0</span> || ty &gt;= board[<span class="number">0</span>].length || board[tx][ty] != <span class="string">'E'</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                dfs(board, tx, ty);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度O(mn)，空间复杂度O(mn)，m 和 n 为面板的长宽。</p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode Medium</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>找到所有数组中消失的数字</title>
    <url>/2020/04/09/%E6%89%BE%E5%88%B0%E6%89%80%E6%9C%89%E6%95%B0%E7%BB%84%E4%B8%AD%E6%B6%88%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<h4 id="448-找到所有数组中消失的数字"><a href="#448-找到所有数组中消失的数字" class="headerlink" title="448. 找到所有数组中消失的数字"></a><a href="https://leetcode-cn.com/problems/find-all-numbers-disappeared-in-an-array/" target="_blank" rel="noopener">448. 找到所有数组中消失的数字</a></h4><p>给定一个范围在 1 ≤ a[i] ≤ <em>n</em> ( <em>n</em> = 数组大小 ) 的 整型数组，数组中的元素一些出现了两次，另一些只出现一次。</p>
<p>找到所有在 [1, <em>n</em>] 范围之间没有出现在数组中的数字。</p>
 <a id="more"></a>

<p>您能在不使用额外空间且时间复杂度为<em>O(n)</em>的情况下完成这个任务吗? 你可以假定返回的数组不算在额外空间内。</p>
<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">[4,3,2,7,8,2,3,1]</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line">[5,6]</span><br></pre></td></tr></table></figure>

<p>将当前元素的值的绝对值作为下标，将以当前元素为下标的数组元素值置位为负，再遍历一次数组即可找出所有未出现的数字。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findDisappearedNumbers</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> index = Math.abs(nums[i])-<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//标记</span></span><br><span class="line">        <span class="keyword">if</span>(nums[index]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            nums[index] = -nums[index];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            res.add(i+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度O(n)，空间复杂度O(1)。</p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode Easy</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>把数字翻译成字符串</title>
    <url>/2020/07/01/%E6%8A%8A%E6%95%B0%E5%AD%97%E7%BF%BB%E8%AF%91%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<h4 id="面试题46-把数字翻译成字符串"><a href="#面试题46-把数字翻译成字符串" class="headerlink" title="面试题46. 把数字翻译成字符串"></a><a href="https://leetcode-cn.com/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof/" target="_blank" rel="noopener">面试题46. 把数字翻译成字符串</a></h4><p>给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。</p>
 <a id="more"></a>

<p> <strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 12258</span><br><span class="line">输出: 5</span><br><span class="line">解释: 12258有5种不同的翻译，分别是&quot;bccfi&quot;, &quot;bwfi&quot;, &quot;bczi&quot;, &quot;mcfi&quot;和&quot;mzi&quot;</span><br></pre></td></tr></table></figure>

<p> <strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= num &lt; 231</code></li>
</ul>
<p>将 12258 的每一位翻译为一个字母得到 “bccfi”；</p>
<p>将 12258 中的 22 翻译为 “w” ，其他的每一位翻译为一个字母得到 “bwfi”；</p>
<p>可以总结出翻译的规则，字符串的 i 位置：</p>
<ul>
<li>可以单独作为一位来翻译</li>
<li>如果第 i - 1 位和第 i 位组成的数字在 10 到 25 之间，可以把这两位连起来翻译</li>
</ul>
<p>用 f(i) 表示以第 i 位结尾的前缀串翻译的方案数，考虑每一位单独翻译和前一位连起来再翻译的贡献。单独翻译对 f(i) 的贡献为 f(i - 1)；如果第 i - 1 位存在，第 i - 1位和第 i 位连起来的数字 x 满足 10 &lt;= x &lt;= 25，那么可以连起来翻译，对 f(i) 的贡献为 f(i - 2)，否则为 0。</p>
<p>我们可以列出下面的动态规划转移方程：</p>
<p>f(i) = f(i - 1) + f(i - 2) ( i - 1 &gt;= 0，10 &lt;= x &lt;= 25)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">translateNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        String src = String.valueOf(num);</span><br><span class="line">        <span class="keyword">int</span> p = <span class="number">0</span>, q = <span class="number">0</span>, r = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; src.length(); i++)&#123;</span><br><span class="line">            p = q;</span><br><span class="line">            q = r;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            String pre = src.substring(i - <span class="number">1</span>, i + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(pre.compareTo(<span class="string">"25"</span>) &lt;= <span class="number">0</span> &amp;&amp; pre.compareTo(<span class="string">"10"</span>) &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                r += p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度 O(log n)，空间复杂度O(logn)。</p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode Medium</tag>
        <tag>动态规划</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>打家劫舍II</title>
    <url>/2021/04/15/%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8DII/</url>
    <content><![CDATA[<h4 id="213-打家劫舍-II"><a href="#213-打家劫舍-II" class="headerlink" title="213. 打家劫舍 II"></a><a href="https://leetcode-cn.com/problems/house-robber-ii/" target="_blank" rel="noopener">213. 打家劫舍 II</a></h4><p>你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 <strong>围成一圈</strong> ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong> 。</p>
<p>给定一个代表每个房屋存放金额的非负整数数组，计算你 <strong>在不触动警报装置的情况下</strong> ，能够偷窃到的最高金额。</p>
 <a id="more"></a>

<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [2,3,2]</span><br><span class="line">输出：3</span><br><span class="line">解释：你不能先偷窃 1 号房屋（金额 &#x3D; 2），然后偷窃 3 号房屋（金额 &#x3D; 2）, 因为他们是相邻的。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [1,2,3,1]</span><br><span class="line">输出：4</span><br><span class="line">解释：你可以先偷窃 1 号房屋（金额 &#x3D; 1），然后偷窃 3 号房屋（金额 &#x3D; 3）。</span><br><span class="line">     偷窃到的最高金额 &#x3D; 1 + 3 &#x3D; 4 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [0]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure>

<p> <strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 100</code></li>
<li><code>0 &lt;= nums[i] &lt;= 1000</code></li>
</ul>
<p><strong>方法一：动态规划</strong></p>
<p>此题是<a href="https://hoo334.github.io/2020/07/01/%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D/">打家劫舍</a>的进阶，与打家劫舍不同的是，这题中的房屋是首尾相连的，第一间和最后一间房屋相邻，因此第一间房屋和最后一间房屋不能在同一晚上偷窃。</p>
<p>假设数组 nums 的长度为 n。如果不偷窃最后一间房屋，则偷窃房屋的下标范围是[0, n - 2]；如果偷最后一间房屋，则偷窃房屋的下标是[1, n - 1]。在确定偷窃房屋的下标范围之后，即可用打家劫舍中的方法解决。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//第一个房子和最后一个房子只能选择偷一个，因此做两次动态规划就可以了。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">1</span>)<span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">//偷第一个房子</span></span><br><span class="line">        <span class="keyword">int</span> first = robHelper(Arrays.copyOfRange(nums, <span class="number">0</span>, nums.length-<span class="number">1</span>));</span><br><span class="line">        <span class="comment">//偷最后一个房子</span></span><br><span class="line">        <span class="keyword">int</span> last = robHelper(Arrays.copyOfRange(nums, <span class="number">1</span>, nums.length));</span><br><span class="line">        <span class="keyword">return</span> Math.max(first,last);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">robHelper</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pre=<span class="number">0</span>,cur=<span class="number">0</span>,temp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.length; ++i)&#123;</span><br><span class="line">            temp = cur;</span><br><span class="line">            cur = Math.max(pre+nums[i], cur);</span><br><span class="line">            pre = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度O(n)</li>
<li>空间复杂度O(1)</li>
</ul>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode Medium</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法</title>
    <url>/2020/04/22/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h3 id="冒泡排序（Bubble-Sort）"><a href="#冒泡排序（Bubble-Sort）" class="headerlink" title="冒泡排序（Bubble Sort）"></a>冒泡排序（Bubble Sort）</h3><p>冒泡排序是一种简单的排序算法。它重复地遍历要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。每次遍历一次都使一个元素归位。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bubble</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = a.length;</span><br><span class="line">		<span class="comment">//外层循环 N-1 次</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;N-<span class="number">1</span>; ++i)&#123;</span><br><span class="line">            <span class="comment">//内层循环 N-i-1 次。第 i 次遍历整个数组需要交换 N-i-1 次。</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;N-i; j++)&#123;</span><br><span class="line">                <span class="comment">//比较和交换</span></span><br><span class="line">                <span class="keyword">if</span>(a[j].compareTo(a[j-<span class="number">1</span>]) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                    Comparable temp = a[j];</span><br><span class="line">                    a[j] = a[j-<span class="number">1</span>];</span><br><span class="line">                    a[j-<span class="number">1</span>] =temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="选择排序-Selection-Sort"><a href="#选择排序-Selection-Sort" class="headerlink" title="选择排序(Selection Sort)"></a>选择排序(Selection Sort)</h3><p>选择排序是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小元素，存放到排序序列的前部分，然后，再从剩余未排序元素中继续寻找最小元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Selection</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = a.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> min = i;</span><br><span class="line">            <span class="comment">// 找出未排序序列中的最小元素</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; N; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (a[min].compareTo(a[j]) &gt; <span class="number">0</span>) min = j;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//使未排序序列中的最小值归位</span></span><br><span class="line">            Comparable temp = a[min];</span><br><span class="line">            a[min] = a[i];</span><br><span class="line">            a[i] = temp;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="插入排序（Insertion-Sort）"><a href="#插入排序（Insertion-Sort）" class="headerlink" title="插入排序（Insertion Sort）"></a>插入排序（Insertion Sort）</h3><p>插入排序是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Insertion</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = a.length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将第 i 个元素与前面的 0 ~ i-1 个元素比较,若比其中的元素小则依次交换</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;N; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i; j&gt;<span class="number">0</span> &amp;&amp; a[j].compareTo(a[j-<span class="number">1</span>])&lt;<span class="number">0</span> ;j--)&#123;</span><br><span class="line">               Comparable temp = a[j];</span><br><span class="line">               a[j] = a[j-<span class="number">1</span>];</span><br><span class="line">               a[j-<span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="希尔排序（Shell-Sort）"><a href="#希尔排序（Shell-Sort）" class="headerlink" title="希尔排序（Shell Sort）"></a>希尔排序（Shell Sort）</h3><p>1959年Shell发明，第一个突破O(n2)的排序算法，是简单插入排序的改进版。它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫<strong>缩小增量排序</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Shell</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = a.length;</span><br><span class="line">        <span class="keyword">int</span> h = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(h &lt; N/<span class="number">3</span>) h = <span class="number">3</span>*h +<span class="number">1</span>;  <span class="comment">//h = 1,4,13,40 ...</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(h &gt;= <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        将数组变为 h 有序，即相隔 h 个元素 的元素构成一组，组内有序，</span></span><br><span class="line"><span class="comment">        将 h 的值逐渐缩小则数组有序。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=h; i&lt;N; i++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=i; j&gt;=h &amp;&amp; a[j].compareTo(a[j-h])&lt;<span class="number">0</span>; j-=h)&#123;</span><br><span class="line">                    Comparable temp = a[j];</span><br><span class="line">                    a[j] = a[j-h];</span><br><span class="line">                    a[j-h] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            h = h/<span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="归并排序（Merge-Sort）"><a href="#归并排序（Merge-Sort）" class="headerlink" title="归并排序（Merge Sort）"></a>归并排序（Merge Sort）</h3><p>归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Merge</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Comparable[] aux;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span></span>&#123;</span><br><span class="line">        aux = <span class="keyword">new</span> Comparable[a.length];</span><br><span class="line">        sort(a,<span class="number">0</span>,a.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span>&#123;</span><br><span class="line">        <span class="comment">//将数组a[lo...hi]排序</span></span><br><span class="line">        <span class="keyword">if</span>(hi &lt;= lo)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> mid = lo + (hi - lo)/<span class="number">2</span>;</span><br><span class="line">        sort(a,lo,mid);</span><br><span class="line">        sort(a,mid+<span class="number">1</span>,hi);</span><br><span class="line">        merge(a,lo,mid,hi);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">//将a[lo..mid] 和a[mid+1..hi]归并</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(Comparable[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> mid, <span class="keyword">int</span> hi)</span></span>&#123;</span><br><span class="line">       </span><br><span class="line">        <span class="comment">//将a[lo..hi] 复制到aux[lo..hi]</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=lo; k&lt;=hi; ++k)</span><br><span class="line">            aux[k] = a[k];</span><br><span class="line">        </span><br><span class="line">		<span class="keyword">int</span> i = lo, j = mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=lo; k&lt;=hi; ++k)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; mid) a[k] = aux[j++]; <span class="comment">//左半边用尽</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(j &gt; hi) a[k] = aux[i++];<span class="comment">//右半边用尽</span></span><br><span class="line">                 <span class="keyword">else</span> <span class="keyword">if</span>(aux[i].compareTo(aux[j]) &lt; <span class="number">0</span>) a[k] = aux[i++];</span><br><span class="line">                      <span class="keyword">else</span> a[k] = aux[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="快速排序（Quick-Sort）"><a href="#快速排序（Quick-Sort）" class="headerlink" title="快速排序（Quick Sort）"></a>快速排序（Quick Sort）</h3><p>快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。</p>
<ul>
<li>从数列中挑出一个元素，称为 “基准”（pivot）；</li>
<li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</li>
<li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Quick</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span>  <span class="title">sort</span><span class="params">(Comparable[] a)</span></span>&#123;</span><br><span class="line">        sort(a,<span class="number">0</span>,a.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(hi &lt;= lo)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//切分</span></span><br><span class="line">        <span class="keyword">int</span> j = partition(a,lo,hi);</span><br><span class="line">        <span class="comment">//将左半部分排序</span></span><br><span class="line">        sort(a,lo,j-<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//将右半部分排序</span></span><br><span class="line">        sort(a,j+<span class="number">1</span>,hi);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(Comparable[]a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span>&#123;</span><br><span class="line">        <span class="comment">//将数组切分为a[lo..i-1], a[i], a[i+1..hi]</span></span><br><span class="line">        <span class="keyword">int</span> i=lo,j=hi;</span><br><span class="line">        <span class="comment">//选取第一个元素为基准点</span></span><br><span class="line">        Comparable v = a[lo];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//i，j 相遇停止</span></span><br><span class="line">        <span class="keyword">while</span>(i != j)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//先从左边开始，不能保证你最后和基准点交换的那个数，是小于等于左边的。例如 2，1，4，9</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//找出右边比基准点小的元素的下标</span></span><br><span class="line">            <span class="keyword">while</span>(j &gt; i &amp;&amp; a[j].compareTo(v) &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//找出左边比基准点大的元素的下标</span></span><br><span class="line">            <span class="keyword">while</span>(i &lt; j &amp;&amp; a[i].compareTo(v) &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(i&lt;j)&#123;</span><br><span class="line">                <span class="comment">//交换a[i] 和 a[j]</span></span><br><span class="line">                Comparable temp = a[i];</span><br><span class="line">                a[i] = a[j];</span><br><span class="line">                a[j] =temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//i，j 相遇，基准点的位置已经找到，将a[v] 与 a[i] 交换。</span></span><br><span class="line">        Comparable temp = a[lo];</span><br><span class="line">        a[lo] = a[j];</span><br><span class="line">        a[j] =temp;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//返回基准点的下标</span></span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="堆排序（Heap-Sort）"><a href="#堆排序（Heap-Sort）" class="headerlink" title="堆排序（Heap Sort）"></a>堆排序（Heap Sort）</h3><p>堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。</p>
<ul>
<li>将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区；</li>
<li>将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]&lt;=R[n]；</li>
<li>由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Heap</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=a.length/<span class="number">2</span>-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="comment">//从第一个非叶子结点开始，从下至上，从右至左向下调整。</span></span><br><span class="line">            adjustDown(a,i,a.length);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//交换堆顶元素与最后一个元素，最大的元素归位。由于破坏了大根堆的特性需要重新调整堆顶元素。</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=a.length-<span class="number">1</span>; j&gt;<span class="number">0</span>; j--)&#123;</span><br><span class="line">            <span class="comment">//交换元素</span></span><br><span class="line">            Comparable temp = a[<span class="number">0</span>];</span><br><span class="line">            a[<span class="number">0</span>] = a[j];</span><br><span class="line">            a[j] = temp;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//向下调整大根堆</span></span><br><span class="line">            adjustDown(a,<span class="number">0</span>,j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">adjustDown</span><span class="params">(Comparable[] a,<span class="keyword">int</span> i,<span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line">        Comparable temp = a[i];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">2</span>*i+<span class="number">1</span>; k&lt;length; k=k*<span class="number">2</span>+<span class="number">1</span>)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//找到两个子结点中较大的一个结点</span></span><br><span class="line">            <span class="keyword">if</span>(k+<span class="number">1</span>&lt;length &amp;&amp; a[k].compareTo(a[k+<span class="number">1</span>])&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                k++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果子结点的值大于父结点的值，将父结点向下调整，继续向下调整</span></span><br><span class="line">            <span class="keyword">if</span>(a[k].compareTo(temp) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//父结点的值设置为子结点的值</span></span><br><span class="line">                a[i] = a[k];</span><br><span class="line">                <span class="comment">//对当前结点继续向下调整</span></span><br><span class="line">                i = k;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将 temp 值放到最终的位置</span></span><br><span class="line">        a[i] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参考：<a href="https://www.cnblogs.com/onepixel/articles/7674659.html" target="_blank" rel="noopener">https://www.cnblogs.com/onepixel/articles/7674659.html</a></p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>插入区间</title>
    <url>/2020/11/04/%E6%8F%92%E5%85%A5%E5%8C%BA%E9%97%B4/</url>
    <content><![CDATA[<h4 id="57-插入区间"><a href="#57-插入区间" class="headerlink" title="57. 插入区间"></a><a href="https://leetcode-cn.com/problems/insert-interval/" target="_blank" rel="noopener">57. 插入区间</a></h4><p>给出一个<em>无重叠的 ，</em>按照区间起始端点排序的区间列表。</p>
<p>在列表中插入一个新的区间，你需要确保列表中的区间仍然有序且不重叠（如果有必要的话，可以合并区间）。</p>
<a id="more"></a> 

<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：intervals &#x3D; [[1,3],[6,9]], newInterval &#x3D; [2,5]</span><br><span class="line">输出：[[1,5],[6,9]]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：intervals &#x3D; [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval &#x3D; [4,8]</span><br><span class="line">输出：[[1,2],[3,10],[12,16]]</span><br><span class="line">解释：这是因为新的区间 [4,8] 与 [3,5],[6,7],[8,10] 重叠。</span><br></pre></td></tr></table></figure>

<p><strong>方法一：模拟</strong></p>
<p>对于区间<code>s1 = [l1, r1]</code>和区间<code>s2 = [l2, r2]</code>，如果它们没有交集，那么要么 s1 在 s2 左侧（r1 &lt; l2），要么 s2 在 s1 左侧（r2 &lt; l1）。</p>
<p>如果两者有交集，那么并集为<code>[min(l1, l2), max(r1, r2)]</code>。</p>
<p>当插入区间[left, right]时，如果它不与其他区间相交，直接将其加入答案；如果它与其他区间有交集，将两个区间取并集，然后继续插入新的区间[left’, right‘]。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] insert(<span class="keyword">int</span>[][] intervals, <span class="keyword">int</span>[] newInterval) &#123;</span><br><span class="line">        <span class="keyword">int</span> left = newInterval[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> right = newInterval[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">boolean</span> placed = <span class="keyword">false</span>;</span><br><span class="line">        List&lt;<span class="keyword">int</span>[]&gt; ansList = <span class="keyword">new</span> ArrayList&lt;<span class="keyword">int</span>[]&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] interval : intervals)&#123;</span><br><span class="line">            <span class="keyword">if</span>(interval[<span class="number">0</span>] &gt; right)&#123;</span><br><span class="line">                <span class="comment">//当前区间在插入区间的右侧且无交集，直接加入结果集</span></span><br><span class="line">                <span class="keyword">if</span>(!placed)&#123;</span><br><span class="line">                    ansList.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;left, right&#125;);</span><br><span class="line">                    placed = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                ansList.add(interval);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(interval[<span class="number">1</span>] &lt; left)&#123;</span><br><span class="line">                <span class="comment">//当前区间在插入区间的左侧且无交集，将当前区间加入结果集</span></span><br><span class="line">                ansList.add(interval);</span><br><span class="line">            &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//与插入区间有交集，计算它们的并集</span></span><br><span class="line">                left = Math.min(left, interval[<span class="number">0</span>]);</span><br><span class="line">                right = Math.max(right, interval[<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!placed)&#123;</span><br><span class="line">            ansList.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;left, right&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[][] ans = <span class="keyword">new</span> <span class="keyword">int</span>[ansList.size()][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ansList.size(); ++i)&#123;</span><br><span class="line">            ans[i] = ansList.get(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度O(N)</li>
<li>空间复杂度O(1)</li>
</ul>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode Hard</tag>
      </tags>
  </entry>
  <entry>
    <title>搜索旋转排序数组II</title>
    <url>/2021/04/07/%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84II/</url>
    <content><![CDATA[<h4 id="81-搜索旋转排序数组-II"><a href="#81-搜索旋转排序数组-II" class="headerlink" title="81. 搜索旋转排序数组 II"></a><a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array-ii/" target="_blank" rel="noopener">81. 搜索旋转排序数组 II</a></h4><p>已知存在一个按非降序排列的整数数组 <code>nums</code> ，数组中的值不必互不相同。</p>
<p>在传递给函数之前，<code>nums</code> 在预先未知的某个下标 <code>k</code>（<code>0 &lt;= k &lt; nums.length</code>）上进行了 <strong>旋转</strong> ，使数组变为 <code>[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]</code>（下标 <strong>从 0 开始</strong> 计数）。例如， <code>[0,1,2,4,4,4,5,6,6,7]</code> 在下标 <code>5</code> 处经旋转后可能变为 <code>[4,5,6,6,7,0,1,2,4,4]</code> 。</p>
<p>给你 <strong>旋转后</strong> 的数组 <code>nums</code> 和一个整数 <code>target</code> ，请你编写一个函数来判断给定的目标值是否存在于数组中。如果 <code>nums</code> 中存在这个目标值 <code>target</code> ，则返回 <code>true</code> ，否则返回 <code>false</code> 。</p>
 <a id="more"></a>

<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [2,5,6,0,0,1,2], target &#x3D; 0</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [2,5,6,0,0,1,2], target &#x3D; 3</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>

<p> <strong>提示：</strong></p>
<ul>
<li><p><code>1 &lt;= nums.length &lt;= 5000</code></p>
</li>
<li><p><code>-104 &lt;= nums[i] &lt;= 104</code></p>
</li>
<li><p>题目数据保证 <code>nums</code> 在预先未知的某个下标上进行了旋转</p>
</li>
<li><p><code>-104 &lt;= target &lt;= 104</code></p>
<p><strong>进阶：</strong></p>
</li>
<li><p>这是 <a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/description/" target="_blank" rel="noopener">搜索旋转排序数组</a> 的延伸题目，本题中的 <code>nums</code> 可能包含重复元素。</p>
</li>
<li><p>这会影响到程序的时间复杂度吗？会有怎样的影响，为什么？</p>
</li>
</ul>
<p><strong>方法一：二分查找</strong></p>
<p>可以先查看题解<a href="https://hoo334.github.io/2020/04/27/%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/">搜索旋转排序数组</a>，对于数组中有重复元素的情况，二分查找可能会有<code>nums[l] = nums[mid] = nums[r]</code>,此时我们无法判断区间<code>[l, mid]</code>和 <code>[mid + 1, r]</code>哪个是有序的。</p>
<p>例如 <code>nums =[3,1,2,3,3,3,3]</code> ,target = 2，首次二分时，无法判断区间<code>[0,3]</code>和<code>[4,6]</code></p>
<p>哪个是有序的。对于这种情况，我们智能将当前二分区间左边界加一，右边界减一，然后在新区间上继续二分查找。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>] == target;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//当三个数都相等时，左边界加一，右边界减一</span></span><br><span class="line">            <span class="keyword">if</span> (nums[l] == nums[mid] &amp;&amp; nums[mid] == nums[r]) &#123;</span><br><span class="line">                ++l;</span><br><span class="line">                --r;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[l] &lt;= nums[mid]) &#123;<span class="comment">//左边界有序</span></span><br><span class="line">                <span class="keyword">if</span> (nums[l] &lt;= target &amp;&amp; target &lt; nums[mid]) &#123;<span class="comment">//mid 在有序部分</span></span><br><span class="line">                    r = mid - <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;<span class="comment">//mid 不在有序部分</span></span><br><span class="line">                    l = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">//右边界有序</span></span><br><span class="line">                <span class="keyword">if</span> (nums[mid] &lt; target &amp;&amp; target &lt;= nums[r]) &#123;</span><br><span class="line">                    l = mid + <span class="number">1</span>;  <span class="comment">//mid 在有序部分</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;  <span class="comment">//mid 不在有序部分</span></span><br><span class="line">                    r = mid - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度O(logN)</li>
<li>空间复杂度O(1)</li>
</ul>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode Medium</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>搜索插入位置</title>
    <url>/2020/07/17/%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE/</url>
    <content><![CDATA[<h4 id="35-搜索插入位置"><a href="#35-搜索插入位置" class="headerlink" title="35. 搜索插入位置"></a><a href="https://leetcode-cn.com/problems/search-insert-position/" target="_blank" rel="noopener">35. 搜索插入位置</a></h4><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p>
<p>你可以假设数组中无重复元素。</p>
<a id="more"></a>

<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,3,5,6], 5</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,3,5,6], 2</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure>

<p><strong>示例 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,3,5,6], 7</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure>

<p><strong>示例 4:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,3,5,6], 0</span><br><span class="line">输出: 0</span><br></pre></td></tr></table></figure>

<p>看到数组有序，可以想到二分查找，此题查找的是第一个大于等于 target 数值的下标。我们直接使用二分法，利用二分法不断逼近第一个大于等于 target 的下标。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">searchInsert</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == target)&#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target)&#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度O(log n)，空间复杂度O(1)。</p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode Easy</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>摆动序列</title>
    <url>/2020/07/01/%E6%91%86%E5%8A%A8%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<h4 id="376-摆动序列"><a href="#376-摆动序列" class="headerlink" title="376. 摆动序列"></a><a href="https://leetcode-cn.com/problems/wiggle-subsequence/" target="_blank" rel="noopener">376. 摆动序列</a></h4><p>如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为<strong>摆动序列。</strong>第一个差（如果存在的话）可能是正数或负数。少于两个元素的序列也是摆动序列。</p>
 <a id="more"></a>

<p>例如， <code>[1,7,4,9,2,5]</code> 是一个摆动序列，因为差值 <code>(6,-3,5,-7,3)</code> 是正负交替出现的。相反, <code>[1,4,7,2,5]</code> 和 <code>[1,7,4,5,5]</code> 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。</p>
<p>给定一个整数序列，返回作为摆动序列的最长子序列的长度。 通过从原始序列中删除一些（也可以不删除）元素来获得子序列，剩下的元素保持其原始顺序。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,7,4,9,2,5]</span><br><span class="line">输出: 6 </span><br><span class="line">解释: 整个序列均为摆动序列。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,17,5,10,13,15,10,5,16,8]</span><br><span class="line">输出: 7</span><br><span class="line">解释: 这个序列包含几个长度为 7 摆动序列，其中一个可为[1,17,10,13,10,16,8]。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,2,3,4,5,6,7,8,9]</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure>

<p><strong>进阶:</strong><br>你能否用 O(<em>n</em>) 时间复杂度完成此题?</p>
<p>每当我们选择一个元素作为摆动序列的一部分时，这个元素要么是上升的，要么是下降的，这取决于前一个元素的大小。</p>
<p>我们使用两个数组来 dp，up[i] 存的是目前为止的以第 i 个元素结尾的上升摆动序列的长度。</p>
<p>类似的，down[i] 存的是目前为止以第 i 个元素结尾的下降摆动序列的长度。</p>
<p>数组中的任何元素都对应下面三种可能状态中的一种：</p>
<ol>
<li>上升的位置，意味着 nums[i] &gt; nums[i - 1]</li>
<li>下降的位置，意味着 nums[i] &lt; nums[i - 1]</li>
<li>相同的位置，意味着 nums[i] == nums[i - 1]</li>
</ol>
<p>如果为情况 1 ，意味着在这里摆动上升，前一个数字肯定处于下降的位置。所以 up[i] = down[i-1]+1, down[i] = down[i-1]。</p>
<p>如果为情况 2， 意味着在这里摆动下降，前一个数字肯定处在上升的位置。所以 down[i] = up[i-1]+1, up[i] = up[i-1]。</p>
<p>如果为情况 3，up[i] = up[i-1], down[i] = down[i-1]。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">wiggleMaxLength</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length &lt; <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> nums.length;</span><br><span class="line">        <span class="keyword">int</span>[] up = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">int</span>[] down = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        up[<span class="number">0</span>] = down[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; ++i)&#123;</span><br><span class="line">            <span class="comment">//情况1</span></span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; nums[i-<span class="number">1</span>])&#123;</span><br><span class="line">                up[i] = down[i-<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                down[i] = down[i-<span class="number">1</span>];</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[i] &lt; nums[i-<span class="number">1</span>])&#123; <span class="comment">//情况 2</span></span><br><span class="line">                down[i] = up[i-<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                up[i] = up[i-<span class="number">1</span>];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="comment">//情况 3</span></span><br><span class="line">                down[i] = down[i-<span class="number">1</span>];</span><br><span class="line">                up[i] = up[i-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(up[nums.length-<span class="number">1</span>], down[nums.length-<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度为O(n)，空间复杂度为 O(n)。</p>
<p>优化：我们只需要 up[i-1] 和 down[i-1] ，只需要两个变量来保存。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">wiggleMaxLength</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length &lt; <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> nums.length;</span><br><span class="line">        <span class="keyword">int</span> up = <span class="number">1</span>, down = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; nums[i-<span class="number">1</span>])&#123;</span><br><span class="line">                up = down + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[i] &lt; nums[i-<span class="number">1</span>])&#123;</span><br><span class="line">                down = up + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(up, down);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度为O(n)，空间复杂度为 O(1)。</p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode Medium</tag>
        <tag>动态规划</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>数字范围按位与</title>
    <url>/2020/08/23/%E6%95%B0%E5%AD%97%E8%8C%83%E5%9B%B4%E6%8C%89%E4%BD%8D%E4%B8%8E/</url>
    <content><![CDATA[<h4 id="201-数字范围按位与"><a href="#201-数字范围按位与" class="headerlink" title="201. 数字范围按位与"></a><a href="https://leetcode-cn.com/problems/bitwise-and-of-numbers-range/" target="_blank" rel="noopener">201. 数字范围按位与</a></h4><p>给定范围 [m, n]，其中 0 &lt;= m &lt;= n &lt;= 2147483647，返回此范围内所有数字的按位与（包含 m, n 两端点）。</p>
<a id="more"></a>

<p><strong>示例 1:</strong> </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [5,7]</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [0,1]</span><br><span class="line">输出: 0</span><br></pre></td></tr></table></figure>

<p>我们首先想到将[m, n] 范围内的运算全部做一次与运算，然而超时。我们将 [9, 12] 的二进制字符画成图：</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20200823090713328.png" alt="image-20200823090713328"></p>
<p>我们可以发现，对所有数字执行按位与运算的结果是对应二进制字符串的公共前缀再用零补上后面的剩余位。进一步的说，这些字符串的公共前缀就等于 9 和 12 两个数字的二进制字符串的公共前缀。</p>
<p><strong>方法一：位移</strong></p>
<p>我们可以将两个数字不断右移，同时记录位移的次数，直到它们相等，得到了公共前缀，我们再将公共前缀左移相应的次数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rangeBitwiseAnd</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> shift = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//找到公共前缀</span></span><br><span class="line">        <span class="keyword">while</span>(m != n)&#123;</span><br><span class="line">            m &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">            n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">            ++shift;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//左移相应的次数</span></span><br><span class="line">        <span class="keyword">return</span> m &lt;&lt; shift;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度O(1)，空间复杂度O(1)。</p>
<p><strong>方法二：Brian Kernighan 算法</strong></p>
<p>「Brian Kernighan 算法」，用于清除二进制串中最右边的 1。</p>
<p>我们每次对 n 和 n - 1进行按位与操作后，n 中最右边的 1 会被抹去变为 0 。</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20200823091337544.png" alt="image-20200823091337544"></p>
<p>对于此题，我们将一直清除 n 最右边的 1 ，直到  n &lt;= m，此时 n 就是公共前缀。</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20200823092218184.png" alt="image-20200823092218184"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rangeBitwiseAnd</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(m &lt; n)&#123;</span><br><span class="line">            n = n &amp; (n - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度O(1)，空间复杂度O(1)。</p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode Medium</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>搜索旋转排序数组</title>
    <url>/2020/04/27/%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h4 id="33-搜索旋转排序数组"><a href="#33-搜索旋转排序数组" class="headerlink" title="33. 搜索旋转排序数组"></a><a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/" target="_blank" rel="noopener">33. 搜索旋转排序数组</a></h4><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。</p>
<p>( 例如，数组 <code>[0,1,2,4,5,6,7]</code> 可能变为 <code>[4,5,6,7,0,1,2]</code> )。</p>
<p>搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 <code>-1</code> 。</p>
 <a id="more"></a>

<p>你可以假设数组中不存在重复的元素。</p>
<p>你的算法时间复杂度必须是 <em>O</em>(log <em>n</em>) 级别。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: nums &#x3D; [4,5,6,7,0,1,2], target &#x3D; 0</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: nums &#x3D; [4,5,6,7,0,1,2], target &#x3D; 3</span><br><span class="line">输出: -1</span><br></pre></td></tr></table></figure>

<p>由于题目要求时间复杂度为O(log n)，这提示我们使用二分查找。</p>
<p>数组本身不是有序的，进行旋转后只是局部有序的，还能二分查找吗？</p>
<p>可以发现，我们将数组从中间分成左右两部分后，左右部分中一定有一个部分是有序的。例如示例中我们从 <code>6</code> 这个位置分开为<code>[4,5,6]</code> 和 <code>[7,0,1,2]</code> ，其中左边 <code>[4,5,6]</code> 这个部分的数组是有序的。</p>
<p>这启示我们可以在常规二分查找上改动，每次判断分割出来的两个部分，哪个是有序的，根据有序的部分改变二分搜索的上下界。</p>
<ul>
<li>如果 <code>[1, mid-1]</code> 是有序数组，且 <code>target</code>  的大小满足 <code>[nums[l], nums[mid])</code> ，则我们将搜索范围缩小到 <code>[1, mid-1]</code> ，否则在<code>[mid+1, r]</code> 中寻找。</li>
<li>如果 <code>[mid, r]</code> 是有序数组，且 <code>target</code>  的大小满足 <code>[nums[mid+1], nums[r])</code> ，则我们将搜索范围缩小到 <code>[mid+1, r]</code> ，否则在<code>[1, mid-1]</code> 中寻找。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == target)<span class="keyword">return</span> mid;</span><br><span class="line">            <span class="comment">//左边部分有序</span></span><br><span class="line">            <span class="keyword">if</span>(nums[<span class="number">0</span>] &lt;= nums[mid])&#123;</span><br><span class="line">                <span class="comment">//target 在有序部分</span></span><br><span class="line">                <span class="keyword">if</span>(nums[<span class="number">0</span>] &lt;= target &amp;&amp; target &lt;= nums[mid])&#123;</span><br><span class="line">                    r = mid - <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;<span class="comment">//target 不在有序部分</span></span><br><span class="line">                    l = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="comment">//右边部分有序</span></span><br><span class="line">                 <span class="comment">//target 在有序部分</span></span><br><span class="line">                <span class="keyword">if</span>(nums[mid] &lt;= target &amp;&amp; target &lt;= nums[n-<span class="number">1</span>])&#123;</span><br><span class="line">                    l = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;<span class="comment">//target 不在有序部分</span></span><br><span class="line">                    r = mid - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度 O(logN)，空间复杂度 O(1)。</p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode Medium</tag>
        <tag>二分查找</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>数组中数字出现的次数</title>
    <url>/2020/07/01/%E6%95%B0%E7%BB%84%E4%B8%AD%E6%95%B0%E5%AD%97%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0/</url>
    <content><![CDATA[<h4 id="面试题56-I-数组中数字出现的次数"><a href="#面试题56-I-数组中数字出现的次数" class="headerlink" title="面试题56 - I. 数组中数字出现的次数"></a><a href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/" target="_blank" rel="noopener">面试题56 - I. 数组中数字出现的次数</a></h4><p>一个整型数组 <code>nums</code> 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。</p>
  <a id="more"></a>

<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [4,1,4,6]</span><br><span class="line">输出：[1,6] 或 [6,1]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [1,2,10,4,1,4,3,3]</span><br><span class="line">输出：[2,10] 或 [10,2]</span><br></pre></td></tr></table></figure>



<p><strong>限制：</strong></p>
<ul>
<li><code>2 &lt;= nums &lt;= 10000</code></li>
</ul>
<p>一个整型数组 <code>nums</code> 里除一个数字之外，其他数字都出现了两次。这个问题我们直接将 <code>nums</code> 数组中所有数字异或即可得到结果。现在只出现一次的数字有两个，我们再将所有数字进行异或即可得到两个只出现一次的数字的异或结果。</p>
<p>如果将这两个数字分别分成两组，一组里面含有一个出现一次的数字。我们直接将两组中的所有数字异或即可得到结果。</p>
<p>如何分组？我们从两个只出现一次的数字的异或结果入手，找出两个数字中不同的<strong>位</strong>（该位为 1 ）， 按照这个不同的位将所有数字分为两组。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">例如 [4,1,4,6] 数组中所有数字异或的结果为 1 ^ 6 &#x3D; 7</span><br><span class="line">将 7 表示为二进制 0111（忽略前面的 28 个 0）</span><br><span class="line">我们可以将数字的最后三位中任选一位作为分组的判断。</span><br><span class="line">例如将倒数第一位为 0 分为第一组 得到[4,4,6]</span><br><span class="line">将倒数第一位为 1 分为第二组 得到[1]</span><br><span class="line">分别将这两组中的数字全部异或即可得到结果 1 和 6。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] singleNumbers(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="comment">//计算两个只出现一次数字的异或结果</span></span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">            ret ^= num;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//找出用来分组的那一位</span></span><br><span class="line">        <span class="keyword">int</span> idx = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>((idx &amp; ret) == <span class="number">0</span>)&#123;</span><br><span class="line">            idx = idx &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//分组异或计算结果</span></span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>((num &amp; idx) == <span class="number">0</span>)&#123;</span><br><span class="line">                a ^= num;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                b ^= num;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;a,b&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度O(n)，空间复杂度O(1)。</p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode Medium</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>数组中的K-diff数对</title>
    <url>/2020/04/09/%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84K-diff%E6%95%B0%E5%AF%B9/</url>
    <content><![CDATA[<h4 id="532-数组中的K-diff数对"><a href="#532-数组中的K-diff数对" class="headerlink" title="532. 数组中的K-diff数对"></a><a href="https://leetcode-cn.com/problems/k-diff-pairs-in-an-array/" target="_blank" rel="noopener">532. 数组中的K-diff数对</a></h4><p>给定一个整数数组和一个整数 <strong>k</strong>, 你需要在数组里找到<strong>不同的</strong> k-diff 数对。这里将 <strong>k-diff</strong> 数对定义为一个整数对 (i, j), 其中 <strong>i</strong> 和 <strong>j</strong> 都是数组中的数字，且两数之差的绝对值是 <strong>k</strong>.</p>
 <a id="more"></a>

<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [3, 1, 4, 1, 5], k &#x3D; 2</span><br><span class="line">输出: 2</span><br><span class="line">解释: 数组中有两个 2-diff 数对, (1, 3) 和 (3, 5)。</span><br><span class="line">尽管数组中有两个1，但我们只应返回不同的数对的数量。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:[1, 2, 3, 4, 5], k &#x3D; 1</span><br><span class="line">输出: 4</span><br><span class="line">解释: 数组中有四个 1-diff 数对, (1, 2), (2, 3), (3, 4) 和 (4, 5)。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1, 3, 1, 5, 4], k &#x3D; 0</span><br><span class="line">输出: 1</span><br><span class="line">解释: 数组中只有一个 0-diff 数对，(1, 1)。</span><br></pre></td></tr></table></figure>

<p><strong>注意:</strong></p>
<ol>
<li>数对 (i, j) 和数对 (j, i) 被算作同一数对。</li>
<li>数组的长度不超过10,000。</li>
<li>所有输入的整数的范围在 [-1e7, 1e7]。</li>
</ol>
<p>我们先将整数数组排序， 从第一个元素开始 向右寻找 diff 为 k 的元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findPairs</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">        <span class="comment">//去掉相同元素</span></span><br><span class="line">        <span class="keyword">for</span>(;i&gt;<span class="number">0</span>&amp;&amp;i&lt;nums.length&amp;&amp;nums[i]==nums[i-<span class="number">1</span>];i++);</span><br><span class="line">　　　　　　　<span class="comment">//向右寻找</span></span><br><span class="line">        j=i+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(;j&lt;nums.length&amp;&amp;nums[j]-nums[i]&lt;k;j++);</span><br><span class="line">        <span class="comment">//找到一对 j-i==k</span></span><br><span class="line">        <span class="keyword">if</span>(j&lt;nums.length&amp;&amp;nums[j]-nums[i]==k)</span><br><span class="line">            res++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度O(n^2)，空间复杂度O(log n)。</p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode Easy</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统</title>
    <url>/2020/05/10/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h2 id="计算机系统概述"><a href="#计算机系统概述" class="headerlink" title="计算机系统概述"></a>计算机系统概述</h2><h3 id="操作系统基本概念"><a href="#操作系统基本概念" class="headerlink" title="操作系统基本概念"></a>操作系统基本概念</h3><p>操作系统特征：<strong>并发</strong>和<strong>共享</strong>。</p>
<h3 id="操作系统的目标和功能"><a href="#操作系统的目标和功能" class="headerlink" title="操作系统的目标和功能"></a>操作系统的目标和功能</h3><ul>
<li>资源管理：处理机管理、存储器管理、文件管理、设备管理。</li>
<li>用户与硬件的接口：命令接口、程序接口（系统调用）。</li>
</ul>
<h3 id="操作系统的分类和发展"><a href="#操作系统的分类和发展" class="headerlink" title="操作系统的分类和发展"></a>操作系统的分类和发展</h3><ol>
<li>手工操作阶段（无操作系统）</li>
<li>批处理阶段（操作系统开始阶段）解决人机矛盾和CPU和I/O速度不匹配的问题。分为单道批处理和多道批处理系统（内存中只能保持一道作业和能保持多道作业）。</li>
<li>分时操作系统。将 CPU 时间分为许多时间片，采用时间片轮转法，支持多道程序设计的系统。</li>
<li>实时操作系统。</li>
<li>网络操作系统和分布式操作系统。</li>
</ol>
<h3 id="中断和异常"><a href="#中断和异常" class="headerlink" title="中断和异常"></a>中断和异常</h3><p>中断也称为外中断，指来自 CPU 执行指令以外的事情发生，如 I/O 中断。时钟中断表示固定的时间片已到。</p>
<p>异常也称为内中断，指源自CPU执行指令或内存内部的时间，如程序的非法操作码、地址越界、算术溢出、缺页等引起的事件。</p>
<h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><p>系统调用可视为特殊的公共子程序。凡是与资源有关的操作（如存储分配、进行 I/O 传输及管理文件等），都必须通过系统调用方式向操作系统提出服务请求。</p>
<h3 id="核心态与用户态"><a href="#核心态与用户态" class="headerlink" title="核心态与用户态"></a>核心态与用户态</h3><p>系统调用需要使用某些特权指令才能完成，需要由操作系统内核程序负责完成。用户程序通过执行访管指令来发起系统调用，请求操作系统提供服务。执行操作系统内核应用程序时，CPU 会在核心态，执行用户程序时在用户态。</p>
<p>用户态转向核心态：系统调用、发生中断和异常、执行特权指令、进程状态变换。</p>
<h2 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h2><h3 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h3><p>进程的特征：动态性、并发性、独立性、异步性、结构性。进程实体都是由程序段、数据段和进程控制块三部分组成的。</p>
<h3 id="进程的状态与转换"><a href="#进程的状态与转换" class="headerlink" title="进程的状态与转换"></a>进程的状态与转换</h3><p>运行态：单处理机环境下，每个时刻最多只能有一个进程处于运行态。</p>
<p>就绪态：进程已经准备运行，等待 CPU 调度。</p>
<p>阻塞态：进程正在等待某一事件而暂停运行。</p>
<p>进程三大状态之间的转换忽略。</p>
<h3 id="线程概念和多线程模型"><a href="#线程概念和多线程模型" class="headerlink" title="线程概念和多线程模型"></a>线程概念和多线程模型</h3><p>引入线程的目的是为了更好地使用多道程序并发执行，提高资源利用率和系统吞吐率。引进线程地目的则是为了减少程序在并发执行时所付出地时空开销，提高操作系统地并发性能。</p>
<h3 id="处理机调度"><a href="#处理机调度" class="headerlink" title="处理机调度"></a>处理机调度</h3><ol>
<li>作业调度。又称高级调度，从外存上处于后备状态地作业中挑选一个或多个作业，给他们分配内存、输入/输出等必要的资源，并建立相应的进程。</li>
<li>内存调度。又称中级调度，其作用是提高内存利用率和系统吞吐量。将暂时不能运行的进程调至外存等待，当运行条件已经具备，再将就绪进程重新调入内存。</li>
<li>进程调度。又称低级调度，按照某种方法和策略从就绪队列中选取一个进程，将处理机分配给它。</li>
</ol>
<h3 id="典型的调度算法"><a href="#典型的调度算法" class="headerlink" title="典型的调度算法"></a>典型的调度算法</h3><h4 id="先来先服务算法"><a href="#先来先服务算法" class="headerlink" title="先来先服务算法"></a>先来先服务算法</h4><p>FCFS 调度算法既可以用于作业调度，又可以用于进程调度。算法简单，效率较低。<strong>对长作业比较有利，对短作业不利；有利于 CPU 繁忙型作业，不利于 I/O繁忙型作业</strong>。</p>
<h4 id="短作业优先"><a href="#短作业优先" class="headerlink" title="短作业优先"></a>短作业优先</h4><p>短作业优先算法从后备队列中选择一个或若干估计运行时间最短作业，将它们调入内存运行。对长作业不利，会导致“饥饿”现象，SJF 调度算法的平均等待时间、平均周转时间最少。</p>
<h4 id="优先级调度算法"><a href="#优先级调度算法" class="headerlink" title="优先级调度算法"></a>优先级调度算法</h4><p>既可用于作业调度，又可用于进程调度，优先级描述作业运行的紧迫程度。按高优先级进程能否抢占正在执行的进程分为剥夺式优先级调度算法和非剥夺优先级调度算法。根据优先级是否改变分为动态优先级和静态优先级。</p>
<h4 id="高响应比优先调度算法"><a href="#高响应比优先调度算法" class="headerlink" title="高响应比优先调度算法"></a>高响应比优先调度算法</h4><p>用于作业调度，是对FCFS调度算法和SJF调度算法的一种综合平衡，同时还考虑了每个作业的等待时间和估计运行时间。<br>$$<br>响应比R_p=\frac{等待时间+要求服务时间}{要求服务时间}<br>$$</p>
<h4 id="时间片轮转法"><a href="#时间片轮转法" class="headerlink" title="时间片轮转法"></a>时间片轮转法</h4><p>主要适用于分时系统，系统将所搜就绪进程按时间的先后顺序排成一个队列，进程调度程序选择就绪进程依次执行一个时间片。时间片很大时退化为 FCFS 算法，时间片很小时导致进程切换开销过大。</p>
<h4 id="多级反馈队列调度算法"><a href="#多级反馈队列调度算法" class="headerlink" title="多级反馈队列调度算法"></a>多级反馈队列调度算法</h4><p>时间片轮转法和优先级调度算法的综合与发展。通过动态调整进程优先级和时间片大小，多级反馈队列可以兼顾多方面的系统目标。设置多个就绪队列，并为每个队列赋予不同的优先级，在优先级越高的队列中，每个进程运行的时间片越小。</p>
<h3 id="进程的同步"><a href="#进程的同步" class="headerlink" title="进程的同步"></a>进程的同步</h3><h4 id="进程同步的基本概念"><a href="#进程同步的基本概念" class="headerlink" title="进程同步的基本概念"></a>进程同步的基本概念</h4><p>临界资源：一次只允许一个进程使用的资源称为临界资源。</p>
<p>临界区：访问临界资源的那段代码。</p>
<p>同步：直接制约关系，为完成某任务而建立的两个或多个进程，这些进程因为需要在某些位置上协调它们的工作次序而等待、传递信息所产生的制约关系。进程之间的直接制约关系源于它们之间的合作。</p>
<p>互斥：间接制约关系。当一个进程进入临界区使用临界资源时，另一个进程必须等待，当占用临界区资源的进程退出临界区后，另一个进程才允许访问此临界资源。</p>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>多个进程因竞争资源而造成的一种相互等待的情况，若无外力作用，这些进程都将无法向前推进。</p>
<h4 id="死锁产生的必要条件"><a href="#死锁产生的必要条件" class="headerlink" title="死锁产生的必要条件"></a>死锁产生的必要条件</h4><ul>
<li>互斥条件</li>
<li>不可抢占条件</li>
<li>请求并保持条件</li>
<li>循环等待条件</li>
</ul>
<h4 id="死锁的处理策略"><a href="#死锁的处理策略" class="headerlink" title="死锁的处理策略"></a>死锁的处理策略</h4><ol>
<li>死锁预防，破环产生死锁 4 个条件中的一个或几个。</li>
<li>死锁避免，在动态分配资源过程中，用某种方法防止系统进入不安全状态。<strong>银行家算法</strong></li>
<li>死锁的检测及解除，通过系统检查出死锁的发生，采取某种措施解除死锁。</li>
</ol>
<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><h3 id="内存管理概念"><a href="#内存管理概念" class="headerlink" title="内存管理概念"></a>内存管理概念</h3><h4 id="内存管理的功能"><a href="#内存管理的功能" class="headerlink" title="内存管理的功能"></a>内存管理的功能</h4><ol>
<li>内存空间的分配与回收，由操作系统完成主存储器空间的分配与管理。</li>
<li>地址转换，在多道程序环境下，程序中的逻辑地址与内存中的物理地址不可能一致，存储器管理须提供地址变换功能，将逻辑地址转换为响应的物理地址。</li>
<li>内存空间的扩充，利用虚拟存储技术</li>
<li>存储保护，保证各道作业在各自的存储空间内运行，互不干扰。</li>
</ol>
<h4 id="程序的装入和链接"><a href="#程序的装入和链接" class="headerlink" title="程序的装入和链接"></a>程序的装入和链接</h4><p>将源程序变为可在内存中执行的程序，一般需要以下几个步骤：</p>
<ul>
<li>编译，将用户源代码编译成若干目标模块，形成<strong>逻辑地址</strong>。</li>
<li>链接，将编译后的目标模块及所需要的库函数链接在一起，形成整个完整的装入模块。</li>
<li>装入，将完整的装入模块装入内存。</li>
</ul>
<p>链接分为三种：</p>
<ol>
<li>静态链接，在程序运行前，链接库函数。</li>
<li>装入时动态链接，在程序装入内存时，将库函数链接。</li>
<li>运行时动态链接，在程序执行时，将库函数链接。</li>
</ol>
<p>装入分三种：</p>
<ol>
<li>绝对装入，逻辑地址和物理地址完全相同。</li>
<li>可重定位装入。将装入模块装入内存适当的位置，装入时对指令和数据的修改过程称为重定位。地址变化通常是在装入时一次完成。</li>
<li>动态运行时装入，装入程序把装入模块装入内存后，并不立即把模块中的相对地址转换为绝对地址，在程序运行的过程中才进行地址的转换。</li>
</ol>
<h4 id="连续分配管理方式"><a href="#连续分配管理方式" class="headerlink" title="连续分配管理方式"></a>连续分配管理方式</h4><ol>
<li>单一连续分配。在内存中永远只有一道程序，不会产生越界访问。</li>
<li>固定分区分配。将内存划分为若干固定大小的区域，每个分区只装入一道作业。</li>
<li>动态分区分配。在进程装入内存时，根据进程的大小动态地建立分区。</li>
</ol>
<p>动态分区的分配策略：</p>
<ul>
<li>首次适应算法，空闲分区按<strong>地址递增</strong>的次序链接，分配时按顺序查找，找到大小能满足要求的第一个空闲分区。</li>
<li>最佳适应算法，空闲分区按<strong>分区大小递增</strong>的次序链接，找到第一个能满足要求的分区。</li>
<li>最坏适应算法，空闲分区按<strong>分区大小递减</strong>的次序链接，找到第一个能满足要求的分区。</li>
<li>临近适应算法，分配内存时从上一次查找结束的位置开始继续查找。</li>
</ul>
<h4 id="非连续分配管理方式"><a href="#非连续分配管理方式" class="headerlink" title="非连续分配管理方式"></a>非连续分配管理方式</h4><p>非连续分配允许将一个程序分散地装入不相邻的内存分区。</p>
<p>把主存空间划分为大小相等且固定的块，块相对较小，作为主存的基本单位。每个进程也以块为单位进行划分，进程在执行时，以块为单位逐个申请主存块中的空间。</p>
<h5 id="1-分页"><a href="#1-分页" class="headerlink" title="1. 分页"></a>1. 分页</h5><p><strong>进程中的块称为页(Page)，内存中的块称为页框(Page Frame，或页帧)</strong>。外存也以同样的单位进行划分，直接称为块(Block)。进程在执行时需要申请主存空间，即为每个页面分配主存中的可用页框。</p>
<p>&emsp;&emsp;页面大小应该是2的整数幂。页面太小会使进程的页面过多，页表过长，占用大量的内存，增加硬件地址转换的开销，降低页面换人/换出的效率；页面过大会使内部碎片增多，降低内存利用率。</p>
<p>&emsp;&emsp;为了便于内存中找到进程的每个页面所对应的物理块，系统为每个进程建立一张页表，它记录页面在内存中对应的物理块号，<strong>页表一般存放在内存中</strong>。页表由页表项组成，<strong>页表项 = 页号 + 页框号</strong>。<strong>物理地址 = 页内地址 + 页框号 &times; 页面大小</strong></p>
<h5 id="2-分段"><a href="#2-分段" class="headerlink" title="2. 分段"></a>2. 分段</h5><p>段式管理按照用户进程中的自然段划分逻辑空间。在页式系统中，逻辑地址的页号和页内偏移量对用户是透明的，但在段式系统中，段号和段内偏移量必须由用户显式提供，在高级程序设计语言中，这个工作由编译程序完成。</p>
<h3 id="虚拟内存管理"><a href="#虚拟内存管理" class="headerlink" title="虚拟内存管理"></a>虚拟内存管理</h3><h4 id="虚拟内存基本概念"><a href="#虚拟内存基本概念" class="headerlink" title="虚拟内存基本概念"></a>虚拟内存基本概念</h4><h5 id="传统存储管理方式的特征"><a href="#传统存储管理方式的特征" class="headerlink" title="传统存储管理方式的特征"></a>传统存储管理方式的特征</h5><p>1）一次性。作业必须一次性全部装入内存，才开始运行。</p>
<p>2）驻留性。作业被装入内存后，就一直驻留在内存中，可能造成进程长时间阻塞。</p>
<h5 id="局部性原则"><a href="#局部性原则" class="headerlink" title="局部性原则"></a>局部性原则</h5><p>1）时间局部性。程序中某条指令一旦执行，不久后该指令可能再次执行。</p>
<p>2）空间局部性。一旦程序访问了某个存储单元，不久后，其附近的存储单元也被访问。</p>
<h5 id="虚拟存储器的主要特性"><a href="#虚拟存储器的主要特性" class="headerlink" title="虚拟存储器的主要特性"></a>虚拟存储器的主要特性</h5><p>1）多次性。作业可分多次调入内存执行。</p>
<p>2）对换性。在作业运行过程中允许进行换入和换出。</p>
<p>3）虚拟性。从逻辑上扩充内存的容量。</p>
<h5 id="虚拟存储技术的实现"><a href="#虚拟存储技术的实现" class="headerlink" title="虚拟存储技术的实现"></a>虚拟存储技术的实现</h5><p>虚拟存储系统<strong>只能基于非连续分配技术</strong>，连续分配方式时，会使相当一部分内存空间处于暂时或者“永久”空闲的状态，严重造成内存资源的浪费。</p>
<p>1）请求分页存储管理</p>
<p>2）请求分段存储管理</p>
<p>3）请求段页式存储管理</p>
<p>不管哪种方式，都需要一定的<strong>硬件的支持</strong>，一般需要的支持有以下几个方面：</p>
<ul>
<li>一定容量的<strong>内存</strong>和<strong>外存</strong></li>
<li><strong>页表机制(或段表机制)</strong>，作为主要的数据结构</li>
<li><strong>中断机制</strong>，当用户程序要访问的部分尚未调入内存时，则产生中断</li>
<li><strong>地址变换机制</strong>，逻辑地址和物理地址的转换。</li>
</ul>
<h4 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h4><h5 id="最佳-OPT-置换算法"><a href="#最佳-OPT-置换算法" class="headerlink" title="最佳(OPT)置换算法"></a>最佳(OPT)置换算法</h5><p>淘汰以后永久不使用的页面或者在最长时间内不再被访问的页面，以便保证获得最低的缺页率。由于人们目前无法预知进程在内存下的若干页面中哪个是未来最长时间内不再被访问的，因此该算法无法实现。</p>
<h5 id="先进先出-FIFO-页面置换算法"><a href="#先进先出-FIFO-页面置换算法" class="headerlink" title="先进先出(FIFO)页面置换算法"></a>先进先出(FIFO)页面置换算法</h5><p>优先淘汰最早进入内存的页面，即在内存中驻留时间最久的页面。</p>
<h5 id="最近最久未使用-LRU-置换算法"><a href="#最近最久未使用-LRU-置换算法" class="headerlink" title="最近最久未使用(LRU)置换算法"></a>最近最久未使用(LRU)置换算法</h5><p>选择最近最长时间未访问过的页面予以淘汰，它认为过去一段时间内未访问过的页面，在最近将来可能也不会被访问。</p>
<h5 id="时钟-CLOCK-置换算法"><a href="#时钟-CLOCK-置换算法" class="headerlink" title="时钟(CLOCK)置换算法"></a>时钟(CLOCK)置换算法</h5><p>简单的CLOCK算法给每帧关联一个附加位，称为<strong>使用位</strong>。当某页首次装入主存时，将该帧的使用位置为1。</p>
<h4 id="抖动"><a href="#抖动" class="headerlink" title="抖动"></a>抖动</h4><p>在页面置换算法中，<strong>刚刚换出的页面马上又要换入主存，刚刚换入的页面马上又要换出主存</strong>，这种频繁的页面调度行为称为<strong>抖动</strong>。</p>
<h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><h3 id="文件三种分配方式比较"><a href="#文件三种分配方式比较" class="headerlink" title="文件三种分配方式比较"></a>文件三种分配方式比较</h3><table>
<thead>
<tr>
<th></th>
<th>访问第 n 条记录</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>连续分配</td>
<td>访问磁盘 1 次</td>
<td>顺序存取速度快，文件定长时可按文件起始地址及记录长度进行随机访问。</td>
<td>文件存储需要连续 的存储空间，会产生碎片，不利于文件的动态扩充</td>
</tr>
<tr>
<td>链式分配</td>
<td>访问磁盘 n 次</td>
<td>可解决外存的随便化问题，提高外存空间的利用率，动态增长较方便</td>
<td>只能按照文件的指针链顺序访问，查找效率低，指针信息存放消耗外存空间</td>
</tr>
<tr>
<td>索引分配</td>
<td>m 级需访问磁盘 m+1 次</td>
<td>可以随机访问，文件易于增删</td>
<td>索引表增加存储空间的开销，索引表的查找策略对文件系统效率影响较大</td>
</tr>
</tbody></table>
<h3 id="磁盘调度算法"><a href="#磁盘调度算法" class="headerlink" title="磁盘调度算法"></a>磁盘调度算法</h3><table>
<thead>
<tr>
<th></th>
<th>描述</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>先来先服务(FCFS)算法</td>
<td>按磁盘请求队列中的磁道号依次移动</td>
<td>公平、简单</td>
<td>平均寻道距离大，仅应用在磁盘I/O较少的 场合</td>
</tr>
<tr>
<td>最短寻找时间优先(SSTF)算法</td>
<td>选择离当前磁头距离最近的磁道</td>
<td>性能比“先来先服务”好</td>
<td>不能保证平均寻道时间最短，可能导致“饥饿”现象</td>
</tr>
<tr>
<td>扫描(SCAN)算法</td>
<td>按磁头移动方向移动到最边缘的磁道，然后反向</td>
<td>寻道性能较好，可避免“饥饿”现象</td>
<td>不利于远离磁头一端的访问请求</td>
</tr>
<tr>
<td>循环扫描(C-SCAN)算法</td>
<td>按磁头移动方向移动到最边缘的磁道，然后从另一端开始重新扫描</td>
<td>消除了对两端磁道请求的不公平</td>
<td>—</td>
</tr>
</tbody></table>
<h2 id="I-O-管理"><a href="#I-O-管理" class="headerlink" title="I/O 管理"></a>I/O 管理</h2><h3 id="I-O-控制方式"><a href="#I-O-控制方式" class="headerlink" title="I/O 控制方式"></a>I/O 控制方式</h3><ul>
<li>程序直接控制方式，每读一个字，CPU 对外设状态进行循环检查。CPU和I/O设备只能串行工作，CPU的利用率相对低。</li>
<li>中断驱动方式，允许I/O设备主动打断CPU的运行并请求服务，使得其向I/O控制器发送读命令后 CPU 继续做其它有用的工作。比程序直接控制更有效，但由于<strong>数据中的每个字在存储器与I/O控制器之间的传输都必须经过CPU</strong>，这就导致了中断驱动方式仍然会耗很多CPU时间。</li>
<li>DMA 方式，<strong>I/O设备和内存之间开辟直接的数据通路</strong>。</li>
<li>通道控制方式，I/O通道是专门负责输入/输出的处理机。I/O通道方式是DMA方式的发展，它<strong>可以减少CPU的干预</strong>。</li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
  </entry>
  <entry>
    <title>数组中的最长山脉</title>
    <url>/2020/10/25/%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E9%95%BF%E5%B1%B1%E8%84%89/</url>
    <content><![CDATA[<h4 id="845-数组中的最长山脉"><a href="#845-数组中的最长山脉" class="headerlink" title="845. 数组中的最长山脉"></a><a href="https://leetcode-cn.com/problems/longest-mountain-in-array/" target="_blank" rel="noopener">845. 数组中的最长山脉</a></h4><p>我们把数组 A 中符合下列属性的任意连续子数组 B 称为 “<em>山脉”</em>：</p>
<ul>
<li><code>B.length &gt;= 3</code></li>
<li>存在 <code>0 &lt; i &lt; B.length - 1</code> 使得 <code>B[0] &lt; B[1] &lt; ... B[i-1] &lt; B[i] &gt; B[i+1] &gt; ... &gt; B[B.length - 1]</code></li>
</ul>
<p>（注意：B 可以是 A 的任意子数组，包括整个数组 A。）</p>
<p>给出一个整数数组 <code>A</code>，返回最长 <em>“山脉”</em> 的长度。</p>
<p>如果不含有 “<em>山脉”</em> 则返回 <code>0</code>。</p>
 <a id="more"></a>

<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[2,1,4,7,3,2,5]</span><br><span class="line">输出：5</span><br><span class="line">解释：最长的 “山脉” 是 [1,4,7,3,2]，长度为 5。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[2,2,2]</span><br><span class="line">输出：0</span><br><span class="line">解释：不含 “山脉”。</span><br></pre></td></tr></table></figure>

<p> <strong>提示：</strong></p>
<ol>
<li><code>0 &lt;= A.length &lt;= 10000</code></li>
<li><code>0 &lt;= A[i] &lt;= 10000</code></li>
</ol>
<p><strong>方法一：枚举山顶</strong></p>
<p>我们对于数组 A 中的每个数使用一次中心扩展，即可求出以当前数为山顶的子数组长度。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestMountain</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.length; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> l = i - <span class="number">1</span>, r = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(l &gt;= <span class="number">0</span> &amp;&amp; A[l] &lt; A[l + <span class="number">1</span>])&#123;</span><br><span class="line">                --l;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(r &lt; A.length &amp;&amp; A[r - <span class="number">1</span>] &gt; A[r])&#123;</span><br><span class="line">                ++r;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(l != i - <span class="number">1</span> &amp;&amp; r != i + <span class="number">1</span>)&#123;</span><br><span class="line">                ans = Math.max(ans, r - l - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度O(n^2)</li>
<li>空间复杂度O(1)</li>
</ul>
<p>由于左侧山脚到山顶的序列是严格单调递增的，从山顶到右侧山脚的序列是严格单调递减的。我们可以计算从任意一个元素开始，向左右两侧最多可扩展的元素。</p>
<p>我们用 <code>left[i]</code>表示<code>A[i]</code>向左侧最多可以扩展的元素数目，用 <code>right[i]</code>表示<code>A[i]</code>向右侧最多可以扩展的元素数目。<br>$$<br>left[i]=\left{<br>\begin{aligned}<br>left[i - 1] + 1, \ \ A[i] &gt; A[i - 1] \<br>0, \ \ A[i] \leq A[i - 1] 或 i =0\<br>\end{aligned}<br>\right.<br>$$</p>
<p>$$<br>right[i]=\left{<br>\begin{aligned}<br>right[i + 1] + 1, \ \ A[i] &gt; A[i + 1] \<br>0, \ \ A[i] \leq A[i + 1] 或 i = n -1\<br>\end{aligned}<br>\right.<br>$$<br>计算出所有 left 和 right 后，枚举山顶，只有当left[i] 和 right[i]都大于 0 时，A[i]才能作为山顶。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestMountain</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = A.length;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] left = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">int</span>[] right = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">            left[i] = A[i] &gt; A[i - <span class="number">1</span>] ? left[i - <span class="number">1</span>] + <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            right[i] = A[i] &gt; A[i + <span class="number">1</span>] ? right[i + <span class="number">1</span>] + <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(left[i] != <span class="number">0</span> &amp;&amp; right[i] != <span class="number">0</span>)&#123;</span><br><span class="line">                ans = Math.max(ans, left[i] + right[i] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度O(n)</li>
<li>空间复杂度O(n)</li>
</ul>
<p><strong>方法二：枚举山脚</strong></p>
<p>当我们从左向右遍历整个数组 A 时，可以使用双指针的方法，一个枚举左侧山脚，另一个不断向右移动到右侧山脚。</p>
<p>山顶数组最少为 3 个元素，需要保证<code>left + 2 &lt; n</code>和 <code>A[left] &lt; A[left + 1]</code>。</p>
<p>我们将right 初始化为 left + 1，不断将其右移，直到不满足<code>A[right] &lt; A[right + 1]</code></p>
<ul>
<li>如果 right = n - 1，此时已经无法形成山脉</li>
<li>如果 right 指向的是山顶，我们需要判断是否有 A[right] &gt; A[right + 1]，如果right 指向的是山顶，不断右移 right 直到不满足 A[right] &gt; A[right + 1]，此时 right 指向右侧山脚，A[left] 到 A[right]就对应着一座山脉。</li>
<li>右侧的山脚有可能是下一座山脉的左侧山脚，我们需要将 right 的值赋予 left，以便进行下一次枚举。在其他所有情况下，将right + 1赋给left。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestMountain</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = A.length;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(left + <span class="number">2</span> &lt; n)&#123;</span><br><span class="line">            <span class="keyword">int</span> right = left + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(A[left] &lt; A[left + <span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">while</span>(right + <span class="number">1</span> &lt; n &amp;&amp; A[right] &lt; A[right + <span class="number">1</span>])&#123;</span><br><span class="line">                    ++right;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(right &lt; n - <span class="number">1</span> &amp;&amp; A[right] &gt; A[right + <span class="number">1</span>])&#123;</span><br><span class="line">                    <span class="keyword">while</span>(right + <span class="number">1</span> &lt; n &amp;&amp; A[right] &gt; A[right + <span class="number">1</span>])&#123;</span><br><span class="line">                        ++right;</span><br><span class="line">                    &#125;</span><br><span class="line">                    ans = Math.max(ans, right - left + <span class="number">1</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    ++right;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            left = right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度O(n)</li>
<li>空间复杂度O(1)</li>
</ul>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode Medium</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>数组中的第K个最大元素</title>
    <url>/2020/07/01/%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACK%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<h4 id="215-数组中的第K个最大元素"><a href="#215-数组中的第K个最大元素" class="headerlink" title="215. 数组中的第K个最大元素"></a><a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/" target="_blank" rel="noopener">215. 数组中的第K个最大元素</a></h4><p>在未排序的数组中找到第 <strong>k</strong> 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。</p>
 <a id="more"></a>

<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [3,2,1,5,6,4] 和 k &#x3D; 2</span><br><span class="line">输出: 5</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [3,2,3,1,2,4,5,5,6] 和 k &#x3D; 4</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure>

<p><strong>说明:</strong></p>
<p>你可以假设 k 总是有效的，且 1 ≤ k ≤ 数组的长度。</p>
<p>遇到这题我们首先就想到直接排序：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">return</span> nums[nums.length - k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们思考快排每次都将一个元素归位，我们需要的是 nums.length - k 处的元素，我们可以改进快排，并不是需要将所有元素都排序。我们使用 partition 函数将一个元素归位，得到这个归位后的元素下标 x ，对于下标 x ，我们有三种情况：</p>
<ol>
<li>x == nums.length - k ，直接返回 nums[x]</li>
<li>x &gt; nums.length - k，在 x 左侧寻找，直到 x == nums.length - k</li>
<li>x &lt; nums.length - k，在 x 右侧寻找，直到 x == nums.length - k</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> quickSelect(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>, nums.length - k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">quickSelect</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> q = partition(a, l, r);</span><br><span class="line">        <span class="keyword">if</span>(q == index)&#123;</span><br><span class="line">            <span class="keyword">return</span> a[q];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> q &lt; index ? quickSelect(a, q + <span class="number">1</span>, r, index) : quickSelect(a, l, q - <span class="number">1</span>, index);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="comment">//选取基准点</span></span><br><span class="line">        <span class="keyword">int</span> pivot = a[l];</span><br><span class="line">        <span class="keyword">int</span> i = l, j = r;</span><br><span class="line">        <span class="comment">//使基准点左侧元素全部小于基准点，右侧元素全部大于基准点</span></span><br><span class="line">        <span class="keyword">while</span>(i &lt; j)&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span>(a[j] &gt;= pivot &amp;&amp; i &lt; j)&#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(a[i] &lt;= pivot &amp;&amp; i &lt; j)&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i &lt; j)&#123;</span><br><span class="line">                swap(a, i, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//使基准点归位</span></span><br><span class="line">    	swap(a, l, j);</span><br><span class="line">        <span class="comment">//返回基准点下标</span></span><br><span class="line">    	<span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = a[i];</span><br><span class="line">        a[i] = a[j];</span><br><span class="line">        a[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度O(n)，空间复杂度O(logN)，递归栈空间。</p>
<p>其实所有每趟循环都将一个元素归位的算法都能解决这个问题（e.g. 冒泡排序，选择排序序，堆排序等）。出于时间复杂度的考虑，我们可以选择快速排序，堆排序，下面是堆排序。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//建立大根堆，从最后一个非叶子结点开始向下调整</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = nums.length / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            adjustdown(nums, i, nums.length);</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//类似堆排序，每次将最大值放到末尾</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = nums.length - <span class="number">1</span>; j &gt;= nums.length - k; j--)&#123;</span><br><span class="line">            swap(nums, <span class="number">0</span>, j);</span><br><span class="line">            adjustdown(nums, <span class="number">0</span>, j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[nums.length - k];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将 a[i] 向下调整</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">adjustdown</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> i, <span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = a[i];</span><br><span class="line">		<span class="comment">//选择 a[i] 左右子树中最大的子树</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">2</span>*i+<span class="number">1</span>; k &lt; length; k = k*<span class="number">2</span>+<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(k + <span class="number">1</span> &lt; length &amp;&amp; a[k] &lt; a[k + <span class="number">1</span>])&#123;</span><br><span class="line">                k++;</span><br><span class="line">            &#125;</span><br><span class="line">			<span class="comment">//如果最大的子树值 大于 根结点，根结点下调</span></span><br><span class="line">            <span class="keyword">if</span>(a[k] &gt; temp)&#123;</span><br><span class="line">                a[i] = a[k];</span><br><span class="line">                i = k;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="comment">//根结点值大于子结点，退出递归</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//将调整后的结点赋值</span></span><br><span class="line">        a[i] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = a[i];</span><br><span class="line">        a[i] = a[j];</span><br><span class="line">        a[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度 O(n log n)，建堆时间代价是 O(n)，删除的总代价是 O(k log n)，因为 k &lt; n，故渐进时间复杂度为O(n + k log n) = O(n log n)。</p>
<p>空间复杂度O(log n)，递归使用栈空间的空间代价。</p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode Medium</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>整数拆分</title>
    <url>/2020/07/30/%E6%95%B4%E6%95%B0%E6%8B%86%E5%88%86/</url>
    <content><![CDATA[<h4 id="343-整数拆分"><a href="#343-整数拆分" class="headerlink" title="343. 整数拆分"></a><a href="https://leetcode-cn.com/problems/integer-break/" target="_blank" rel="noopener">343. 整数拆分</a></h4><p>给定一个正整数 <em>n</em>，将其拆分为<strong>至少</strong>两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。</p>
<a id="more"></a>

<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 2</span><br><span class="line">输出: 1</span><br><span class="line">解释: 2 &#x3D; 1 + 1, 1 × 1 &#x3D; 1。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 10</span><br><span class="line">输出: 36</span><br><span class="line">解释: 10 &#x3D; 3 + 3 + 4, 3 × 3 × 4 &#x3D; 36。</span><br></pre></td></tr></table></figure>

<p><strong>说明:</strong> 你可以假设 <em>n</em> 不小于 2 且不大于 58。</p>
<p><strong>方法一：动态规划</strong></p>
<p>对于任意正整数 n，我们至少可以将其拆分为两个正整数的和。令 k 是拆分出来的第一个正整数，剩下的部分是 n - k，n - k 可以选择「不拆分」和「继续拆分」，是否拆分取决于这两个选择哪一个的最大乘积最大。</p>
<p>创建 dp 数组，<code>dp[i]</code> 表示将正整数 i 拆分为至少两个正整数的和之后，这些正整数的最大乘积。0 和 1 都不能进行拆分 所以 <code>dp[0] = dp[1] = 0</code>。</p>
<p>当 <code>i &gt;= 2</code> 时，假设对正整数 i 拆分出的第一个正整数是 j (1 &lt;= j &lt; i)，有以下两种选择：</p>
<ul>
<li>i - j 不继续拆分，此时的乘积是 j * (i - j)</li>
<li>i - j 继续拆分，此时的乘积是 j * dp[i - j]</li>
</ul>
<p>我们取这两者的最大值，得到状态转移方程：<br>$$<br>dp[i] = \max_{1\leq j &lt;i}{j \times max((i - j), dp[i - j])}<br>$$<br>最终结果为 <code>dp[n]</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">integerBreak</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = dp[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> x = Integer.MIN_VALUE;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; j++)&#123;</span><br><span class="line">                x = Math.max(x, j * Math.max(dp[i - j], i - j));</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i] = x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度O(n^2)，空间复杂度O(n)。</p>
<p><strong>方法二：数学</strong></p>
<p>将 n 拆分成最多的 3 和 2，但是不能出现 1。</p>
<p>例如当 n = 10 时，最多的 3 的拆分方法为 3331，但是由于 1 对结果没有贡献，将最后的 31 改成 2*2。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">integerBreak</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;=<span class="number">3</span> )<span class="keyword">return</span> n-<span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> x = n / <span class="number">3</span>, b = n % <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">if</span>(b == <span class="number">0</span>) <span class="keyword">return</span> (<span class="keyword">int</span>)Math.pow(<span class="number">3</span>, x);</span><br><span class="line">        <span class="comment">//如果最后的余数为 1 ，代表存在 3*1这种情况，要改为 2*2</span></span><br><span class="line">        <span class="keyword">if</span>(b == <span class="number">1</span>) <span class="keyword">return</span> (<span class="keyword">int</span>)Math.pow(<span class="number">3</span>, x-<span class="number">1</span>)*<span class="number">4</span>;</span><br><span class="line">		<span class="comment">//余数为 2 </span></span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)Math.pow(<span class="number">3</span>,x)*<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度O(1)，空间复杂度O(1)。</p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>Leetcode Medium</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>新21点</title>
    <url>/2020/07/01/%E6%96%B021%E7%82%B9/</url>
    <content><![CDATA[<h4 id="837-新21点"><a href="#837-新21点" class="headerlink" title="837. 新21点"></a><a href="https://leetcode-cn.com/problems/new-21-game/" target="_blank" rel="noopener">837. 新21点</a></h4><p>爱丽丝参与一个大致基于纸牌游戏 “21点” 规则的游戏，描述如下：</p>
<p>爱丽丝以 <code>0</code> 分开始，并在她的得分少于 <code>K</code> 分时抽取数字。 抽取时，她从 <code>[1, W]</code> 的范围中随机获得一个整数作为分数进行累计，其中 <code>W</code> 是整数。 每次抽取都是独立的，其结果具有相同的概率。</p>
<p>当爱丽丝获得不少于 <code>K</code> 分时，她就停止抽取数字。 爱丽丝的分数不超过 <code>N</code> 的概率是多少？</p>
 <a id="more"></a>

<p><strong>示例</strong> <strong>1**</strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：N &#x3D; 10, K &#x3D; 1, W &#x3D; 10</span><br><span class="line">输出：1.00000</span><br><span class="line">说明：爱丽丝得到一张卡，然后停止。</span><br></pre></td></tr></table></figure>

<p><strong>示例</strong> <strong>2</strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：N &#x3D; 6, K &#x3D; 1, W &#x3D; 10</span><br><span class="line">输出：0.60000</span><br><span class="line">说明：爱丽丝得到一张卡，然后停止。</span><br><span class="line">在 W &#x3D; 10 的 6 种可能下，她的得分不超过 N &#x3D; 6 分。</span><br></pre></td></tr></table></figure>

<p><strong>示例</strong> <strong>3</strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：N &#x3D; 21, K &#x3D; 17, W &#x3D; 10</span><br><span class="line">输出：0.73278</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ol>
<li><code>0 &lt;= K &lt;= N &lt;= 10000</code></li>
<li><code>1 &lt;= W &lt;= 10000</code></li>
<li>如果答案与正确答案的误差不超过 <code>10^-5</code>，则该答案将被视为正确答案通过。</li>
<li>此问题的判断限制时间已经减少。</li>
</ol>
<p>爱丽丝获胜的概率只和下一轮开始前的得分有关，因此根据得分计算概率。令 dp[x] 表示从得分为 x 的情况开始游戏并且获胜的概率，目标是求 dp[0] 的值。</p>
<p>根据游戏规则，当分数大于等于 K 时，游戏结束，游戏结束时，如果分数不超过 N 则获胜，分数超过 N 则失败。</p>
<p>对于示例  3 ，我们可以列出以下表格</p>
<table>
<thead>
<tr>
<th>0</th>
<th>…</th>
<th>15</th>
<th>16</th>
<th>17</th>
<th>18</th>
<th>19</th>
<th>20</th>
<th>21</th>
<th>22</th>
<th>23</th>
<th>24</th>
<th>25</th>
<th>26</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
<td></td>
<td>0.5</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
</tbody></table>
<p>抽到的最大数字为 16 + 10，当最后结果为 17 ~ 21 时获胜概率为 1 （结果小于等于 N），当最后结果为 22 ~ 26 时获胜概率为 0 （结果大于N）。</p>
<p>则 dp[16] = ( dp[16+1] + dp[16+2] + … +dp[16+10] ) / 10，结果为 0.5。</p>
<p>dp[15] = ( dp[15+1] + dp[15+2] + … +dp[15+10] ) / 10，结果为 0.55。</p>
<p>得到公式</p>
<p>dp[x] = ( dp[x+1] + dp[x+2] + … +dp[x+W] ) / 10。</p>
<p>我们可以使用两层循环来求解，但会超出时间限制。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">new21Game</span><span class="params">(<span class="keyword">int</span> N, <span class="keyword">int</span> K, <span class="keyword">int</span> W)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(K == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//初始化 dp 数组最后 W 个元素</span></span><br><span class="line">        <span class="keyword">double</span>[] dp = <span class="keyword">new</span> <span class="keyword">double</span>[K + W];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = K; i &lt;= N &amp;&amp; i &lt; K + W; i++)&#123;</span><br><span class="line">            dp[i] = <span class="number">1.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//从后往前按照公式依次计算 dp 数组中的值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = K - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= W; j++)&#123;</span><br><span class="line">                dp[i] += dp[i + j] / W;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度是 O(N+KW) ，空间复杂度 O(n)。</p>
<p>上述dp[15] 和 dp[16]公式相减得到：</p>
<p>dp[15] = dp[16] - dp[16 + 10] / 10 + dp[16] / 10;</p>
<p>更一般地得到：</p>
<p>dp[x] =dp[x+1] - dp[x+1+W] / W +dp[x+1] / W。其中 x 取值范围为 [0, K-1)。</p>
<p>只有当 x 在[N, min(K + W + 1)] 范围内时才有 dp[x] = 1,因此可以在 O(1) 时间复杂度求出 dp[K - 1]。</p>
<p>dp[k - 1] = (min(N, K + W - 1) - K + 1) / W  = ( min(N - K + 1, W) )  / W。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">new21Game</span><span class="params">(<span class="keyword">int</span> N, <span class="keyword">int</span> K, <span class="keyword">int</span> W)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(K == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">double</span>[] dp = <span class="keyword">new</span> <span class="keyword">double</span>[K + W];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = K; i &lt;= N &amp;&amp; i &lt; K + W; i++)&#123;</span><br><span class="line">            dp[i] = <span class="number">1.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//计算 dp[K - 1]</span></span><br><span class="line">        dp[K - <span class="number">1</span>] = <span class="number">1.0</span> * Math.min(N - K + <span class="number">1</span>, W) / W;</span><br><span class="line">        <span class="comment">//利用公式计算 dp 数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = K - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            dp[i] = dp[i + <span class="number">1</span>] - (dp[i + W + <span class="number">1</span>] - dp[i + <span class="number">1</span>]) / W;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度是 <em>O</em>(min(<em>N</em>,<em>K</em>+<em>W</em>))，空间复杂度 O(K+W)。</p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode Medium</tag>
        <tag>动态规划</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>数组的度</title>
    <url>/2021/02/20/%E6%95%B0%E7%BB%84%E7%9A%84%E5%BA%A6/</url>
    <content><![CDATA[<h4 id="697-数组的度"><a href="#697-数组的度" class="headerlink" title="697. 数组的度"></a><a href="https://leetcode-cn.com/problems/degree-of-an-array/" target="_blank" rel="noopener">697. 数组的度</a></h4><p>给定一个非空且只包含非负数的整数数组 <code>nums</code>，数组的度的定义是指数组里任一元素出现频数的最大值。</p>
<p>你的任务是在 <code>nums</code> 中找到与 <code>nums</code> 拥有相同大小的度的最短连续子数组，返回其长度。</p>
 <a id="more"></a>

<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[1, 2, 2, 3, 1]</span><br><span class="line">输出：2</span><br><span class="line">解释：</span><br><span class="line">输入数组的度是2，因为元素1和2的出现频数最大，均为2.</span><br><span class="line">连续子数组里面拥有相同度的有如下所示:</span><br><span class="line">[1, 2, 2, 3, 1], [1, 2, 2, 3], [2, 2, 3, 1], [1, 2, 2], [2, 2, 3], [2, 2]</span><br><span class="line">最短连续子数组[2, 2]的长度为2，所以返回2.</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[1,2,2,3,1,4,2]</span><br><span class="line">输出：6</span><br></pre></td></tr></table></figure>

<p> <strong>提示：</strong></p>
<ul>
<li><code>nums.length</code> 在1到 50,000 区间范围内。</li>
<li><code>nums[i]</code> 是一个在 0 到 49,999 范围内的整数。</li>
</ul>
<p><strong>方法一：哈希表</strong></p>
<p>假设数组中出现次数最多的数为 x，数组中最短连续子数组中必定包含了数组中所有 x，且子数组首尾必定都是 x。</p>
<p>数组中可能有多个与数组的度相同的子数组，为了找到最短子数组的长度，需要统计每一个数第一次出现的位置和最后一次出现的位置。</p>
<p>使用哈希表来保存每一个数，每个数映射到一个数组，数组中三个元素分别为：这个数出现的次数，这个数第一次出现的数组下标，这个数最后一次出现的数组下标。</p>
<p>优先选择度最大的数，在度相同的情况下选择子数组最短的数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findShortestSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer, <span class="keyword">int</span>[]&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(nums[i]))&#123;<span class="comment">//数出现过，出现次数加一并维护最后一次出现的位置</span></span><br><span class="line">                ++map.get(nums[i])[<span class="number">0</span>]; </span><br><span class="line">                map.get(nums[i])[<span class="number">2</span>] = i;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="comment">//数第一次出现，添加信息</span></span><br><span class="line">                map.put(nums[i], <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, i, i&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> maxNum = <span class="number">0</span>, minLen = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;Integer, <span class="keyword">int</span>[]&gt; entry : map.entrySet())&#123;<span class="comment">//对每个数筛选</span></span><br><span class="line">            <span class="keyword">int</span>[] arr = entry.getValue();</span><br><span class="line">            <span class="keyword">if</span>(maxNum &lt; arr[<span class="number">0</span>])&#123;<span class="comment">//优先选择度最大的数，并保存度和最短连续子数组长度</span></span><br><span class="line">                maxNum = arr[<span class="number">0</span>];</span><br><span class="line">                minLen = arr[<span class="number">2</span>] - arr[<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(maxNum == arr[<span class="number">0</span>])&#123;<span class="comment">//度相同，选择子数组最短的数</span></span><br><span class="line">                <span class="keyword">if</span>(minLen &gt; arr[<span class="number">2</span>] - arr[<span class="number">1</span>] + <span class="number">1</span>)&#123;</span><br><span class="line">                    minLen = arr[<span class="number">2</span>] - arr[<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minLen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度O(n)</li>
<li>空间复杂度O(n)</li>
</ul>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode Easy</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>最佳买卖股票时机含冷冻期</title>
    <url>/2020/07/10/%E6%9C%80%E4%BD%B3%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E6%97%B6%E6%9C%BA%E5%90%AB%E5%86%B7%E5%86%BB%E6%9C%9F/</url>
    <content><![CDATA[<h4 id="309-最佳买卖股票时机含冷冻期"><a href="#309-最佳买卖股票时机含冷冻期" class="headerlink" title="309. 最佳买卖股票时机含冷冻期"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/" target="_blank" rel="noopener">309. 最佳买卖股票时机含冷冻期</a></h4><p>给定一个整数数组，其中第 <em>i</em> 个元素代表了第 <em>i</em> 天的股票价格 。</p>
<p>设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:</p>
<ul>
<li>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</li>
<li>卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。</li>
</ul>
<a id="more"></a>

<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,2,3,0,2]</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]</span><br></pre></td></tr></table></figure>

<p>将「买入」和「卖出」分开考虑，「买入」为负收益，「卖出」为正收益。我们需要尽可能地降低负收益而提高正收益，我们可以使用动态规划，维护股市中每一天结束后可以获得的「累计最大收益」，并以此进行状态转移，得到最终的答案。</p>
<p>我们使用 f[i] 表示<strong>第 i 天结束之后</strong>的「累计最大收益」。根据题目描述，我们有三种状态：</p>
<ol>
<li><p>有股票 记为 <code>f[i][0]</code>;</p>
</li>
<li><p>不在冷冻期，有股票，记为 <code>f[i][1]</code>;</p>
</li>
<li><p>不在冷冻期，无股票，记为 <code>f[i][2]</code>;</p>
</li>
</ol>
<p>这里的处于冷冻期指在第 i 天结束之后的状态。也就是说：第 i 天结束之后处于冷冻期，那么第 i + 1 天将无法买入股票。</p>
<p>状态转移分析：</p>
<ul>
<li><p>对于<code>f[i][0]</code>，第 i 天的股票可以是第 i - 1 天已经持有的，对应 <code>f[i - 1][0]</code>；或者是第 i 天买入的，第 i 天能买入股票证明第 i - 1 天没有股票且不能在冷冻期，对应<code>f[i - 1][2]</code>，加上买股票的负收益。因此状态转移方程为：<br>$$<br>f[i][0] = max(f[i - 1][0], f[i - 1][2] - prices[i])<br>$$</p>
</li>
<li><p>对于<code>f[i][1]</code>，我们在第 i 天结束之后在冷冻期，证明在第 i 天卖出了股票，说明第 i - 1 天必须持有股票，对应的状态为 <code>f[i - 1][0]</code>加上卖出股票的正收益。状态转移方程为：<br>$$<br>f[i][1] = f[i - 1][0] + prices[i]<br>$$</p>
</li>
<li><p>对于<code>f[i][2]</code>，我们在第 i 天结束之后不在冷冻期，可能在第 i - 1 天也是没有股票，不在冷冻期的状态转移过来，对应<code>f[i - 1][2]</code>；或者是第 i - 1 天无股票，在冷冻期的状态转移过来，对应<code>f[i - 1][1]</code>。状态转移方程为：<br>$$<br>f[i][2] = max(f[i - 1][2], f[i - 1][1])<br>$$<br>最终的答案为：<br>$$<br>max(f[n - 1][1], f[n - 1][2])<br>$$<br>如果在最后一天手里仍有股票是没有任何意义的。</p>
<p>我们可以初始化第 0 天的条件：<code>f[0][0]=-prices[0]</code>，<code>&#39;f[0][1]=0</code>，<code>f[0][2]=0</code></p>
<p>第 0 天有股票的负收益为 -prices[0]，第 0 天无股票的收益为 0 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = prices.length;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][<span class="number">3</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">2</span>] - prices[i]);</span><br><span class="line">            dp[i][<span class="number">1</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>] + prices[i];</span><br><span class="line">            dp[i][<span class="number">2</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">2</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(dp[n - <span class="number">1</span>][<span class="number">1</span>], dp[n - <span class="number">1</span>][<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度O(n)，空间复杂度O(n)。</p>
<p>注意到第 i 天的状态只与第 i - 1 天的状态有关，我们可以将空间复杂度优化到常数级。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = prices.length;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> one = -prices[<span class="number">0</span>], two = <span class="number">0</span>, three = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> newOne = Math.max(one, three - prices[i]);</span><br><span class="line">            <span class="keyword">int</span> newTwo = one + prices[i];</span><br><span class="line">            <span class="keyword">int</span> newThree = Math.max(three, two);</span><br><span class="line"></span><br><span class="line">            one = newOne;</span><br><span class="line">            two = newTwo;</span><br><span class="line">            three = newThree;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(two, three);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度O(n)，空间复杂度O(1)。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode Medium</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>最小区间</title>
    <url>/2020/08/01/%E6%9C%80%E5%B0%8F%E5%8C%BA%E9%97%B4/</url>
    <content><![CDATA[<h4 id="632-最小区间"><a href="#632-最小区间" class="headerlink" title="632. 最小区间"></a><a href="https://leetcode-cn.com/problems/smallest-range-covering-elements-from-k-lists/" target="_blank" rel="noopener">632. 最小区间</a></h4><p>你有 <code>k</code> 个升序排列的整数数组。找到一个<strong>最小</strong>区间，使得 <code>k</code> 个列表中的每个列表至少有一个数包含在其中。</p>
<p>我们定义如果 <code>b-a &lt; d-c</code> 或者在 <code>b-a == d-c</code> 时 <code>a &lt; c</code>，则区间 [a,b] 比 [c,d] 小。</p>
<a id="more"></a>

<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:[[4,10,15,24,26], [0,9,12,20], [5,18,22,30]]</span><br><span class="line">输出: [20,24]</span><br><span class="line">解释: </span><br><span class="line">列表 1：[4, 10, 15, 24, 26]，24 在区间 [20,24] 中。</span><br><span class="line">列表 2：[0, 9, 12, 20]，20 在区间 [20,24] 中。</span><br><span class="line">列表 3：[5, 18, 22, 30]，22 在区间 [20,24] 中。</span><br></pre></td></tr></table></figure>

<p><strong>注意:</strong></p>
<ol>
<li>给定的列表可能包含重复元素，所以在这里升序表示 &gt;= 。</li>
<li>1 &lt;= <code>k</code> &lt;= 3500</li>
<li>-105 &lt;= <code>元素的值</code> &lt;= 105</li>
</ol>
<p><strong>方法一：堆</strong></p>
<p>给定 k 个列表，需要找到最小区间，使得每个列表都至少有一个数在该区间中。该问题可以转化为：从 k 个列表中各取一个数，使得这 k 个数中的最大值与最小值的差最小。</p>
<p>假设这 k 个数中的最小值是第 i 个列表中的 x，对于 任意 <code>j≠i</code>，设第 j 个列表中被选为 k 个数之一的数是 y，为了找到最小区间，y 应该取第 j 个列表中大于等于 x 的最小的数。</p>
<p>使用最小堆维护 k 个指针指向的元素中的最小值，同时维护堆中元素的最大值。初始时，k个指针都指向下标 0 ，最大元素即为所有列表中下标为 0 位置的元素中的最大值。每次从堆中取出最小值（<strong>尝试将最小值扩大来获得更小的区间</strong>），根据最大值和最小值计算区间，如果当前区间小于最小区间，则更新最小区间，然后将对应列表的指针右移，将新元素加入堆中，并更新堆中元素的最大值。</p>
<p>如果一个列表遍历到末尾，则堆中不会再有该列表的元素，退出循环。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] smallestRange(List&lt;List&lt;Integer&gt;&gt; nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> rangeLeft = <span class="number">0</span>, rangeRight = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">int</span> minRange = rangeRight - rangeLeft;</span><br><span class="line">        <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">int</span> size = nums.size();</span><br><span class="line">        <span class="comment">//存储每个列表的指针</span></span><br><span class="line">        <span class="keyword">int</span>[] next = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line">        <span class="comment">//小根堆</span></span><br><span class="line">        PriorityQueue&lt;Integer&gt; priorityQueue = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="keyword">new</span> Comparator&lt;Integer&gt;()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer index1, Integer index2)</span></span>&#123;</span><br><span class="line">                <span class="keyword">return</span> nums.get(index1).get(next[index1]) - nums.get(index2).get(next[index2]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//将每个列表第一个元素指针加入最小堆，并维护这些指针指向的元素的最大值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)&#123;</span><br><span class="line">            priorityQueue.offer(i);</span><br><span class="line">            max = Math.max(max, nums.get(i).get(<span class="number">0</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="comment">//从堆中取出最小值的指针</span></span><br><span class="line">            <span class="keyword">int</span> minIndex = priorityQueue.poll();</span><br><span class="line">            <span class="comment">//根据最大值和最小值计算当前区间</span></span><br><span class="line">            <span class="keyword">int</span> curRange = max - nums.get(minIndex).get(next[minIndex]);</span><br><span class="line">            <span class="comment">//如果当前区间小于最小区间</span></span><br><span class="line">            <span class="keyword">if</span>(curRange &lt; minRange)&#123;</span><br><span class="line">                minRange = curRange;</span><br><span class="line">                rangeLeft = nums.get(minIndex).get(next[minIndex]);</span><br><span class="line">                rangeRight = max;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//指针右移</span></span><br><span class="line">            next[minIndex]++;</span><br><span class="line">            <span class="comment">//如果某个列表的指针遍历到末尾，堆中不会有该列表的元素退出循环</span></span><br><span class="line">            <span class="keyword">if</span>(next[minIndex] == nums.get(minIndex).size())&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将新元素加入堆中</span></span><br><span class="line">            priorityQueue.offer(minIndex);</span><br><span class="line">            <span class="comment">//更新堆中的最大值</span></span><br><span class="line">            max = Math.max(max, nums.get(minIndex).get(next[minIndex]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;rangeLeft, rangeRight&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度O(n k log k)，n 是所有列表的平均长度，k是列表数量。所有指针移动次数为 nk，操作堆的时间复杂度为O(logk)。</p>
<p>空间复杂度O(k)，堆中维护 k 个元素。</p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode Hard</tag>
        <tag>堆</tag>
      </tags>
  </entry>
  <entry>
    <title>最大子序和</title>
    <url>/2020/07/01/%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C/</url>
    <content><![CDATA[<h4 id="53-最大子序和"><a href="#53-最大子序和" class="headerlink" title="53. 最大子序和"></a><a href="https://leetcode-cn.com/problems/maximum-subarray/" target="_blank" rel="noopener">53. 最大子序和</a></h4><p>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
 <a id="more"></a>

<p>示例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [-2,1,-3,4,-1,2,1,-5,4],</span><br><span class="line">输出: 6</span><br><span class="line">解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</span><br></pre></td></tr></table></figure>

<p><strong>设f(k) 表示连续以下标为 k 的元素结尾的连续子数组的和，f(k) = max( nums[k], nums[k] + f(k-1) ),如果f(k) &lt; 0 ，从当前元素开始求和。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//初始化连续子数组的最大和，当前子数组的最大和。</span></span><br><span class="line">    <span class="keyword">int</span> max = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> sum = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;nums.length;++i)&#123;</span><br><span class="line">    	<span class="comment">//尝试向当前子数组后加入 nums[i]，如果当前子数组和为负，</span></span><br><span class="line">        <span class="comment">//则以当前元素作为第一个元素开始重新计算连续子数组。</span></span><br><span class="line">        sum = Math.max(nums[i],sum+nums[i]);</span><br><span class="line">        <span class="comment">//取最大值。</span></span><br><span class="line">        max = Math.max(max,sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode Easy</tag>
        <tag>动态规划</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>最小覆盖子串</title>
    <url>/2020/05/23/%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2/</url>
    <content><![CDATA[<h4 id="76-最小覆盖子串"><a href="#76-最小覆盖子串" class="headerlink" title="76. 最小覆盖子串"></a><a href="https://leetcode-cn.com/problems/minimum-window-substring/" target="_blank" rel="noopener">76. 最小覆盖子串</a></h4><p>给你一个字符串 S、一个字符串 T，请在字符串 S 里面找出：包含 T 所有字符的最小子串。<br> <a id="more"></a><br><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: S &#x3D; &quot;ADOBECODEBANC&quot;, T &#x3D; &quot;ABC&quot;</span><br><span class="line">输出: &quot;BANC&quot;</span><br></pre></td></tr></table></figure>

<p><strong>说明：</strong></p>
<ul>
<li>如果 S 中不存这样的子串，则返回空字符串 <code>&quot;&quot;</code>。</li>
<li>如果 S 中存在这样的子串，我们保证它是唯一的答案。</li>
</ul>
<p>我们可以用滑动窗口的思想解决这个问题，在滑动窗口类型的问题中都会有两个指针。一个用于延伸现有窗口的 right 指针，和一个用于收缩窗口的 left 指针。在任意时刻，只有一个指针移动，另一个保持静止。我们在 s 上滑动窗口，通过 right 指针不断扩张窗口，当窗口包含 t 全部所需的字符后，如果能收缩，我们就收缩直到得到最小窗口。</p>
<p>如何判断滑动窗口[left,right)是否包含字符串 t 中所有字符呢？当让我们可以暴力统计，但这样效率太低。我们使用两个辅助数组 ，winFreq 表示窗口中的字符统计数组，tFreq 表示字符串 t 中的字符统计数组。维护变量 distance，表示滑动窗口内部包含了 t 中字符的个数，窗口内单个字符个数等于 t 中对应字符个数时不再增加。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">minWindow</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sLen = s.length();</span><br><span class="line">        <span class="keyword">int</span> tLen = t.length();</span><br><span class="line">        <span class="keyword">if</span>(sLen == <span class="number">0</span> || tLen == <span class="number">0</span> || tLen &gt; sLen)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span>[] charArrayS = s.toCharArray();</span><br><span class="line">        <span class="keyword">char</span>[] charArrayT = t.toCharArray();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] winFreq = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">128</span>];</span><br><span class="line">        <span class="keyword">int</span>[] tFreq = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">128</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c : charArrayT)&#123;</span><br><span class="line">            tFreq[c] ++ ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//distance 表示滑动窗口内部包含了 t 中字符的个数，窗口内单个字符个数等于 t 中对应字符个数时不再增加</span></span><br><span class="line">        <span class="keyword">int</span> distance = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> minLen = sLen + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> begin = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//[left, right)滑动窗口长度</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(right &lt; sLen)&#123;</span><br><span class="line">            <span class="keyword">char</span> charRight = charArrayS[right];</span><br><span class="line"></span><br><span class="line">            <span class="comment">//右边界元素在 t 中不出现</span></span><br><span class="line">            <span class="keyword">if</span>(tFreq[charRight] == <span class="number">0</span>)&#123;</span><br><span class="line">                right++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//右边界元素在 t 中出现</span></span><br><span class="line">            <span class="keyword">if</span>(winFreq[charRight] &lt; tFreq[charRight])&#123;</span><br><span class="line">                distance++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//窗口字符减一，窗口右边界右移</span></span><br><span class="line">            winFreq[charRight]++;</span><br><span class="line">            right++;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//左边界向右移动，滑动窗口此时已经包含 t 中所有字符</span></span><br><span class="line">            <span class="keyword">while</span>(distance == tLen)&#123;</span><br><span class="line">                <span class="comment">//统计最小子串的开始位置及长度</span></span><br><span class="line">                <span class="keyword">if</span>(right - left &lt; minLen)&#123;</span><br><span class="line">                    minLen = right - left;</span><br><span class="line">                    begin = left;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//左边界元素在 t 中没有出现</span></span><br><span class="line">                <span class="keyword">char</span> charLeft = charArrayS[left];</span><br><span class="line">                <span class="keyword">if</span>(tFreq[charLeft] == <span class="number">0</span>)&#123;</span><br><span class="line">                    left++;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//左边界元素在 t 中出现</span></span><br><span class="line">                <span class="keyword">if</span>(winFreq[charLeft] == tFreq[charLeft])&#123;</span><br><span class="line">                    distance--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//窗口字符减一，窗口左边界右移</span></span><br><span class="line">                winFreq[charLeft]--;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(minLen == sLen + <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(begin, begin + minLen);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以优化空间只使用 tFreq 一个数组，将 distance 设置为 tLen ，对distance 使用减法，当distance == 0时表示窗口中含有字符串 t 中所有字符。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">minWindow</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sLen = s.length();</span><br><span class="line">        <span class="keyword">int</span> tLen = t.length();</span><br><span class="line">        <span class="keyword">if</span>(sLen == <span class="number">0</span> || tLen == <span class="number">0</span> || tLen &gt; sLen)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span>[] charArrayS = s.toCharArray();</span><br><span class="line">        <span class="keyword">char</span>[] charArrayT = t.toCharArray();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] tFreq = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">128</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c : charArrayT)&#123;</span><br><span class="line">            tFreq[c] ++ ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//distance 表示滑动窗口内部包含了 t 中字符的个数，窗口内单个字符个数等于 t 中对应字符个数时不再增加</span></span><br><span class="line">        <span class="keyword">int</span> distance = tLen;</span><br><span class="line">        <span class="keyword">int</span> minLen = sLen + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> begin = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//[left, right)滑动窗口长度</span></span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(right &lt; sLen)&#123;</span><br><span class="line">            <span class="keyword">char</span> charRight = charArrayS[right];</span><br><span class="line"></span><br><span class="line">            <span class="comment">//右边界元素在 t 中出现</span></span><br><span class="line">            <span class="keyword">if</span>(tFreq[charRight] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                distance--;</span><br><span class="line">            &#125;</span><br><span class="line">            tFreq[charRight]--;</span><br><span class="line">            right++;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//左边界向右移动，滑动窗口此时已经包含 t 中所有字符</span></span><br><span class="line">            <span class="keyword">while</span>(distance == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//统计最小子串的开始位置及长度</span></span><br><span class="line">                <span class="keyword">if</span>(right - left &lt; minLen)&#123;</span><br><span class="line">                    minLen = right - left;</span><br><span class="line">                    begin = left;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//左边界元素在 t 中出现</span></span><br><span class="line">                <span class="keyword">char</span> charLeft = charArrayS[left];</span><br><span class="line">                <span class="keyword">if</span>(tFreq[charLeft] == <span class="number">0</span>)&#123;</span><br><span class="line">                    distance++;</span><br><span class="line">                &#125;</span><br><span class="line">                tFreq[charLeft]++;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(minLen == sLen + <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(begin, begin + minLen);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode Hard</tag>
        <tag>字符串</tag>
        <tag>滑动窗口</tag>
      </tags>
  </entry>
  <entry>
    <title>最佳观光组合</title>
    <url>/2020/07/01/%E6%9C%80%E4%BD%B3%E8%A7%82%E5%85%89%E7%BB%84%E5%90%88/</url>
    <content><![CDATA[<h4 id="1014-最佳观光组合"><a href="#1014-最佳观光组合" class="headerlink" title="1014. 最佳观光组合"></a><a href="https://leetcode-cn.com/problems/best-sightseeing-pair/" target="_blank" rel="noopener">1014. 最佳观光组合</a></h4><p>给定正整数数组 <code>A</code>，<code>A[i]</code> 表示第 <code>i</code> 个观光景点的评分，并且两个景点 <code>i</code> 和 <code>j</code> 之间的距离为 <code>j - i</code>。</p>
<p>一对景点（<code>i &lt; j</code>）组成的观光组合的得分为（<code>A[i] + A[j] + i - j</code>）：景点的评分之和<strong>减去</strong>它们两者之间的距离。</p>
<p>返回一对观光景点能取得的最高分。</p>
 <a id="more"></a>

<p> <strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[8,1,5,2,6]</span><br><span class="line">输出：11</span><br><span class="line">解释：i &#x3D; 0, j &#x3D; 2, A[i] + A[j] + i - j &#x3D; 8 + 5 + 0 - 2 &#x3D; 11</span><br></pre></td></tr></table></figure>

<p> <strong>提示：</strong></p>
<ol>
<li><code>2 &lt;= A.length &lt;= 50000</code></li>
<li><code>1 &lt;= A[i] &lt;= 1000</code></li>
</ol>
<p>我们很轻松就可以写出暴力解法（超时）,时间复杂度 O(n^2)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxScoreSightseeingPair</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxScore = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">int</span> n = A.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++)&#123;</span><br><span class="line">                maxScore = Math.max(maxScore, A[i] + A[j] + i - j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxScore;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度 O(n^2)，空间复杂度O(1)。</p>
<p>将得分<code>A[i] + A[j] + i - j</code> 拆分成 <code>A[i]+ i</code>和<code>A[j] - j</code>两个部分，仔细分析题意可知，在 <code>i &lt; j</code> 时，对于每一个 j 值我们需要求得数组 A[0…j - 1]中的 A[i] + i 最大值，注意 i &lt; j 这个条件，我们可以先求出下标 j 之前的  A[i] + i 最大值，并维护这个最大值 mx ，在 j 遍历过程中只用 O(1) 的时间即可求得 A[i] + i 最大值，遍历整个数组 A 需要O(n)，总时间复杂度 O(n)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxScoreSightseeingPair</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>, mx = A[<span class="number">0</span>] + <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; A.length; j++)&#123;</span><br><span class="line">            ans = Math.max(ans, mx + A[j] - j);</span><br><span class="line">            mx = Math.max(mx, A[j] + j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度 O(n)，空间复杂度O(1)。</p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode Medium</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>最小路径和</title>
    <url>/2020/07/23/%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/</url>
    <content><![CDATA[<h4 id="64-最小路径和"><a href="#64-最小路径和" class="headerlink" title="64. 最小路径和"></a><a href="https://leetcode-cn.com/problems/minimum-path-sum/" target="_blank" rel="noopener">64. 最小路径和</a></h4><p>给定一个包含非负整数的 <em>m</em> x <em>n</em> 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p>
<p><strong>说明：</strong>每次只能向下或者向右移动一步。</p>
<a id="more"></a>

<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">[</span><br><span class="line">  [1,3,1],</span><br><span class="line">  [1,5,1],</span><br><span class="line">  [4,2,1]</span><br><span class="line">]</span><br><span class="line">输出: 7</span><br><span class="line">解释: 因为路径 1→3→1→1→1 的总和最小。</span><br></pre></td></tr></table></figure>

<p>我们创建二维 dp 数组，<code>dp[i][j]</code>表示从左上角出发到<code>(i, j)</code>位置的最小路径和。<code>dp[0][0]=grid[0][0]</code>。对于其他元素有以下方程：</p>
<ul>
<li>当 i = 0，j &gt; 0 时，<code>dp[0][j] = dp[0][j - 1] + grid[0][j]</code>；</li>
<li>当 j = 0，i &gt; 0 时，<code>dp[i][0] =  dp[i - 1][0] + grid[i][0]</code>；</li>
<li>当 j &gt; 0，i &gt; 0 时，<code>dp[i][j] = grid[i][j] + min(dp[i - 1][j], dp[i][j - 1])</code>。</li>
</ul>
<p><code>dp[m - 1][n - 1]</code>即为从左上角到右下角的路径和。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> row = grid.length;</span><br><span class="line">        <span class="keyword">int</span> col = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span>[][] cost = <span class="keyword">new</span> <span class="keyword">int</span>[row][col];</span><br><span class="line"></span><br><span class="line">        cost[<span class="number">0</span>][<span class="number">0</span>] = grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;row; ++i)&#123;</span><br><span class="line">            cost[i][<span class="number">0</span>] = cost[i-<span class="number">1</span>][<span class="number">0</span>] + grid[i][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;col; ++i)&#123;</span><br><span class="line">            cost[<span class="number">0</span>][i] = cost[<span class="number">0</span>][i-<span class="number">1</span>] + grid[<span class="number">0</span>][i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;row; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;col; j++)&#123;</span><br><span class="line">                cost[i][j] = Math.min(cost[i-<span class="number">1</span>][j],cost[i][j-<span class="number">1</span>])+grid[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cost[row-<span class="number">1</span>][col-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度O(mn)，空间复杂度O(mn)。</p>
<p>我们可以使用滚动数组来优化空间复杂度。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> row = grid.length;</span><br><span class="line">        <span class="keyword">int</span> col = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span>[] cost = <span class="keyword">new</span> <span class="keyword">int</span>[col];</span><br><span class="line"></span><br><span class="line">        cost[<span class="number">0</span>] = grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;col; ++i)&#123;</span><br><span class="line">            cost[i] = cost[i-<span class="number">1</span>] + grid[<span class="number">0</span>][i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;row; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;col; j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> left = j &gt; <span class="number">0</span> ? cost[j - <span class="number">1</span>] : Integer.MAX_VALUE;</span><br><span class="line">                cost[j] = Math.min(cost[j],left)+grid[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cost[col-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度O(mn)，空间复杂度O(n)。</p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode Medium</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>最大整除子集</title>
    <url>/2021/04/23/%E6%9C%80%E5%A4%A7%E6%95%B4%E9%99%A4%E5%AD%90%E9%9B%86/</url>
    <content><![CDATA[<h4 id="368-最大整除子集"><a href="#368-最大整除子集" class="headerlink" title="368. 最大整除子集"></a><a href="https://leetcode-cn.com/problems/largest-divisible-subset/" target="_blank" rel="noopener">368. 最大整除子集</a></h4><p>给你一个由 <strong>无重复</strong> 正整数组成的集合 <code>nums</code> ，请你找出并返回其中最大的整除子集 <code>answer</code> ，子集中每一元素对 <code>(answer[i], answer[j])</code> 都应当满足：</p>
<ul>
<li><code>answer[i] % answer[j] == 0</code> ，或</li>
<li><code>answer[j] % answer[i] == 0</code></li>
</ul>
<p>如果存在多个有效解子集，返回其中任何一个均可。</p>
 <a id="more"></a>

<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [1,2,3]</span><br><span class="line">输出：[1,2]</span><br><span class="line">解释：[1,3] 也会被视为正确答案。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [1,2,4,8]</span><br><span class="line">输出：[1,2,4,8]</span><br></pre></td></tr></table></figure>

<p> <strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 1000</code></li>
<li><code>1 &lt;= nums[i] &lt;= 2 * 109</code></li>
<li><code>nums</code> 中的所有整数 <strong>互不相同</strong></li>
</ul>
<p><strong>方法一：动态规划</strong></p>
<ol>
<li>求最大整除子集的长度</li>
</ol>
<p>我们首先将输入数组按照升序排序，以便获得一个子集的最小整数或最大整数。dp[i] 定义为：以nums[i] 为最大整数的<strong>有序</strong>整除子集的数字个数，nums[i] 必须被选择。</p>
<p>从小到大计算 dp 数组的值，在计算 dp[i] 之前，我们已经计算出 dp[0 … i - 1]的值，状态转移方程为：<br>$$<br>dp[i] = max(dp[j]) + 1, 其中 0 \leq j&lt;i 且\ nums[i]\  %\  nums[j] == 0<br>$$<br>最大整除子集长度就是 dp 数组中的最大值。</p>
<p>在遍历过程中我们保存最大整除子集的长度 maxSize 和子集中的最大数字 maxVal。</p>
<ol start="2">
<li>倒序找出最大整除子集</li>
</ol>
<p>假设输入数组为[2,4,7,8,9,12,16,18](已经有序)，得到的动态规划表格如下：</p>
<table>
<thead>
<tr>
<th>nums</th>
<th>2</th>
<th>4</th>
<th>7</th>
<th>8</th>
<th>9</th>
<th>12</th>
<th>16</th>
<th>18</th>
</tr>
</thead>
<tbody><tr>
<td>dp</td>
<td>1</td>
<td>2</td>
<td>1</td>
<td>3</td>
<td>1</td>
<td>3</td>
<td>4</td>
<td>3</td>
</tr>
</tbody></table>
<ol>
<li>初始时 maxSize = 4, maxVal = 16</li>
<li>寻找大小为 3 的最大整除子集，我们看到 8 和 12 对应的状态值都是 3，但 16 % 12 != 0，我们选择包含 8 的最大整除子集，此时maxSize = 3, maxVal = 8</li>
<li>继续向左寻找大小为 2 的最大整除子集，只有 4 对应的状态值为 2 ，选择包含 4 的最大整除子集，此时maxSize = 2, maxVal = 4</li>
<li>继续向左寻找大小为 1 的最大整除子集，2 对应的状态值为 1 ，选择包含 2 的最大整除子集，此时maxSize = 1, maxVal = 2</li>
</ol>
<p>我们就得到最大整除子集[16,8,4,2]。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">largestDivisibleSubset</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//动态规划找出最大子集的个数、最大子集中的最大整数</span></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> maxSize = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> maxVal = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++)&#123;</span><br><span class="line">            dp[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] % nums[j] == <span class="number">0</span>)&#123;</span><br><span class="line">                    dp[i] = Math.max(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(dp[i] &gt; maxSize)&#123;</span><br><span class="line">                maxSize = dp[i];</span><br><span class="line">                maxVal = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//倒推获得最大子集</span></span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(maxSize == <span class="number">1</span>)&#123;</span><br><span class="line">            res.add(nums[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; maxSize &gt; <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[i] == maxSize &amp;&amp; maxVal % nums[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                res.add(nums[i]);</span><br><span class="line">                maxSize--;</span><br><span class="line">                maxVal = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度O(n^2)</li>
<li>空间复杂度O(n)</li>
</ul>
<p>当前问题和使用动态规划解决的经典问题「<a href="https://leetcode-cn.com/problems/longest-increasing-subsequence" target="_blank" rel="noopener">300. 最长递增子序列</a>」有相似之处。</p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode Medium</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>最长连续序列</title>
    <url>/2020/07/01/%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<h4 id="128-最长连续序列"><a href="#128-最长连续序列" class="headerlink" title="128. 最长连续序列"></a><a href="https://leetcode-cn.com/problems/longest-consecutive-sequence/" target="_blank" rel="noopener">128. 最长连续序列</a></h4><p>给定一个未排序的整数数组，找出最长连续序列的长度。</p>
<p>要求算法的时间复杂度为 <em>O(n)</em>。</p>
 <a id="more"></a>

<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [100, 4, 200, 1, 3, 2]</span><br><span class="line">输出: 4</span><br><span class="line">解释: 最长连续序列是 [1, 2, 3, 4]。它的长度为 4。</span><br></pre></td></tr></table></figure>

<p>考虑枚举数组中的每一个数 x，考虑以其为起点，不断尝试匹配 x + 1，x + 2，…… 是否存在。采用暴力法，需要 O(n) 来遍历每个元素，使用 O(n^2) 来求取最长连续序列，时间复杂度 O(n^2)，总共时间复杂度O(n^3)。我们可以采用哈希表优化，这样判断一个数字是否存在只用 O(1)，总共时间复杂度O(n^2)。分析判断的过程，我们发现执行了很多不必要的枚举，如果已知有一个 x, x+1, x+2, … , x+y 的连续序列，我们从 x+1, x+2, … , x+y 等位置开始寻找的最长连续序列绝对小于从 x 处得到的最长连续序列长度大。因此，我们在外层循环的时候跳过这种情况。</p>
<p>如何跳过这种情况呢？由于我们要枚举的数 x 一定在数组中不存在前驱数 x - 1 的，不然我们会从 x - 1处开始尝试匹配，因此在哈希表中检查是否存在数 x - 1 即能判断是否需要跳过。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestConsecutive</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Set&lt;Integer&gt; s = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="comment">//生成哈希表</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">            s.add(num);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> longestStreak = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">            <span class="comment">//判断是否跳过匹配</span></span><br><span class="line">            <span class="keyword">if</span>(!s.contains(num - <span class="number">1</span>))&#123;</span><br><span class="line">                <span class="keyword">int</span> currentNum = num;</span><br><span class="line">                <span class="keyword">int</span> currentStreak = <span class="number">1</span>;</span><br><span class="line">			<span class="comment">//匹配</span></span><br><span class="line">                <span class="keyword">while</span>(s.contains(currentNum + <span class="number">1</span>))&#123;</span><br><span class="line">                    currentNum++ ;</span><br><span class="line">                    currentStreak++ ;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">			<span class="comment">//更新最大长度</span></span><br><span class="line">                longestStreak = Math.max(currentStreak, longestStreak);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> longestStreak;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度O(n) ，空间复杂度 O(n)。</p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode Hard</tag>
        <tag>哈希表</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>最长重复子数组</title>
    <url>/2020/07/01/%E6%9C%80%E9%95%BF%E9%87%8D%E5%A4%8D%E5%AD%90%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h4 id="718-最长重复子数组"><a href="#718-最长重复子数组" class="headerlink" title="718. 最长重复子数组"></a><a href="https://leetcode-cn.com/problems/maximum-length-of-repeated-subarray/" target="_blank" rel="noopener">718. 最长重复子数组</a></h4><p>给两个整数数组 <code>A</code> 和 <code>B</code> ，返回两个数组中公共的、长度最长的子数组的长度。</p>
 <a id="more"></a>

<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">A: [1,2,3,2,1]</span><br><span class="line">B: [3,2,1,4,7]</span><br><span class="line">输出: 3</span><br><span class="line">解释: </span><br><span class="line">长度最长的公共子数组是 [3, 2, 1]。</span><br></pre></td></tr></table></figure>

<p><strong>说明:</strong></p>
<ol>
<li>1 &lt;= len(A), len(B) &lt;= 1000</li>
<li>0 &lt;= A[i], B[i] &lt; 100</li>
</ol>
<p>我们可以想到暴力解法，即枚举数组 A 的起始位置 i 与数组 B 中的起始位置 j，然后计算A[i: ] 和 B[j: ]的最长公共前缀 k。保存 k 的最大值即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findLength</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span>[] B)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = A.length, n = B.length;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span>(k + i &lt; m &amp;&amp; k + j &lt; n &amp;&amp; A[i + k] == B[j + k])&#123;</span><br><span class="line">                    k++;</span><br><span class="line">                &#125;</span><br><span class="line">                ans = Math.max(k, ans);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度O(n^3)，空间复杂度O(1)。</p>
<p><strong>方法一：动态规划</strong></p>
<p>在暴力法中我们做了很多重复比较，设 A 数组为<code>[1, 2, 3]</code>，B 数组为<code>[1, 2, 4]</code>，在暴力法中A[2] 与 B[2] 被比较了三次，分别是计算 A[0: ] 与 B[0: ]的最长前缀和、A[1: ] 与 B[1: ]的最长前缀和、A[2: ] 与 B[2: ]的最长前缀和时产生的。</p>
<p>我们可以优化这个过程，使任意 A[i] 与 B[j] 都只被比较一次。对于A[i: ] 和 B[j: ] 的最长前缀和，如果A[i] == B[j] 那么 A[i: ] 和 B[j: ] 的最长前缀和 = A[i+1: ] 和 B[j+1: ] 的最长前缀和 + 1，否则A[i: ] 和 B[j: ] 的最长前缀和为 0 。</p>
<p>动态规划解法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if(A[i] &#x3D;&#x3D; B[j])&#123;</span><br><span class="line">	dp[i][j] &#x3D;&#x3D; dp[i - 1][j - 1] + 1;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">	dp[i][j] &#x3D; 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findLength</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span>[] B)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = A.length, n = B.length;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = m - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = n - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--)&#123;</span><br><span class="line">                dp[i][j] = A[i] == B[j] ? dp[i + <span class="number">1</span>][j + <span class="number">1</span>] + <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">                ans = Math.max(dp[i][j], ans);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度O(mn)，空间复杂度O(mn)，m 和 n 分别为数组 A 和数组 B 的长度。</p>
<p><strong>方法二：滑动窗口</strong></p>
<p>我们注意到两个位置之所以会比较多次，使因为重复子数组在两个数组中的位置可能不同：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A &#x3D; [3, 6, 1, 2, 4]</span><br><span class="line">B &#x3D; [7, 1, 2, 9]</span><br></pre></td></tr></table></figure>

<p>重复子数组[1, 2] 位置没有对齐，我们人为地将它们对齐，然后只需进行一次遍历即可得到最长重复子数组的长度。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A &#x3D; [3, 6, 1, 2, 4]</span><br><span class="line">B &#x3D;    [7, 1, 2, 9]</span><br><span class="line">           ↑  ↑</span><br></pre></td></tr></table></figure>

<p>我们可以枚举 A 和 B 所有的对齐方式：</p>
<ol>
<li>A 不变，B 的首元素与 A 中的某一个元素对齐；</li>
<li>B 不变，A 的首元素与 B 中的某一个元素对齐。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findLength</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span>[] B)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = A.length, n = B.length;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//B 不变</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">            <span class="comment">//计算剩下元素的最大长度</span></span><br><span class="line">            <span class="keyword">int</span> len = Math.min(n, m - i);</span><br><span class="line">            ans = Math.max(maxLength(A, B, i, <span class="number">0</span>, len), ans);</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//A 不变</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> len = Math.min(m, n - i);</span><br><span class="line">            ans = Math.max(maxLength(A, B, <span class="number">0</span>, i, len), ans);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//从对齐位置开始比较</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxLength</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span>[] B, <span class="keyword">int</span> addA, <span class="keyword">int</span> addB, <span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>, k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(A[addA + i] == B[addB + i])&#123;</span><br><span class="line">                ++k;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                k = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = Math.max(ans, k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度O((m + n) * min(m, n))，空间复杂度O(1)。</p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode Medium</tag>
        <tag>动态规划</tag>
        <tag>滑动窗口</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>最接近的三数之和</title>
    <url>/2020/07/01/%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9A%84%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<h4 id="16-最接近的三数之和"><a href="#16-最接近的三数之和" class="headerlink" title="16. 最接近的三数之和"></a><a href="https://leetcode-cn.com/problems/3sum-closest/" target="_blank" rel="noopener">16. 最接近的三数之和</a></h4><p>给定一个包括 <em>n</em> 个整数的数组 <code>nums</code> 和 一个目标值 <code>target</code>。找出 <code>nums</code> 中的三个整数，使得它们的和与 <code>target</code> 最接近。返回这三个数的和。假定每组输入只存在唯一答案。</p>
 <a id="more"></a>

<p> <strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [-1,2,1,-4], target &#x3D; 1</span><br><span class="line">输出：2</span><br><span class="line">解释：与 target 最接近的和是 2 (-1 + 2 + 1 &#x3D; 2) 。</span><br></pre></td></tr></table></figure>

<p> <strong>提示：</strong></p>
<ul>
<li><code>3 &lt;= nums.length &lt;= 10^3</code></li>
<li><code>-10^3 &lt;= nums[i] &lt;= 10^3</code></li>
<li><code>-10^4 &lt;= target &lt;= 10^4</code></li>
</ul>
<p>题目要求找到与 target 最接近的三元组，我们可以直接使用三重循环枚举三元组 时间复杂度O(n^3)。我们首先枚举第一个元素 a ，对于剩下的两个元素 b 和 c ，希望它们的和能最接近 target - a。对于 b 和 c ，如果数组无序则只能使用两层循环枚举，当数组有序时则可以使用双指针优化。</p>
<p>左指针指向元素 a 右侧第一个元素，右指针指向数组最后一个元素（最大的元素）。</p>
<p>我们计算每一次遍历时 a + b + c 的值 temp，对于 temp 我们有两种情况：</p>
<ul>
<li>temp &gt; target：数组的和较大，右指针左移</li>
<li>temp &lt; target：数组的和较小，左指针右移</li>
</ul>
<p>在左右指针移动的过程中 左指针必须在右指针左侧，且指针下一次指向的值不能与上一次指向的值相同，这是为了避免结果重复。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">threeSumClosest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//排序</span></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">int</span> best = <span class="number">100000</span>, n = nums.length;</span><br><span class="line">        </span><br><span class="line">		<span class="comment">//遍历元素 a </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> a = <span class="number">0</span>; a &lt; n; a++)&#123;</span><br><span class="line">            <span class="comment">//必须与上一次遍历的元素不同</span></span><br><span class="line">            <span class="keyword">if</span>(a &gt; <span class="number">0</span> &amp;&amp; a &lt; n &amp;&amp; nums[a] == nums[a - <span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> b = a + <span class="number">1</span>, c = n - <span class="number">1</span>; b &lt; c; )&#123;</span><br><span class="line">                <span class="comment">//三个元素之和等于 target 直接返回</span></span><br><span class="line">                <span class="keyword">int</span> temp = nums[a] + nums[b] + nums[c];</span><br><span class="line">                <span class="keyword">if</span>(temp == target)&#123;</span><br><span class="line">                    <span class="keyword">return</span> temp;</span><br><span class="line">                &#125;</span><br><span class="line">				</span><br><span class="line">                <span class="comment">//更新最接近 target 的值</span></span><br><span class="line">                <span class="keyword">if</span>(Math.abs(best - target) &gt; Math.abs(temp - target))&#123;</span><br><span class="line">                    best = temp;</span><br><span class="line">                &#125;</span><br><span class="line">				</span><br><span class="line">                <span class="keyword">if</span>(temp &gt; target)&#123;</span><br><span class="line">                    <span class="comment">//右指针左移</span></span><br><span class="line">                    --c;</span><br><span class="line">                    <span class="comment">//必须与上次遍历的元素不同</span></span><br><span class="line">                    <span class="keyword">while</span>(c &gt; b &amp;&amp; nums[c] == nums[c + <span class="number">1</span>])&#123;</span><br><span class="line">                        --c;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;<span class="comment">//左指针右移</span></span><br><span class="line">                    ++b;</span><br><span class="line">                    <span class="comment">//必须与上次遍历的元素不同</span></span><br><span class="line">                    <span class="keyword">while</span>(b &lt; c &amp;&amp; nums[b] == nums[b - <span class="number">1</span>])&#123;</span><br><span class="line">                        ++b;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> best;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度O(n^2)，空间复杂度O(logN)，快排需要空间。</p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode Medium</tag>
        <tag>双指针</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>有序列表转换二叉搜索树</title>
    <url>/2020/08/18/%E6%9C%89%E5%BA%8F%E5%88%97%E8%A1%A8%E8%BD%AC%E6%8D%A2%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
    <content><![CDATA[<h4 id="109-有序链表转换二叉搜索树"><a href="#109-有序链表转换二叉搜索树" class="headerlink" title="109. 有序链表转换二叉搜索树"></a><a href="https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/" target="_blank" rel="noopener">109. 有序链表转换二叉搜索树</a></h4><p>给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。</p>
<p>本题中，一个高度平衡二叉树是指一个二叉树<em>每个节点</em> 的左右两个子树的高度差的绝对值不超过 1。</p>
<a id="more"></a>

<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定的有序链表： [-10, -3, 0, 5, 9],</span><br><span class="line"></span><br><span class="line">一个可能的答案是：[0, -3, 9, -10, null, 5], 它可以表示下面这个高度平衡二叉搜索树：</span><br><span class="line"></span><br><span class="line">      0</span><br><span class="line">     &#x2F; \</span><br><span class="line">   -3   9</span><br><span class="line">   &#x2F;   &#x2F;</span><br><span class="line"> -10  5</span><br></pre></td></tr></table></figure>

<p>我们需要构造出平衡的二叉树，每次让左右子树的结点个数接近，我们可以找出链表元素的中位数作为根节点的值。链表中小于根节点的元素个数与大于根节点的元素个数要么相等，要么相差 1。我们递归地对左右子树进行构造。</p>
<p>设当前链表左端点为 left， 右端点为 right，具体范围为<code>[left, right)</code>，左闭右开区间。定义左闭右开区间的好处是，可以方便表示初始列表<code>[head, null)</code>，如果使用左闭右闭区间，则第一次需要遍历到链表末尾来获取 right 的值。在找出链表中位数结点 mid后，我们可以使用<code>[left, mid)</code>和<code>[mid.next, right)</code>来分别表示左右子树对应的列表。</p>
<p>使用快慢指针法来得到链表的中位数结点，fast 指针每次移动两次，slow 指针每次移动一次，当 fast 到达边界（fast == right 或 fast.next == right，right 的前驱结点为链表的最后一个结点）时停止，此时 slow 指向的元素就是链表的中位数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">sortedListToBST</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//左闭右开区间 [left, right)</span></span><br><span class="line">        <span class="keyword">return</span> buildTree(head, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(ListNode left, ListNode right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left == right)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//得到中间结点</span></span><br><span class="line">        ListNode mid = getMid(left, right);</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(mid.val);</span><br><span class="line">        <span class="comment">//递归构造左右子树</span></span><br><span class="line">        root.left = buildTree(left, mid);</span><br><span class="line">        root.right =  buildTree(mid.next, right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//快慢指针法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">getMid</span><span class="params">(ListNode left, ListNode right)</span></span>&#123;</span><br><span class="line">        ListNode slow = left;</span><br><span class="line">        ListNode fast = left;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(fast != right &amp;&amp; fast.next != right)&#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度O(n logn)，空间复杂度O(log n)。 n 是链表的长度。</p>
<p>寻找链表的中位数是一个比较耗时的操作，在二叉搜索树的构建过程是一个中序遍历，遍历结果就是链表，我们可以使用一个指针 ptr 来指向下一个需要建立的链表结点，在构建二叉搜索树的同时不断将 ptr 向后移动。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    ListNode ptr;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">sortedListToBST</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ptr = head;</span><br><span class="line">        <span class="keyword">int</span> length = getLength(head);</span><br><span class="line">		<span class="comment">//左闭右闭区间 [left, right]</span></span><br><span class="line">        <span class="keyword">return</span> buildTree(<span class="number">0</span>, length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//得到链表的长度</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getLength</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(head != <span class="keyword">null</span>)&#123;</span><br><span class="line">            head = head.next;</span><br><span class="line">            ++ret;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left &gt; right)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//计算 mid 位置</span></span><br><span class="line">        <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode();</span><br><span class="line">        <span class="comment">//先构建左子树</span></span><br><span class="line">        root.left = buildTree(left, mid - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//左子树构建完时，ptr 指向根节点</span></span><br><span class="line">        root.val = ptr.val;</span><br><span class="line">        ptr = ptr.next;</span><br><span class="line">        <span class="comment">//构建右子树</span></span><br><span class="line">        root.right = buildTree(mid + <span class="number">1</span>, right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度O(n)，空间复杂度O(log n)。n 为链表的长度。</p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>链表</tag>
        <tag>Leetcode Medium</tag>
        <tag>二叉搜索树</tag>
      </tags>
  </entry>
  <entry>
    <title>最长公共子序列</title>
    <url>/2021/04/03/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<h4 id="1143-最长公共子序列"><a href="#1143-最长公共子序列" class="headerlink" title="1143. 最长公共子序列"></a><a href="https://leetcode-cn.com/problems/longest-common-subsequence/" target="_blank" rel="noopener">1143. 最长公共子序列</a></h4><p>给定两个字符串 <code>text1</code> 和 <code>text2</code>，返回这两个字符串的最长 <strong>公共子序列</strong> 的长度。如果不存在 <strong>公共子序列</strong> ，返回 <code>0</code> 。</p>
<p>一个字符串的 <strong>子序列</strong> 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。</p>
<ul>
<li>例如，<code>&quot;ace&quot;</code> 是 <code>&quot;abcde&quot;</code> 的子序列，但 <code>&quot;aec&quot;</code> 不是 <code>&quot;abcde&quot;</code> 的子序列。</li>
</ul>
<p>两个字符串的 <strong>公共子序列</strong> 是这两个字符串所共同拥有的子序列。</p>
 <a id="more"></a>

<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：text1 &#x3D; &quot;abcde&quot;, text2 &#x3D; &quot;ace&quot; </span><br><span class="line">输出：3  </span><br><span class="line">解释：最长公共子序列是 &quot;ace&quot; ，它的长度为 3 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：text1 &#x3D; &quot;abc&quot;, text2 &#x3D; &quot;abc&quot;</span><br><span class="line">输出：3</span><br><span class="line">解释：最长公共子序列是 &quot;abc&quot; ，它的长度为 3 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：text1 &#x3D; &quot;abc&quot;, text2 &#x3D; &quot;def&quot;</span><br><span class="line">输出：0</span><br><span class="line">解释：两个字符串没有公共子序列，返回 0 。</span><br></pre></td></tr></table></figure>

<p> <strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= text1.length, text2.length &lt;= 1000</code></li>
<li><code>text1</code> 和 <code>text2</code> 仅由小写英文字符组成。</li>
</ul>
<p>我们自顶向下考虑这个问题，以示例 1 为例：</p>
<ol>
<li><p>text1 的最后一个字符等于 text2 的最后一个字符，所以它们的最长公共子序列长度为 “abcd” 和 “ac” 的公共子序列长度 + 1。</p>
</li>
<li><p>问题转换为求 “abcd” 和 “ac” 的公共子序列长度，此时两个字符串末尾数字不相等，我们也可求 text1 的子串 “abc” 和 text2 “ac” 的公共子序列长度，也可求 text1 “abd” 和 text2的子串 “a”的公共子序列长度，结果为这两个公共子序列长度的最大值。</p>
</li>
<li><p>继续这个操作直到两个字符串为空。</p>
</li>
</ol>
<p>我们可以写出 dp：<br>$$<br>dp[i][j] =dp[i - 1][j - 1] + 1, \ text1[i] = text2[j] \<br>$$<br>$$<br>dp[i][j] = Math.max(dp[i - 1][j],\  dp[i][j - 1]), \ text1[i] \neq text2[j] \<br>$$</p>
<p><code>dp[i][j]</code>代表字符串 text1[0 … i - 1]，和 text2[0 … j - 1]的最长公共子序列，当 i = 0 或 j = 0 时，<code>dp[i][j] = 0</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(String text1, String text2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = text1.length(), n = text2.length();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(text1.charAt(i - <span class="number">1</span>) == text2.charAt(j - <span class="number">1</span>))&#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j] = Math.max(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度O(mn)，m 和 n 分别为两个字符串的长度。</li>
<li>空间复杂度O(mn)</li>
</ul>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode Medium</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>最长回文子串</title>
    <url>/2020/07/01/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/</url>
    <content><![CDATA[<h4 id="5-最长回文子串"><a href="#5-最长回文子串" class="headerlink" title="5. 最长回文子串"></a><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/" target="_blank" rel="noopener">5. 最长回文子串</a></h4><p>给定一个字符串 <code>s</code>，找到 <code>s</code> 中最长的回文子串。你可以假设 <code>s</code> 的最大长度为 1000。</p>
 <a id="more"></a>

<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;babad&quot;</span><br><span class="line">输出: &quot;bab&quot;</span><br><span class="line">注意: &quot;aba&quot; 也是一个有效答案。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;cbbd&quot;</span><br><span class="line">输出: &quot;bb&quot;</span><br></pre></td></tr></table></figure>

<p>在看这个问题之前我们首先来看看如何判断回文字符串，我们很容易写出下面的代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>, j=s.length()-<span class="number">1</span>; i&lt;j; ++i,--j)&#123;</span><br><span class="line">		<span class="keyword">if</span>(s.charAt(i) != s.charAt(j))&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出，回文字符串是关于一个字符或者最中心的两个字符左右对称的。</p>
<ul>
<li>当字符串中字符数为奇数时关于最中心的字符对称，例如 abcba 关于字符 c 对称。</li>
<li>当字符串中字符数为偶数时关于最中心的两个字符之间的空格对称，例如 abba 关于 bb 对称。</li>
</ul>
<p>一个字符数为 n 的字符串可以关于 n 个单字符对称，关于 n-1 个两个字符对称。我们只需遍历 2n - 1 次即可得到所有回文字符串，在遍历时记录最长回文字符串的位置即可找出最长回文子串。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s == <span class="keyword">null</span> || s.length()&lt;<span class="number">1</span>)<span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">int</span> start=<span class="number">0</span>, end=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;s.length(); ++i)&#123;</span><br><span class="line">        <span class="comment">//关于单个字符对称</span></span><br><span class="line">       <span class="keyword">int</span> len1 = expandAround(s,i,i);</span><br><span class="line">        <span class="comment">//关于中心两个字符对称</span></span><br><span class="line">       <span class="keyword">int</span> len2 = expandAround(s,i,i+<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//取最大长度</span></span><br><span class="line">       <span class="keyword">int</span> len = Math.max(len1,len2);</span><br><span class="line">        <span class="comment">//记录最长回文子串的起始位置</span></span><br><span class="line">       <span class="keyword">if</span>(len &gt; end-start)&#123;</span><br><span class="line">       start = i - (len-<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">        end = i + len/<span class="number">2</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回子串</span></span><br><span class="line">    <span class="keyword">return</span> s.substring(start,end+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 求字符串 s 中，left right 开始的对称点的回文字符串长度。</span></span><br><span class="line"><span class="comment">* 当 left == right 时，关于单个字符对称，当 left + 1 == right 时关于s[left],s[right]这两个中心字* 符对称。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">expandAround</span><span class="params">(String s, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(left &gt;=<span class="number">0</span> &amp;&amp; right&lt;s.length() &amp;&amp; s.charAt(left) == s.charAt(right))&#123;</span><br><span class="line">        left--;</span><br><span class="line">        right++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> right-left-<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度 O(n^2)，空间复杂度O(1)。</p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode Medium</tag>
        <tag>字符串</tag>
        <tag>动态规划</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>有效的括号</title>
    <url>/2020/08/14/%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/</url>
    <content><![CDATA[<h4 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20. 有效的括号"></a><a href="https://leetcode-cn.com/problems/valid-parentheses/" target="_blank" rel="noopener">20. 有效的括号</a></h4><p>给定一个只包括 <code>&#39;(&#39;</code>，<code>&#39;)&#39;</code>，<code>&#39;{&#39;</code>，<code>&#39;}&#39;</code>，<code>&#39;[&#39;</code>，<code>&#39;]&#39;</code> 的字符串，判断字符串是否有效。</p>
<p>有效字符串需满足：</p>
<ol>
<li>左括号必须用相同类型的右括号闭合。</li>
<li>左括号必须以正确的顺序闭合。</li>
</ol>
<p>注意空字符串可被认为是有效字符串。</p>
<a id="more"></a>

<p>使用栈的经典题目，我们将所有的左括号入栈，当遇到右括号时，如果栈为空或者栈顶元素不能与当前括号匹配，返回false。遍历到最后，如果栈为空则 返回 true。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        Deque&lt;Character&gt; stack = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">char</span> c = s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">'('</span> || c == <span class="string">'['</span> || c == <span class="string">'&#123;'</span>)&#123;</span><br><span class="line">                stack.push(c);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">')'</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(stack.size() == <span class="number">0</span> || stack.pop() != <span class="string">'('</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">']'</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(stack.size() == <span class="number">0</span> || stack.pop() != <span class="string">'['</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(stack.size() == <span class="number">0</span> || stack.pop() != <span class="string">'&#123;'</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度O(n)，空间复杂度O(n)。</p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode Easy</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>有序矩阵中第K小的元素</title>
    <url>/2020/07/02/%E6%9C%89%E5%BA%8F%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%AC%ACK%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<h4 id="378-有序矩阵中第K小的元素"><a href="#378-有序矩阵中第K小的元素" class="headerlink" title="378. 有序矩阵中第K小的元素"></a><a href="https://leetcode-cn.com/problems/kth-smallest-element-in-a-sorted-matrix/" target="_blank" rel="noopener">378. 有序矩阵中第K小的元素</a></h4><p>给定一个 <em><code>n x n</code></em> 矩阵，其中每行和每列元素均按升序排序，找到矩阵中第 <code>k</code> 小的元素。<br>请注意，它是排序后的第 <code>k</code> 小元素，而不是第 <code>k</code> 个不同的元素。</p>
 <a id="more"></a>

<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">matrix &#x3D; [</span><br><span class="line">   [ 1,  5,  9],</span><br><span class="line">   [10, 11, 13],</span><br><span class="line">   [12, 13, 15]</span><br><span class="line">],</span><br><span class="line">k &#x3D; 8,</span><br><span class="line"></span><br><span class="line">返回 13。</span><br></pre></td></tr></table></figure>

<p> <strong>提示：</strong><br>你可以假设 k 的值永远是有效的，<code>1 ≤ k ≤ n2</code>。</p>
<p><strong>方法一：暴力</strong></p>
<p>我们直接将矩阵中的元素存到一维数组，然后进行排序，得到第 K 小的元素值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rows = matrix.length, cols = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] sorted = <span class="keyword">new</span> <span class="keyword">int</span>[rows * cols];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] mRow : matrix)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> x : mRow)&#123;</span><br><span class="line">                sorted[index++] = x;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(sorted);</span><br><span class="line">        <span class="keyword">return</span> sorted[k - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度O(n^2 log n)，对 n^2 个数排序。</p>
<p>空间复杂度O(n^2)。</p>
<p><strong>方法二：归并排序</strong></p>
<p>使用小根堆维护，将最小的 k - 1 个值丢弃，最后的最小值就是答案。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//优先级队列</span></span><br><span class="line">        PriorityQueue&lt;<span class="keyword">int</span>[]&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;<span class="keyword">int</span>[]&gt;(<span class="keyword">new</span> Comparator&lt;<span class="keyword">int</span>[]&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span>[] b)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> a[<span class="number">0</span>] - b[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">int</span> n = matrix.length;</span><br><span class="line">        <span class="comment">//将第一列的元素加入优先级队列</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            pq.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;matrix[i][<span class="number">0</span>], i, <span class="number">0</span>&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//依次取出最小的 k - 1 个数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span>[] now = pq.poll();</span><br><span class="line">            <span class="keyword">if</span> (now[<span class="number">2</span>] != n - <span class="number">1</span>) &#123;</span><br><span class="line">                pq.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;matrix[now[<span class="number">1</span>]][now[<span class="number">2</span>] + <span class="number">1</span>], now[<span class="number">1</span>], now[<span class="number">2</span>] + <span class="number">1</span>&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pq.poll()[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度O(k log n) 归并 k 次，每次调整堆 O(log n)。</p>
<p>空间复杂度O(n)，堆大小始终为 n。</p>
<p><strong>方法三：二分查找</strong></p>
<p>由题目给出的性质可知，这个矩阵内的元素是从左上到右下2递增的，在整个二维数组中 <code>matrix[0][0]</code> 为最小值， <code>matrix[n - 1][n - 1]</code> 为最大值，将其记作 l 和 r。我们发现：任取一个数 mid ，满足 l &lt;= mid &lt;= r，那么矩阵中不大于 mid 的数肯定分布在矩阵的左上角。</p>
<p>例如下图，取mid = 8：</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/FCK4Y1WT9gZscNP.png" alt="image-20200702110950664"></p>
<p>我们可以看到，矩阵中大于 mid 的数和不大于 mid 的数被分成了两块，其中左上角板块的大小即为矩阵中不大于mid 的数的数量。</p>
<p>我们只需沿着这条锯齿线走一遍即可计算出这两个板块的大小：</p>
<ol>
<li>初始位置在 <code>matrix[n - 1][0]</code> 左下角；</li>
<li>设当前位置为 <code>matrix[i][j]</code> 。若 <code>matrix[i][j] &lt;= mid</code>，则将当前所在列的不大于 mid 的数的数量(即 i + 1)累加到答案中，并向右移动，否则向上移动。</li>
<li>不断移动直到走出格子为止。</li>
</ol>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/asmUykfHSzrXQvY.png" alt="image-20200702120647972"></p>
<p>设答案为 x ，已知<code>l &lt;= x &lt;= r</code>，这样就确定了二分答案的上下界。</p>
<p>每次对于猜测的答案 mid ，计算矩阵中有多少数不大于 mid：</p>
<ul>
<li>数量不多于 k，那么 mid &lt;= x；</li>
<li>数量大于 k，那么 x &lt; mid。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = matrix.length;</span><br><span class="line">        <span class="keyword">int</span> left = matrix[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> right = matrix[n - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(check(matrix, mid, k, n))&#123;</span><br><span class="line">                <span class="comment">//不大于 mid 的数大于 k 个，x &lt;= mid</span></span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//不大于 mid 的数小于 k 个，x &gt; mid</span></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> mid, <span class="keyword">int</span> k, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &gt;= <span class="number">0</span> &amp;&amp; j &lt; n)&#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[i][j] &lt;= mid)&#123;</span><br><span class="line">                <span class="comment">//将第 j 列中小于 mid 的数的个数加到总数</span></span><br><span class="line">                num += i + <span class="number">1</span>;</span><br><span class="line">                <span class="comment">//右移</span></span><br><span class="line">                j++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//上移</span></span><br><span class="line">                i--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//不大于 mid 的数是否大于等于 k </span></span><br><span class="line">        <span class="keyword">return</span> num &gt;= k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n log(r - l))，二分查找进行次数为 O(log(r - l))，每次操作时间复杂度O(n)。空间复杂度：O(1)。</p>
<p><strong>关于为什么返回 left 及left = mid + 1 是否存在于数组中</strong>：</p>
<p>matrix = [ [ 1, 5, 9], [10, 11, 13], [12, 13, 15] ] k=8 res=13</p>
<p>假设 left = 14，那么 check 函数返回 true ，此时选择 right = mid，也就是选择右边界往左缩，即使 mid = 14 为可能的解，二分查找并不会结束。我们要找的是满足 不大于 mid 的数的个数等于 k 的最左值，可以想像成寻找有序数组中某个重复出现数字第一次出现的位置，这个最左值一定存在于数组中，所以直接返回 left。</p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode Medium</tag>
        <tag>二分查找</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>柱状图中最大的矩形</title>
    <url>/2020/07/01/%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2/</url>
    <content><![CDATA[<h4 id="84-柱状图中最大的矩形"><a href="#84-柱状图中最大的矩形" class="headerlink" title="84. 柱状图中最大的矩形"></a><a href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram/" target="_blank" rel="noopener">84. 柱状图中最大的矩形</a></h4><p>给定 <em>n</em> 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。</p>
<p>求在该柱状图中，能够勾勒出来的矩形的最大面积。</p>
  <a id="more"></a>

<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/pCdscWKFb4qRMNP.png" alt="img"></p>
<p>以上是柱状图的示例，其中每个柱子的宽度为 1，给定的高度为 <code>[2,1,5,6,2,3]</code>。</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/Nmh9znMFBDqGJ7b.png" alt="img"></p>
<p>图中阴影部分为所能勾勒出的最大矩形面积，其面积为 <code>10</code> 个单位。</p>
<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [2,1,5,6,2,3]</span><br><span class="line">输出: 10</span><br></pre></td></tr></table></figure>

<p>方法一：暴力法</p>
<p>矩形面积为宽乘高，我们可以固定其中一个，然后枚举另一个求出最大矩形面积。这里我们枚举高，使用一重循环枚举某一根柱子，将其固定为矩形的高度 h，随后我们以这根柱子为中心向左右两边扩散，当遇到高度比 h 小的柱子时停止，得到矩形的宽度 w，进而求出矩形面积 w*h。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="keyword">int</span>[] heights)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len  = heights.length;</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//枚举每一根柱子</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len ; ++ i)&#123;</span><br><span class="line">            <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">			<span class="comment">//寻找左边界</span></span><br><span class="line">            <span class="keyword">for</span>(left = i - <span class="number">1</span> ; left &gt;= <span class="number">0</span> &amp;&amp; heights[left] &gt;= heights[i] ; --left);</span><br><span class="line">            <span class="comment">//寻找右边界</span></span><br><span class="line">            <span class="keyword">for</span>(right = i + <span class="number">1</span> ; right &lt; len &amp;&amp; heights[right] &gt;= heights[i] ; ++right);</span><br><span class="line">			<span class="comment">//计算结果</span></span><br><span class="line">            res = Math.max(res, heights[i] * (right - left - <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度O(n^2) 空间复杂度 O(1)</p>
<p>方法二：单调栈</p>
<p>对于某一根柱子 i ，高度为 h = heights[i]。我们需要向两边扩展，找到<strong>左右两侧最近的高度小于  h 的柱子</strong>。先来看如何求一根柱子左侧且最近的小于其高度的柱子。</p>
<p>对于两根柱子，下标分别为 a 和 b，其中 a &lt; b，且heights[a] &gt;= heights[b]。在后面的柱子 i 向左照小于其高度的柱子时，由于柱子 a 的高度大于柱子 b 的高度，所以柱子 a 不可能成为柱子 i 左侧最近且小于其高度的柱子（应该是柱子 b），称为柱子 b  <strong>挡住</strong>了柱子 a。</p>
<p>这样一来，我们可以对数组从左到右进行遍历，同时维护一个可能作为答案的数据结构，其中按照从小到大存放柱子的下标值，并且它们的高度值也是单调递增的。如果有两个相邻的下标值不满足递增关系，则后者会挡住前者，前者不会作为答案。 </p>
<p>我们在枚举到第 i 根柱子时，可以先将所有高度大于等于 heights[i] 的下标值全部移除，剩下的下标值中高度最高的即为答案。在这之后，我们将 i 放入数据结构中，开始接下来的枚举。</p>
<p>我们使用栈这一数据结构：</p>
<ul>
<li>栈中存放了下标值 j。从栈底到栈顶，j 的值严格单调递增，同时对应的高度值也严格单调递增；</li>
<li>当我们枚举到第 i 根柱子时，我们从栈顶不断地移除 heights[j] &gt;= heights[i] 的 j 值。在移除完毕后，栈顶的 j 值就一定满足 heights[j] &lt; heights[i]。此时 j 就是 i 左侧最近的小于其高度的柱子；</li>
<li>再将 i 放入栈顶。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="keyword">int</span>[] heights)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len  = heights.length;</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> heights[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> area = <span class="number">0</span>;</span><br><span class="line">        Deque&lt;Integer&gt; stack = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        <span class="comment">//枚举每一根柱子</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">            <span class="comment">//栈顶的柱子 j 高度比当前柱子 i 的高度大，不满足递增关系。</span></span><br><span class="line">            <span class="keyword">while</span>(!stack.isEmpty() &amp;&amp; heights[stack.peekLast()] &gt; heights[i])&#123;</span><br><span class="line">                <span class="keyword">int</span> height = heights[stack.removeLast()];</span><br><span class="line">				<span class="comment">//如果两个柱子高度相等不满足递增关系，出栈一个元素。</span></span><br><span class="line">                <span class="keyword">while</span>(!stack.isEmpty() &amp;&amp; heights[stack.peekLast()] == height)&#123;</span><br><span class="line">                    stack.removeLast();</span><br><span class="line">                &#125;</span><br><span class="line">				</span><br><span class="line">                <span class="keyword">int</span> width;</span><br><span class="line">                <span class="keyword">if</span>(stack.isEmpty())&#123;<span class="comment">//栈为空，左侧的柱子都比柱子 i 高</span></span><br><span class="line">                    width = i;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;<span class="comment">//栈非空，左侧最近比柱子 i 小的下标为栈顶元素的值</span></span><br><span class="line">                    width = i - stack.peekLast() - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">				<span class="comment">//计算矩形面积</span></span><br><span class="line">                area = Math.max(area, width * height);</span><br><span class="line">            &#125;</span><br><span class="line">			<span class="comment">//将柱子 i 添加到栈中</span></span><br><span class="line">            stack.addLast(i);</span><br><span class="line">        &#125;</span><br><span class="line">        	<span class="comment">//考虑遍历完数组后栈中不为空的情况，例如高度数组为[1,2,3,4,5]。</span></span><br><span class="line">            <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">                <span class="keyword">int</span> height = heights[stack.removeLast()];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span>(!stack.isEmpty() &amp;&amp;  heights[stack.peekLast()] == height)&#123;</span><br><span class="line">                    stack.removeLast();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> width;</span><br><span class="line">                <span class="keyword">if</span>(stack.isEmpty())&#123;</span><br><span class="line">                    width = len;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    width = len - stack.peekLast() - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                area = Math.max(area, width * height);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> area;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度O(n) 空间复杂度 O(n)</p>
<p>我们还可以用哨兵来保持栈中不为空，这样少了很多判空处理。同时由于最后一个柱子高度为 0 可以清空栈，同时处理了高度数组为[1,2,3,4,5] 这种情况。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="keyword">int</span>[] heights)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len  = heights.length;</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> heights[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> area = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//高度数组首尾添加高度为 0 的两个柱子。</span></span><br><span class="line">        <span class="keyword">int</span>[] newHeights = <span class="keyword">new</span> <span class="keyword">int</span>[len + <span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">            newHeights[i + <span class="number">1</span>] = heights[i];</span><br><span class="line">        &#125;</span><br><span class="line">        len += <span class="number">2</span>;</span><br><span class="line">        heights = newHeights;</span><br><span class="line"></span><br><span class="line">        Deque&lt;Integer&gt; stack = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        <span class="comment">//将高度为 0 的柱子下标加入栈中</span></span><br><span class="line">        stack.addLast(<span class="number">0</span>);</span><br><span class="line">		<span class="comment">// 从第一根高度不为 0 的柱子开始遍历。</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++)&#123;</span><br><span class="line">            <span class="comment">//不可能有高度小于 0 的柱子，所以不需要判断栈是否为空</span></span><br><span class="line">            <span class="keyword">while</span>(heights[stack.peekLast()] &gt; heights[i])&#123;</span><br><span class="line">                <span class="keyword">int</span> height = heights[stack.removeLast()];</span><br><span class="line">                <span class="comment">//计算宽度</span></span><br><span class="line">                <span class="keyword">int</span> width = i - stack.peekLast() - <span class="number">1</span>;</span><br><span class="line">                area = Math.max(area, width * height);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将柱子 i 添加到栈中</span></span><br><span class="line">            stack.addLast(i);</span><br><span class="line">        &#125;</span><br><span class="line">            <span class="keyword">return</span> area;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度，空间复杂度同上。</p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode Hard</tag>
        <tag>数组</tag>
        <tag>单调栈</tag>
      </tags>
  </entry>
  <entry>
    <title>最长有效括号</title>
    <url>/2020/07/04/%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7/</url>
    <content><![CDATA[<h4 id="32-最长有效括号"><a href="#32-最长有效括号" class="headerlink" title="32. 最长有效括号"></a><a href="https://leetcode-cn.com/problems/longest-valid-parentheses/" target="_blank" rel="noopener">32. 最长有效括号</a></h4><p>给定一个只包含 <code>&#39;(&#39;</code> 和 <code>&#39;)&#39;</code> 的字符串，找出最长的包含有效括号的子串的长度。</p>
<a id="more"></a>

<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;(()&quot;</span><br><span class="line">输出: 2</span><br><span class="line">解释: 最长有效括号子串为 &quot;()&quot;</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;)()())&quot;</span><br><span class="line">输出: 4</span><br><span class="line">解释: 最长有效括号子串为 &quot;()()&quot;</span><br></pre></td></tr></table></figure>

<p><strong>方法一：暴力法</strong></p>
<p>我们直接枚举所有的字符串并判断其是否有效。这里我们使用一个窗口，窗口大小初始化为不大于字符串长度的最大偶数，每次循环都判断窗口内的字符串是否有效，如果有效则返回窗口大小，无效则将窗口大小减小 2 ，继续判断。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="keyword">int</span> window = (len &amp; <span class="number">1</span>) == <span class="number">1</span> ? len - <span class="number">1</span> : len;</span><br><span class="line">        <span class="keyword">while</span>(window != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; window &gt;= <span class="number">2</span> &amp;&amp; i + window - <span class="number">1</span> &lt; len; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(isValid(s, i, i + window - <span class="number">1</span>))&#123;</span><br><span class="line">                <span class="keyword">return</span> window;</span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;</span><br><span class="line">        window -= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        LinkedList&lt;Character&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt;= end; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i) == <span class="string">'('</span>)&#123;</span><br><span class="line">                stack.add(<span class="string">'('</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(stack.size() != <span class="number">0</span>)&#123;</span><br><span class="line">                    stack.removeLast();</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.size() == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度O(n^3)，空间复杂度O(1)。</p>
<p><strong>方法二：动态规划</strong></p>
<p>定义 dp[i] 表示以下标 i 字符结尾的最长有效括号的长度。我们将 dp 数组全部初始化为 0。有效的子串一定以 ‘)’ 结尾，以 ‘(‘ 结尾的子串对应的 dp 值一定为 0 。</p>
<p>我们从前往后遍历字符串求解 dp 值，每两个字符检查依次：</p>
<ol>
<li><p>s[i] = ‘)’ 且 s[i - 1] = ‘(‘，形如  “………()”，我们可以推出：<br>$$<br>dp[i]=dp[i - 2] + 2<br>$$</p>
</li>
<li><p>s[i] = ‘)’ 且 s[i - 1] = ‘)’，形如 “……….))”，我们可以推出：</p>
<p>如果 s[i - dp[i - 1] - 1] = ‘(‘ 那么<br>$$<br>dp[i]=dp[i-1] + 2 + dp[i - dp[i - 1] - 2]<br>$$</p>
</li>
</ol>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20210824162120356.png" alt="image-20210824162120356"></p>
<p>第一种情况为后面的两个字符 “()” 与前面的字符串构成一个更长的有效括号子串；</p>
<p>第二种情况为后面两个字符 “))” 中有两层子串，里面一个 ‘)’ 构成一个有效括号子串，再加上外层括号，然后看包括外层括号的子串能否与外层括号’(‘ 连接起来构成一个更长的有效括号子串，<code>s[i - dp[i - 1] - 1] = &#39;(&#39;</code> 判断外层左括号是否存在，<code>dp[i - 1] + 2</code> 表示内层子串加上外层两个括号构成更长的子串长度，<code>dp[i - dp[i - 1] - 2]</code> 表示外层 ‘(‘ 与其之前的字符串构成更长的有效括号子串。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> dp[] = <span class="keyword">new</span> <span class="keyword">int</span>[s.length()];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; dp.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i) == <span class="string">')'</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s.charAt(i - <span class="number">1</span>) == <span class="string">'('</span>)&#123;</span><br><span class="line">                    dp[i] = (i &gt;= <span class="number">2</span> ? dp[i - <span class="number">2</span>] : <span class="number">0</span>) + <span class="number">2</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i - dp[i - <span class="number">1</span>] &gt; <span class="number">0</span> &amp;&amp; s.charAt(i - dp[i - <span class="number">1</span>] - <span class="number">1</span>) == <span class="string">'('</span>)&#123;</span><br><span class="line">                    dp[i] = dp[i - <span class="number">1</span>] + ((i - dp[i - <span class="number">1</span>]) &gt;= <span class="number">2</span> ? dp[i - dp[i - <span class="number">1</span>] - <span class="number">2</span>] : <span class="number">0</span>) + <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                ans = Math.max(ans, dp[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度O(n)，空间复杂度O(n)。</p>
<p><strong>方法三：栈</strong></p>
<p>通过栈，我们可以在遍历给定字符串的过程中去判断到目前为止扫描的子串的有效性，同时能得到最长有效括号的长度。</p>
<p>我们始终保持栈底元素为当前已经遍历过的元素中「最后一个没有被匹配的右括号的下标」，这样的作法考虑了边界条件的处理，栈中其他元素维护左括号的下标：</p>
<ul>
<li>对于遇到的每个 ‘(‘ ，我们将它的下标放入栈中</li>
<li>对于遇到的每个 ‘)’，我i们先弹出栈顶元素表示匹配了当前右括号：<ul>
<li>如果栈为空，说明当前右括号为「没有被匹配的右括号」，我们将其下标放入栈中更新栈底元素。</li>
<li>如果栈不为空，当前右括号的下标减去栈顶元素即为「以该右括号为结尾的最长有效括号的长度」</li>
</ul>
</li>
</ul>
<p>为了满足栈底一直是「最后一个没有被匹配的右括号的下标」，我们在一开始往栈中放入一个值为 - 1 的元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        LinkedList&lt;Integer&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        stack.add(-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i) == <span class="string">'('</span>)&#123;</span><br><span class="line">                stack.add(i);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                stack.removeLast();</span><br><span class="line">                <span class="keyword">if</span>(stack.size() == <span class="number">0</span>)&#123;</span><br><span class="line">                    stack.add(i);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    ans = Math.max(ans, i - stack.getLast());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度O(n)，空间复杂度O(n)。</p>
<p><strong>方法四：正向逆向结合</strong></p>
<p>我们利用两个计数器 left 和 right 。首先，我们从左到右遍历字符串，对于遇到的每个 ‘(‘，我们增加 left 计数器，对于遇到的每个 ‘)’，我们增加 right计数器。每当 left 计数器与 right 计数器相等时，我们计算当前有效字符串的长度，记录目前为止找到的最长子字符串。当 right 计数器比 left 计数器大时，我们将 left 和 right 同时变回 0 。</p>
<p>这样的做法贪心地考虑了以当前字符下标结尾的有效括号长度，每次当右括号数量多于左括号数量的时候之前的字符我们都扔掉不再考虑，重新从下一个字符开始计算，但这样会漏掉一种情况，就是遍历的时候左括号的数量始终大于右括号的数量，即 ”(() “，这种时候最长有效括号是求不出来的。</p>
<p>我们只用从右往左遍历用类似的方法计算即可：</p>
<ul>
<li>left 计数器比 right 计数器大时，将 left 计数器和 right 计数器同时变回 0 。</li>
<li>left 计数器与 right 计数器相等时，我们计算当前有效字符串的长度，并且记录目前为止找到的最长子字符串。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>, maxLength = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i) == <span class="string">'('</span>)&#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                right++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(left == right)&#123;</span><br><span class="line">                maxLength = Math.max(maxLength, <span class="number">2</span> * right);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(right &gt; left)&#123;</span><br><span class="line">                left = right = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        left = right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = s.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i) == <span class="string">'('</span>)&#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                right++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(left == right)&#123;</span><br><span class="line">                maxLength = Math.max(maxLength, <span class="number">2</span> * left);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(left &gt; right)&#123;</span><br><span class="line">                left = right = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxLength;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度O(n)，空间复杂度O(1)。</p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode Hard</tag>
        <tag>字符串</tag>
        <tag>动态规划</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>森林中的兔子</title>
    <url>/2021/04/04/%E6%A3%AE%E6%9E%97%E4%B8%AD%E7%9A%84%E5%85%94%E5%AD%90/</url>
    <content><![CDATA[<h4 id="781-森林中的兔子"><a href="#781-森林中的兔子" class="headerlink" title="781. 森林中的兔子"></a><a href="https://leetcode-cn.com/problems/rabbits-in-forest/" target="_blank" rel="noopener">781. 森林中的兔子</a></h4><p>森林中，每个兔子都有颜色。其中一些兔子（可能是全部）告诉你还有多少其他的兔子和自己有相同的颜色。我们将这些回答放在 <code>answers</code> 数组里。</p>
<p>返回森林中兔子的最少数量。</p>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例:</span><br><span class="line">输入: answers &#x3D; [1, 1, 2]</span><br><span class="line">输出: 5</span><br><span class="line">解释:</span><br><span class="line">两只回答了 &quot;1&quot; 的兔子可能有相同的颜色，设为红色。</span><br><span class="line">之后回答了 &quot;2&quot; 的兔子不会是红色，否则他们的回答会相互矛盾。</span><br><span class="line">设回答了 &quot;2&quot; 的兔子为蓝色。</span><br><span class="line">此外，森林中还应有另外 2 只蓝色兔子的回答没有包含在数组中。</span><br><span class="line">因此森林中兔子的最少数量是 5: 3 只回答的和 2 只没有回答的。</span><br><span class="line"></span><br><span class="line">输入: answers &#x3D; [10, 10, 10]</span><br><span class="line">输出: 11</span><br><span class="line"></span><br><span class="line">输入: answers &#x3D; []</span><br><span class="line">输出: 0</span><br></pre></td></tr></table></figure>

<p><strong>说明:</strong></p>
<ol>
<li><code>answers</code> 的长度最大为<code>1000</code>。</li>
<li><code>answers[i]</code> 是在 <code>[0, 999]</code> 范围内的整数。</li>
</ol>
<p><strong>方法一：贪心</strong></p>
<p>两只相同颜色的兔子看到的其他同色兔子数必然是相同的。反之，若两只兔子看到的其他同色兔子数不同，那么这两只兔子颜色也不同。</p>
<p>因此，将 answer 中值相同的元素分为一组，对于每一组，计算出兔子的最少数量，然后将所有组的计算结果累加，就是最终的答案。</p>
<p>例如，现在有 13 只兔子回答 5，可以肯定至少有 3 种颜色的兔子。假设一只蓝色兔子回答 5 ，那么还有 5 只蓝色兔子；假设还有一只红色兔子回答 5 ，那么还有 5 只红色兔子；为了最小化可能的兔子数量，我们假设这 12 只兔子都在这 13 只兔子中。还剩下 1 只其他颜色兔子回答 5 ，那么其他颜色的兔子也为 5 只。最少会有 18 只兔子。</p>
<p>一般如果有 x 只兔子回答 y，则至少有 ceil(x / (y  + 1))种不同的颜色，且每种颜色有 y  + 1 只兔子，因此兔子数至少为<br>$$<br>\lceil \frac{x}{y + 1}\rceil * (y + 1)<br>$$</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numRabbits</span><span class="params">(<span class="keyword">int</span>[] answers)</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; count = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> y : answers)&#123;</span><br><span class="line">            count.put(y, count.getOrDefault(y, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;Integer, Integer&gt; entry : count.entrySet())&#123;</span><br><span class="line">            <span class="keyword">int</span> y = entry.getKey(), x = entry.getValue();</span><br><span class="line">            ans += (x + y) / (y + <span class="number">1</span>) * (y + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度O(n)</li>
<li>空间复杂度O(n)</li>
</ul>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode Medium</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>模式匹配</title>
    <url>/2020/07/01/%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D/</url>
    <content><![CDATA[<h4 id="面试题-16-18-模式匹配"><a href="#面试题-16-18-模式匹配" class="headerlink" title="面试题 16.18. 模式匹配"></a><a href="https://leetcode-cn.com/problems/pattern-matching-lcci/" target="_blank" rel="noopener">面试题 16.18. 模式匹配</a></h4><p>你有两个字符串，即<code>pattern</code>和<code>value</code>。 <code>pattern</code>字符串由字母<code>&quot;a&quot;</code>和<code>&quot;b&quot;</code>组成，用于描述字符串中的模式。例如，字符串<code>&quot;catcatgocatgo&quot;</code>匹配模式<code>&quot;aabab&quot;</code>（其中<code>&quot;cat&quot;</code>是<code>&quot;a&quot;</code>，<code>&quot;go&quot;</code>是<code>&quot;b&quot;</code>），该字符串也匹配像<code>&quot;a&quot;</code>、<code>&quot;ab&quot;</code>和<code>&quot;b&quot;</code>这样的模式。但需注意<code>&quot;a&quot;</code>和<code>&quot;b&quot;</code>不能同时表示相同的字符串。编写一个方法判断<code>value</code>字符串是否匹配<code>pattern</code>字符串。<br> <a id="more"></a><br><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入： pattern &#x3D; &quot;abba&quot;, value &#x3D; &quot;dogcatcatdog&quot;</span><br><span class="line">输出： true</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入： pattern &#x3D; &quot;abba&quot;, value &#x3D; &quot;dogcatcatfish&quot;</span><br><span class="line">输出： false</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入： pattern &#x3D; &quot;aaaa&quot;, value &#x3D; &quot;dogcatcatdog&quot;</span><br><span class="line">输出： false</span><br></pre></td></tr></table></figure>

<p><strong>示例 4：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入： pattern &#x3D; &quot;abba&quot;, value &#x3D; &quot;dogdogdogdog&quot;</span><br><span class="line">输出： true</span><br><span class="line">解释： &quot;a&quot;&#x3D;&quot;dogdog&quot;,b&#x3D;&quot;&quot;，反之也符合规则</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= len(pattern) &lt;= 1000</code></li>
<li><code>0 &lt;= len(value) &lt;= 1000</code></li>
<li>你可以假设<code>pattern</code>只包含字母<code>&quot;a&quot;</code>和<code>&quot;b&quot;</code>，<code>value</code>仅包含小写字母。</li>
</ul>
<p>我们设 pattern 的长度为 Lp，value 的长度为 Lv。将 a 对应的字符串长度设为 lenA，b 对应的字符串长度设为 lenB。假设 pattern 中出现了 countA  个 a 以及 Lp - countA 个 b ，那么满足下式：<br>$$<br>countA * lenA + (Lp - countA) * lenB = Lv<br>$$<br>其中 countA 已知，lenA 和 lenB 未知。我们需要求解这个二元一次方程，lenA 和 lenB 必须为自然数，我们可以枚举 lenA （lenA * countA &lt;= Lv）的值，在枚举 lenA 之后，带入等式求解 lenB，如果 lenB 为整数，我们就枚举了一组 a  和 b 的可能长度。</p>
<p>在枚举了长度之后，我们可以根据 pattern 将  value 划分为 Lp 个子串。所有 a 对应的子串必须对应同一个相同的字符串，同样 所有 b 对应的子串必须对应同一个字符串，且 a 和 b 对应的字符串必须不一样，不满足这些条件则匹配失败。</p>
<p>在求解二元一次方程时，我们先枚举 lenA，那么必须要求 countA != 0 ，因为在 countA = 0 的情况下，如果原方程有解，那么一定有无数解，这会增加编码的复杂度，因为要处理 countA = 0 这一特殊情况。在统计 a 和 b 出现的次数时，如果出现 countA &lt; countB 的情况，我们将 a 和 b 互相替换，保证 countA  &gt; 0。</p>
<p>我们总结判断逻辑：</p>
<ol>
<li>保证 pattern 中  a 出现的次数 不少于 b 出现的次数。如果不满足，我们就将 a 和 b 互换。</li>
<li>如果 value 为空，那么要求 pattern 也为空，或者只出现了 a ，在其他情况下匹配失败。</li>
<li>如果 pattern 为空且 value 不为空，匹配失败。</li>
<li>如果 pattern 和 value 非空，我们就可以枚举 lenA 并判断。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">patternMatching</span><span class="params">(String pattern, String value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//计算模式中 'a' 和 'b'数量</span></span><br><span class="line">        <span class="keyword">int</span> countA = <span class="number">0</span>, countB = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> ch : pattern.toCharArray())&#123;</span><br><span class="line">            <span class="keyword">if</span>(ch == <span class="string">'a'</span>)&#123;</span><br><span class="line">                ++countA;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ++countB;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">// 保证 'a' 出现的次数大于 'b'</span></span><br><span class="line">        <span class="keyword">if</span>(countA &lt; countB)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = countA;</span><br><span class="line">            countA = countB;</span><br><span class="line">            countB = temp;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">char</span>[] array = pattern.toCharArray();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++)&#123;</span><br><span class="line">                array[i] = array[i] == <span class="string">'a'</span> ? <span class="string">'b'</span> : <span class="string">'a'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            pattern = <span class="keyword">new</span> String(array);</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">// 判空处理</span></span><br><span class="line">        <span class="keyword">if</span>(value.length() == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> countB == <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pattern.length() == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//枚举lenA</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> lenA = <span class="number">0</span>; countA * lenA &lt;= value.length(); ++lenA)&#123;</span><br><span class="line">            <span class="comment">//计算 b 对应字符串的总长度</span></span><br><span class="line">            <span class="keyword">int</span> rest = value.length() - countA * lenA;</span><br><span class="line">            <span class="comment">// countB 为自然数</span></span><br><span class="line">            <span class="keyword">if</span>((countB == <span class="number">0</span> &amp;&amp; rest == <span class="number">0</span>) || (countB != <span class="number">0</span> &amp;&amp; rest % countB == <span class="number">0</span>))&#123;</span><br><span class="line">                <span class="keyword">int</span> lenB = (countB == <span class="number">0</span> ? <span class="number">0</span> : rest / countB);</span><br><span class="line">                <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">boolean</span> correct = <span class="keyword">true</span>;</span><br><span class="line">                String valueA = <span class="string">""</span>, valueB = <span class="string">""</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">char</span> ch : pattern.toCharArray())&#123;</span><br><span class="line">                    <span class="comment">//判断所有 a 对应的字符串是否相等</span></span><br><span class="line">                    <span class="keyword">if</span>(ch == <span class="string">'a'</span>)&#123;</span><br><span class="line">                        String sub = value.substring(pos, pos + lenA);</span><br><span class="line">                        <span class="keyword">if</span>(valueA.length() == <span class="number">0</span>)&#123;</span><br><span class="line">                            valueA = sub;</span><br><span class="line">                        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(! valueA.equals(sub))&#123;</span><br><span class="line">                            correct = <span class="keyword">false</span>;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        pos += lenA;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="comment">//判断所有 b 对应的字符串是否相等</span></span><br><span class="line">                        String sub = value.substring(pos, pos + lenB);</span><br><span class="line">                        <span class="keyword">if</span>(valueB.length() == <span class="number">0</span>)&#123;</span><br><span class="line">                            valueB = sub;</span><br><span class="line">                        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(! valueB.equals(sub))&#123;</span><br><span class="line">                            correct = <span class="keyword">false</span>;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        pos += lenB;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 所有 a 对应的字符串相等，所有 b 对应的字符串相等，</span></span><br><span class="line">                <span class="comment">// a 和 b 对应的字符串不相等，返回true</span></span><br><span class="line">                <span class="keyword">if</span>(correct &amp;&amp; !valueA.equals(valueB))&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode Medium</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>最长递增子序列</title>
    <url>/2021/04/23/%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<h4 id="300-最长递增子序列"><a href="#300-最长递增子序列" class="headerlink" title="300. 最长递增子序列"></a><a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/" target="_blank" rel="noopener">300. 最长递增子序列</a></h4><p>给你一个整数数组 <code>nums</code> ，找到其中最长严格递增子序列的长度。</p>
<p>子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，<code>[3,6,2,7]</code> 是数组 <code>[0,3,1,6,2,2,7]</code> 的子序列。</p>
<a id="more"></a>

<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [10,9,2,5,3,7,101,18]</span><br><span class="line">输出：4</span><br><span class="line">解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [0,1,0,3,2,3]</span><br><span class="line">输出：4</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [7,7,7,7,7,7,7]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>

<p> <strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 2500</code></li>
<li><code>-104 &lt;= nums[i] &lt;= 104</code></li>
</ul>
<p>定义 dp[i] 为考虑前 i 个元素，以第 i 个数字结尾的最长上升子序列长度，<strong>nums[i] 必须被选择</strong>。</p>
<p>从小到大计算 dp 数组的值，在计算 dp[i] 之前，我们已经计算出 dp[0 … i - 1]的值，状态转移方程为：<br>$$<br>dp[i] = max(dp[j]) + 1, 其中 0 \leq j&lt;i 且nums[j] &lt; nums[i]<br>$$<br>即考虑往 dp[0 … i - 1]中的最长上升子序列后面再加一个 nums[i]，此时 nums[i]必须大于前面的最长子序列中的最后一个元素，假设我们选择最长上升子序列 dp[j]，nums[i] 就必须大于 nums[j]。</p>
<p>最后整个数组的最长上升子序列即为所有 dp[i] 中的最大值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">int</span> maxLen = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            dp[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//尝试在dp[0 ... i-1]中找一个最长递增子序列</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] &gt; nums[j])&#123;</span><br><span class="line">                    dp[i] = Math.max(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                maxLen = Math.max(maxLen, dp[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxLen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度O(n^2)</li>
<li>空间复杂度O(n)</li>
</ul>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode Medium</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>正则表达式匹配</title>
    <url>/2020/07/01/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D/</url>
    <content><![CDATA[<h4 id="10-正则表达式匹配"><a href="#10-正则表达式匹配" class="headerlink" title="10. 正则表达式匹配"></a><a href="https://leetcode-cn.com/problems/regular-expression-matching/" target="_blank" rel="noopener">10. 正则表达式匹配</a></h4><p>给你一个字符串 <code>s</code> 和一个字符规律 <code>p</code>，请你来实现一个支持 <code>&#39;.&#39;</code> 和 <code>&#39;*&#39;</code> 的正则表达式匹配。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#39;.&#39; 匹配任意单个字符</span><br><span class="line">&#39;*&#39; 匹配零个或多个前面的那一个元素</span><br></pre></td></tr></table></figure>

<p>所谓匹配，是要涵盖 <strong>整个</strong> 字符串 <code>s</code>的，而不是部分字符串。</p>
 <a id="more"></a>

<p><strong>说明:</strong></p>
<ul>
<li><code>s</code> 可能为空，且只包含从 <code>a-z</code> 的小写字母。</li>
<li><code>p</code> 可能为空，且只包含从 <code>a-z</code> 的小写字母，以及字符 <code>.</code> 和 <code>*</code>。</li>
</ul>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">s &#x3D; &quot;aa&quot;</span><br><span class="line">p &#x3D; &quot;a&quot;</span><br><span class="line">输出: false</span><br><span class="line">解释: &quot;a&quot; 无法匹配 &quot;aa&quot; 整个字符串。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">s &#x3D; &quot;aa&quot;</span><br><span class="line">p &#x3D; &quot;a*&quot;</span><br><span class="line">输出: true</span><br><span class="line">解释: 因为 &#39;*&#39; 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 &#39;a&#39;。因此，字符串 &quot;aa&quot; 可被视为 &#39;a&#39; 重复了一次。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">s &#x3D; &quot;ab&quot;</span><br><span class="line">p &#x3D; &quot;.*&quot;</span><br><span class="line">输出: true</span><br><span class="line">解释: &quot;.*&quot; 表示可匹配零个或多个（&#39;*&#39;）任意字符（&#39;.&#39;）。</span><br></pre></td></tr></table></figure>

<p><strong>示例 4:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">s &#x3D; &quot;aab&quot;</span><br><span class="line">p &#x3D; &quot;c*a*b&quot;</span><br><span class="line">输出: true</span><br><span class="line">解释: 因为 &#39;*&#39; 表示零个或多个，这里 &#39;c&#39; 为 0 个, &#39;a&#39; 被重复一次。因此可以匹配字符串 &quot;aab&quot;。</span><br></pre></td></tr></table></figure>

<p><strong>示例 5:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">s &#x3D; &quot;mississippi&quot;</span><br><span class="line">p &#x3D; &quot;mis*is*p*.&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>

<p>我们每次从字符串  p 中取出一个字符或者字符 + 星号的组合，并在 s 中进行匹配。对于 p 中的一个字符，它只能匹配 s 中的一个字符；对于字符和星号的组合，它可以在 s 中匹配任意个字符。因此，我们考虑使用动态规划，对匹配的方案进行枚举。</p>
<p>我们使用 <code>f[i][j]</code> 表示 s 的前 i 个字符与 p 中的前 j 个字符是否能够匹配。在进行状态转移时，我们考虑 p 的第 j 个字符的匹配情况：</p>
<ul>
<li>如果 p 的第 j 个字符是一个小写字母，那么必须在 s 中匹配一个相同的小写字母即：</li>
</ul>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/ag1jy63GdvwDWB2.png" alt="image-20200620105517136"></p>
<p>如果 s 的第 i 个字符与 p 的第 j 个字符不同则返回 false，如果它们相同，则匹配结果等于两个字符串前面部分匹配的结果</p>
<ul>
<li><p>如果 p 的第 j 个字符是 <code>*</code> ，那么就表示我们可以对 p 的 <code>j-1</code> 个字符匹配任意次。在匹配 0 次的情况下：<code>f[i][j] = f[i][j-2]</code> （直接丢弃这个字母加星号的组合）；在匹配 1 次的情况下：<code>f[i][j] = f[i-1][j-2], if s[i] = p[j-1]</code>；在匹配 2 次的情况下：<code>f[i][j] = f[i-2][j-2], if s[i-1] = s[i] = p[j-1]</code>；在匹配 3 次的情况下：<code>f[i][j] = f[i-3][j-2], if s[i-2] = s[i-1] = s[i] = p[j-1]</code>……</p>
<p>仔细思考，字母 + 星号只有两种情况：</p>
<ul>
<li>匹配 s 末尾的一个字符，将该字符扔掉，该组合继续匹配</li>
<li>不匹配字符，将组合扔掉，不再进行匹配</li>
</ul>
</li>
</ul>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/PEuicjdpZ3bofqg.png" alt="image-20200620111004440"></p>
<p><code>f[i][j] = f[i-1][j], if s[i] = p[j-1]</code> 代表扔掉 s 末尾的一个字符，继续匹配；<code>f[i][j] = f[i][j-2], if s[i] = p[j-1]</code>代表扔掉组合，不再匹配。</p>
<p>最终的状态转移方程如下：</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/35y2B8oDbgKqvL1.png" alt="image-20200620111757955"><br>字符串的字符下标是从 0 开始的，在实现上面的状态转移方程时，需要注意状态中每一维下标与实际字符下标的对应关系。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = s.length();</span><br><span class="line">        <span class="keyword">int</span> n = p.length();</span><br><span class="line">		<span class="comment">//初试化 dp 数组，两个字符串为空时，匹配成功</span></span><br><span class="line">        <span class="keyword">boolean</span>[][] f = <span class="keyword">new</span> <span class="keyword">boolean</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; i++)&#123;</span><br><span class="line">            <span class="comment">//s 为空，p 不为空情况下，f[0] 全为false</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">                <span class="comment">// p[j] 为 * 号</span></span><br><span class="line">                <span class="keyword">if</span>(p.charAt(j - <span class="number">1</span>) == <span class="string">'*'</span>)&#123;</span><br><span class="line">                    <span class="comment">// s[i] == p[j-1] ??? 能否匹配字母+星号组合中的字母</span></span><br><span class="line">                    <span class="keyword">if</span>(matches(s, p, i, j - <span class="number">1</span>))&#123;</span><br><span class="line">                        f[i][j] = f[i][j - <span class="number">2</span>] || f[i - <span class="number">1</span>][j];</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="comment">//丢弃组合</span></span><br><span class="line">                        f[i][j] = f[i][j - <span class="number">2</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;<span class="comment">// p[j] 不为 * 号</span></span><br><span class="line">                    <span class="keyword">if</span>(matches(s, p, i, j))&#123;</span><br><span class="line">                        f[i][j] = f[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//判断s[i - 1] 和 p[j - 1]是否相等</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(String s, String p, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(p.charAt(j - <span class="number">1</span>) == <span class="string">'.'</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> s.charAt(i - <span class="number">1</span>) == p.charAt(j - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度 O(mn)，空间复杂度O(mn)。</p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode Medium</tag>
        <tag>字符串</tag>
        <tag>动态规划</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>栈的压入、弹出序列</title>
    <url>/2021/05/26/%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%E3%80%81%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<h4 id="剑指-Offer-31-栈的压入、弹出序列"><a href="#剑指-Offer-31-栈的压入、弹出序列" class="headerlink" title="剑指 Offer 31. 栈的压入、弹出序列"></a><a href="https://leetcode-cn.com/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/" target="_blank" rel="noopener">剑指 Offer 31. 栈的压入、弹出序列</a></h4><p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如，序列 {1,2,3,4,5} 是某栈的压栈序列，序列 {4,5,3,2,1} 是该压栈序列对应的一个弹出序列，但 {4,3,5,1,2} 就不可能是该压栈序列的弹出序列。</p>
 <a id="more"></a>

<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：pushed &#x3D; [1,2,3,4,5], popped &#x3D; [4,5,3,2,1]</span><br><span class="line">输出：true</span><br><span class="line">解释：我们可以按以下顺序执行：</span><br><span class="line">push(1), push(2), push(3), push(4), pop() -&gt; 4,</span><br><span class="line">push(5), pop() -&gt; 5, pop() -&gt; 3, pop() -&gt; 2, pop() -&gt; 1</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：pushed &#x3D; [1,2,3,4,5], popped &#x3D; [4,3,5,1,2]</span><br><span class="line">输出：false</span><br><span class="line">解释：1 不能在 2 之前弹出。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ol>
<li><code>0 &lt;= pushed.length == popped.length &lt;= 1000</code></li>
<li><code>0 &lt;= pushed[i], popped[i] &lt; 1000</code></li>
<li><code>pushed</code> 是 <code>popped</code> 的排列。</li>
</ol>
<p><strong>方法一：栈</strong></p>
<p>我们可以模拟做类似题时的思路：如果栈顶数字不等于当前出栈数字，将入栈序列中的数字依次加入栈中，直到栈顶元素与当前出栈数字相等。</p>
<p>以示例 1 为例，idx1 指向压入序列，idx2 指向弹出序列。</p>
<ol>
<li>栈为空，先将 1 压入栈中</li>
<li>栈顶数字 1 与数字 4 不相等，继续将 2 压入栈中</li>
<li>栈顶数字 2 与数字 4 不相等，继续将 3 压入栈中</li>
<li>栈顶数字 3 与数字 4 不相等，继续将 4 压入栈中</li>
<li>栈顶数字 4 与数字 4 相等，</li>
<li>栈顶数字 3 与数字 4 不相等，继续将 4 压入栈中</li>
<li>栈顶数字 5 与数字 5 相等，将 idx1 和 idx2 后移</li>
<li>数字 3 与栈顶数字 3 相等，idx2 后移，弹出栈顶元素</li>
<li>数字 2 与栈顶数字 2 相等，idx2 后移，弹出栈顶元素</li>
<li>数字 1 与栈顶数字 1 相等，idx2 后移，弹出栈顶元素</li>
<li>此时栈为空，代表第二个序列是第一个序列的弹出序列，返回 true。</li>
</ol>
<p>如果出现栈顶元素与当前弹出数字不相同且 idx1 已经指向入栈序列末尾，返回 false。</p>
<p>下图可以辅助理解</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/1.jpg" alt="1"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validateStackSequences</span><span class="params">(<span class="keyword">int</span>[] pushed, <span class="keyword">int</span>[] popped)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pushed.length != popped.length)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> n = popped.length;</span><br><span class="line">        Deque&lt;Integer&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> idx1 = <span class="number">0</span>, idx2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(idx2 &lt; n)&#123;</span><br><span class="line">            <span class="comment">//栈为空或者栈顶元素不等于当前弹出数字，直接将当前数字加入栈中</span></span><br><span class="line">            <span class="keyword">while</span>(idx1 &lt; n &amp;&amp; (stack.isEmpty() || stack.peek() != popped[idx2]))&#123;</span><br><span class="line">                stack.push(pushed[idx1]);</span><br><span class="line">                ++idx1;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//栈顶元素等于当前弹出数字</span></span><br><span class="line">            <span class="keyword">if</span>(stack.peek() == popped[idx2])&#123;</span><br><span class="line">                ++idx2;</span><br><span class="line">                stack.pop();</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="comment">//栈顶元素不等于当前弹出数字，出栈序列与入栈序列不匹配</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度O(n)</li>
<li>空间复杂度O(n)</li>
</ul>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode Medium</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>比较含退格的字符串</title>
    <url>/2020/10/19/%E6%AF%94%E8%BE%83%E5%90%AB%E9%80%80%E6%A0%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<h4 id="844-比较含退格的字符串"><a href="#844-比较含退格的字符串" class="headerlink" title="844. 比较含退格的字符串"></a><a href="https://leetcode-cn.com/problems/backspace-string-compare/" target="_blank" rel="noopener">844. 比较含退格的字符串</a></h4><p>给定 <code>S</code> 和 <code>T</code> 两个字符串，当它们分别被输入到空白的文本编辑器后，判断二者是否相等，并返回结果。 <code>#</code> 代表退格字符。</p>
<p><strong>注意：</strong>如果对空文本输入退格字符，文本继续为空。</p>
 <a id="more"></a>

<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：S &#x3D; &quot;ab#c&quot;, T &#x3D; &quot;ad#c&quot;</span><br><span class="line">输出：true</span><br><span class="line">解释：S 和 T 都会变成 “ac”。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：S &#x3D; &quot;ab##&quot;, T &#x3D; &quot;c#d#&quot;</span><br><span class="line">输出：true</span><br><span class="line">解释：S 和 T 都会变成 “”。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：S &#x3D; &quot;a##c&quot;, T &#x3D; &quot;#a#c&quot;</span><br><span class="line">输出：true</span><br><span class="line">解释：S 和 T 都会变成 “c”。</span><br></pre></td></tr></table></figure>

<p><strong>示例 4：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：S &#x3D; &quot;a#c&quot;, T &#x3D; &quot;b&quot;</span><br><span class="line">输出：false</span><br><span class="line">解释：S 会变成 “c”，但 T 仍然是 “b”。</span><br></pre></td></tr></table></figure>

<p> <strong>提示：</strong></p>
<ol>
<li><p><code>1 &lt;= S.length &lt;= 200</code></p>
</li>
<li><p><code>1 &lt;= T.length &lt;= 200</code></p>
</li>
<li><p><code>S</code> 和 <code>T</code> 只含有小写字母以及字符 <code>&#39;#&#39;</code>。</p>
<p><strong>进阶：</strong></p>
</li>
</ol>
<ul>
<li>你可以用 <code>O(N)</code> 的时间复杂度和 <code>O(1)</code> 的空间复杂度解决该问题吗？</li>
</ul>
<p>一个字符是否被删掉取决于它后面是否有#号，我们逆序遍历字符串，就可以立即确定当前字符是否会被删掉。</p>
<p>使用 s 记录字符串 S 中 # 号的数量，从后往前遍历每个字符：</p>
<ul>
<li>当前字符为 # 号，我们要多删除一个字符，s 加一；</li>
<li>当前字符不是 # 号：<ul>
<li>若 s 大于 0 ，则删去当前字符；</li>
<li>若 s 等于 0 ，当前字符不需要删除。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">backspaceCompare</span><span class="params">(String S, String T)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> s = <span class="number">0</span>, t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = S.length() - <span class="number">1</span>, j = T.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span>;)&#123;</span><br><span class="line">            <span class="comment">//去掉 S 尾部需要删除的字符</span></span><br><span class="line">            <span class="keyword">while</span>(i &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(S.charAt(i) == <span class="string">'#'</span>)&#123;</span><br><span class="line">                    ++s;</span><br><span class="line">                    --i;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    --s;</span><br><span class="line">                    --i;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">			<span class="comment">//去掉 T 尾部需要删除的字符</span></span><br><span class="line">            <span class="keyword">while</span>(j &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(T.charAt(j) == <span class="string">'#'</span>)&#123;</span><br><span class="line">                    ++t;</span><br><span class="line">                    --j;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(t &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    --t;</span><br><span class="line">                    --j;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">			</span><br><span class="line">            <span class="keyword">if</span>(i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//判断两个字符是否相等</span></span><br><span class="line">                <span class="keyword">if</span>(S.charAt(i) != T.charAt(j))&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//有一个字符串已经遍历完</span></span><br><span class="line">                <span class="keyword">if</span>(i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            --i;</span><br><span class="line">            --j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度O(n)</li>
<li>空间复杂度O(1)</li>
</ul>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode Easy</tag>
        <tag>字符串</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>求1+2+…+n</title>
    <url>/2020/06/02/%E6%B1%821+2+%E2%80%A6+n/</url>
    <content><![CDATA[<h4 id="面试题64-求1-2-…-n"><a href="#面试题64-求1-2-…-n" class="headerlink" title="面试题64. 求1+2+…+n"></a><a href="https://leetcode-cn.com/problems/qiu-12n-lcof/" target="_blank" rel="noopener">面试题64. 求1+2+…+n</a></h4><p>求 <code>1+2+...+n</code> ，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。</p>
<a id="more"></a>

<p> <strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: n &#x3D; 3</span><br><span class="line">输出: 6</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: n &#x3D; 9</span><br><span class="line">输出: 45</span><br></pre></td></tr></table></figure>

<p><strong>限制：</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 10000</code></li>
</ul>
<p>对于此题我们首先想到等差数列求和公式：<code>(1 + n) * n / 2</code>，很可惜，我们并不能使用乘除法。我们想到使用递归来实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumNums</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n == <span class="number">1</span> ? <span class="number">1</span> : n + sumNums(n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们使用了三目运算符，也不符合题目要求，这里我们使用 &amp;&amp; 短路与的知识，例如 A &amp;&amp; B，当逻辑结果 A 为false 时，B 不会被执行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumNums</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> flag = n &gt; <span class="number">0</span> &amp;&amp; (n += sumNums(n - <span class="number">1</span>)) &gt; <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们还可以使用异常机制来实现递归：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumNums</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> arr[n];</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            <span class="keyword">return</span> n + sumNums(n - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度 O(n)，空间复杂度O(n)。</p>
<p>我们还可以模拟乘法来解决这个问题，利用加法和移位来模拟乘法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumNums</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mul(n, n+<span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">mul</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(; b != <span class="number">0</span>; b &gt;&gt;= <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>((b &amp; <span class="number">1</span>) == <span class="number">1</span>)&#123;</span><br><span class="line">                ans += a;</span><br><span class="line">            &#125;</span><br><span class="line">            a &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们使用了循环不符合要求，但我们注意到 n 最大为 10000，只用 14 位二进制就可表示，我们直接将循环代码写 14 次。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumNums</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>, a = n, b = n + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">        flag = ((b &amp; <span class="number">1</span>) == <span class="number">1</span>) &amp;&amp; (ans += a) &gt; <span class="number">0</span>;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        a &lt;&lt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        flag = ((b &amp; <span class="number">1</span>) == <span class="number">1</span>) &amp;&amp; (ans += a) &gt; <span class="number">0</span>;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        a &lt;&lt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        flag = ((b &amp; <span class="number">1</span>) == <span class="number">1</span>) &amp;&amp; (ans += a) &gt; <span class="number">0</span>;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        a &lt;&lt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        flag = ((b &amp; <span class="number">1</span>) == <span class="number">1</span>) &amp;&amp; (ans += a) &gt; <span class="number">0</span>;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        a &lt;&lt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        flag = ((b &amp; <span class="number">1</span>) == <span class="number">1</span>) &amp;&amp; (ans += a) &gt; <span class="number">0</span>;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        a &lt;&lt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        flag = ((b &amp; <span class="number">1</span>) == <span class="number">1</span>) &amp;&amp; (ans += a) &gt; <span class="number">0</span>;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        a &lt;&lt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        flag = ((b &amp; <span class="number">1</span>) == <span class="number">1</span>) &amp;&amp; (ans += a) &gt; <span class="number">0</span>;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        a &lt;&lt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        flag = ((b &amp; <span class="number">1</span>) == <span class="number">1</span>) &amp;&amp; (ans += a) &gt; <span class="number">0</span>;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        a &lt;&lt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        flag = ((b &amp; <span class="number">1</span>) == <span class="number">1</span>) &amp;&amp; (ans += a) &gt; <span class="number">0</span>;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        a &lt;&lt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        flag = ((b &amp; <span class="number">1</span>) == <span class="number">1</span>) &amp;&amp; (ans += a) &gt; <span class="number">0</span>;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        a &lt;&lt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        flag = ((b &amp; <span class="number">1</span>) == <span class="number">1</span>) &amp;&amp; (ans += a) &gt; <span class="number">0</span>;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        a &lt;&lt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        flag = ((b &amp; <span class="number">1</span>) == <span class="number">1</span>) &amp;&amp; (ans += a) &gt; <span class="number">0</span>;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        a &lt;&lt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        flag = ((b &amp; <span class="number">1</span>) == <span class="number">1</span>) &amp;&amp; (ans += a) &gt; <span class="number">0</span>;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        a &lt;&lt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        flag = ((b &amp; <span class="number">1</span>) == <span class="number">1</span>) &amp;&amp; (ans += a) &gt; <span class="number">0</span>;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        a &lt;&lt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度 O(log n)，空间复杂度O(1)。</p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>Leetcode Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>汉明距离</title>
    <url>/2020/08/23/%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB/</url>
    <content><![CDATA[<h4 id="461-汉明距离"><a href="#461-汉明距离" class="headerlink" title="461. 汉明距离"></a><a href="https://leetcode-cn.com/problems/hamming-distance/" target="_blank" rel="noopener">461. 汉明距离</a></h4><p>两个整数之间的<a href="https://baike.baidu.com/item/汉明距离" target="_blank" rel="noopener">汉明距离</a>指的是这两个数字对应二进制位不同的位置的数目。</p>
<p>给出两个整数 <code>x</code> 和 <code>y</code>，计算它们之间的汉明距离。</p>
<a id="more"></a>

<p><strong>注意：</strong><br>0 ≤ <code>x</code>, <code>y</code> &lt; 231.</p>
<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: x &#x3D; 1, y &#x3D; 4</span><br><span class="line"></span><br><span class="line">输出: 2</span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line">1   (0 0 0 1)</span><br><span class="line">4   (0 1 0 0)</span><br><span class="line">       ↑   ↑</span><br><span class="line"></span><br><span class="line">上面的箭头指出了对应二进制位不同的位置。</span><br></pre></td></tr></table></figure>

<p>我们知道异或操作：不同得 1 ，相同得 0。我们对 x 和 y 做一次异或操作，得到的数的二进制位中的 1 的个数就是 x 和 y 的汉明距离。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x &#x3D; 1, y &#x3D; 4</span><br><span class="line">1       (0 0 0 1)</span><br><span class="line">4       (0 1 0 0)</span><br><span class="line">1 xor 4 (0 1 0 1)  &quot;1&quot; 的个数为 2，即汉明距离为 2</span><br></pre></td></tr></table></figure>

<p><strong>方法一：位移</strong></p>
<p>我们要求一个数字二进制位中 “1” 的个数，可以不断将数字右移，统计最后一位为 1 的个数，直到数字为 0。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingDistance</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = x ^ y, count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(m != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(m % <span class="number">2</span> == <span class="number">1</span>)&#123;</span><br><span class="line">                ++count;</span><br><span class="line">            &#125;</span><br><span class="line">            m &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度O(1)，空间复杂度O(1)。</p>
<p><strong>方法二：布赖恩·克尼根算法</strong></p>
<p>「Brian Kernighan 算法」，用于清除二进制串中最右边的 1。</p>
<p>我们每次对 n 和 n - 1进行按位与操作后，n 中最右边的 1 会被抹去变为 0 。</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20200823091337544.png" alt="image-20200823091337544"></p>
<p>我们不断地将数字的最右边的 “1” 变为 0 ，同时统计 1 的个数，直到数字为 0 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingDistance</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = x ^ y, count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(m != <span class="number">0</span>)&#123;</span><br><span class="line">            m = m &amp; (m - <span class="number">1</span>);</span><br><span class="line">            ++count;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度O(1)，空间复杂度O(1)。</p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode Easy</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>爬楼梯</title>
    <url>/2020/07/01/%E7%88%AC%E6%A5%BC%E6%A2%AF/</url>
    <content><![CDATA[<h4 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70. 爬楼梯"></a><a href="https://leetcode-cn.com/problems/climbing-stairs/" target="_blank" rel="noopener">70. 爬楼梯</a></h4><p>假设你正在爬楼梯。需要 <em>n</em> 阶你才能到达楼顶。</p>
<p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p>
<p><strong>注意：</strong>给定 <em>n</em> 是一个正整数。</p>
 <a id="more"></a>

<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入： 2</span><br><span class="line">输出： 2</span><br><span class="line">解释： 有两种方法可以爬到楼顶。</span><br><span class="line">1.  1 阶 + 1 阶</span><br><span class="line">2.  2 阶</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入： 3</span><br><span class="line">输出： 3</span><br><span class="line">解释： 有三种方法可以爬到楼顶。</span><br><span class="line">1.  1 阶 + 1 阶 + 1 阶</span><br><span class="line">2.  1 阶 + 2 阶</span><br><span class="line">3.  2 阶 + 1 阶</span><br></pre></td></tr></table></figure>

<ol>
<li>有一个台阶只有一种选择；</li>
<li>有两个台阶有 2 阶、1阶 + 1阶两种选择；</li>
<li>有三个台阶有也有两种选择：从第二个台阶爬一阶，从第一个台阶一次爬两阶。爬上第二个台阶有两种方法，故通过第二个台阶到第三个台阶有两种方法，加上从第一个台阶到第三个台阶有一种方法故有三种方法。</li>
</ol>
<p>设 f(n) 为爬上第 n 个台阶的方法总数，则有 f(n) = f(n-1) + f(n-2)；第 n 个台阶的方法数由第 n-1 个台阶和第 n-2 个台阶的方法数组成，即可以从 n-1 个台阶爬一个台阶到第 n 阶和从第 n-2 个台阶爬两个台阶到第 n 个台阶。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> first = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> second = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> third = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span> ;i &lt; n ; ++i)&#123;</span><br><span class="line">            third = first + second;</span><br><span class="line">            first = second;</span><br><span class="line">            second = third;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> third;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度O(n)，空间复杂度O(1)。</p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode Easy</tag>
        <tag>动态规划</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>爱生气的书店老板</title>
    <url>/2021/02/23/%E7%88%B1%E7%94%9F%E6%B0%94%E7%9A%84%E4%B9%A6%E5%BA%97%E8%80%81%E6%9D%BF/</url>
    <content><![CDATA[<h4 id="1052-爱生气的书店老板"><a href="#1052-爱生气的书店老板" class="headerlink" title="1052. 爱生气的书店老板"></a><a href="https://leetcode-cn.com/problems/grumpy-bookstore-owner/" target="_blank" rel="noopener">1052. 爱生气的书店老板</a></h4><p>今天，书店老板有一家店打算试营业 <code>customers.length</code> 分钟。每分钟都有一些顾客（<code>customers[i]</code>）会进入书店，所有这些顾客都会在那一分钟结束后离开。</p>
<p>在某些时候，书店老板会生气。 如果书店老板在第 <code>i</code> 分钟生气，那么 <code>grumpy[i] = 1</code>，否则 <code>grumpy[i] = 0</code>。 当书店老板生气时，那一分钟的顾客就会不满意，不生气则他们是满意的。</p>
<p>书店老板知道一个秘密技巧，能抑制自己的情绪，可以让自己连续 <code>X</code> 分钟不生气，但却只能使用一次。</p>
<p>请你返回这一天营业下来，最多有多少客户能够感到满意的数量。<br> <a id="more"></a></p>
<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：customers &#x3D; [1,0,1,2,1,1,7,5], grumpy &#x3D; [0,1,0,1,0,1,0,1], X &#x3D; 3</span><br><span class="line">输出：16</span><br><span class="line">解释：</span><br><span class="line">书店老板在最后 3 分钟保持冷静。</span><br><span class="line">感到满意的最大客户数量 &#x3D; 1 + 1 + 1 + 1 + 7 + 5 &#x3D; 16.</span><br></pre></td></tr></table></figure>

<p> <strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= X &lt;= customers.length == grumpy.length &lt;= 20000</code></li>
<li><code>0 &lt;= customers[i] &lt;= 1000</code></li>
<li><code>0 &lt;= grumpy[i] &lt;= 1</code></li>
</ul>
<p><strong>方法一：滑动窗口</strong></p>
<p>首先我们将确定满意的顾客加起来，然后使用滑动窗口计算可以额外增加的最大满意数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSatisfied</span><span class="params">(<span class="keyword">int</span>[] customers, <span class="keyword">int</span>[] grumpy, <span class="keyword">int</span> X)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//统计确定满意的客户</span></span><br><span class="line">        <span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; customers.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(grumpy[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                total += customers[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//统计第一个窗口中额外增加的满意数</span></span><br><span class="line">        <span class="keyword">int</span> increase = <span class="number">0</span>, maxIncrease = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; X; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(grumpy[i] == <span class="number">1</span>)&#123;</span><br><span class="line">                increase += customers[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        maxIncrease = increase;</span><br><span class="line">		<span class="comment">//使用滑动窗口计算最大满意数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = X; i &lt; customers.length; i++)&#123;</span><br><span class="line">            increase = increase - grumpy[i - X] * customers[i - X] + grumpy[i] * customers[i];   </span><br><span class="line">            maxIncrease = Math.max(increase, maxIncrease);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> total + maxIncrease;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度O(n)</li>
<li>空间复杂度O(1)</li>
</ul>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode Medium</tag>
        <tag>滑动窗口</tag>
      </tags>
  </entry>
  <entry>
    <title>每日温度</title>
    <url>/2020/07/01/%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6/</url>
    <content><![CDATA[<h4 id="739-每日温度"><a href="#739-每日温度" class="headerlink" title="739. 每日温度"></a><a href="https://leetcode-cn.com/problems/daily-temperatures/" target="_blank" rel="noopener">739. 每日温度</a></h4><p>请根据每日 <code>气温</code> 列表，重新生成一个列表。对应位置的输出为：要想观测到更高的气温，至少需要等待的天数。如果气温在这之后都不会升高，请在该位置用 <code>0</code> 来代替。</p>
 <a id="more"></a>

<p>例如，给定一个列表 <code>temperatures = [73, 74, 75, 71, 69, 72, 76, 73]</code>，你的输出应该是 <code>[1, 1, 4, 2, 1, 1, 0, 0]</code>。</p>
<p><strong>提示：</strong><code>气温</code> 列表长度的范围是 <code>[1, 30000]</code>。每个气温的值的均为华氏度，都是在 <code>[30, 100]</code> 范围内的整数。</p>
<p>此题就是找出每一个数字后面出现的第一个比它大的数字的下标，可以维护一个存储下标的单调栈，从栈底到栈顶的下标对应的温度列表中的温度依次递减。如果一个下标在单调栈里，则代表未找到下一个温度更高的下标。</p>
<p>正向遍历温度列表。对于温度列表中的每个元素 T[i]，如果栈为空，则直接将 i 进栈，如果栈不为空，则比较栈顶元素 prevIndex 对应的温度 T[prevIndex] 和当前温度 T[i]，如果 T[i] &gt; T[prevIndex]，则将 prevIndex 移除，并将 prevIndex 对应的等待天数赋为 i - prevIndex，重复上述操作直到栈为空或者栈顶元素对应的温度小于等于当前温度，然后将 i 进栈。</p>
<p>由于单调栈满足从栈底到栈顶元素对应的温度递减，因此每次有元素进栈时，会将温度更低的元素全部移除，并更新出栈元素对应的等待天数，这样可以确保等待天数一定是最小的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] dailyTemperatures(<span class="keyword">int</span>[] T) &#123;</span><br><span class="line">        <span class="keyword">int</span> len = T.length;</span><br><span class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        Deque&lt;Integer&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> temperature = T[i];</span><br><span class="line">            <span class="keyword">while</span>(!stack.isEmpty() &amp;&amp; temperature &gt; T[stack.peek()])&#123;</span><br><span class="line">                <span class="keyword">int</span> prevIndex = stack.pop();</span><br><span class="line">                ans[prevIndex] = i - prevIndex;</span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度 O(n)，空间复杂度O(n)。</p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode Medium</tag>
        <tag>数组</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>环形链表II</title>
    <url>/2020/10/10/%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II/</url>
    <content><![CDATA[<h4 id="142-环形链表-II"><a href="#142-环形链表-II" class="headerlink" title="142. 环形链表 II"></a><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/" target="_blank" rel="noopener">142. 环形链表 II</a></h4><p>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 <code>null</code>。</p>
<p>为了表示给定链表中的环，我们使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 <code>pos</code> 是 <code>-1</code>，则在该链表中没有环。</p>
<p><strong>说明：</strong>不允许修改给定的链表。</p>
 <a id="more"></a>

<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：head &#x3D; [3,2,0,-4], pos &#x3D; 1</span><br><span class="line">输出：tail connects to node index 1</span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节点。</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20201010085610758.png" alt="image-20201010085610758"></p>
<p><strong>方法一：快慢指针</strong></p>
<p>在环形链表中，我们使用快慢指针，快慢指针相遇则链表中有环。我们具体分析相遇时的情况：</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20201010090508224.png" alt="image-20201010090508224"></p>
<p>假设相遇的点在图中红点处，快慢指针在快指针走了 n 圈后相遇，快指针走过的总路程为 <code>a + n(b + c) + b</code>，慢指针走过的总路程为<code>a + b</code>，由于快指针走过的路程是慢指针走过路程的两倍，故<code>a + n(b + c) + b == 2(a + b)</code>，得到<code>a = (n - 1)(b + c) + c</code>，到这里我们发现从相遇点到入环点的距离加上 n - 1 圈的环长，恰好等于从链表头部到入环点的位置。</p>
<p>在快慢指针相遇时，让另外一个指针 ptr 从链表头开始向后走，同时让慢指针在环中走，当两个指针相遇时，ptr 指向的结点就是环的入口，此时慢指针走过的路程为<code>(n - 1)(b + c) + c</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">detectCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode slow = head, fast = head;</span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(slow == fast)&#123;</span><br><span class="line">                ListNode ptr = head;</span><br><span class="line">                <span class="keyword">while</span>(ptr != slow)&#123;</span><br><span class="line">                    ptr = ptr.next;</span><br><span class="line">                    slow = slow.next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> ptr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度O(n)</li>
<li>空间复杂度O(1)</li>
</ul>
<p><strong>方法二：哈希表</strong></p>
<p>使用一个哈希表存储已经访问过的结点，发现当前访问过的结点存在于哈希表，返回当前结点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">detectCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode pos = head;</span><br><span class="line">        Set&lt;ListNode&gt; visited = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(pos != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(visited.contains(pos))&#123;</span><br><span class="line">                <span class="keyword">return</span> pos;</span><br><span class="line">            &#125;</span><br><span class="line">            visited.add(pos);</span><br><span class="line">            pos = pos.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度O(n)</li>
<li>空间复杂度O(n)</li>
</ul>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>链表</tag>
        <tag>Leetcode Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>汉明距离总和</title>
    <url>/2021/05/28/%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB%E6%80%BB%E5%92%8C/</url>
    <content><![CDATA[<h4 id="477-汉明距离总和"><a href="#477-汉明距离总和" class="headerlink" title="477. 汉明距离总和"></a><a href="https://leetcode-cn.com/problems/total-hamming-distance/" target="_blank" rel="noopener">477. 汉明距离总和</a></h4><p>两个整数的 <a href="https://baike.baidu.com/item/汉明距离/475174?fr=aladdin" target="_blank" rel="noopener">汉明距离</a> 指的是这两个数字的二进制数对应位不同的数量。</p>
<p>计算一个数组中，任意两个数之间汉明距离的总和。</p>
<a id="more"></a>

<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 4, 14, 2</span><br><span class="line"></span><br><span class="line">输出: 6</span><br><span class="line"></span><br><span class="line">解释: 在二进制表示中，4表示为0100，14表示为1110，2表示为0010。（这样表示是为了体现后四位之间关系）</span><br><span class="line">所以答案为：</span><br><span class="line">HammingDistance(4, 14) + HammingDistance(4, 2) + HammingDistance(14, 2) &#x3D; 2 + 2 + 2 &#x3D; 6.</span><br></pre></td></tr></table></figure>

<p><strong>注意:</strong></p>
<ol>
<li>数组中元素的范围为从 <code>0</code>到 <code>10^9</code>。</li>
<li>数组的长度不超过 <code>10^4</code>。</li>
</ol>
<p><strong>方法一：逐位统计</strong></p>
<p>在计算汉明距离时，我们考虑的是同一比特位上的值是否不同，而不同比特位之间是互不影响的。</p>
<p>对于数组 nums 中的某个元素 val，若其二进制的第 i 位为 1，我们只需统计 nums 中有多少元素的第 i 位为 0 ，这样就就得到了 val 与其他元素在第 i 位上的汉明距离之和。</p>
<p>若长度为 n 的数组 nums 的所有元素二进制的第 i 位共有 c 个 1， n - c 个 0，这些元素在二进制第 i 位上的汉明距离位<code>c * (n - c)</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">totalHammingDistance</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">30</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">                c += (num &gt;&gt; i) &amp; <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ret += c * (n - c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度O(n * L)，n 为数组长度，L  = 30</li>
<li>空间复杂度O(1)</li>
</ul>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode Medium</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>电话号码的字母组合</title>
    <url>/2020/08/26/%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/</url>
    <content><![CDATA[<h4 id="17-电话号码的字母组合"><a href="#17-电话号码的字母组合" class="headerlink" title="17. 电话号码的字母组合"></a><a href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/" target="_blank" rel="noopener">17. 电话号码的字母组合</a></h4><p>给定一个仅包含数字 <code>2-9</code> 的字符串，返回所有它能表示的字母组合。</p>
<p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p>
<a id="more"></a>

<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20200826085317695.png" alt="image-20200826085317695"></p>
<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：&quot;23&quot;</span><br><span class="line">输出：[&quot;ad&quot;, &quot;ae&quot;, &quot;af&quot;, &quot;bd&quot;, &quot;be&quot;, &quot;bf&quot;, &quot;cd&quot;, &quot;ce&quot;, &quot;cf&quot;].</span><br></pre></td></tr></table></figure>

<p><strong>说明:</strong><br>尽管上面的答案是按字典序排列的，但是你可以任意选择答案输出的顺序。</p>
<p><strong>方法一：回溯</strong></p>
<p>首先使用哈希表存储每个数字对应的所有可能的字母，然后进行回溯操作。</p>
<p>回溯过程中维护一个字符串，表示已有的字母排列。该字符串初始为空，每次取电话号码的一位数字，从哈希表中获取该数字对应的所有字母，将其中一个字母插入到已有字母的后面，然后继续处理电话号码的后一位数字，直到处理完所有数字，得到一个完整的字母排列。然后进行回退操作，遍历其余的字母排列。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">letterCombinations</span><span class="params">(String digits)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; combinations = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(digits.length() == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> combinations;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Map&lt;Character, String&gt; numMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        numMap.put(<span class="string">'2'</span>, <span class="string">"abc"</span>);</span><br><span class="line">        numMap.put(<span class="string">'3'</span>, <span class="string">"def"</span>);</span><br><span class="line">        numMap.put(<span class="string">'4'</span>, <span class="string">"ghi"</span>);</span><br><span class="line">        numMap.put(<span class="string">'5'</span>, <span class="string">"jkl"</span>);</span><br><span class="line">        numMap.put(<span class="string">'6'</span>, <span class="string">"mno"</span>);</span><br><span class="line">        numMap.put(<span class="string">'7'</span>, <span class="string">"pqrs"</span>);</span><br><span class="line">        numMap.put(<span class="string">'8'</span>, <span class="string">"tuv"</span>);</span><br><span class="line">        numMap.put(<span class="string">'9'</span>, <span class="string">"wxyz"</span>);</span><br><span class="line"></span><br><span class="line">        backtrack(combinations, numMap, digits, <span class="number">0</span>, <span class="keyword">new</span> StringBuffer());</span><br><span class="line">        <span class="keyword">return</span> combinations;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(List&lt;String&gt; combinations, Map&lt;Character, String&gt; numMap, String digits, <span class="keyword">int</span> index, StringBuffer combination)</span></span>&#123;</span><br><span class="line">        <span class="comment">//是否遍历完 digits 中所有数字</span></span><br><span class="line">        <span class="keyword">if</span>(index == digits.length())&#123;</span><br><span class="line">            combinations.add(combination.toString());</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//获取数字对应的所有字符</span></span><br><span class="line">            <span class="keyword">char</span> c = digits.charAt(index);</span><br><span class="line">            String letters = numMap.get(c);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; letters.length(); i++)&#123;</span><br><span class="line">                <span class="comment">//取一个字母，并继续处理后一位数字</span></span><br><span class="line">                combination.append(letters.charAt(i));</span><br><span class="line">                backtrack(combinations, numMap, digits, index + <span class="number">1</span>, combination);</span><br><span class="line">                <span class="comment">//删除当前字母，并进行下一个循环</span></span><br><span class="line">                combination.deleteCharAt(index);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度O(3^m * 4^ n)，m 为对应三个字母的数字个数，n 为对应四个字母的数字个数。</p>
<p>空间复杂度O(m + n)，m 为对应三个字母的数字个数，n 为对应四个字母的数字个数。除返回值外，空间复杂度取决于哈希表及递归调用层数，递归调用层数最多为 m + n。</p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode Medium</tag>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>监控二叉树</title>
    <url>/2020/09/22/%E7%9B%91%E6%8E%A7%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h4 id="968-监控二叉树"><a href="#968-监控二叉树" class="headerlink" title="968. 监控二叉树"></a><a href="https://leetcode-cn.com/problems/binary-tree-cameras/" target="_blank" rel="noopener">968. 监控二叉树</a></h4><p>给定一个二叉树，我们在树的节点上安装摄像头。</p>
<p>节点上的每个摄影头都可以监视<strong>其父对象、自身及其直接子对象。</strong></p>
<p>计算监控树的所有节点所需的最小摄像头数量。</p>
 <a id="more"></a>

<p><strong>示例 1：</strong></p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20200922101835400.png" alt="image-20200922101835400"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[0,0,null,0,0]</span><br><span class="line">输出：1</span><br><span class="line">解释：如图所示，一台摄像头足以监控所有节点。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20200922102001569.png" alt="image-20200922102001569"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[0,0,null,0,null,0,null,null,0]</span><br><span class="line">输出：2</span><br><span class="line">解释：需要至少两个摄像头来监视树的所有节点。 上图显示了摄像头放置的有效位置之一。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ol>
<li>给定树的节点数的范围是 <code>[1, 1000]</code>。</li>
<li>每个节点的值都是 0。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minCameraCover</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//只有一个结点，为当前结点安装相机</span></span><br><span class="line">        <span class="keyword">if</span>(dfs(root) == <span class="number">0</span>)&#123;</span><br><span class="line">            ++ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 0: 待覆盖; 1: 已覆盖; 2: 已安装相机</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="comment">//结点为空表示已覆盖</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> l = dfs(root.left);</span><br><span class="line">        <span class="keyword">int</span> r = dfs(root.right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(l == <span class="number">0</span> || r == <span class="number">0</span>)&#123; <span class="comment">// 有任意一个子结点未覆盖就需要将当前结点安装相机</span></span><br><span class="line">            ans += <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(l == <span class="number">2</span> || r == <span class="number">2</span>)&#123; <span class="comment">// 任意一个结点安装了相机，当前结点为已覆盖</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//子结点都已覆盖，且都没有相机，当前结点由父节点来覆盖</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode Hard</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>盛最多水的容器</title>
    <url>/2020/04/17/%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/</url>
    <content><![CDATA[<h4 id="11-盛最多水的容器"><a href="#11-盛最多水的容器" class="headerlink" title="11. 盛最多水的容器"></a><a href="https://leetcode-cn.com/problems/container-with-most-water/" target="_blank" rel="noopener">11. 盛最多水的容器</a></h4><p>给你 <em>n</em> 个非负整数 <em>a</em>1，<em>a</em>2，…，<em>a</em>n，每个数代表坐标中的一个点 (<em>i</em>, <em>ai</em>) 。在坐标内画 <em>n</em> 条垂直线，垂直线 <em>i</em> 的两个端点分别为 (<em>i</em>, <em>ai</em>) 和 (<em>i</em>, 0)。找出其中的两条线，使得它们与 <em>x</em> 轴共同构成的容器可以容纳最多的水。</p>
<p><strong>说明：</strong>你不能倾斜容器，且 <em>n</em> 的值至少为 2。</p>
<a id="more"></a>

<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/23RAHzps9cYvGKC.jpg" alt=""></p>
<p>图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。</p>
<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[1,8,6,2,5,4,8,3,7]</span><br><span class="line">输出：49</span><br></pre></td></tr></table></figure>

<p>使用双指针。左指针为 i，右指针为 j 。水的容量为 (j - i) * min(i , j) 。我们需要维护一个容器的容量的最大值。我们需要找出最大的容量。此时需要向中间移动左右指针中比较小的那个值。证明：一般 i &lt; j ，容器的容量为  <code>min(height[i] , height[j])*(j-i)</code> , 如果我们将两个指针中的比较高的值向中间移动，那么得到的容量一定小于前面算出的容量（j 变小了，i 不变，两个边界最小值不变）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>, j=height.length-<span class="number">1</span>; i&lt;=j ;)&#123;</span><br><span class="line">            <span class="comment">//维护最大容量</span></span><br><span class="line">            max = Math.max(max, (j-i) * Math.min(height[i], height[j]) );</span><br><span class="line">            <span class="comment">//移动高度较小的指针</span></span><br><span class="line">            <span class="keyword">if</span>(height[i] &lt; height[j])&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度O(n)，空间复杂度O(1)。</p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode Medium</tag>
        <tag>双指针</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>矩阵中的最长递增路径</title>
    <url>/2020/07/26/%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<h4 id="329-矩阵中的最长递增路径"><a href="#329-矩阵中的最长递增路径" class="headerlink" title="329. 矩阵中的最长递增路径"></a><a href="https://leetcode-cn.com/problems/longest-increasing-path-in-a-matrix/" target="_blank" rel="noopener">329. 矩阵中的最长递增路径</a></h4><p>给定一个整数矩阵，找出最长递增路径的长度。</p>
<p>对于每个单元格，你可以往上，下，左，右四个方向移动。 你不能在对角线方向上移动或移动到边界外（即不允许环绕）。</p>
<a id="more"></a>

<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: nums &#x3D; </span><br><span class="line">[</span><br><span class="line">  [9,9,4],</span><br><span class="line">  [6,6,8],</span><br><span class="line">  [2,1,1]</span><br><span class="line">] </span><br><span class="line">输出: 4 </span><br><span class="line">解释: 最长递增路径为 [1, 2, 6, 9]。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: nums &#x3D; </span><br><span class="line">[</span><br><span class="line">  [3,4,5],</span><br><span class="line">  [3,2,6],</span><br><span class="line">  [2,2,1]</span><br><span class="line">] </span><br><span class="line">输出: 4 </span><br><span class="line">解释: 最长递增路径是 [3, 4, 5, 6]。注意不允许在对角线方向上移动。</span><br></pre></td></tr></table></figure>

<p>将矩阵看成一个有向图，每个元素对应图中一个结点，如果两个相邻元素的值不相等，则存在一条从较小值到较大值的有向边，问题转化为在有向图中寻找最长路径。</p>
<p>从一个结点开始进行深度优先搜索，可以得到从该结点开始的最长递增路径，对矩阵中每个结点进行深度优先搜索后可得到最长递增路径的长度。</p>
<p>朴素深度优先搜索的问题是进行了大量的重复计算，同一个结点会被访问多次，每次都重新计算，由于同一个元素的最长递增路径是不变的，我们可以使用矩阵 memo 来存储已经计算过的结果。</p>
<p>使用记忆化深度优先搜索，当访问到一个元素<code>(i, j)</code>时，如果<code>memo[i][j] != 0</code>，说明该元素的结果已经计算过，直接返回结果；否则需要计算结果，并将其存入 memo 中。</p>
<p>我们维护一个最大值 max，当遍历完矩阵中所有的元素时即可得到结果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//方向向量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] dirs = &#123;&#123;-<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> rows, cols;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestIncreasingPath</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        rows = matrix.length;</span><br><span class="line">        cols = matrix[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[][] memo = <span class="keyword">new</span> <span class="keyword">int</span>[rows][cols];</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//对矩阵中每个元素进行 dfs</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols; j++)&#123;</span><br><span class="line">                ans = Math.max(ans, dfs(matrix, i, j, memo));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">int</span>[][] memo)</span></span>&#123;</span><br><span class="line">        <span class="comment">//该结点已经计算过</span></span><br><span class="line">        <span class="keyword">if</span>(memo[row][col] != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> memo[row][col];</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//递增路径长度为 1 </span></span><br><span class="line">        ++memo[row][col];</span><br><span class="line">        <span class="comment">//尝试从不同方向进行深搜</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] dir : dirs)&#123;</span><br><span class="line">            <span class="keyword">int</span> newRow = row + dir[<span class="number">0</span>], newCol = col + dir[<span class="number">1</span>];</span><br><span class="line">            <span class="comment">//当前结点的值要小于相邻结点的值</span></span><br><span class="line">            <span class="keyword">if</span>(newRow &gt;= <span class="number">0</span> &amp;&amp; newRow &lt; rows &amp;&amp; newCol &gt;= <span class="number">0</span> &amp;&amp; newCol &lt; cols &amp;&amp; matrix[newRow][newCol] &gt; matrix[row][col])&#123;</span><br><span class="line">                <span class="comment">//更新当前结点的最大递增路径</span></span><br><span class="line">                memo[row][col] = Math.max(memo[row][col], dfs(matrix, newRow, newCol, memo) + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> memo[row][col];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度O(mn)，其中 m 和 n 是矩阵的行数和列数。深度优先搜索的时间复杂度为O(V + E),其中 V 是结点书，E 是边数。在矩阵中 O(V) = O(mn)，O(E) 近似为 O(4mn)。</p>
<p>空间复杂度O(mn)。</p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode Hard</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>相同的树</title>
    <url>/2020/08/07/%E7%9B%B8%E5%90%8C%E7%9A%84%E6%A0%91/</url>
    <content><![CDATA[<h4 id="100-相同的树"><a href="#100-相同的树" class="headerlink" title="100. 相同的树"></a><a href="https://leetcode-cn.com/problems/same-tree/" target="_blank" rel="noopener">100. 相同的树</a></h4><p>给定两个二叉树，编写一个函数来检验它们是否相同。</p>
<p>如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。</p>
<a id="more"></a>

<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:       1         1</span><br><span class="line">          &#x2F; \       &#x2F; \</span><br><span class="line">         2   3     2   3</span><br><span class="line"></span><br><span class="line">        [1,2,3],   [1,2,3]</span><br><span class="line"></span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:      1          1</span><br><span class="line">          &#x2F;           \</span><br><span class="line">         2             2</span><br><span class="line"></span><br><span class="line">        [1,2],     [1,null,2]</span><br><span class="line"></span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>

<p><strong>示例 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:       1         1</span><br><span class="line">          &#x2F; \       &#x2F; \</span><br><span class="line">         2   1     1   2</span><br><span class="line"></span><br><span class="line">        [1,2,1],   [1,1,2]</span><br><span class="line"></span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>

<p><strong>方法一：DFS</strong></p>
<p>对于两棵树 root1，root2，如果 root1 和 root2 都为空，则返回 true；如果 root1 和 root2 中有一个为空，另一个不为空，则返回false。如果都不为空且它们的值相等，则递归判断左右子树。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSameTree</span><span class="params">(TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p == <span class="keyword">null</span> &amp;&amp; q == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(p == <span class="keyword">null</span> || q == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> p.val == q.val &amp;&amp; isSameTree(p.left, q.left) &amp;&amp; isSameTree(p.right, q.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度O(min(m, n))，m，n为两棵树的节点数。空间复杂度O(min(m, n))。</p>
<p><strong>方法二：BFS</strong></p>
<p>我们使用两个队列来存储二叉树的层次遍历。判断这个队列中的结点值是否相同即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSameTree</span><span class="params">(TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p == <span class="keyword">null</span> &amp;&amp; q == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(p == <span class="keyword">null</span> || q == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Queue&lt;TreeNode&gt; q1 = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        Queue&lt;TreeNode&gt; q2 = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        q1.offer(p);</span><br><span class="line">        q2.offer(q);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!q1.isEmpty() &amp;&amp; !q2.isEmpty())&#123;</span><br><span class="line">            TreeNode n1 = q1.poll(), n2 = q2.poll();</span><br><span class="line">            <span class="keyword">if</span>(n1.val != n2.val)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>( (n1.left == <span class="keyword">null</span> ^ n2.left == <span class="keyword">null</span>) || (n1.right == <span class="keyword">null</span> ^ n2.right == <span class="keyword">null</span>) )&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(n1.left != <span class="keyword">null</span>) q1.offer(n1.left);</span><br><span class="line">            <span class="keyword">if</span>(n1.right != <span class="keyword">null</span>) q1.offer(n1.right);</span><br><span class="line">            <span class="keyword">if</span>(n2.left != <span class="keyword">null</span>) q2.offer(n2.left);</span><br><span class="line">            <span class="keyword">if</span>(n2.right != <span class="keyword">null</span>) q2.offer(n2.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度O(min(m, n))，m，n为两棵树的节点数。空间复杂度O(min(m, n))。</p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode Easy</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>硬币N</title>
    <url>/2020/07/01/%E7%A1%AC%E5%B8%81N/</url>
    <content><![CDATA[<h4 id="面试题-08-11-硬币N"><a href="#面试题-08-11-硬币N" class="headerlink" title="面试题 08.11. 硬币N"></a><a href="https://leetcode-cn.com/problems/coin-lcci/" target="_blank" rel="noopener">面试题 08.11. 硬币N</a></h4><p>硬币。给定数量不限的硬币，币值为25分、10分、5分和1分，编写代码计算n分有几种表示法。(结果可能会很大，你需要将结果模上1000000007)</p>
 <a id="more"></a>

<p><strong>示例1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 输入: n &#x3D; 5</span><br><span class="line"> 输出：2</span><br><span class="line"> 解释: 有两种方式可以凑成总金额:</span><br><span class="line">5&#x3D;5</span><br><span class="line">5&#x3D;1+1+1+1+1</span><br></pre></td></tr></table></figure>

<p><strong>示例2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 输入: n &#x3D; 10</span><br><span class="line"> 输出：4</span><br><span class="line"> 解释: 有四种方式可以凑成总金额:</span><br><span class="line">10&#x3D;10</span><br><span class="line">10&#x3D;5+5</span><br><span class="line">10&#x3D;5+1+1+1+1+1</span><br><span class="line">10&#x3D;1+1+1+1+1+1+1+1+1+1</span><br></pre></td></tr></table></figure>

<p><strong>说明：</strong></p>
<p>注意:</p>
<p>你可以假设：</p>
<ul>
<li>0 &lt;= n (总金额) &lt;= 1000000</li>
</ul>
<p>完全背包问题即不限定硬币的个数去组合硬币达到指定的值。</p>
<p>这道题为求组合成指定数额有几种情况，我们设置 dp 数组：dp[k]  为组成 k 面额的硬币情况数。</p>
<p>设置基本情况：dp[0] = 1，这里 dp[0] 的含义不是 组成 0 的硬币种类为 0，二是作为完美能被一个硬币表示的情况为 1。即：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">while k - coin &#x3D;&#x3D; 0 :</span><br><span class="line">	dp[k] +&#x3D; dp[k - coin];</span><br><span class="line">	&#x3D;&gt;</span><br><span class="line">	dp[k] +&#x3D; dp[0];</span><br></pre></td></tr></table></figure>

<p>我们可以得到 dp 方程 dp[k] += dp[k-coin]；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">waysToChange</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> mod = <span class="number">1000000007</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span>[] coins = &#123;<span class="number">25</span>,<span class="number">10</span>,<span class="number">5</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//刚好可以用一个硬币凑成的情况</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> c=<span class="number">0</span>; c&lt;<span class="number">4</span>; ++c)&#123;</span><br><span class="line">            <span class="keyword">int</span> coin = coins[c];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=coin; i&lt;=n; ++i)&#123;</span><br><span class="line">                dp[i] = (dp[i] + dp[i - coin]) % mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度为O(n)，空间复杂度为 O(n)。</p>
<p>coins 数组中的硬币顺序必须是由大到小。</p>
<p>如果硬币由小到大，我们求6的硬币情况数时，我们观察一下流程：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">前面5种情况数：dp[1,5] &#x3D; [1,1,1,1,2];</span><br><span class="line"></span><br><span class="line">coin &#x3D; 1:</span><br><span class="line">dp[6] +&#x3D; (dp[6 - coin] &#x3D;&gt; dp[5] &#x3D;&gt; 2);</span><br><span class="line">即拿到coin(1)的情况有两种 :</span><br><span class="line">	coin(1,1,1,1,1) + coin(1);</span><br><span class="line">	coin(5) + coin(1);</span><br><span class="line">	</span><br><span class="line">coin &#x3D; 5:</span><br><span class="line">dp[6] +&#x3D; (dp[6 - coin] &#x3D;&gt; dp[1] &#x3D;&gt; 1);</span><br><span class="line">即拿到coin（5）的情况有一种:</span><br><span class="line">	coin(1) + coin(5);</span><br><span class="line">但是事实却是6的情况只有两种，（1，1，1，1，1，1）和（1，5）。这里是把（1，5）和（5，1）前后顺序不同的情况重复算了1次。因此我们应该去考虑硬币顺序带来的影响。</span><br></pre></td></tr></table></figure>
<p>正确答案：<br>于是我们先遍历硬币，保证在考虑一枚硬币的情况时，没有较大的硬币影响，这样，我们最终每种组合情况，都是以硬币的面额大小非递减组合。保证了同样的情况，调换顺序后重复计算的情况。</p>
<p>这时候，我们求6的硬币情况数时，我们观察一下流程：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">coin &#x3D; 1:</span><br><span class="line">前面5种情况数：dp[1,5] &#x3D; [1,1,1,1,1];</span><br><span class="line"></span><br><span class="line">dp[6] +&#x3D; (dp[6 - coin] &#x3D;&gt; dp[5] &#x3D;&gt; 1);</span><br><span class="line">即拿到coin(1)的情况有一种 :</span><br><span class="line">	coin(1,1,1,1,1) + coin(1);</span><br><span class="line">	</span><br><span class="line">coin &#x3D; 5:</span><br><span class="line">前面5种情况数：dp[1,5] &#x3D; [1,1,1,1,2];</span><br><span class="line"></span><br><span class="line">dp[6] +&#x3D; (dp[6 - coin] &#x3D;&gt; dp[1] &#x3D;&gt; 1);</span><br><span class="line">即拿到coin（5）的情况有一种:</span><br><span class="line">	coin(1) + coin(5);</span><br><span class="line">此时，硬币组合情况，的确为正确的情况。</span><br></pre></td></tr></table></figure>
<p>参考：<a href="https://leetcode-cn.com/problems/coin-lcci/solution/dong-tai-gui-hua-wan-quan-bei-bao-wen-ti-by-eddiev/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/coin-lcci/solution/dong-tai-gui-hua-wan-quan-bei-bao-wen-ti-by-eddiev/</a></p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode Medium</tag>
        <tag>动态规划</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>移掉K位数字</title>
    <url>/2020/11/15/%E7%A7%BB%E6%8E%89K%E4%BD%8D%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<h4 id="402-移掉K位数字"><a href="#402-移掉K位数字" class="headerlink" title="402. 移掉K位数字"></a><a href="https://leetcode-cn.com/problems/remove-k-digits/" target="_blank" rel="noopener">402. 移掉K位数字</a></h4><p>给定一个以字符串表示的非负整数 <em>num*，移除这个数中的 *k</em> 位数字，使得剩下的数字最小。</p>
<a id="more"></a>

<p><strong>注意:</strong></p>
<ul>
<li><em>num</em> 的长度小于 10002 且 ≥ <em>k。</em></li>
<li><em>num</em> 不会包含任何前导零。</li>
</ul>
<p><strong>示例 1 :</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: num &#x3D; &quot;1432219&quot;, k &#x3D; 3</span><br><span class="line">输出: &quot;1219&quot;</span><br><span class="line">解释: 移除掉三个数字 4, 3, 和 2 形成一个新的最小的数字 1219。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2 :</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: num &#x3D; &quot;10200&quot;, k &#x3D; 1</span><br><span class="line">输出: &quot;200&quot;</span><br><span class="line">解释: 移掉首位的 1 剩下的数字为 200. 注意输出不能有任何前导零。</span><br></pre></td></tr></table></figure>

<p>示例 <strong>3 :</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: num &#x3D; &quot;10&quot;, k &#x3D; 2</span><br><span class="line">输出: &quot;0&quot;</span><br><span class="line">解释: 从原数字移除所有的数字，剩余为空就是0。</span><br></pre></td></tr></table></figure>

<p><strong>方法一：贪心+单调栈</strong></p>
<p>对于两个长度相同的序列，最左边的不同数字决定了这两个数字的大小。例如，对于 A = laxxx，B = lbxxx，如果 a &gt; b 则 A &gt; B。</p>
<p>要使剩下的数字最小，需要保证靠前的数字尽可能小。以 425 为例，如果只要求我们删除一个数字，从左到右，有 4，2，5三个选择。我们将每一个数字和它的左邻居进行比较。从 2 开始，2 小于它的左邻居 4。假设我们保留数字 4 ，可能的组合都以 4 开头。如果我们保留数字 2 ，可能的组合都以 2 开头，显然小于 4 开头的组合，我们应该删除数字 4 。</p>
<p>我们可以得到删除一个数字的贪心策略：</p>
<p>在一个序列中，如果发现前一个数字大于后一个数字，删除前一个数字；如果没有，则删除序列中最后一个数字。</p>
<p>我们可以对序列执行 k 次这个策略，最后就可得到结果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">removeKdigits</span><span class="params">(String num, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        StringBuffer sb = <span class="keyword">new</span> StringBuffer(num);</span><br><span class="line">        <span class="comment">//执行 k 次删除一个数字策略</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; sb.length() &amp;&amp; k &gt; <span class="number">0</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(sb.charAt(i - <span class="number">1</span>) &gt; sb.charAt(i))&#123;</span><br><span class="line">                sb.deleteCharAt(i - <span class="number">1</span>);</span><br><span class="line">                i = <span class="number">0</span>;</span><br><span class="line">                --k;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">		<span class="comment">//序列中没有递减数字，删除最后 k 个数字</span></span><br><span class="line">        <span class="keyword">if</span>(k &gt; <span class="number">0</span> &amp;&amp; k &lt;= sb.length())&#123;</span><br><span class="line">            sb.delete(sb.length() - k, sb.length());</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">		<span class="comment">//删除前导 0 </span></span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(index &lt; sb.length() &amp;&amp; sb.charAt(index) == <span class="string">'0'</span>)&#123;</span><br><span class="line">            ++index;</span><br><span class="line">        &#125;</span><br><span class="line">        sb.delete(<span class="number">0</span>, index);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> sb.length() == <span class="number">0</span> ? <span class="string">"0"</span> : sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度O(NK)，N 为 num 序列长度，K 为要删除的数字个数。</p>
<p>空间复杂度O(N)，N 为 StringBuffer 空间。</p>
<p>我们可以使用单调栈来加速删除的过程，栈中的元素代表截止到当前位置，删除不超过 k 个数字后，所能得到的最小整数。根据之前的讨论：在使用 k 个删除字数前，栈中的序列从栈底到栈顶单调不减。</p>
<p>对于每个数字，如果该数字小于栈顶元素，我们就不断地弹出栈顶元素，直到</p>
<ul>
<li>栈为空</li>
<li>新的栈顶元素不大于当前数字</li>
<li>我们已经删除了  k 位数字</li>
</ul>
<p>上述步骤结束后我们还需要进行额外的处理：</p>
<ul>
<li>我们删除了 m 个数字 且 m &lt; k，需要删除序列尾部的 k - m 个数字</li>
<li>需要删除前导 0 </li>
<li>如果最后序列为空，应该返回 0 </li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">removeKdigits</span><span class="params">(String num, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        Deque&lt;Character&gt; deque = <span class="keyword">new</span> LinkedList&lt;Character&gt;();</span><br><span class="line">        <span class="keyword">int</span> length = num.length();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++)&#123;</span><br><span class="line">            <span class="keyword">char</span> digit = num.charAt(i);</span><br><span class="line">            <span class="keyword">while</span>(!deque.isEmpty() &amp;&amp; k &gt; <span class="number">0</span> &amp;&amp; deque.peekLast() &gt; digit)&#123;</span><br><span class="line">                deque.pollLast();</span><br><span class="line">                --k;</span><br><span class="line">            &#125;</span><br><span class="line">            deque.offerLast(digit);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)&#123;</span><br><span class="line">            deque.pollLast();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        StringBuffer ret = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">boolean</span> leadingZero = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">while</span>(!deque.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">char</span> digit = deque.pollFirst();</span><br><span class="line">            <span class="keyword">if</span>(leadingZero &amp;&amp; digit == <span class="string">'0'</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            leadingZero = <span class="keyword">false</span>;</span><br><span class="line">            ret.append(digit);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret.length() == <span class="number">0</span> ? <span class="string">"0"</span> : ret.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度O(N)，N 为 num 序列长度，尽管存在嵌套循环，但最坏情况为删除序列全部数字，时间复杂度为 2N。</p>
<p>空间复杂度O(N)，N 为 StringBuffer 空间。</p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode Medium</tag>
        <tag>贪心</tag>
        <tag>单调栈</tag>
      </tags>
  </entry>
  <entry>
    <title>移除重复节点</title>
    <url>/2020/06/26/%E7%A7%BB%E9%99%A4%E9%87%8D%E5%A4%8D%E7%BB%93%E7%82%B9/</url>
    <content><![CDATA[<h4 id="面试题-02-01-移除重复节点"><a href="#面试题-02-01-移除重复节点" class="headerlink" title="面试题 02.01. 移除重复节点"></a><a href="https://leetcode-cn.com/problems/remove-duplicate-node-lcci/" target="_blank" rel="noopener">面试题 02.01. 移除重复节点</a></h4><p>编写代码，移除未排序链表中的重复节点。保留最开始出现的节点。</p>
<a id="more"></a>

<p><strong>示例1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[1, 2, 3, 3, 2, 1]</span><br><span class="line">输出：[1, 2, 3]</span><br></pre></td></tr></table></figure>

<p><strong>示例2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[1, 1, 1, 1, 2]</span><br><span class="line">输出：[1, 2]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ol>
<li>链表长度在[0, 20000]范围内。</li>
<li>链表元素在[0, 20000]范围内。</li>
</ol>
<p><strong>进阶：</strong></p>
<p>如果不得使用临时缓冲区，该怎么解决？</p>
<p>我们可以使用哈希表来存储不重复的结点元素，在遍历过程中只用O(1) 时间就可判断出该结点是否重复。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">removeDuplicateNodes</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//判空处理</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode p = head;</span><br><span class="line">        Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">//将第一个结点放入 HashMap</span></span><br><span class="line">        map.put(head.val, <span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(p.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//判断结点是否重复</span></span><br><span class="line">            <span class="keyword">if</span>(!map.containsKey(p.next.val))&#123;</span><br><span class="line">                <span class="comment">//不重复，将结点值加入 HashMap</span></span><br><span class="line">                map.put(p.next.val, <span class="number">1</span>);</span><br><span class="line">                p = p.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//重复，删除下一个结点</span></span><br><span class="line">                p.next = p.next.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度 O(n)，空间复杂度O(n)。</p>
<p>我们也可以直接使用暴力求解，在遍历链表的每个结点时，使用另一个指针，遍历当前结点之后的所有结点，若与当前结点值相同则删除。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">removeDuplicateNodes</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode p = head, q = head;</span><br><span class="line">        <span class="keyword">while</span>(p != <span class="keyword">null</span>)&#123;</span><br><span class="line">            q = p;</span><br><span class="line">            <span class="comment">//删除后续结点中与 p 指向的结点值相同的结点</span></span><br><span class="line">            <span class="keyword">while</span>(q.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(q.next.val == p.val)&#123;</span><br><span class="line">                    q.next = q.next.next;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    q = q.next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度O(n^2)，空间复杂度O(1)。</p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode Easy</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>笨阶乘</title>
    <url>/2021/04/01/%E7%AC%A8%E9%98%B6%E4%B9%98/</url>
    <content><![CDATA[<h4 id="1006-笨阶乘"><a href="#1006-笨阶乘" class="headerlink" title="1006. 笨阶乘"></a><a href="https://leetcode-cn.com/problems/clumsy-factorial/" target="_blank" rel="noopener">1006. 笨阶乘</a></h4><p>通常，正整数 <code>n</code> 的阶乘是所有小于或等于 <code>n</code> 的正整数的乘积。例如，<code>factorial(10) = 10 * 9 * 8 * 7 * 6 * 5 * 4 * 3 * 2 * 1</code>。</p>
<p>相反，我们设计了一个笨阶乘 <code>clumsy</code>：在整数的递减序列中，我们以一个固定顺序的操作符序列来依次替换原有的乘法操作符：乘法(*)，除法(/)，加法(+)和减法(-)。</p>
<p>例如，<code>clumsy(10) = 10 * 9 / 8 + 7 - 6 * 5 / 4 + 3 - 2 * 1</code>。然而，这些运算仍然使用通常的算术运算顺序：我们在任何加、减步骤之前执行所有的乘法和除法步骤，并且按从左到右处理乘法和除法步骤。</p>
<p>另外，我们使用的除法是地板除法（<em>floor division</em>），所以 <code>10 * 9 / 8</code> 等于 <code>11</code>。这保证结果是一个整数。</p>
<p>实现上面定义的笨函数：给定一个整数 <code>N</code>，它返回 <code>N</code> 的笨阶乘。</p>
<a id="more"></a>

<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：4</span><br><span class="line">输出：7</span><br><span class="line">解释：7 &#x3D; 4 * 3 &#x2F; 2 + 1</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：10</span><br><span class="line">输出：12</span><br><span class="line">解释：12 &#x3D; 10 * 9 &#x2F; 8 + 7 - 6 * 5 &#x2F; 4 + 3 - 2 * 1</span><br></pre></td></tr></table></figure>

<p> <strong>提示：</strong></p>
<ol>
<li><code>1 &lt;= N &lt;= 10000</code></li>
<li><code>-2^31 &lt;= answer &lt;= 2^31 - 1</code> （答案保证符合 32 位整数。）</li>
</ol>
<p><strong>方法一：使用栈模拟</strong></p>
<p>运算优先级是先乘除后加减。我们可以从 N 开始，枚举N - 1，N - 2 直到 1，枚举这些数的时候，认为它们之前的操作符按乘、除、加、减交替进行。</p>
<ul>
<li>出现乘除法是，我们可以把栈顶元素去除，与当前的 N 进行乘除法运算，并将结果重新压入栈中</li>
<li>出现加减法是，把减法视为加上一个数的相反数，然后压入栈，等待以后遇见乘除法时取出。</li>
</ul>
<p>最后将栈中所有元素相加得到答案。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">clumsy</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        Deque&lt;Integer&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        stack.push(N);</span><br><span class="line">        N--;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(N != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(index % <span class="number">4</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                stack.push(stack.pop() * N);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(index % <span class="number">4</span> == <span class="number">1</span>)&#123;</span><br><span class="line">                stack.push(stack.pop() / N);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(index % <span class="number">4</span> == <span class="number">2</span>)&#123;</span><br><span class="line">                stack.push(N);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                stack.push(-N);</span><br><span class="line">            &#125;</span><br><span class="line">            --N;</span><br><span class="line">            ++index;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">            ret += stack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度O(n)</li>
<li>空间复杂度O(n)</li>
</ul>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode Medium</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>直方图的水量</title>
    <url>/2021/04/02/%E7%9B%B4%E6%96%B9%E5%9B%BE%E7%9A%84%E6%B0%B4%E9%87%8F/</url>
    <content><![CDATA[<h4 id="面试题-17-21-直方图的水量"><a href="#面试题-17-21-直方图的水量" class="headerlink" title="面试题 17.21. 直方图的水量"></a><a href="https://leetcode-cn.com/problems/volume-of-histogram-lcci/" target="_blank" rel="noopener">面试题 17.21. 直方图的水量</a></h4><p>给定一个直方图(也称柱状图)，假设有人从上面源源不断地倒水，最后直方图能存多少水量?直方图的宽度为 1。</p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/rainwatertrap.png" alt="img"></p>
<p>上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的直方图，在这种情况下，可以接 6 个单位的水（蓝色部分表示水）。 </p>
<a id="more"></a>

<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [0,1,0,2,1,0,1,3,2,1,2,1]</span><br><span class="line">输出: 6</span><br></pre></td></tr></table></figure>

<p><strong>方法一：暴力</strong></p>
<p>对于下标 i ，水能达到的最大高度等于下标 i 两边的最大高度的最小值。下标 i 处能接的水能到达的最大高度减去 height[i]。</p>
<p>对于每个下标 i ，我们直接搜索其左边和右边的最大高度，取其中的最小值减去 height[i]，即是位置 i 能存的水量。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = height.length;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> leftMax = height[i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(height[j] &gt; leftMax)&#123;</span><br><span class="line">                    leftMax = height[j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> rightMax = height[i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(height[j] &gt; rightMax)&#123;</span><br><span class="line">                    rightMax = height[j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans += Math.min(leftMax, rightMax) - height[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度O(n^2)</li>
<li>空间复杂度O(1)</li>
</ul>
<p><strong>方法二：动态规划</strong></p>
<p>我们使用两个数组 leftMax 和 rightMax，来存储左侧最小值和右侧最小值。leftMax[i] 表示下标 i 及其左边的位置中，height 的最大高度，rightMax[i]表示下标 i 及其右边的位置中，height的最大高度。</p>
<p>leftMax[0] = height[0]，rightMax[n - 1]  = height[n - 1]。最左边元素左侧没有比它更大的元素，最右边元素右侧没有比它更大的元素。<br>$$<br>leftMax[i] = max(leftMax[i - 1], height[i])\ \ \ 1 \leq i \leq n - 1<br>$$</p>
<p>$$<br>rightMax[i] = max(rightMax[i + 1],height[i])\ \ \ 0 \leq i \leq n - 2<br>$$</p>
<p>下标 i 处能接的水量为 min(leftMax[i], rightMax[i]) - height[i] 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = height.length;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] leftMax = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        leftMax[<span class="number">0</span>] = height[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            leftMax[i] = Math.max(leftMax[i - <span class="number">1</span>], height[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] rightMax = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        rightMax[n - <span class="number">1</span>] = height[n - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">            rightMax[i] = Math.max(rightMax[i + <span class="number">1</span>], height[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            ans += Math.min(leftMax[i], rightMax[i]) - height[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度O(n)</li>
<li>空间复杂度O(n)</li>
</ul>
<p><strong>方法三：双指针</strong></p>
<p>注意到下标 i 处能接的水量由 leftMax[i] 和 rightMax[i] 中的最小值决定。由于数组leftMax 是</p>
<p>从左往右计算，数组rightMax 是从右往左计算，因此可以使用双指针和两个标量代替两个数组。</p>
<p>维护两个指针 left 和 right，以及两个变量 leftMax 和 rightMax，初始时 left = 0， right = n - 1，leftMax = 0，rightMax = 0，在移动指针的过程中维护两个变量 leftMax 和 rightMax 的值。</p>
<p>当指针没有相遇时，进行如下操作：</p>
<ul>
<li>使用 height[left] 和 height[right] 的值更新 leftMax  和 rightMax 的值。</li>
<li>如果 <strong>height[left] &lt; height[right]</strong>，则必有 <strong>leftMax &lt; rightMax</strong>,下标 <strong>left</strong> 处能接的水量等于 <strong>leftMax - height[left]</strong>,将数量加入结果中，<strong>left++</strong></li>
<li>如果 <strong>height[left] &gt;= height[right]</strong>，则必有 <strong>leftMax &gt;= rightMax</strong>,下标 <strong>right</strong>处能接的水量等于 <strong>rightMax - height[right]</strong>,将数量加入结果中，<strong>right–</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = height.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> leftMax = <span class="number">0</span>, rightMax = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            leftMax = Math.max(leftMax, height[left]);</span><br><span class="line">            rightMax = Math.max(rightMax, height[right]);</span><br><span class="line">            <span class="keyword">if</span>(height[left] &lt; height[right])&#123;</span><br><span class="line">                ans += leftMax - height[left];</span><br><span class="line">                ++left;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ans += rightMax - height[right];</span><br><span class="line">                --right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度O(n)</li>
<li>空间复杂度O(1)</li>
</ul>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode Hard</tag>
        <tag>动态规划</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>等式方程的可满足性</title>
    <url>/2020/06/08/%E7%AD%89%E5%BC%8F%E6%96%B9%E7%A8%8B%E7%9A%84%E5%8F%AF%E6%BB%A1%E8%B6%B3%E6%80%A7/</url>
    <content><![CDATA[<h4 id="990-等式方程的可满足性"><a href="#990-等式方程的可满足性" class="headerlink" title="990. 等式方程的可满足性"></a><a href="https://leetcode-cn.com/problems/satisfiability-of-equality-equations/" target="_blank" rel="noopener">990. 等式方程的可满足性</a></h4><p>给定一个由表示变量之间关系的字符串方程组成的数组，每个字符串方程 <code>equations[i]</code> 的长度为 <code>4</code>，并采用两种不同的形式之一：<code>&quot;a==b&quot;</code> 或 <code>&quot;a!=b&quot;</code>。在这里，a 和 b 是小写字母（不一定不同），表示单字母变量名。</p>
<p>只有当可以将整数分配给变量名，以便满足所有给定的方程时才返回 <code>true</code>，否则返回 <code>false</code>。 </p>
<a id="more"></a>

<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[&quot;a&#x3D;&#x3D;b&quot;,&quot;b!&#x3D;a&quot;]</span><br><span class="line">输出：false</span><br><span class="line">解释：如果我们指定，a &#x3D; 1 且 b &#x3D; 1，那么可以满足第一个方程，但无法满足第二个方程。没有办法分配变量同时满足这两个方程。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输出：[&quot;b&#x3D;&#x3D;a&quot;,&quot;a&#x3D;&#x3D;b&quot;]</span><br><span class="line">输入：true</span><br><span class="line">解释：我们可以指定 a &#x3D; 1 且 b &#x3D; 1 以满足满足这两个方程。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[&quot;a&#x3D;&#x3D;b&quot;,&quot;b&#x3D;&#x3D;c&quot;,&quot;a&#x3D;&#x3D;c&quot;]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>

<p><strong>示例 4：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[&quot;a&#x3D;&#x3D;b&quot;,&quot;b!&#x3D;c&quot;,&quot;c&#x3D;&#x3D;a&quot;]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>

<p><strong>示例 5：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[&quot;c&#x3D;&#x3D;c&quot;,&quot;b&#x3D;&#x3D;d&quot;,&quot;x!&#x3D;z&quot;]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>

<p> <strong>提示：</strong></p>
<ol>
<li><code>1 &lt;= equations.length &lt;= 500</code></li>
<li><code>equations[i].length == 4</code></li>
<li><code>equations[i][0]</code> 和 <code>equations[i][3]</code> 是小写字母</li>
<li><code>equations[i][1]</code> 要么是 <code>&#39;=&#39;</code>，要么是 <code>&#39;!&#39;</code></li>
<li><code>equations[i][2]</code> 是 <code>&#39;=&#39;</code></li>
</ol>
<p>由于相等关系具有<strong>传递性</strong>，所有相等的变量属于同一个集合，只关心连通性，不关心距离，因此很容易想到并查集。</p>
<p>算法流程：</p>
<ul>
<li>扫描所有等式，将等式两边的顶点进行合并；</li>
<li>再扫描所有不等式，检查每一个不等式的两个顶点是不是在一个连通分量里：<ul>
<li>如果在，代表 a == b 和 a != b 同时成立，返回 false</li>
<li>如果所有检查都没有矛盾，返回 true</li>
</ul>
</li>
</ul>
<p>使用一个数组 parent 存储每个变量的连通分量信息，其中的每个元素表示当前连通分量的父节点信息，如果父节点是自身，说明该变量为所在连通分量的根结点。一开始所有变量的父节点都是它们自身。对于合并操作，我们将第一个变量的根结点的父节点指向第二个变量的根结点；对于查找操作，我们沿着当前变量的父节点一路向上查找，直到找到根结点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equationsPossible</span><span class="params">(String[] equations)</span> </span>&#123;</span><br><span class="line">        UnionFind unionFind = <span class="keyword">new</span> UnionFind(<span class="number">26</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(String equation : equations)&#123;</span><br><span class="line">            <span class="keyword">char</span>[] charArray = equation.toCharArray();</span><br><span class="line">            <span class="keyword">if</span>(charArray[<span class="number">1</span>] == <span class="string">'='</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> index1 = charArray[<span class="number">0</span>] - <span class="string">'a'</span>;</span><br><span class="line">                <span class="keyword">int</span> index2 = charArray[<span class="number">3</span>] - <span class="string">'a'</span>;</span><br><span class="line">                unionFind.union(index1, index2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(String equation : equations)&#123;</span><br><span class="line">            <span class="keyword">char</span>[] charArray = equation.toCharArray();</span><br><span class="line">            <span class="keyword">if</span>(charArray[<span class="number">1</span>] == <span class="string">'!'</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> index1 = charArray[<span class="number">0</span>] - <span class="string">'a'</span>;</span><br><span class="line">                <span class="keyword">int</span> index2 = charArray[<span class="number">3</span>] - <span class="string">'a'</span>;</span><br><span class="line">                <span class="keyword">if</span>(unionFind.isConnected(index1, index2))&#123;</span><br><span class="line">                    <span class="comment">//如果合并失败，表示等式有矛盾，返回false</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//检查了所有不等式，没有发现矛盾，返回 true</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span>[] parent;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">UnionFind</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">            parent = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">                parent[i] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">            <span class="comment">//找根结点</span></span><br><span class="line">            <span class="keyword">while</span>(x != parent[x])&#123;</span><br><span class="line">                <span class="comment">//路径压缩</span></span><br><span class="line">                parent[x] = parent[parent[x]];</span><br><span class="line">                x = parent[x];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">            <span class="keyword">int</span> rootX = find(x);</span><br><span class="line">            <span class="keyword">int</span> rootY = find(y);</span><br><span class="line">            parent[rootX] = rootY;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isConnected</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">            <span class="comment">//根结点相同则连通</span></span><br><span class="line">            <span class="keyword">return</span> find(x) == find(y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度 O(n + ClogC)，其中 n 是 equations 中的方程数量，C 是变量的总数，本题中变量都是小写字母即 C&lt;=26。并查集代码中使用了路径压缩算法，对于每个方程的合并和查找的均摊时间复杂度都是 O(logC)。</p>
<p>空间复杂度 O(C)，创建一个 parent 数组存储每个变量的连通分量信息。</p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode Medium</tag>
        <tag>图</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title>组合</title>
    <url>/2020/09/08/%E7%BB%84%E5%90%88/</url>
    <content><![CDATA[<h4 id="77-组合"><a href="#77-组合" class="headerlink" title="77. 组合"></a><a href="https://leetcode-cn.com/problems/combinations/" target="_blank" rel="noopener">77. 组合</a></h4><p>给定两个整数 <em>n</em> 和 <em>k</em>，返回 1 … <em>n</em> 中所有可能的 <em>k</em> 个数的组合。</p>
<a id="more"></a>

<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: n &#x3D; 4, k &#x3D; 2</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [2,4],</span><br><span class="line">  [3,4],</span><br><span class="line">  [2,3],</span><br><span class="line">  [1,2],</span><br><span class="line">  [1,3],</span><br><span class="line">  [1,4],</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>以 n = 4， k = 2为例，我们可以发现如下递归结构：</p>
<ol>
<li>如果组合里面有 <code>1</code> ，那么需要在<code>[2, 3, 4]</code>里再找 1 个数；</li>
<li>如果组合里有 <code>2</code> ，那么需要在<code>[3, 4]</code>里再找 1 个数。这里不能再包含 1 ，因为[1, 2] 这个组合已经在第一种情况中包含。</li>
</ol>
<p>我们可以写出如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combine(<span class="keyword">int</span> n, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        dfs(<span class="number">1</span>, n, k, <span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在[start, end] 选取 k 个数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span> k, List&lt;Integer&gt; cur)</span></span>&#123;</span><br><span class="line">		<span class="comment">// k == 0 直接返回</span></span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">0</span>)&#123;</span><br><span class="line">            ans.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(cur));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//对每一个数进行枚举</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; start + i &lt;= end; i++)&#123;</span><br><span class="line">            cur.add(start + i);</span><br><span class="line">            <span class="comment">//继续在[start + i + 1, end] 范围内选取 k - 1 个数</span></span><br><span class="line">            dfs(start + i + <span class="number">1</span>, end, k - <span class="number">1</span>, cur);</span><br><span class="line">            <span class="comment">//删除当前选取的数，重新循环</span></span><br><span class="line">            cur.remove(cur.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同时我们注意到，使用ArrayList 进行删除效率很低，将其改为 ArrayDeque。在进行循环的时候，我们选取的退出条件为<code>start + i &lt;= end</code>，其实还可以缩小一点，当<code>[start + i, end]</code> 中的元素小于 k 个时，我们可以直接退出，将该条件修改为<code>start + i &lt;= end - k + 1</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combine(<span class="keyword">int</span> n, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        dfs(<span class="number">1</span>, n, k, <span class="keyword">new</span> ArrayDeque&lt;Integer&gt;());</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span> k, Deque&lt;Integer&gt; path)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">0</span>)&#123;</span><br><span class="line">            ans.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//当[start + i, end]范围内数字个数小于 k 个时退出循环</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; start + i &lt;= end - k + <span class="number">1</span>; i++)&#123;</span><br><span class="line">            path.addLast(start + i);</span><br><span class="line">            dfs(start + i + <span class="number">1</span>, end, k - <span class="number">1</span>, path);</span><br><span class="line">            path.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode Medium</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>组合总和</title>
    <url>/2020/09/09/%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C/</url>
    <content><![CDATA[<h4 id="39-组合总和"><a href="#39-组合总和" class="headerlink" title="39. 组合总和"></a><a href="https://leetcode-cn.com/problems/combination-sum/" target="_blank" rel="noopener">39. 组合总和</a></h4><p>给定一个<strong>无重复元素</strong>的数组 <code>candidates</code> 和一个目标数 <code>target</code> ，找出 <code>candidates</code> 中所有可以使数字和为 <code>target</code> 的组合。</p>
<p><code>candidates</code> 中的数字可以无限制重复被选取。</p>
<a id="more"></a>

<p><strong>说明：</strong></p>
<ul>
<li>所有数字（包括 <code>target</code>）都是正整数。</li>
<li>解集不能包含重复的组合。 </li>
</ul>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：candidates &#x3D; [2,3,6,7], target &#x3D; 7,</span><br><span class="line">所求解集为：</span><br><span class="line">[</span><br><span class="line">  [7],</span><br><span class="line">  [2,2,3]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：candidates &#x3D; [2,3,5], target &#x3D; 8,</span><br><span class="line">所求解集为：</span><br><span class="line">[</span><br><span class="line">  [2,2,2,2],</span><br><span class="line">  [2,3,3],</span><br><span class="line">  [3,5]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p> <strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= candidates.length &lt;= 30</code></li>
<li><code>1 &lt;= candidates[i] &lt;= 200</code></li>
<li><code>candidate</code> 中的每个元素都是独一无二的。</li>
<li><code>1 &lt;= target &lt;= 500</code></li>
</ul>
<p>由于 candidates 是无序的，只能暴力搜索全部的解。考虑剪枝，先将 candidates 数组排序，在搜索的过程中如果得到的当前总和大于 target ，那么后面的元素总和都不用尝试（由于数组递增，它们的总和比大于当前总和）。</p>
<p>数字可以被重复选取代表下一次递归时，还可以取当前选取的数字。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="comment">//排序是剪枝的基础</span></span><br><span class="line">        Arrays.sort(candidates);</span><br><span class="line">        dfs(<span class="number">0</span>, target, candidates, <span class="keyword">new</span> ArrayDeque&lt;Integer&gt;());</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> target, <span class="keyword">int</span>[] candidates, ArrayDeque&lt;Integer&gt; path)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> end = candidates.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(target == <span class="number">0</span>)&#123;</span><br><span class="line">            ans.add(<span class="keyword">new</span> ArrayList(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; start + i &lt;= end; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> cur = candidates[start + i];</span><br><span class="line">            <span class="comment">//剪枝</span></span><br><span class="line">            <span class="keyword">if</span>(target - cur &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                path.addLast(cur);</span><br><span class="line">                <span class="comment">//只能使用当前元素及其右侧的值，避免重复解</span></span><br><span class="line">                dfs(start + i, target - cur, candidates, path);</span><br><span class="line">                path.removeLast();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode Medium</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>组合总和II</title>
    <url>/2020/09/10/%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CII/</url>
    <content><![CDATA[<h4 id="40-组合总和-II"><a href="#40-组合总和-II" class="headerlink" title="40. 组合总和 II"></a><a href="https://leetcode-cn.com/problems/combination-sum-ii/" target="_blank" rel="noopener">40. 组合总和 II</a></h4><p>给定一个数组 <code>candidates</code> 和一个目标数 <code>target</code> ，找出 <code>candidates</code> 中所有可以使数字和为 <code>target</code> 的组合。</p>
<p><code>candidates</code> 中的每个数字在每个组合中只能使用一次。</p>
<a id="more"></a>

<p><strong>说明：</strong></p>
<ul>
<li>所有数字（包括目标数）都是正整数。</li>
<li>解集不能包含重复的组合。 </li>
</ul>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: candidates &#x3D; [10,1,2,7,6,1,5], target &#x3D; 8,</span><br><span class="line">所求解集为:</span><br><span class="line">[</span><br><span class="line">  [1, 7],</span><br><span class="line">  [1, 2, 5],</span><br><span class="line">  [2, 6],</span><br><span class="line">  [1, 1, 6]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: candidates &#x3D; [2,5,2,1,2], target &#x3D; 5,</span><br><span class="line">所求解集为:</span><br><span class="line">[</span><br><span class="line">  [1,2,2],</span><br><span class="line">  [5]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>此题与第 39 题差不多，只是条件限制有些不同。我们首先写出允许重复的初始程序，然后再添加限制条件：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum2(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        Arrays.sort(candidates);</span><br><span class="line">        dfs(<span class="number">0</span>, target, candidates, <span class="keyword">new</span> ArrayDeque&lt;Integer&gt;());</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> target, <span class="keyword">int</span>[] candidates, ArrayDeque&lt;Integer&gt; path)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(target == <span class="number">0</span>)&#123;</span><br><span class="line">            ans.add(<span class="keyword">new</span> ArrayList(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> index = start; index &lt; candidates.length; index++)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> cur = candidates[index];</span><br><span class="line">            <span class="keyword">if</span>(target - cur &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            path.addLast(cur);</span><br><span class="line">            dfs(index + <span class="number">1</span>, target - cur, candidates, path);</span><br><span class="line">            path.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当<code>candidates = [1, 2, 2, 2, 5]</code>，<code>target = 5</code> 时运行得到的结果为<code>[[1,2,2],[1,2,2],[1,2,2],[5]]</code>，<code>[1, 2, 2]</code>这个结果重复了三次。</p>
<p>想到可以在递归的时候限制，遇到重复的元素就跳过，我们写出如下版本（错误示例）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> target, <span class="keyword">int</span>[] candidates, ArrayDeque&lt;Integer&gt; path)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span>(target == <span class="number">0</span>)&#123;</span><br><span class="line">         ans.add(<span class="keyword">new</span> ArrayList(path));</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> index = start; index &lt; candidates.length; index++)&#123;</span><br><span class="line">         <span class="keyword">int</span> cur = candidates[index];</span><br><span class="line">         <span class="keyword">if</span>(target - cur &lt; <span class="number">0</span>)&#123;</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">//跳过重复的元素            </span></span><br><span class="line"><span class="keyword">if</span>(index &gt; <span class="number">0</span> &amp;&amp; candidates[index] == candidates[index - <span class="number">1</span>])&#123;</span><br><span class="line">             <span class="keyword">continue</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         </span><br><span class="line">         path.addLast(cur);</span><br><span class="line">         dfs(index + <span class="number">1</span>, target - cur, candidates, path);</span><br><span class="line">         path.removeLast();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>再次运行上述示例，我们得到结果<code>[[5]]</code>，<code>[1, 2, 2]</code>被剪掉了。当 index = 2 时，发现 index - 1 的值与它的值相同，则剪掉了这一分支，但我们需要保留这条分支。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">	1    index &#x3D; 0      第 1 层</span><br><span class="line">   &#x2F;</span><br><span class="line">  2      index &#x3D; 1      第 2 层</span><br><span class="line"> &#x2F;</span><br><span class="line">2        index &#x3D; 2      第 3 层</span><br></pre></td></tr></table></figure>

<p>对于下图中的递归路径，我们需要保留左边的分支，删除右边的分支，使每层都可以保留一个与上一层相同的元素，同时在每一层中，只能有一个相同的元素。这样就保留了最左侧的分支。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    1</span><br><span class="line">   &#x2F; \</span><br><span class="line">  2   2</span><br><span class="line"> &#x2F;     \</span><br><span class="line">2       2</span><br></pre></td></tr></table></figure>

<p>具体的代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> target, <span class="keyword">int</span>[] candidates, ArrayDeque&lt;Integer&gt; path)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span>(target == <span class="number">0</span>)&#123;</span><br><span class="line">         ans.add(<span class="keyword">new</span> ArrayList(path));</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> index = start; index &lt; candidates.length; index++)&#123;</span><br><span class="line">         <span class="keyword">int</span> cur = candidates[index];</span><br><span class="line">         <span class="keyword">if</span>(target - cur &lt; <span class="number">0</span>)&#123;</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">//跳过重复的元素，当 index == start 时不剪枝，保留最左侧的分支            </span></span><br><span class="line"><span class="keyword">if</span>(index &gt; start &amp;&amp; candidates[index] == candidates[index - <span class="number">1</span>])&#123;</span><br><span class="line">             <span class="keyword">continue</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         </span><br><span class="line">         path.addLast(cur);</span><br><span class="line">         dfs(index + <span class="number">1</span>, target - cur, candidates, path);</span><br><span class="line">         path.removeLast();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>参考：<a href="https://leetcode-cn.com/problems/combination-sum-ii/solution/hui-su-suan-fa-jian-zhi-python-dai-ma-java-dai-m-3/" target="_blank" rel="noopener">weiwei哥的题解</a>。</p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode Medium</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>组合总和III</title>
    <url>/2020/09/11/%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CIII/</url>
    <content><![CDATA[<h4 id="216-组合总和-III"><a href="#216-组合总和-III" class="headerlink" title="216. 组合总和 III"></a><a href="https://leetcode-cn.com/problems/combination-sum-iii/" target="_blank" rel="noopener">216. 组合总和 III</a></h4><p>找出所有相加之和为 <strong><em>n</em></strong> 的 <strong>k</strong> 个数的组合。组合中只允许含有 1 - 9 的正整数，并且每种组合中不存在重复的数字。</p>
<a id="more"></a>

<p><strong>说明：</strong></p>
<ul>
<li>所有数字都是正整数。</li>
<li>解集不能包含重复的组合。 </li>
</ul>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: k &#x3D; 3, n &#x3D; 7</span><br><span class="line">输出: [[1,2,4]]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: k &#x3D; 3, n &#x3D; 9</span><br><span class="line">输出: [[1,2,6], [1,3,5], [2,3,4]]</span><br></pre></td></tr></table></figure>

<p>需要注意的是，不能包含重复的数字，不能包含重复的组合。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum3(<span class="keyword">int</span> k, <span class="keyword">int</span> n) &#123;</span><br><span class="line">        dfs(n, k, <span class="number">1</span>, <span class="keyword">new</span> ArrayDeque&lt;Integer&gt;());</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> n 剩余的数字之和</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> k 剩余的数字个数</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> min 当前能选取的最小数字</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> path 递归路径</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k, <span class="keyword">int</span> min, Deque&lt;Integer&gt; path)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 和为 0 且 剩余数字个数为 0 将当前路径加入结果</span></span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span> &amp;&amp; k == <span class="number">0</span>)&#123;</span><br><span class="line">            ans.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//从最小值开始递归</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = min; k &gt; <span class="number">0</span> &amp;&amp; i &lt;= <span class="number">9</span>; i++)&#123;</span><br><span class="line">            <span class="comment">//剪枝</span></span><br><span class="line">            <span class="keyword">if</span>(i &gt; n)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            path.addLast(i);</span><br><span class="line">            <span class="comment">//下一次选择只能选择比自己大的数字</span></span><br><span class="line">            dfs(n - i, k - <span class="number">1</span>, i + <span class="number">1</span>, path);</span><br><span class="line">            path.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode Medium</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>绝对差不超过限制的最长连续子数组</title>
    <url>/2021/02/21/%E7%BB%9D%E5%AF%B9%E5%B7%AE%E4%B8%8D%E8%B6%85%E8%BF%87%E9%99%90%E5%88%B6%E7%9A%84%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h4 id="1438-绝对差不超过限制的最长连续子数组"><a href="#1438-绝对差不超过限制的最长连续子数组" class="headerlink" title="1438. 绝对差不超过限制的最长连续子数组"></a><a href="https://leetcode-cn.com/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/" target="_blank" rel="noopener">1438. 绝对差不超过限制的最长连续子数组</a></h4><p>给你一个整数数组 <code>nums</code> ，和一个表示限制的整数 <code>limit</code>，请你返回最长连续子数组的长度，该子数组中的任意两个元素之间的绝对差必须小于或者等于 <code>limit</code> <em>。</em></p>
<p>如果不存在满足条件的子数组，则返回 <code>0</code> 。</p>
 <a id="more"></a>

<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [8,2,4,7], limit &#x3D; 4</span><br><span class="line">输出：2 </span><br><span class="line">解释：所有子数组如下：</span><br><span class="line">[8] 最大绝对差 |8-8| &#x3D; 0 &lt;&#x3D; 4.</span><br><span class="line">[8,2] 最大绝对差 |8-2| &#x3D; 6 &gt; 4. </span><br><span class="line">[8,2,4] 最大绝对差 |8-2| &#x3D; 6 &gt; 4.</span><br><span class="line">[8,2,4,7] 最大绝对差 |8-2| &#x3D; 6 &gt; 4.</span><br><span class="line">[2] 最大绝对差 |2-2| &#x3D; 0 &lt;&#x3D; 4.</span><br><span class="line">[2,4] 最大绝对差 |2-4| &#x3D; 2 &lt;&#x3D; 4.</span><br><span class="line">[2,4,7] 最大绝对差 |2-7| &#x3D; 5 &gt; 4.</span><br><span class="line">[4] 最大绝对差 |4-4| &#x3D; 0 &lt;&#x3D; 4.</span><br><span class="line">[4,7] 最大绝对差 |4-7| &#x3D; 3 &lt;&#x3D; 4.</span><br><span class="line">[7] 最大绝对差 |7-7| &#x3D; 0 &lt;&#x3D; 4. </span><br><span class="line">因此，满足题意的最长子数组的长度为 2 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [10,1,2,4,7,2], limit &#x3D; 5</span><br><span class="line">输出：4 </span><br><span class="line">解释：满足题意的最长子数组是 [2,4,7,2]，其最大绝对差 |2-7| &#x3D; 5 &lt;&#x3D; 5 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [4,2,2,2,4,4,2,2], limit &#x3D; 0</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure>

<p> <strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 10^5</code></li>
<li><code>1 &lt;= nums[i] &lt;= 10^9</code></li>
<li><code>0 &lt;= limit &lt;= 10^9</code></li>
</ul>
<p><strong>方法一：暴力法（超时）</strong></p>
<p>直接枚举子数组的开始位置和结束位置，同时维护最大最小值，并判断该子数组是否满足条件。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestSubarray</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> limit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">		<span class="comment">//枚举每一个子数组nums[i ... j]</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="comment">//初始化子数组中最大最小值</span></span><br><span class="line">            <span class="keyword">int</span> min = nums[i], max = nums[i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; n; j++)&#123;<span class="comment">//对于每个子数组，更新最大最小值</span></span><br><span class="line">                <span class="keyword">if</span>(nums[j] &gt; max)&#123;</span><br><span class="line">                    max = nums[j];</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[j] &lt; min)&#123;</span><br><span class="line">                    min = nums[j];</span><br><span class="line">                &#125;</span><br><span class="line">				<span class="comment">//判断子数组是否满足条件并维护结果</span></span><br><span class="line">                <span class="keyword">if</span>(max - min &lt;= limit &amp;&amp; j - i + <span class="number">1</span> &gt; ans)&#123;</span><br><span class="line">                    ans = j - i + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度O(n^2)</li>
<li>空间复杂度O(1)</li>
</ul>
<p><strong>方法二：滑动窗口+单调队列</strong></p>
<p>枚举每一个位置作为右端点，找到其对应的最靠左的左端点，满足区间中最大与最小值不超过 limit。我们分别使用两个单调队列保存最大和最小值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestSubarray</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> limit)</span> </span>&#123;</span><br><span class="line">        Deque&lt;Integer&gt; queMax = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">        Deque&lt;Integer&gt; queMin = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//枚举每一个右端点 right</span></span><br><span class="line">        <span class="keyword">while</span> (right &lt; n) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!queMax.isEmpty() &amp;&amp; queMax.peekLast() &lt; nums[right]) &#123;</span><br><span class="line">                queMax.pollLast();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (!queMin.isEmpty() &amp;&amp; queMin.peekLast() &gt; nums[right]) &#123;</span><br><span class="line">                queMin.pollLast();</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            queMax.offerLast(nums[right]);</span><br><span class="line">            queMin.offerLast(nums[right]);</span><br><span class="line">            <span class="comment">//当 nums[left ... right]不满足条件时将 left 右移</span></span><br><span class="line">            <span class="keyword">while</span> (!queMax.isEmpty() &amp;&amp; !queMin.isEmpty() &amp;&amp; queMax.peekFirst() - queMin.peekFirst() &gt; limit) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[left] == queMin.peekFirst()) &#123;</span><br><span class="line">                    queMin.pollFirst();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (nums[left] == queMax.peekFirst()) &#123;</span><br><span class="line">                    queMax.pollFirst();</span><br><span class="line">                &#125;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            ret = Math.max(ret, right - left + <span class="number">1</span>);</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度O(n)</li>
<li>空间复杂度O(n)</li>
</ul>
<p><strong>方法三：滑动窗口+有序集合</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestSubarray</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> limit)</span> </span>&#123;</span><br><span class="line">        TreeMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> TreeMap&lt;Integer, Integer&gt;();</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (right &lt; n) &#123;</span><br><span class="line">            map.put(nums[right], map.getOrDefault(nums[right], <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">while</span> (map.lastKey() - map.firstKey() &gt; limit) &#123;</span><br><span class="line">                map.put(nums[left], map.get(nums[left]) - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (map.get(nums[left]) == <span class="number">0</span>) &#123;</span><br><span class="line">                    map.remove(nums[left]);</span><br><span class="line">                &#125;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            ret = Math.max(ret, right - left + <span class="number">1</span>);</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode Medium</tag>
        <tag>滑动窗口</tag>
      </tags>
  </entry>
  <entry>
    <title>统计「优美子数组」</title>
    <url>/2020/07/01/%E7%BB%9F%E8%AE%A1%E3%80%8C%E4%BC%98%E7%BE%8E%E5%AD%90%E6%95%B0%E7%BB%84%E3%80%8D/</url>
    <content><![CDATA[<h4 id="1248-统计「优美子数组」"><a href="#1248-统计「优美子数组」" class="headerlink" title="1248. 统计「优美子数组」"></a><a href="https://leetcode-cn.com/problems/count-number-of-nice-subarrays/" target="_blank" rel="noopener">1248. 统计「优美子数组」</a></h4><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code>。</p>
<p>如果某个 <strong>连续</strong> 子数组中恰好有 <code>k</code> 个奇数数字，我们就认为这个子数组是「<strong>优美子数组</strong>」。</p>
<p>请返回这个数组中「优美子数组」的数目。</p>
  <a id="more"></a>

<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [1,1,2,1,1], k &#x3D; 3</span><br><span class="line">输出：2</span><br><span class="line">解释：包含 3 个奇数的子数组是 [1,1,2,1] 和 [1,2,1,1] 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [2,4,6], k &#x3D; 1</span><br><span class="line">输出：0</span><br><span class="line">解释：数列中不包含任何奇数，所以不存在优美子数组。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [2,2,2,1,2,2,1,2,2,2], k &#x3D; 2</span><br><span class="line">输出：16</span><br></pre></td></tr></table></figure>



<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 50000</code></li>
<li><code>1 &lt;= nums[i] &lt;= 10^5</code></li>
<li><code>1 &lt;= k &lt;= nums.length</code></li>
</ul>
<p>在这个题目中偶数是没有用的，我们可以建立一个 odd 数组来记录第 i 个奇数的下标，假设当前枚举到第 i 个，那么 <code>[odd[i], odd[i+k-1]]</code> 这个子数组恰好包含 k 个奇数。这个范围左侧的奇数下标为 odd[i-1], 右侧的奇数下标为 odd[i+k]。如果<code>[odd[i], odd[i+k-1]]</code> 这个包含 k 个奇数的子数组左右侧都右偶数，那么满足条件的包含 k 个奇数的子数组个数为  (<em>odd</em>[<em>i</em>]−<em>odd</em>[<em>i</em>−1])∗(<em>odd</em>[<em>i</em>+<em>k</em>]−<em>odd</em>[<em>i</em>+<em>k</em>−1]) 。我们只要遍历一遍 odd 数组即可求解答案。</p>
<p>边界处理：</p>
<ol>
<li>当 nums[0] 为奇数时，odd[1] = 0，此时左边没有偶数 odd[1] - odd[0] 应该为 1（只有 nums[0] 为子数组左侧边界）。此时 odd[0] = -1。</li>
<li>当记录最后一个奇数时（假设这是第 index 个奇数，对应 nums 数组中的下标为 x）， odd[index] = x, odd[index+1] = nums.length。odd 数组最后一个元素记录的是数组中所有元素的数量。</li>
</ol>
<p>以示例 3 来解释：我们生成的 odd 数组为 [-1, 3, 6, 10]，对其遍历一遍得到结果 (3 - (-1)) * (10-6) = 16。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numberOfSubarrays</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span>[] odd = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//生成 odd 数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span> ; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>( (nums[i] &amp; <span class="number">1</span>) == <span class="number">1</span>)odd[++index] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//边界处理</span></span><br><span class="line">        odd[<span class="number">0</span>] = -<span class="number">1</span>; odd[++index] = n;</span><br><span class="line">		<span class="comment">//计算结果</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i+k &lt;= index; ++i)&#123;</span><br><span class="line">            ans += (odd[i] - odd[i-<span class="number">1</span>])*(odd[i+k] - odd[i+k-<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度O(n)，空间复杂度O(1)。</p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode Medium</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>缺失数字</title>
    <url>/2020/04/09/%E7%BC%BA%E5%A4%B1%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<h4 id="268-缺失数字"><a href="#268-缺失数字" class="headerlink" title="268. 缺失数字"></a><a href="https://leetcode-cn.com/problems/missing-number/" target="_blank" rel="noopener">268. 缺失数字</a></h4><p>给定一个包含 <code>0, 1, 2, ..., n</code> 中 <em>n</em> 个数的序列，找出 0 .. <em>n</em> 中没有出现在序列中的那个数。</p>
 <a id="more"></a>

<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [3,0,1]</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [9,6,4,2,3,5,7,0,1]</span><br><span class="line">输出: 8</span><br></pre></td></tr></table></figure>



<p>利用 2 ^2 = 0 ， 0 ^ 2 = 2 异或运算的特性，我们可以在线性时间复杂度找出缺失的数字。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">missingNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;++i)&#123;</span><br><span class="line">        res=res^(i+<span class="number">1</span>)^nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度O(n)，空间复杂度O(1)。</p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode Easy</tag>
        <tag>数组</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>缺失的第一个正数</title>
    <url>/2020/07/01/%E7%BC%BA%E5%A4%B1%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AD%A3%E6%95%B0/</url>
    <content><![CDATA[<h4 id="41-缺失的第一个正数"><a href="#41-缺失的第一个正数" class="headerlink" title="41. 缺失的第一个正数"></a><a href="https://leetcode-cn.com/problems/first-missing-positive/" target="_blank" rel="noopener">41. 缺失的第一个正数</a></h4><p>给你一个未排序的整数数组，请你找出其中没有出现的最小的正整数。</p>
 <a id="more"></a>

<p> <strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,2,0]</span><br><span class="line">输出: 3</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [3,4,-1,1]</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure>

<p><strong>示例 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [7,8,9,11,12]</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure>

<p> <strong>提示：</strong></p>
<p>你的算法的时间复杂度应为O(<em>n</em>)，并且只能使用常数级别的额外空间。</p>
<p>如果没有时空复杂度要求可以很容易实现：</p>
<ul>
<li>将数组所有数放入哈希表，从 1 开始枚举正整数，并判断其是否在哈希表中。</li>
<li>将从 1 开始枚举正整数，遍历数组判断其是否存在。</li>
</ul>
<p>第一种方法时间复杂度O(n)，空间复杂度O(n)；第二种方法时间复杂度O(n^2)，空间复杂度O(1)。</p>
<p>此题要求时间复杂度O(n)，空间复杂度O(1)。如果题目给的数组是不可修改的，那么不存在满足要求的算法，如果我们可以修改给定的数组，那么可以做到满足要求的算法。</p>
<p><strong>方法一：哈希表</strong></p>
<p>我们可以将给定数组当作哈希表。对于一个长度为 N 的数组来说，没有出现的最小正整数只能在[1, N + 1] 中出现。如果[1, N]都出现，那么答案为 N + 1，否则答案是 [1, N] 中没有出现的最小正整数。这样一来，我们将所有在 [1, N] 中的数放入哈希表，正好数组的长度为 N ，我们可以将其设计为哈希表：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">遍历数组，对于遍历到的数 x ，如果 x ∈ [1, N]，将数组中第 x - 1 个位置（下标从 0 开始）上的数变为负数。在遍历结束后，如果所有位置都为负数，那么答案是 N + 1，否则答案是正数的位置加 1 。</span><br></pre></td></tr></table></figure>
<p>对于数组中的负数我们首先将其变为 N + 1 ，然后遍历数组将[1, N] 中出现的数字对应的位置上的数字变为负数，再次遍历数组，数组中数字为正数的位置加 1 即为结果，全为负数则结果为 N + 1。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">firstMissingPositive</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="comment">//将所有负数变为 n + 1</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">                nums[i] = n + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//上标记</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="comment">//数组中数字可以为负数，应对其取绝对值</span></span><br><span class="line">            <span class="keyword">int</span> x = Math.abs(nums[i]);</span><br><span class="line">            <span class="keyword">if</span>(x &lt; n + <span class="number">1</span>)&#123;</span><br><span class="line">                nums[x - <span class="number">1</span>] = -Math.abs(nums[x - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//再次遍历数组，得到答案</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度O(n)，空间复杂度O(1)。</p>
<p><strong>方法二：置换</strong></p>
<p>与方法一类似，将数组当作哈希表，我们将下标为<code>x - 1</code> 的位置放数字 <code>x</code>。我们对数组进行一次遍历，如果遍历到的数字 x = nums[i] 且 x ∈ [1, N] ，我们直到 x 应该放置在 x - 1 位置上，那么我们交换 nums[i] 和 nums[x - 1]，这样 x 就出现在了正确的位置，注意当 nums[i] == nums[x - 1] 时应该直接进行下次遍历，不再交换。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">firstMissingPositive</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(nums[i] &gt; <span class="number">0</span> &amp;&amp; nums[i] &lt;= n &amp;&amp; nums[nums[i] - <span class="number">1</span>] != nums[i])&#123;</span><br><span class="line">                <span class="keyword">int</span> temp = nums[nums[i] - <span class="number">1</span>];</span><br><span class="line">                nums[nums[i] - <span class="number">1</span>] = nums[i];</span><br><span class="line">                nums[i] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] != i + <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度O(n)，最多进行 n 次交换。空间复杂度O(1)。</p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode Hard</tag>
        <tag>哈希表</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>罗马数字转整数</title>
    <url>/2020/09/19/%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%95%B4%E6%95%B0/</url>
    <content><![CDATA[<h4 id="13-罗马数字转整数"><a href="#13-罗马数字转整数" class="headerlink" title="13. 罗马数字转整数"></a><a href="https://leetcode-cn.com/problems/roman-to-integer/" target="_blank" rel="noopener">13. 罗马数字转整数</a></h4><p>罗马数字包含以下七种字符: <code>I</code>， <code>V</code>， <code>X</code>， <code>L</code>，<code>C</code>，<code>D</code> 和 <code>M</code>。</p>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">字符          数值</span><br><span class="line">I             1</span><br><span class="line">V             5</span><br><span class="line">X             10</span><br><span class="line">L             50</span><br><span class="line">C             100</span><br><span class="line">D             500</span><br><span class="line">M             1000</span><br></pre></td></tr></table></figure>

<p>例如， 罗马数字 2 写做 <code>II</code> ，即为两个并列的 1。12 写做 <code>XII</code> ，即为 <code>X</code> + <code>II</code> 。 27 写做 <code>XXVII</code>, 即为 <code>XX</code> + <code>V</code> + <code>II</code> 。</p>
<p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 <code>IIII</code>，而是 <code>IV</code>。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 <code>IX</code>。这个特殊的规则只适用于以下六种情况：</p>
<ul>
<li><code>I</code> 可以放在 <code>V</code> (5) 和 <code>X</code> (10) 的左边，来表示 4 和 9。</li>
<li><code>X</code> 可以放在 <code>L</code> (50) 和 <code>C</code> (100) 的左边，来表示 40 和 90。 </li>
<li><code>C</code> 可以放在 <code>D</code> (500) 和 <code>M</code> (1000) 的左边，来表示 400 和 900。</li>
</ul>
<p>给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。</p>
<p> <strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;III&quot;</span><br><span class="line">输出: 3</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;IV&quot;</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure>

<p><strong>示例 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;IX&quot;</span><br><span class="line">输出: 9</span><br></pre></td></tr></table></figure>

<p><strong>示例 4:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;LVIII&quot;</span><br><span class="line">输出: 58</span><br><span class="line">解释: L &#x3D; 50, V&#x3D; 5, III &#x3D; 3.</span><br></pre></td></tr></table></figure>

<p><strong>示例 5:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;MCMXCIV&quot;</span><br><span class="line">输出: 1994</span><br><span class="line">解释: M &#x3D; 1000, CM &#x3D; 900, XC &#x3D; 90, IV &#x3D; 4.</span><br></pre></td></tr></table></figure>

<p> <strong>提示：</strong></p>
<ul>
<li>题目所给测试用例皆符合罗马数字书写规则，不会出现跨位等情况。</li>
<li>IC 和 IM 这样的例子并不符合题目要求，49 应该写作 XLIX，999 应该写作 CMXCIX 。</li>
<li>关于罗马数字的详尽书写规则，可以参考 <a href="https://b2b.partcommunity.com/community/knowledge/zh_CN/detail/10753/罗马数字#knowledge_article" target="_blank" rel="noopener">罗马数字 - Mathematics </a>。</li>
</ul>
<p>由题意可知，当一个较小的数放在较大的数左侧时，结果就要减去这个较小的数；当一个较大的数放在较小的数左侧时，结果就要加上这个较大的数。</p>
<p>我们使用一个循环，每次先判断当前数和下一个数的大小，然后维护结果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">romanToInt</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        HashMap&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">'I'</span>, <span class="number">1</span>);</span><br><span class="line">        map.put(<span class="string">'V'</span>, <span class="number">5</span>);</span><br><span class="line">        map.put(<span class="string">'X'</span>, <span class="number">10</span>);</span><br><span class="line">        map.put(<span class="string">'L'</span>, <span class="number">50</span>);</span><br><span class="line">        map.put(<span class="string">'C'</span>, <span class="number">100</span>);</span><br><span class="line">        map.put(<span class="string">'D'</span>, <span class="number">500</span>);</span><br><span class="line">        map.put(<span class="string">'M'</span>, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>, curNum = map.get(s.charAt(<span class="number">0</span>)), nextNum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">            nextNum = map.get(s.charAt(i));</span><br><span class="line">            <span class="keyword">if</span>(curNum &lt; nextNum)&#123;</span><br><span class="line">                ans -= curNum;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ans += curNum;</span><br><span class="line">            &#125;</span><br><span class="line">            curNum = nextNum;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//加上最后一个罗马字符代表的数字</span></span><br><span class="line">        ans += curNum;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>Leetcode Easy</tag>
      </tags>
  </entry>
  <entry>
    <title>组合总和Ⅳ</title>
    <url>/2021/04/28/%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C%E2%85%A3/</url>
    <content><![CDATA[<h4 id="377-组合总和-Ⅳ"><a href="#377-组合总和-Ⅳ" class="headerlink" title="377. 组合总和 Ⅳ"></a><a href="https://leetcode-cn.com/problems/combination-sum-iv/" target="_blank" rel="noopener">377. 组合总和 Ⅳ</a></h4><p>给你一个由 <strong>不同</strong> 整数组成的数组 <code>nums</code> ，和一个目标整数 <code>target</code> 。请你从 <code>nums</code> 中找出并返回总和为 <code>target</code> 的元素组合的个数。</p>
<p>题目数据保证答案符合 32 位整数范围。</p>
 <a id="more"></a>

<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [1,2,3], target &#x3D; 4</span><br><span class="line">输出：7</span><br><span class="line">解释：</span><br><span class="line">所有可能的组合为：</span><br><span class="line">(1, 1, 1, 1)</span><br><span class="line">(1, 1, 2)</span><br><span class="line">(1, 2, 1)</span><br><span class="line">(1, 3)</span><br><span class="line">(2, 1, 1)</span><br><span class="line">(2, 2)</span><br><span class="line">(3, 1)</span><br><span class="line">请注意，顺序不同的序列被视作不同的组合。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [9], target &#x3D; 3</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 200</code></li>
<li><code>1 &lt;= nums[i] &lt;= 1000</code></li>
<li><code>nums</code> 中的所有元素 <strong>互不相同</strong></li>
<li><code>1 &lt;= target &lt;= 1000</code></li>
</ul>
<p><strong>进阶：</strong>如果给定的数组中含有负数会发生什么？问题会产生何种变化？如果允许负数出现，需要向题目中添加哪些限制条件？</p>
<p><strong>方法一：回溯（超时）</strong></p>
<p>我们可以画出搜索路径，很自然写出如下回溯代码</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20210428094002017.png" alt="image-20210428094002017"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">combinationSum4</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> start = <span class="number">0</span>; start &lt; n; ++start)&#123;</span><br><span class="line">            res += backtrack(nums, target, nums[start]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target, <span class="keyword">int</span> cur)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">if</span>(cur &gt; target)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(target == cur)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//每次进入下一层都是从 1 开始</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            res += backtrack(nums, target, cur + nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法二：动态规划</strong></p>
<p>用 dp[x] 选取的元素之和等于 x 的方案数，目标是求 dp[target]。动态规划的边界是 dp[0] = 1。只有当不选取任何元素时，元素之和才为 0 ，因此只有 1 种方案。</p>
<p>当 <code>1 &lt;= i &lt;= target</code>时，如果存在一种排列，其元素之和等于 i，则该排列最后一个元素一定是数组 nums 种的元素。假设该排列最后一个元素是 num，则一定有 num &lt;= i，对于元素之和等于 i - num 的每一种排列，在最后添加 num 之后可以得到一个元素之和等于 i 的排列，因此在计算 dp[i] 时，应该计算所有的 dp[i - num] 之和。</p>
<p>当 <code>1 &lt;= i &lt;= target</code>时，得到如下转移方程：<br>$$<br>dp[i] = sum(dp[i - num]), num \leq i<br>$$<br>初始状态 dp[0] = 1。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">combinationSum4</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[target + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; dp.length; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">                <span class="keyword">if</span>(num &lt;= i)&#123;</span><br><span class="line">                    dp[i] += dp[i - num];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度O(target * n)，target 是 目标值，n 是 数组 nums 的长度。</li>
<li>空间复杂度O(target)</li>
</ul>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode Medium</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>翻转图像</title>
    <url>/2021/02/24/%E7%BF%BB%E8%BD%AC%E5%9B%BE%E5%83%8F/</url>
    <content><![CDATA[<h4 id="832-翻转图像"><a href="#832-翻转图像" class="headerlink" title="832. 翻转图像"></a><a href="https://leetcode-cn.com/problems/flipping-an-image/" target="_blank" rel="noopener">832. 翻转图像</a></h4><p>给定一个二进制矩阵 <code>A</code>，我们想先水平翻转图像，然后反转图像并返回结果。</p>
<p>水平翻转图片就是将图片的每一行都进行翻转，即逆序。例如，水平翻转 <code>[1, 1, 0]</code> 的结果是 <code>[0, 1, 1]</code>。</p>
<p>反转图片的意思是图片中的 <code>0</code> 全部被 <code>1</code> 替换， <code>1</code> 全部被 <code>0</code> 替换。例如，反转 <code>[0, 1, 1]</code> 的结果是 <code>[1, 0, 0]</code>。</p>
<a id="more"></a>

<p> <strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[[1,1,0],[1,0,1],[0,0,0]]</span><br><span class="line">输出：[[1,0,0],[0,1,0],[1,1,1]]</span><br><span class="line">解释：首先翻转每一行: [[0,1,1],[1,0,1],[0,0,0]]；</span><br><span class="line">     然后反转图片: [[1,0,0],[0,1,0],[1,1,1]]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[[1,1,0,0],[1,0,0,1],[0,1,1,1],[1,0,1,0]]</span><br><span class="line">输出：[[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]</span><br><span class="line">解释：首先翻转每一行: [[0,0,1,1],[1,0,0,1],[1,1,1,0],[0,1,0,1]]；</span><br><span class="line">     然后反转图片: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]</span><br></pre></td></tr></table></figure>

<p> <strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= A.length = A[0].length &lt;= 20</code></li>
<li><code>0 &lt;= A[i][j] &lt;= 1</code></li>
</ul>
<p><strong>方法一：双指针</strong></p>
<p>对于每一行元素，我们使用 left 和 right 指针来对该行元素进行水平翻转和反转操作。</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">left</th>
<th align="center">right</th>
<th align="center">处理后left</th>
<th align="center">处理后right</th>
</tr>
</thead>
<tbody><tr>
<td align="center">①</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">②</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">③</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">④</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">0</td>
</tr>
</tbody></table>
<p>我们可以发现，当 left 和 right 指向的值相等时时，元素才需要变化，只用用该元素与 1 异或。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] flipAndInvertImage(<span class="keyword">int</span>[][] A) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = A.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> left = <span class="number">0</span>, right = n - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">                <span class="keyword">if</span>(A[i][left] == A[i][right])&#123;</span><br><span class="line">                    A[i][left] ^= <span class="number">1</span>;</span><br><span class="line">                    A[i][right] ^= <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                ++left;</span><br><span class="line">                --right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//当一行元素个数为奇数时，需要将最中间的数翻转</span></span><br><span class="line">            <span class="keyword">if</span>(left == right)&#123;</span><br><span class="line">                A[i][left] ^= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> A;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度O(n^2)</li>
<li>空间复杂度O(1)</li>
</ul>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode Easy</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>螺旋矩阵</title>
    <url>/2021/03/15/%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/</url>
    <content><![CDATA[<h4 id="54-螺旋矩阵"><a href="#54-螺旋矩阵" class="headerlink" title="54. 螺旋矩阵"></a><a href="https://leetcode-cn.com/problems/spiral-matrix/" target="_blank" rel="noopener">54. 螺旋矩阵</a></h4><p>给你一个 <code>m</code> 行 <code>n</code> 列的矩阵 <code>matrix</code> ，请按照 <strong>顺时针螺旋顺序</strong> ，返回矩阵中的所有元素。</p>
 <a id="more"></a>

<p><strong>示例 1：</strong></p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20210315095358506.png" alt="image-20210315095358506"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：matrix &#x3D; [[1,2,3],[4,5,6],[7,8,9]]</span><br><span class="line">输出：[1,2,3,6,9,8,7,4,5]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20210315095445985.png" alt="image-20210315095445985"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：matrix &#x3D; [[1,2,3,4],[5,6,7,8],[9,10,11,12]]</span><br><span class="line">输出：[1,2,3,4,8,12,11,10,9,5,6,7]</span><br></pre></td></tr></table></figure>

<p> <strong>提示：</strong></p>
<ul>
<li><code>m == matrix.length</code></li>
<li><code>n == matrix[i].length</code></li>
<li><code>1 &lt;= m, n &lt;= 10</code></li>
<li><code>-100 &lt;= matrix[i][j] &lt;= 100</code></li>
</ul>
<p><strong>方法一：模拟</strong></p>
<p>我们可以确定箭头方向顺序为：向右、向下、向左、向上。使用一个数组来保存访问过的元素，在遍历过程中，如果遇到数组边界或已经访问过的元素，改变到下一个方向，继续访问。直到结果数组中的元素个数等于矩阵中元素个数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">spiralOrder</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; order = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//特殊情况处理</span></span><br><span class="line">        <span class="keyword">if</span>(matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> order;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> rows = matrix.length, cols = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">boolean</span>[][] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[rows][cols];</span><br><span class="line">        <span class="keyword">int</span>[][] directions = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;,&#123;<span class="number">1</span>, <span class="number">0</span>&#125;,&#123;<span class="number">0</span>, -<span class="number">1</span>&#125;,&#123;-<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">int</span> total = rows * cols;</span><br><span class="line">        <span class="keyword">int</span> directionIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> row = <span class="number">0</span>, col = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; total; i++)&#123;</span><br><span class="line">            order.add(matrix[row][col]);</span><br><span class="line">            visited[row][col] = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">int</span> nextRow = row + directions[directionIndex][<span class="number">0</span>], nextCol = col + directions[directionIndex][<span class="number">1</span>];</span><br><span class="line">            <span class="comment">//遇到边界或已经访问过的元素，改变方向</span></span><br><span class="line">            <span class="keyword">if</span>(nextRow &lt; <span class="number">0</span> || nextRow &gt;= rows || nextCol &lt; <span class="number">0</span> || nextCol &gt;= cols || visited[nextRow][nextCol])&#123;</span><br><span class="line">                directionIndex = (directionIndex + <span class="number">1</span>) % <span class="number">4</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            row += directions[directionIndex][<span class="number">0</span>];</span><br><span class="line">            col += directions[directionIndex][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> order;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度O(n)，n 为矩阵中元素个数</li>
<li>空间复杂度O(n)</li>
</ul>
<p><strong>方法二：按层遍历</strong></p>
<p>将矩阵看成若干层，依次输出每一层的元素。</p>
<p>对于一个矩阵，我们可以使用四个点来确定其范围，分别是左上角[top, left]，右上角[top, right]，左下角[bottom, left]，右下角[bottom, right]。</p>
<p>访问当前层的元素顺序分别为：</p>
<ol>
<li><p>[top][left] … [top][right]</p>
</li>
<li><p>[top + 1][right] … [bottom][right]</p>
</li>
<li><p>[bottom][right - 1] … [bottom][left]</p>
</li>
<li><p>[bottom - 1][left] … [top + 1][left]</p>
</li>
</ol>
<p>需要注意的是，当矩阵为一行元素（top == bottom）时，步骤1、3会造成元素重复访问;当矩阵为一列元素（left == right）时，步骤2、4 会造成元素重复访问。所以需要在访问步骤 3、4外面加上 <code>top &lt; bottom &amp;&amp; left &lt; right</code>限制，来使这两个重复访问只执行一次。</p>
<p>要访问下一层元素，将 left 和 top 加一，right 和 bottom 减一即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">spiralOrder</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; order = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> order;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> rows = matrix.length, cols = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = cols - <span class="number">1</span>, bottom = rows - <span class="number">1</span>, top = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right &amp;&amp; top &lt;= bottom)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = left; i &lt;= right; i++)&#123;</span><br><span class="line">                order.add(matrix[top][i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = top + <span class="number">1</span>; i &lt;= bottom; i++)&#123;</span><br><span class="line">                order.add(matrix[i][right]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//访问限制</span></span><br><span class="line">            <span class="keyword">if</span>(left &lt; right &amp;&amp; top &lt; bottom)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = right - <span class="number">1</span>; i &gt;= left; --i)&#123;</span><br><span class="line">                    order.add(matrix[bottom][i]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = bottom - <span class="number">1</span>; i &gt;= top + <span class="number">1</span>; --i)&#123;</span><br><span class="line">                    order.add(matrix[i][left]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            ++top;</span><br><span class="line">            ++left;</span><br><span class="line">            --right;</span><br><span class="line">            --bottom;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> order;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度O(n)，n 为矩阵中元素个数</li>
<li>空间复杂度O(1)</li>
</ul>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>表示数值的字符串</title>
    <url>/2020/09/02/%E8%A1%A8%E7%A4%BA%E6%95%B0%E5%80%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<h4 id="剑指-Offer-20-表示数值的字符串"><a href="#剑指-Offer-20-表示数值的字符串" class="headerlink" title="剑指 Offer 20. 表示数值的字符串"></a><a href="https://leetcode-cn.com/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof/" target="_blank" rel="noopener">剑指 Offer 20. 表示数值的字符串</a></h4><p>请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串”+100”、”5e2”、”-123”、”3.1416”、”-1E-16”、”0123”都表示数值，但”12e”、”1a3.14”、”1.2.3”、”+-5”及”12e+5.4”都不是。</p>
<a id="more"></a>

<p>确定有限状态自动机是一类计算模型。它包含一系列状态，这些状态中：</p>
<ul>
<li>有一个特殊状态，被称为<em>初始状态</em>。</li>
<li>还有一系列状态被称为<em>接受状态</em>，他们组成了一个特殊的集合。其中一个状态可能既是<em>初始状态</em>，也是<em>接受状态</em>。</li>
</ul>
<p>起初这个自动机处于初始状态，然后，它顺序地读取字符串中地每一个字符，并根据当前状态和读入的字符，按照某个事先约定好地转移规则，从当前状态转移到下一个状态，当状态转移完成后，它继续读取下一个字符。当字符串读完后，如果这个自动机处于某个接受状态，则判断该字符串被接受；否则判定该字符串被拒绝。</p>
<p>如果在输入的过程中某一步转移失败了，判断字符串被拒绝。</p>
<p>用「当前处理到字符串的哪个部分」当作状态的表述。根据这一技巧，不难挖掘出所有状态：</p>
<ol>
<li>起始的空格</li>
<li>符号位</li>
<li>整数部分</li>
<li>左侧有整数的小数点</li>
<li>左侧无整数的小数点（根据前面的第二条额外规则，需要对左侧有无整数的两种小数点做区分）</li>
<li>小数部分</li>
<li>字符 e</li>
<li>指数部分的符号位</li>
<li>指数部分的整数部分</li>
<li>末尾的空格</li>
</ol>
<p>将状态之间的转移规则画成图。</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20200902095846914.png" alt="image-20200902095846914"></p>
<p>我们需要处理转移失败的情况。为了处理这种情况，我们创建一个特殊的拒绝状态，一旦自动机转移到这个特殊状态，我们可以立即判定该字符串不被接受。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isNumber</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//存储每个点的起始状态和接受状态</span></span><br><span class="line">        Map&lt;State, Map&lt;CharType, State&gt;&gt; transfer = <span class="keyword">new</span> HashMap&lt;State, Map&lt;CharType, State&gt;&gt;();</span><br><span class="line">        Map&lt;CharType, State&gt; initialMap = <span class="keyword">new</span> HashMap&lt;CharType, State&gt;() &#123;&#123;</span><br><span class="line">            put(CharType.CHAR_SPACE, State.STATE_INITIAL);</span><br><span class="line">            put(CharType.CHAR_NUMBER, State.STATE_INTEGER);</span><br><span class="line">            put(CharType.CHAR_POINT, State.STATE_POINT_WITHOUT_INT);</span><br><span class="line">            put(CharType.CHAR_SIGN, State.STATE_INT_SIGN);</span><br><span class="line">        &#125;&#125;;</span><br><span class="line">        transfer.put(State.STATE_INITIAL, initialMap);</span><br><span class="line">        Map&lt;CharType, State&gt; intSignMap = <span class="keyword">new</span> HashMap&lt;CharType, State&gt;() &#123;&#123;</span><br><span class="line">            put(CharType.CHAR_NUMBER, State.STATE_INTEGER);</span><br><span class="line">            put(CharType.CHAR_POINT, State.STATE_POINT_WITHOUT_INT);</span><br><span class="line">        &#125;&#125;;</span><br><span class="line">        transfer.put(State.STATE_INT_SIGN, intSignMap);</span><br><span class="line">        Map&lt;CharType, State&gt; integerMap = <span class="keyword">new</span> HashMap&lt;CharType, State&gt;() &#123;&#123;</span><br><span class="line">            put(CharType.CHAR_NUMBER, State.STATE_INTEGER);</span><br><span class="line">            put(CharType.CHAR_EXP, State.STATE_EXP);</span><br><span class="line">            put(CharType.CHAR_POINT, State.STATE_POINT);</span><br><span class="line">            put(CharType.CHAR_SPACE, State.STATE_END);</span><br><span class="line">        &#125;&#125;;</span><br><span class="line">        transfer.put(State.STATE_INTEGER, integerMap);</span><br><span class="line">        Map&lt;CharType, State&gt; pointMap = <span class="keyword">new</span> HashMap&lt;CharType, State&gt;() &#123;&#123;</span><br><span class="line">            put(CharType.CHAR_NUMBER, State.STATE_FRACTION);</span><br><span class="line">            put(CharType.CHAR_EXP, State.STATE_EXP);</span><br><span class="line">            put(CharType.CHAR_SPACE, State.STATE_END);</span><br><span class="line">        &#125;&#125;;</span><br><span class="line">        transfer.put(State.STATE_POINT, pointMap);</span><br><span class="line">        Map&lt;CharType, State&gt; pointWithoutIntMap = <span class="keyword">new</span> HashMap&lt;CharType, State&gt;() &#123;&#123;</span><br><span class="line">            put(CharType.CHAR_NUMBER, State.STATE_FRACTION);</span><br><span class="line">        &#125;&#125;;</span><br><span class="line">        transfer.put(State.STATE_POINT_WITHOUT_INT, pointWithoutIntMap);</span><br><span class="line">        Map&lt;CharType, State&gt; fractionMap = <span class="keyword">new</span> HashMap&lt;CharType, State&gt;() &#123;&#123;</span><br><span class="line">            put(CharType.CHAR_NUMBER, State.STATE_FRACTION);</span><br><span class="line">            put(CharType.CHAR_EXP, State.STATE_EXP);</span><br><span class="line">            put(CharType.CHAR_SPACE, State.STATE_END);</span><br><span class="line">        &#125;&#125;;</span><br><span class="line">        transfer.put(State.STATE_FRACTION, fractionMap);</span><br><span class="line">        Map&lt;CharType, State&gt; expMap = <span class="keyword">new</span> HashMap&lt;CharType, State&gt;() &#123;&#123;</span><br><span class="line">            put(CharType.CHAR_NUMBER, State.STATE_EXP_NUMBER);</span><br><span class="line">            put(CharType.CHAR_SIGN, State.STATE_EXP_SIGN);</span><br><span class="line">        &#125;&#125;;</span><br><span class="line">        transfer.put(State.STATE_EXP, expMap);</span><br><span class="line">        Map&lt;CharType, State&gt; expSignMap = <span class="keyword">new</span> HashMap&lt;CharType, State&gt;() &#123;&#123;</span><br><span class="line">            put(CharType.CHAR_NUMBER, State.STATE_EXP_NUMBER);</span><br><span class="line">        &#125;&#125;;</span><br><span class="line">        transfer.put(State.STATE_EXP_SIGN, expSignMap);</span><br><span class="line">        Map&lt;CharType, State&gt; expNumberMap = <span class="keyword">new</span> HashMap&lt;CharType, State&gt;() &#123;&#123;</span><br><span class="line">            put(CharType.CHAR_NUMBER, State.STATE_EXP_NUMBER);</span><br><span class="line">            put(CharType.CHAR_SPACE, State.STATE_END);</span><br><span class="line">        &#125;&#125;;</span><br><span class="line">        transfer.put(State.STATE_EXP_NUMBER, expNumberMap);</span><br><span class="line">        Map&lt;CharType, State&gt; endMap = <span class="keyword">new</span> HashMap&lt;CharType, State&gt;() &#123;&#123;</span><br><span class="line">            put(CharType.CHAR_SPACE, State.STATE_END);</span><br><span class="line">        &#125;&#125;;</span><br><span class="line">        transfer.put(State.STATE_END, endMap);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> length = s.length();</span><br><span class="line">        State state = State.STATE_INITIAL;</span><br><span class="line">		<span class="comment">//从开始状态开始转移</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            CharType type = toCharType(s.charAt(i));</span><br><span class="line">            <span class="keyword">if</span> (!transfer.get(state).containsKey(type)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                state = transfer.get(state).get(type);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最后字符除了 初始状态、整数前面的符号，左边没有数字的小数点，指数 e 和指数 e 的负号不被接受，其他状态全部接受</span></span><br><span class="line">        <span class="keyword">return</span> state == State.STATE_INTEGER || state == State.STATE_POINT || state == State.STATE_FRACTION || state == State.STATE_EXP_NUMBER || state == State.STATE_END;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CharType <span class="title">toCharType</span><span class="params">(<span class="keyword">char</span> ch)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ch &gt;= <span class="string">'0'</span> &amp;&amp; ch &lt;= <span class="string">'9'</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> CharType.CHAR_NUMBER;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">'e'</span> || ch == <span class="string">'E'</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> CharType.CHAR_EXP;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">'.'</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> CharType.CHAR_POINT;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">'+'</span> || ch == <span class="string">'-'</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> CharType.CHAR_SIGN;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">' '</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> CharType.CHAR_SPACE;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> CharType.CHAR_ILLEGAL;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">enum</span> State &#123;</span><br><span class="line">        STATE_INITIAL,</span><br><span class="line">        STATE_INT_SIGN,</span><br><span class="line">        STATE_INTEGER,</span><br><span class="line">        STATE_POINT,</span><br><span class="line">        STATE_POINT_WITHOUT_INT,</span><br><span class="line">        STATE_FRACTION,</span><br><span class="line">        STATE_EXP,</span><br><span class="line">        STATE_EXP_SIGN,</span><br><span class="line">        STATE_EXP_NUMBER,</span><br><span class="line">        STATE_END,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">enum</span> CharType &#123;</span><br><span class="line">        CHAR_NUMBER,</span><br><span class="line">        CHAR_EXP,</span><br><span class="line">        CHAR_POINT,</span><br><span class="line">        CHAR_SIGN,</span><br><span class="line">        CHAR_SPACE,</span><br><span class="line">        CHAR_ILLEGAL,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度O(N)，空间复杂度O(1)。</p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode Medium</tag>
        <tag>自动机</tag>
      </tags>
  </entry>
  <entry>
    <title>被围绕的区域</title>
    <url>/2020/08/11/%E8%A2%AB%E5%9B%B4%E7%BB%95%E7%9A%84%E5%8C%BA%E5%9F%9F/</url>
    <content><![CDATA[<h4 id="130-被围绕的区域"><a href="#130-被围绕的区域" class="headerlink" title="130. 被围绕的区域"></a><a href="https://leetcode-cn.com/problems/surrounded-regions/" target="_blank" rel="noopener">130. 被围绕的区域</a></h4><p>给定一个二维的矩阵，包含 <code>&#39;X&#39;</code> 和 <code>&#39;O&#39;</code>（<strong>字母 O</strong>）。</p>
<p>找到所有被 <code>&#39;X&#39;</code> 围绕的区域，并将这些区域里所有的 <code>&#39;O&#39;</code> 用 <code>&#39;X&#39;</code> 填充。</p>
<a id="more"></a>

<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">X X X X</span><br><span class="line">X O O X</span><br><span class="line">X X O X</span><br><span class="line">X O X X</span><br></pre></td></tr></table></figure>

<p>运行你的函数后，矩阵变为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">X X X X</span><br><span class="line">X X X X</span><br><span class="line">X X X X</span><br><span class="line">X O X X</span><br></pre></td></tr></table></figure>

<p><strong>解释:</strong></p>
<p>被围绕的区间不会存在于边界上，换句话说，任何边界上的 <code>&#39;O&#39;</code> 都不会被填充为 <code>&#39;X&#39;</code>。 任何不在边界上，或不与边界上的 <code>&#39;O&#39;</code> 相连的 <code>&#39;O&#39;</code> 最终都会被填充为 <code>&#39;X&#39;</code>。如果两个元素在水平或垂直方向相邻，则称它们是“相连”的。</p>
<p>自己的想法：从每一个字母<code>O</code>（不在边界上）开始DFS，遇到四个 X 返回，在返回过程中将 O 修改为 X；如果碰到边界，直接返回。</p>
<p>发现返回的条件太复杂，不会实现。</p>
<p>下面是官方题解：</p>
<p>给定矩阵中有三种元素：</p>
<ul>
<li>字母X</li>
<li>被字母 X 包围的字母 O</li>
<li>没有被字母 X 包围的字母 O</li>
</ul>
<p>要判断字母 O 是否被字母 X 包围比较困难，注意到：<strong>任何边界上的 <code>O</code> 都不会被填充为<code>X</code></strong>。我们可以想到，所有不被 X 包围的 O 都与边界上的 O 相连。我们利用这个性质判断 O 是否被 X 包围：</p>
<ul>
<li>对于每个边界上的 O，我们以它为起点，标记所有与之相连或间接相连的字母 O</li>
<li>遍历这个矩阵，对于每个字母：<ul>
<li>如果该字母被标记过，则表示它没有被字母X包围，将其恢复为 O</li>
<li>如果该字母没有被标记，则表示它被字母 X 包围，将其改为 X</li>
</ul>
</li>
</ul>
<p><strong>方法一：DFS</strong></p>
<p>使用深度优先搜索实现标记，我们将标记过的字母 O 改为 字母A。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> m, n;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">        m = board.length;</span><br><span class="line">        <span class="keyword">if</span>(m == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        n = board[<span class="number">0</span>].length;</span><br><span class="line">		<span class="comment">//标记与边界相连的字母 O</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">            dfs(board, i, <span class="number">0</span>);</span><br><span class="line">            dfs(board, i, n - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//标记与边界相连的字母 O</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n - <span class="number">1</span>; i++)&#123;</span><br><span class="line">            dfs(board, <span class="number">0</span>, i);</span><br><span class="line">            dfs(board, m - <span class="number">1</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//处理每一个字母</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j] == <span class="string">'A'</span>)&#123;</span><br><span class="line">                    board[i][j] = <span class="string">'O'</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(board[i][j] == <span class="string">'O'</span>)&#123;</span><br><span class="line">                    board[i][j] = <span class="string">'X'</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x &lt; <span class="number">0</span> || x &gt;= m || y &lt; <span class="number">0</span> || y &gt;= n || board[x][y] != <span class="string">'O'</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//标记与边界相连的字母 O</span></span><br><span class="line">        board[x][y] = <span class="string">'A'</span>;</span><br><span class="line">        dfs(board, x + <span class="number">1</span>, y);</span><br><span class="line">        dfs(board, x - <span class="number">1</span>, y);</span><br><span class="line">        dfs(board, x, y + <span class="number">1</span>);</span><br><span class="line">        dfs(board, x, y - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度O(mn)，空间复杂度O(mn)。m，n为矩阵的长宽。</p>
<p><strong>方法二：BFS</strong></p>
<p>我们使用广度优先搜索来实现标记，同样，将标记过的字母 O 改为 字母A。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] dx = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span>[] dy = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = board.length;</span><br><span class="line">        <span class="keyword">if</span>(m == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> n = board[<span class="number">0</span>].length;</span><br><span class="line">        Queue&lt;<span class="keyword">int</span>[]&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">		<span class="comment">//将边界上的字母 O 坐标加入队列</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(board[i][<span class="number">0</span>] == <span class="string">'O'</span>) queue.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i, <span class="number">0</span>&#125;);</span><br><span class="line">            <span class="keyword">if</span>(board[i][n - <span class="number">1</span>] == <span class="string">'O'</span>) queue.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i, n - <span class="number">1</span>&#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n - <span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(board[<span class="number">0</span>][i] == <span class="string">'O'</span>) queue.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>, i&#125;);</span><br><span class="line">            <span class="keyword">if</span>(board[m - <span class="number">1</span>][i] == <span class="string">'O'</span>)queue.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;m - <span class="number">1</span>, i&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//将边界上的字母 O 坐标加入队列</span></span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="comment">//从队列中取出一个字母 O，对其标记</span></span><br><span class="line">            <span class="keyword">int</span>[] t = queue.poll();</span><br><span class="line">            <span class="keyword">int</span> x = t[<span class="number">0</span>], y = t[<span class="number">1</span>];</span><br><span class="line">            board[x][y] = <span class="string">'A'</span>;</span><br><span class="line">			<span class="comment">//将当前字母 O 相连的字母 O 坐标加入队列</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)&#123;</span><br><span class="line">                <span class="keyword">int</span> nx = x + dx[i], ny = y + dy[i];</span><br><span class="line">                <span class="keyword">if</span>(nx &lt; <span class="number">0</span> || nx &gt;= m || ny &lt; <span class="number">0</span> || ny &gt;= n || board[nx][ny] != <span class="string">'O'</span>)&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                queue.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;nx, ny&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//处理每一个字母</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j] == <span class="string">'A'</span>)&#123;</span><br><span class="line">                    board[i][j] = <span class="string">'O'</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(board[i][j] == <span class="string">'O'</span>)&#123;</span><br><span class="line">                    board[i][j] = <span class="string">'X'</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度O(mn)，空间复杂度O(mn)。m，n为矩阵的长宽。</p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode Medium</tag>
        <tag>DFS</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title>视频拼接</title>
    <url>/2020/10/24/%E8%A7%86%E9%A2%91%E6%8B%BC%E6%8E%A5/</url>
    <content><![CDATA[<h4 id="1024-视频拼接"><a href="#1024-视频拼接" class="headerlink" title="1024. 视频拼接"></a><a href="https://leetcode-cn.com/problems/video-stitching/" target="_blank" rel="noopener">1024. 视频拼接</a></h4><p>你将会获得一系列视频片段，这些片段来自于一项持续时长为 <code>T</code> 秒的体育赛事。这些片段可能有所重叠，也可能长度不一。</p>
<p>视频片段 <code>clips[i]</code> 都用区间进行表示：开始于 <code>clips[i][0]</code> 并于 <code>clips[i][1]</code> 结束。我们甚至可以对这些片段自由地再剪辑，例如片段 <code>[0, 7]</code> 可以剪切成 <code>[0, 1] + [1, 3] + [3, 7]</code> 三部分。</p>
<p>我们需要将这些片段进行再剪辑，并将剪辑后的内容拼接成覆盖整个运动过程的片段（<code>[0, T]</code>）。返回所需片段的最小数目，如果无法完成该任务，则返回 <code>-1</code> 。</p>
 <a id="more"></a>

<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：clips &#x3D; [[0,2],[4,6],[8,10],[1,9],[1,5],[5,9]], T &#x3D; 10</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">我们选中 [0,2], [8,10], [1,9] 这三个片段。</span><br><span class="line">然后，按下面的方案重制比赛片段：</span><br><span class="line">将 [1,9] 再剪辑为 [1,2] + [2,8] + [8,9] 。</span><br><span class="line">现在我们手上有 [0,2] + [2,8] + [8,10]，而这些涵盖了整场比赛 [0, 10]。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：clips &#x3D; [[0,1],[1,2]], T &#x3D; 5</span><br><span class="line">输出：-1</span><br><span class="line">解释：</span><br><span class="line">我们无法只用 [0,1] 和 [1,2] 覆盖 [0,5] 的整个过程。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：clips &#x3D; [[0,1],[6,8],[0,2],[5,6],[0,4],[0,3],[6,7],[1,3],[4,7],[1,4],[2,5],[2,6],[3,4],[4,5],[5,7],[6,9]], T &#x3D; 9</span><br><span class="line">输出：3</span><br><span class="line">解释： </span><br><span class="line">我们选取片段 [0,4], [4,7] 和 [6,9] 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 4：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：clips &#x3D; [[0,4],[2,8]], T &#x3D; 5</span><br><span class="line">输出：2</span><br><span class="line">解释：</span><br><span class="line">注意，你可能录制超过比赛结束时间的视频。</span><br></pre></td></tr></table></figure>

<p> <strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= clips.length &lt;= 100</code></li>
<li><code>0 &lt;= clips[i][0] &lt;= clips[i][1] &lt;= 100</code></li>
<li><code>0 &lt;= T &lt;= 100</code></li>
</ul>
<p><strong>方法一：动态规划</strong></p>
<p>我们使用 <code>dp[i]</code>表示整个运动过程<code>[0, i]</code>所需的最小片段数。我们遍历每段 clip ，如果 i 在这段 clip 中（<code>clip[0] &lt; i &lt;= clip[1]</code>），那么使用 <code>dp[clip[0]]</code> 和 当前这一段clip就可覆盖<code>[0,1]</code>.对于符合情况的每段 clip，我们统计 dp[i] 的最小值即可。<br>$$<br>dp[i] = min(dp[i], dp[clip[0]] + 1), (clip[0] &lt; i \leq clip[1])<br>$$</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">videoStitching</span><span class="params">(<span class="keyword">int</span>[][] clips, <span class="keyword">int</span> T)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[T + <span class="number">1</span>];</span><br><span class="line">        Arrays.fill(dp, Integer.MAX_VALUE - <span class="number">1</span>);</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= T; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span>[] clip : clips)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i &gt; clip[<span class="number">0</span>] &amp;&amp; i &lt;= clip[<span class="number">1</span>])&#123;</span><br><span class="line">                    dp[i] = Math.min(dp[i], dp[clip[<span class="number">0</span>]] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[T] == Integer.MAX_VALUE - <span class="number">1</span> ? -<span class="number">1</span> : dp[T];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度O(T * N)，T 是区间的长度，N 是子区间的数量。</li>
<li>空间复杂度O(T)，T 是区间的长度。</li>
</ul>
<p><strong>方法二：贪心</strong></p>
<p>对于每一段左端点相等的视频片段，右端点越远越好。对于每个位置 i，我们记录以其为左端点中最远的右节点<code>maxn[i]</code>。</p>
<p>每遍历到一个位置 i ，我们需要更新当前位置能到达的最远处 last，如果更新后 last == i，那么说明下一个位置不能被覆盖，返回 -1。</p>
<p>同时我们需要维护上一个区间的结束位置 pre，每次我们越过一个旧的子区间，到达一个新的子区间，这个子区间的结束位置就为 last，此时令 pre = last，答案加 1 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">videoStitching</span><span class="params">(<span class="keyword">int</span>[][] clips, <span class="keyword">int</span> T)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] maxn = <span class="keyword">new</span> <span class="keyword">int</span>[T];</span><br><span class="line">        <span class="keyword">int</span> pre = <span class="number">0</span>, last = <span class="number">0</span>, res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] clip : clips)&#123;</span><br><span class="line">            <span class="keyword">if</span>(clip[<span class="number">0</span>] &lt; T)&#123;</span><br><span class="line">                maxn[clip[<span class="number">0</span>]] = Math.max(clip[<span class="number">1</span>], maxn[clip[<span class="number">0</span>]]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; T; i++)&#123;</span><br><span class="line">            last = Math.max(last, maxn[i]);</span><br><span class="line">            <span class="keyword">if</span>(i == last)&#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i == pre)&#123;</span><br><span class="line">                pre = last;</span><br><span class="line">                ++res;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度O(T + N)，O(N)时间对子区间进行预处理，O(T)时间枚举每个位置。</li>
<li>空间复杂度O(T)</li>
</ul>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode Medium</tag>
        <tag>动态规划</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>解决maven依赖下载慢的问题</title>
    <url>/2020/04/04/%E8%A7%A3%E5%86%B3%20IDEA%20%E5%AF%BC%E5%85%A5%E9%A1%B9%E7%9B%AE%E5%90%8E%E4%BE%9D%E8%B5%96%E4%B8%8B%E8%BD%BD%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="解决-IDEA-导入项目后依赖下载慢的问题"><a href="#解决-IDEA-导入项目后依赖下载慢的问题" class="headerlink" title="解决 IDEA 导入项目后依赖下载慢的问题"></a>解决 IDEA 导入项目后依赖下载慢的问题</h1><p>我们找到 IDEA 安装目录下 C:\Program Files\JetBrains\IntelliJ IDEA 2019.3.3\plugins\maven\lib<br>里面会有 maven2 和 maven3 还有其他的文件夹但我们不会去用它们。<br>进入maven3\conf 修改里面的settings.xml<br>在mirrors标签块添加如下代码</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">     <span class="tag">&lt;<span class="name">mirror</span>&gt;</span>  </span><br><span class="line">      <span class="tag">&lt;<span class="name">id</span>&gt;</span>alimaven<span class="tag">&lt;/<span class="name">id</span>&gt;</span>  </span><br><span class="line">      <span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun maven<span class="tag">&lt;/<span class="name">name</span>&gt;</span>  </span><br><span class="line">      <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span>  </span><br><span class="line">      <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span>          </span><br><span class="line"><span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title>解决Github访问不了的问题</title>
    <url>/2020/04/04/%E8%A7%A3%E5%86%B3Github%E8%AE%BF%E9%97%AE%E4%B8%8D%E4%BA%86%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="解决Github访问不了的问题"><a href="#解决Github访问不了的问题" class="headerlink" title="解决Github访问不了的问题"></a>解决Github访问不了的问题</h1><p>修改hosts文件 hosts在windows中位于C:\Windows\System32\drivers\etc目录下</p>
<p>将文件只读去掉</p>
<p>添加</p>
<p>192.30.253.112 github.com<br>192.30.253.119 gist.github.com<br>151.101.100.133 assets-cdn.github.com<br>151.101.100.133 raw.githubusercontent.com<br>151.101.100.133 gist.githubusercontent.com<br>151.101.100.133 cloud.githubusercontent.com<br>151.101.100.133 camo.githubusercontent.com<br>151.101.100.133 avatars0.githubusercontent.com<br>151.101.100.133 avatars1.githubusercontent.com<br>151.101.100.133 avatars2.githubusercontent.com<br>151.101.100.133 avatars3.githubusercontent.com<br>151.101.100.133 avatars4.githubusercontent.com<br>151.101.100.133 avatars5.githubusercontent.com<br>151.101.100.133 avatars6.githubusercontent.com<br>151.101.100.133 avatars7.githubusercontent.com<br>151.101.100.133 avatars8.githubusercontent.com</p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Github</tag>
      </tags>
  </entry>
  <entry>
    <title>解数独</title>
    <url>/2020/09/15/%E8%A7%A3%E6%95%B0%E7%8B%AC/</url>
    <content><![CDATA[<h4 id="37-解数独"><a href="#37-解数独" class="headerlink" title="37. 解数独"></a><a href="https://leetcode-cn.com/problems/sudoku-solver/" target="_blank" rel="noopener">37. 解数独</a></h4><p>编写一个程序，通过已填充的空格来解决数独问题。</p>
<p>一个数独的解法需<strong>遵循如下规则</strong>：</p>
<ol>
<li>数字 <code>1-9</code> 在每一行只能出现一次。</li>
<li>数字 <code>1-9</code> 在每一列只能出现一次。</li>
<li>数字 <code>1-9</code> 在每一个以粗实线分隔的 <code>3x3</code> 宫内只能出现一次。</li>
</ol>
<a id="more"></a>

<p>空白格用 <code>&#39;.&#39;</code> 表示。</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20200915085345737.png" alt="image-20200915085345737"></p>
<p>一个数独。</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20200915085359798.png" alt="image-20200915085359798"></p>
<p>答案被标成红色。</p>
<p><strong>Note:</strong></p>
<ul>
<li>给定的数独序列只包含数字 <code>1-9</code> 和字符 <code>&#39;.&#39;</code> 。</li>
<li>你可以假设给定的数独只有唯一解。</li>
<li>给定数独永远是 <code>9x9</code> 形式的。</li>
</ul>
<p>由于每个数字只能在同一行、同一列和同一个九宫格中只会出现一次，我们使用三个数组来标记该数字是否出现，如果出现则直接退出递归。同时使用一个数组保存剩余的空位，对每个空位尝试放入 1- 9的数字，如果将所有空位都使用完，没有出现错误则发现了一种解。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>[][] line = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">9</span>][<span class="number">9</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>[][] column = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">9</span>][<span class="number">9</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>[][][] block = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">3</span>][<span class="number">3</span>][<span class="number">9</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> valid = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> List&lt;<span class="keyword">int</span>[]&gt; spaces = <span class="keyword">new</span> ArrayList&lt;<span class="keyword">int</span>[]&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">solveSudoku</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span>; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j] == <span class="string">'.'</span>)&#123;</span><br><span class="line">                    <span class="comment">//保存空位</span></span><br><span class="line">                    spaces.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i, j&#125;);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">//标记已存在的数字</span></span><br><span class="line">                    <span class="keyword">int</span> digit = board[i][j] - <span class="string">'0'</span> - <span class="number">1</span>;</span><br><span class="line">                    line[i][digit] = column[j][digit] = block[i / <span class="number">3</span>][j / <span class="number">3</span>][digit] = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//从第一个空位开始递归</span></span><br><span class="line">        dfs(board, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">int</span> pos)</span></span>&#123;</span><br><span class="line">        <span class="comment">//将所有空位用完，找到了一组解</span></span><br><span class="line">        <span class="keyword">if</span>(pos == spaces.size())&#123;</span><br><span class="line">            valid = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//获取一个空位</span></span><br><span class="line">        <span class="keyword">int</span>[] space = spaces.get(pos);</span><br><span class="line">        <span class="keyword">int</span> i = space[<span class="number">0</span>], j = space[<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//尝试将该空位中放入 1-9 </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> digit = <span class="number">0</span>; digit &lt; <span class="number">9</span> &amp;&amp; !valid; ++digit)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!line[i][digit] &amp;&amp; !column[j][digit] &amp;&amp; !block[i / <span class="number">3</span>][j / <span class="number">3</span>][digit])&#123;</span><br><span class="line">                line[i][digit] = column[j][digit] = block[i / <span class="number">3</span>][j / <span class="number">3</span>][digit] = <span class="keyword">true</span>;</span><br><span class="line">                board[i][j] = (<span class="keyword">char</span>) (digit + <span class="string">'0'</span> + <span class="number">1</span>);</span><br><span class="line">                dfs(board, pos + <span class="number">1</span>);</span><br><span class="line">                line[i][digit] = column[j][digit] = block[i / <span class="number">3</span>][j / <span class="number">3</span>][digit] = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode Hard</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>计算二进制子串</title>
    <url>/2020/08/10/%E8%AE%A1%E7%AE%97%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AD%90%E4%B8%B2/</url>
    <content><![CDATA[<h4 id="696-计数二进制子串"><a href="#696-计数二进制子串" class="headerlink" title="696. 计数二进制子串"></a><a href="https://leetcode-cn.com/problems/count-binary-substrings/" target="_blank" rel="noopener">696. 计数二进制子串</a></h4><p>给定一个字符串 <code>s</code>，计算具有相同数量0和1的非空(连续)子字符串的数量，并且这些子字符串中的所有0和所有1都是组合在一起的。</p>
<p>重复出现的子串要计算它们出现的次数。</p>
<a id="more"></a>

<p><strong>示例 1 :</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;00110011&quot;</span><br><span class="line">输出: 6</span><br><span class="line">解释: 有6个子串具有相同数量的连续1和0：“0011”，“01”，“1100”，“10”，“0011” 和 “01”。</span><br><span class="line"></span><br><span class="line">请注意，一些重复出现的子串要计算它们出现的次数。</span><br><span class="line"></span><br><span class="line">另外，“00110011”不是有效的子串，因为所有的0（和1）没有组合在一起。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2 :</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;10101&quot;</span><br><span class="line">输出: 4</span><br><span class="line">解释: 有4个子串：“10”，“01”，“10”，“01”，它们具有相同数量的连续1和0。</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong></p>
<ul>
<li><code>s.length</code> 在1到50,000之间。</li>
<li><code>s</code> 只包含“0”或“1”字符。</li>
</ul>
<p>我们可以将字符串 s 按照 0 和 1 的连续段分组，存在 counts 数组中，例如 s = 00111011，可以得到 counts = {2, 3, 1, 2}。</p>
<p>counts 数组中两个相邻的数一定为两种不同的字符。假设 counts 数组中相邻的两个数字为 u 和 v，那么可能为 u 个 0 ，v  个 1 或 u 个 1 ，v 个 0，这一对数字对答案的贡献为 min{u, v}。我们遍历所有相邻的数对，计算它们的贡献和。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countBinarySubstrings</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; counts = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">		<span class="comment">//生成 counts 数组</span></span><br><span class="line">        <span class="keyword">char</span> cur = s.charAt(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i) == cur)&#123;</span><br><span class="line">                ++c;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                counts.add(c);</span><br><span class="line">                cur = s.charAt(i);</span><br><span class="line">                c =  <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        counts.add(c);</span><br><span class="line">        <span class="comment">//计算贡献和</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; counts.size(); i++)&#123;</span><br><span class="line">            ans += Math.min(counts.get(i), counts.get(i - <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度和空间复杂度都为 O(n)。</p>
<p>我们可以发现，在对每一个数计算贡献时，我们只用到了前一个值，我们使用 last 来保存。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countBinarySubstrings</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ptr = <span class="number">0</span>, n = s.length(), last = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(ptr &lt; n)&#123;</span><br><span class="line">            <span class="keyword">char</span> c = s.charAt(ptr);</span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(ptr &lt; n &amp;&amp; s.charAt(ptr) == c)&#123;</span><br><span class="line">                ++ptr;</span><br><span class="line">                ++count;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ans += Math.min(count, last);</span><br><span class="line">            last = count;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度O(n)，空间复杂度O(1)。</p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode Easy</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>计算右侧小于当前元素的个数</title>
    <url>/2020/07/11/%E8%AE%A1%E7%AE%97%E5%8F%B3%E4%BE%A7%E5%B0%8F%E4%BA%8E%E5%BD%93%E5%89%8D%E5%85%83%E7%B4%A0%E7%9A%84%E4%B8%AA%E6%95%B0/</url>
    <content><![CDATA[<h4 id="315-计算右侧小于当前元素的个数"><a href="#315-计算右侧小于当前元素的个数" class="headerlink" title="315. 计算右侧小于当前元素的个数"></a><a href="https://leetcode-cn.com/problems/count-of-smaller-numbers-after-self/" target="_blank" rel="noopener">315. 计算右侧小于当前元素的个数</a></h4><p>给定一个整数数组 <em>nums<em>，按要求返回一个新数组 *counts</em>。数组 *counts</em> 有该性质： <code>counts[i]</code> 的值是 <code>nums[i]</code> 右侧小于 <code>nums[i]</code> 的元素的数量。</p>
<a id="more"></a>

<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [5,2,6,1]</span><br><span class="line">输出: [2,1,1,0] </span><br><span class="line">解释:</span><br><span class="line">5 的右侧有 2 个更小的元素 (2 和 1).</span><br><span class="line">2 的右侧仅有 1 个更小的元素 (1).</span><br><span class="line">6 的右侧有 1 个更小的元素 (1).</span><br><span class="line">1 的右侧有 0 个更小的元素.</span><br></pre></td></tr></table></figure>

<p>暴力解法（超时）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">countSmaller</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        List&lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[j] &lt; nums[i])&#123;</span><br><span class="line">                    ++count;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans.add(count);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度O(n^2)，空间复杂度O(1)。</p>
<p>从暴力解法中可以看出，我们做了许多的重复的统计工作，我们如果从后往前遍历数组，并保存下已经遍历过的数字及它们出现的次数，在下一次遍历时，就不用重复统计。</p>
<p>使用二叉搜索树也可完成插入并统计的功能，我们从右往左依次遍历数组，并构建二叉树。在插入结点的过程中我们可以统计出右侧小于当前结点元素的个数。</p>
<p>在一般的二叉树结点上，我们添加了一个 count 变量来统计小于当前结点 val 值的结点个数。。</p>
<p>递归实现添加结点的算法：</p>
<ul>
<li>当走到右结点，统计根结点和根结点左结点的个数，继续插入并统计根结点右侧是否还有比当前结点值小的结点。</li>
<li>当走到左节点或根结点时，计数器加一，继续插入并统计根结点左侧是否还有比当前结点值小的结点。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">countSmaller</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">        Integer[] res = <span class="keyword">new</span> Integer[nums.length];</span><br><span class="line">        Arrays.fill(res, <span class="number">0</span>);</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//反向构造二叉树，统计右边最小数</span></span><br><span class="line">        TreeNode root = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = nums.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            root = addAndCount(root, <span class="keyword">new</span> TreeNode(nums[i]), res, i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Arrays.asList(res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">addAndCount</span><span class="params">(TreeNode root, TreeNode node, Integer[] res, <span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            root = node;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//根结点左边的保存不大于根结点的元素</span></span><br><span class="line">        <span class="keyword">if</span>(root.val &gt;= node.val)&#123;</span><br><span class="line">            <span class="comment">//不大于根结点值的结点个数加一</span></span><br><span class="line">            root.count++ ;</span><br><span class="line">            <span class="comment">//递归将当前结点插入左子树</span></span><br><span class="line">            root.left = addAndCount(root.left, node, res, i);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//统计比当前结点值小的元素个数（根结点 1 + 左节点 root.count）</span></span><br><span class="line">            res[i] += <span class="number">1</span> + root.count;</span><br><span class="line">            <span class="comment">//统计根结点右子树中是否还有比当前结点值小的结点</span></span><br><span class="line">            root.right = addAndCount(root.right, node, res, i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        <span class="keyword">int</span> count;</span><br><span class="line">        TreeNode left, right;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">TreeNode</span><span class="params">(<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.val = val;</span><br><span class="line">            <span class="keyword">this</span>.count = <span class="number">0</span>;<span class="comment">//小于 val 值的结点个数</span></span><br><span class="line">            left = <span class="keyword">null</span>;</span><br><span class="line">            right = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度O(nlogn)，空间复杂度O(n)。</p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode Hard</tag>
        <tag>二叉搜索树</tag>
      </tags>
  </entry>
  <entry>
    <title>计算质数</title>
    <url>/2020/09/19/%E8%AE%A1%E7%AE%97%E8%B4%A8%E6%95%B0/</url>
    <content><![CDATA[<h4 id="204-计数质数"><a href="#204-计数质数" class="headerlink" title="204. 计数质数"></a><a href="https://leetcode-cn.com/problems/count-primes/" target="_blank" rel="noopener">204. 计数质数</a></h4><p>统计所有小于非负整数 <em>n</em> 的质数的数量。</p>
<a id="more"></a>

<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 10</span><br><span class="line">输出: 4</span><br><span class="line">解释: 小于 10 的质数一共有 4 个, 它们是 2, 3, 5, 7 。</span><br></pre></td></tr></table></figure>

<p>暴力方法会超时，我们使用<strong>厄拉多塞筛法</strong>。</p>
<p>该方法的核心是，<strong>一个质数的倍数不会是质数</strong>。具体来说，2 是质数，那么 4 ，6，8 … 不会是质数。</p>
<p>我们使用一个数组来存储是否为质数的标记。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countPrimes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// book 初始化全部为false，将不是质数的下标变为 true</span></span><br><span class="line">        <span class="keyword">boolean</span>[] book = <span class="keyword">new</span> <span class="keyword">boolean</span>[n];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!book[i])&#123;</span><br><span class="line">                ++count;</span><br><span class="line">                <span class="comment">//质数 i 的倍数不可能为质数，将其标记为 true</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; n; j += i)&#123;</span><br><span class="line">                    book[j] = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>Leetcode Easy</tag>
      </tags>
  </entry>
  <entry>
    <title>设计哈希集合</title>
    <url>/2021/03/13/%E8%AE%BE%E8%AE%A1%E5%93%88%E5%B8%8C%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<h4 id="705-设计哈希集合"><a href="#705-设计哈希集合" class="headerlink" title="705. 设计哈希集合"></a><a href="https://leetcode-cn.com/problems/design-hashset/" target="_blank" rel="noopener">705. 设计哈希集合</a></h4><p>不使用任何内建的哈希表库设计一个哈希集合（HashSet）。</p>
<p>实现 <code>MyHashSet</code> 类：</p>
<ul>
<li><code>void add(key)</code> 向哈希集合中插入值 <code>key</code> 。</li>
<li><code>bool contains(key)</code> 返回哈希集合中是否存在这个值 <code>key</code> 。</li>
<li><code>void remove(key)</code> 将给定值 <code>key</code> 从哈希集合中删除。如果哈希集合中没有这个值，什么也不做。</li>
</ul>
<a id="more"></a>

<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;MyHashSet&quot;, &quot;add&quot;, &quot;add&quot;, &quot;contains&quot;, &quot;contains&quot;, &quot;add&quot;, &quot;contains&quot;, &quot;remove&quot;, &quot;contains&quot;]</span><br><span class="line">[[], [1], [2], [1], [3], [2], [2], [2], [2]]</span><br><span class="line">输出：</span><br><span class="line">[null, null, null, true, false, null, true, null, false]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">MyHashSet myHashSet &#x3D; new MyHashSet();</span><br><span class="line">myHashSet.add(1);      &#x2F;&#x2F; set &#x3D; [1]</span><br><span class="line">myHashSet.add(2);      &#x2F;&#x2F; set &#x3D; [1, 2]</span><br><span class="line">myHashSet.contains(1); &#x2F;&#x2F; 返回 True</span><br><span class="line">myHashSet.contains(3); &#x2F;&#x2F; 返回 False ，（未找到）</span><br><span class="line">myHashSet.add(2);      &#x2F;&#x2F; set &#x3D; [1, 2]</span><br><span class="line">myHashSet.contains(2); &#x2F;&#x2F; 返回 True</span><br><span class="line">myHashSet.remove(2);   &#x2F;&#x2F; set &#x3D; [1]</span><br><span class="line">myHashSet.contains(2); &#x2F;&#x2F; 返回 False ，（已移除）</span><br></pre></td></tr></table></figure>

<pre><code>**提示：**</code></pre><ul>
<li><code>0 &lt;= key &lt;= 106</code></li>
<li>最多调用 <code>104</code> 次 <code>add</code>、<code>remove</code> 和 <code>contains</code> 。</li>
</ul>
<p><strong>方法一：链地址法</strong></p>
<p>设哈希表的大小为 base，hash 函数为<code>hash(x) = x mod base</code>,base 取质数 769。</p>
<p>数组中每个位置是一个链表，当计算出哈希值后，就插入对应链表中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHashSet</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BASE = <span class="number">769</span>;</span><br><span class="line">    <span class="keyword">private</span> LinkedList[] data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyHashSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        data = <span class="keyword">new</span> LinkedList[BASE];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; BASE; i++)&#123;</span><br><span class="line">            data[i] = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h = hash(key);</span><br><span class="line">        Iterator&lt;Integer&gt; iterator = data[h].iterator();</span><br><span class="line">        <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">            Integer element = iterator.next();</span><br><span class="line">            <span class="keyword">if</span>(element == key)&#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        data[h].offerLast(key);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h = hash(key);</span><br><span class="line">        Iterator&lt;Integer&gt; iterator = data[h].iterator();</span><br><span class="line">        <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">            Integer element = iterator.next();</span><br><span class="line">            <span class="keyword">if</span>(element == key)&#123;</span><br><span class="line">                data[h].remove(element);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns true if this set contains the specified element */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h = hash(key);</span><br><span class="line">        Iterator&lt;Integer&gt; iter = data[h].iterator();</span><br><span class="line">        <span class="keyword">while</span>(iter.hasNext())&#123;</span><br><span class="line">            Integer element = iter.next();</span><br><span class="line">            <span class="keyword">if</span>(element == key)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(<span class="keyword">int</span> key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> key % BASE;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度O(n/b)，n为哈希表中的元素数量，b 为链表的数量，假设链表长度为均匀的。</li>
<li>空间复杂度O(n + b)</li>
</ul>
]]></content>
      <tags>
        <tag>Leetcode Easy</tag>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title>解码方法</title>
    <url>/2021/04/21/%E8%A7%A3%E7%A0%81%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h4 id="91-解码方法"><a href="#91-解码方法" class="headerlink" title="91. 解码方法"></a><a href="https://leetcode-cn.com/problems/decode-ways/" target="_blank" rel="noopener">91. 解码方法</a></h4><p>一条包含字母 <code>A-Z</code> 的消息通过以下映射进行了 <strong>编码</strong> ：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#39;A&#39; -&gt; 1</span><br><span class="line">&#39;B&#39; -&gt; 2</span><br><span class="line">...</span><br><span class="line">&#39;Z&#39; -&gt; 26</span><br></pre></td></tr></table></figure>

<p>要 <strong>解码</strong> 已编码的消息，所有数字必须基于上述映射的方法，反向映射回字母（可能有多种方法）。例如，<code>&quot;11106&quot;</code> 可以映射为：</p>
<ul>
<li><code>&quot;AAJF&quot;</code> ，将消息分组为 <code>(1 1 10 6)</code></li>
<li><code>&quot;KJF&quot;</code> ，将消息分组为 <code>(11 10 6)</code></li>
</ul>
<p>注意，消息不能分组为 <code>(1 11 06)</code> ，因为 <code>&quot;06&quot;</code> 不能映射为 <code>&quot;F&quot;</code> ，这是由于 <code>&quot;6&quot;</code> 和 <code>&quot;06&quot;</code> 在映射中并不等价。</p>
<p>给你一个只含数字的 <strong>非空</strong> 字符串 <code>s</code> ，请计算并返回 <strong>解码</strong> 方法的 <strong>总数</strong> 。</p>
<p>题目数据保证答案肯定是一个 <strong>32 位</strong> 的整数。</p>
 <a id="more"></a>

<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;12&quot;</span><br><span class="line">输出：2</span><br><span class="line">解释：它可以解码为 &quot;AB&quot;（1 2）或者 &quot;L&quot;（12）。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;226&quot;</span><br><span class="line">输出：3</span><br><span class="line">解释：它可以解码为 &quot;BZ&quot; (2 26), &quot;VF&quot; (22 6), 或者 &quot;BBF&quot; (2 2 6) 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;0&quot;</span><br><span class="line">输出：0</span><br><span class="line">解释：没有字符映射到以 0 开头的数字。</span><br><span class="line">含有 0 的有效映射是 &#39;J&#39; -&gt; &quot;10&quot; 和 &#39;T&#39;-&gt; &quot;20&quot; 。</span><br><span class="line">由于没有字符，因此没有有效的方法对此进行解码，因为所有数字都需要映射。</span><br></pre></td></tr></table></figure>

<p><strong>示例 4：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;06&quot;</span><br><span class="line">输出：0</span><br><span class="line">解释：&quot;06&quot; 不能映射到 &quot;F&quot; ，因为字符串含有前导 0（&quot;6&quot; 和 &quot;06&quot; 在映射中并不等价）。</span><br></pre></td></tr></table></figure>

<p> <strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 100</code></li>
<li><code>s</code> 只包含数字，并且可能包含前导零。</li>
</ul>
<p>对于字符串s = “226”，我们从左至右分析，字符 ‘ 2 ’ 可以解码为‘B’，字符 ’22‘ 可以解码为 ‘V’，解码方法总数为剩下的 ”26“ 和 ”6“解码方法总和，我们可以轻松知道 ”26“的解码方法为 2 种，”6“ 的解码方法为 1 种。</p>
<p>因此我们可以使用递归来实现这种思想</p>
<p><strong>方法一：递归（超时）</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numDecodings</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//字符串长度为 0 或字符串第一个字符为 0，直接返回 0 </span></span><br><span class="line">        <span class="keyword">if</span>(s.length() == <span class="number">0</span> || s.charAt(<span class="number">0</span>) == <span class="string">'0'</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">char</span>[] chars = s.toCharArray();</span><br><span class="line">        <span class="keyword">return</span> decode(chars, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">decode</span><span class="params">(<span class="keyword">char</span>[] chars, <span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = chars.length;</span><br><span class="line">        <span class="comment">//边界条件</span></span><br><span class="line">        <span class="keyword">if</span>(start == n)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//以 0 开头，直接返回 0 </span></span><br><span class="line">        <span class="keyword">if</span>(chars[start] == <span class="string">'0'</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//取一个字符</span></span><br><span class="line">        <span class="keyword">int</span> ret = decode(chars, start + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//取两个字符</span></span><br><span class="line">        <span class="keyword">if</span>(start + <span class="number">1</span> &lt; n &amp;&amp; isDigit(chars[start], chars[start + <span class="number">1</span>]))&#123;</span><br><span class="line">            ret += decode(chars, start + <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回相加的结果</span></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//判断两个字符是否能解码</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isDigit</span><span class="params">(<span class="keyword">char</span> upper, <span class="keyword">char</span> lower)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> up = (<span class="keyword">int</span>)(upper - <span class="string">'0'</span>);</span><br><span class="line">        <span class="keyword">int</span> low = (<span class="keyword">int</span>)(lower - <span class="string">'0'</span>);</span><br><span class="line">        <span class="keyword">if</span>( (up == <span class="number">1</span> &amp;&amp; <span class="number">0</span> &lt;= low &amp;&amp; low &lt;= <span class="number">9</span>) || (up == <span class="number">2</span> &amp;&amp; <span class="number">0</span> &lt;= low &amp;&amp; low &lt;= <span class="number">6</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法二：动态规划</strong></p>
<p>虽然递归方法超时了，但我们可以尝试使用动态规划。dp[i] 表示 s[i … n] 的解码方法总数，结果为 dp[0]。我们可以使用 dpi, dpi1, dpi2 三个变量来代替 dp 数组，初始时 dpi = 0, dpi1 = 1, dpi2 = 1。我们可以列出如下 dp 方程：<br>$$<br>dp[i] = 0,  s[i] = ‘0’<br>$$<br>$$<br>dp[i] = dp[i + 1],  s[i] \neq ‘0’ &amp; &amp; \ !isDigit(s[i], s[i + 1])<br>$$<br>$$<br>dp[i] = dp[i + 1] + dp[i + 2],  s[i] \neq ‘0’ &amp; &amp; \ isDigit(s[i], s[i + 1])<br>$$</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numDecodings</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span> || s.charAt(<span class="number">0</span>) == <span class="string">'0'</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> dpi = <span class="number">0</span>, dpi1 = <span class="number">1</span>, dpi2 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i) != <span class="string">'0'</span>)&#123;</span><br><span class="line">                dpi += dpi1;</span><br><span class="line">                <span class="keyword">if</span>(i + <span class="number">1</span> &lt; n &amp;&amp; isDigit(s.charAt(i), s.charAt(i + <span class="number">1</span>))) dpi += dpi2;</span><br><span class="line">            &#125;</span><br><span class="line">            dpi2 = dpi1;</span><br><span class="line">            dpi1 = dpi;</span><br><span class="line">            dpi = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dpi1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isDigit</span><span class="params">(<span class="keyword">char</span> upper, <span class="keyword">char</span> lower)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> up = (<span class="keyword">int</span>)(upper - <span class="string">'0'</span>);</span><br><span class="line">        <span class="keyword">int</span> low = (<span class="keyword">int</span>)(lower - <span class="string">'0'</span>);</span><br><span class="line">        <span class="keyword">if</span>( (up == <span class="number">1</span> &amp;&amp; <span class="number">0</span> &lt;= low &amp;&amp; low &lt;= <span class="number">9</span>) || (up == <span class="number">2</span> &amp;&amp; <span class="number">0</span> &lt;= low &amp;&amp; low &lt;= <span class="number">6</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度O(n)</li>
<li>空间复杂度O(1)</li>
</ul>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode Medium</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>课程表</title>
    <url>/2020/08/04/%E8%AF%BE%E7%A8%8B%E8%A1%A8/</url>
    <content><![CDATA[<h4 id="207-课程表"><a href="#207-课程表" class="headerlink" title="207. 课程表"></a><a href="https://leetcode-cn.com/problems/course-schedule/" target="_blank" rel="noopener">207. 课程表</a></h4><p>你这个学期必须选修 <code>numCourse</code> 门课程，记为 <code>0</code> 到 <code>numCourse-1</code> 。</p>
<p>在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们：<code>[0,1]</code></p>
<p>给定课程总量以及它们的先决条件，请你判断是否可能完成所有课程的学习？</p>
<a id="more"></a>

<p> <strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 2, [[1,0]] </span><br><span class="line">输出: true</span><br><span class="line">解释: 总共有 2 门课程。学习课程 1 之前，你需要完成课程 0。所以这是可能的。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 2, [[1,0],[0,1]]</span><br><span class="line">输出: false</span><br><span class="line">解释: 总共有 2 门课程。学习课程 1 之前，你需要先完成课程 0；并且学习课程 0 之前，你还应先完成课程 1。这是不可能的。</span><br></pre></td></tr></table></figure>

<p> <strong>提示：</strong></p>
<ol>
<li>输入的先决条件是由 <strong>边缘列表</strong> 表示的图形，而不是 邻接矩阵 。详情请参见<a href="http://blog.csdn.net/woaidapaopao/article/details/51732947" target="_blank" rel="noopener">图的表示法</a>。</li>
<li>你可以假定输入的先决条件中没有重复的边。</li>
<li><code>1 &lt;= numCourses &lt;= 10^5</code></li>
</ol>
<p>此题可以看作判断一个有向图是否存在环，如果图中存在环，则不存在拓扑排序。如果图中不存在环，则可能存在不止一种拓扑排序。</p>
<p>不存在拓扑排序：</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20200804101354711.png" alt="image-20200804101354711"></p>
<p>存在拓扑排序：</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20200804101551878.png" alt="image-20200804101551878"></p>
<p>上图中存在拓扑排序中的一种为：[0, 2, 1, 3, 5, 6, 4]。</p>
<p>求拓扑序列方法：不断取下<strong>「入度」为零</strong>的结点直到图中没有结点或没有入度为零的结点，按取下结点的顺序就得到了拓扑排序。</p>
<p>边缘列表就是存储图的每一条边， <code>[[1,0]]</code>代表存在一条结点 0 到结点 1 的边。</p>
<p><strong>方法一：BFS</strong></p>
<p>我们首先统计每个结点的出边信息和入度信息，首先将入度为零的结点加入队列，取下一个结点，并将该结点所指向的结点入度减一，同时将入度减为零的结点加入队列，不断重复这个步骤直到队列为空，取下结点的顺序就是拓扑排序。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; edges;<span class="comment">//edges[i] 为结点 i 所指向的结点数组</span></span><br><span class="line">    <span class="keyword">int</span>[] indeg;<span class="comment">//indeg[i]为结点 i 的入度</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites)</span> </span>&#123;</span><br><span class="line">        edges = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++)&#123;</span><br><span class="line">            edges.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        indeg = <span class="keyword">new</span> <span class="keyword">int</span>[numCourses];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] edge : prerequisites)&#123;</span><br><span class="line">            <span class="comment">//存在 edge[1] 到 edge[0] 的边，把edge[0] 加入到 edge[1]</span></span><br><span class="line">            edges.get(edge[<span class="number">1</span>]).add(edge[<span class="number">0</span>]);</span><br><span class="line">            <span class="comment">//edge[0] 入度加一</span></span><br><span class="line">            ++indeg[edge[<span class="number">0</span>]];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//queue 存储入度为 0 的结点</span></span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(indeg[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                queue.offer(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//visited 记录已经取下的结点个数</span></span><br><span class="line">        <span class="keyword">int</span> visited = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            ++visited;</span><br><span class="line">            <span class="comment">//取下一个入度为 0 的结点</span></span><br><span class="line">            <span class="keyword">int</span> u = queue.poll();</span><br><span class="line">            <span class="comment">//将该结点所指向的结点的入度减一</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> v : edges.get(u))&#123;</span><br><span class="line">                --indeg[v];</span><br><span class="line">                <span class="comment">//将入度为 0 的结点加入队列</span></span><br><span class="line">                <span class="keyword">if</span>(indeg[v] == <span class="number">0</span>)&#123;</span><br><span class="line">                    queue.offer(v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//能取下所有结点则存在拓扑排序</span></span><br><span class="line">        <span class="keyword">return</span> visited == numCourses;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度 O(n+m)，其中 n 为课程数，m 为先修课程的要求数。空间复杂度 O(n+m)。</p>
<p><strong>方法二：DFS</strong></p>
<p>我们也可以使用深度优先搜索来找到拓扑排序，我们使用一个栈来存储拓扑排序。对于任意一个结点，我们首先访问该结点，继续访问该结点指向的结点，一直递归地进行这个操作，直到当前访问的结点出度为 0 ，就开始递归返回，在返回的过程中将结点加入栈中。对所有未搜索过的结点进行深度优先搜索，最后得到的栈中，从栈顶到栈底就是拓扑排序。</p>
<p>对于图中的任意结点有三个状态：</p>
<ul>
<li>未搜索，还没有搜索到这个结点；</li>
<li>搜索中，已经搜索过这个结点，还未回溯到该结点，此时这个结点还没有入栈；</li>
<li>已完成，已经搜索过这个结点，已经将该结点入栈。</li>
</ul>
<p>每一轮深度优先搜索开始时，我们选择一个未搜索过的结点。</p>
<p>算法流程：</p>
<ul>
<li><p>将当前搜索的结点 u 标记为搜索中，遍历该结点所指向的每一个结点 v</p>
<ul>
<li>如果 v 为 未搜索 ，那么开始搜索 v，等待回溯到 u；</li>
<li>如果 v 为搜索中，那么图中存在一个环，不存在拓扑序列；</li>
<li>如果 v 为已完成，v 已经在栈中，u 还不在栈中，满足栈中 u 在 v 的上方，不用操作。</li>
</ul>
</li>
<li><p>当 u 所指向的所有结点都为 已完成 时，将 u 放入栈中，将其标为 已完成。</p>
</li>
</ul>
<p>由于我们不需要拓扑序列，只用判断它是否存在，我们只用一个布尔值来代替栈。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; edges;</span><br><span class="line">    <span class="keyword">int</span>[] visited;</span><br><span class="line">    <span class="keyword">boolean</span> valid = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites)</span> </span>&#123;</span><br><span class="line">        edges = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++)&#123;</span><br><span class="line">            edges.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//visited[i] 为结点 i 的状态，0 代表未搜索，1 代表搜索中，2 代表已完成</span></span><br><span class="line">        visited = <span class="keyword">new</span> <span class="keyword">int</span>[numCourses];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] edge : prerequisites)&#123;</span><br><span class="line">            edges.get(edge[<span class="number">1</span>]).add(edge[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//拓扑序列存在时搜索</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses &amp;&amp; valid; i++)&#123;</span><br><span class="line">            <span class="comment">//不断选取未搜索的结点进行 DFS</span></span><br><span class="line">            <span class="keyword">if</span>(visited[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                dfs(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> valid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">        <span class="comment">//将当前结点 u 状态改为 搜索中</span></span><br><span class="line">        visited[u] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//选取 u 所指向的结点进行 DFS</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> v : edges.get(u))&#123;</span><br><span class="line">            <span class="comment">//u 指向的结点 v 未搜索过，递归地搜索</span></span><br><span class="line">            <span class="keyword">if</span>(visited[v] == <span class="number">0</span>)&#123;</span><br><span class="line">                dfs(v);</span><br><span class="line">                <span class="comment">//搜索过程中出现环，返回</span></span><br><span class="line">                <span class="keyword">if</span>(!valid)&#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(visited[v] == <span class="number">1</span>)&#123;<span class="comment">//存在环，将 valid 设为false，返回</span></span><br><span class="line">                valid = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将结点 u 设为已完成状态</span></span><br><span class="line">        visited[u] = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度 O(n+m)，其中 n 为课程数，m 为先修课程的要求数。空间复杂度 O(n+m)。</p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode Medium</tag>
        <tag>DFS</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title>路径总和</title>
    <url>/2020/07/07/%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C/</url>
    <content><![CDATA[<h4 id="112-路径总和"><a href="#112-路径总和" class="headerlink" title="112. 路径总和"></a><a href="https://leetcode-cn.com/problems/path-sum/" target="_blank" rel="noopener">112. 路径总和</a></h4><p>给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。</p>
<p><strong>说明:</strong> 叶子节点是指没有子节点的节点。</p>
<a id="more"></a>

<p><strong>示例:</strong><br>给定如下二叉树，以及目标和 <code>sum = 22</code>，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">      5</span><br><span class="line">     &#x2F; \</span><br><span class="line">    4   8</span><br><span class="line">   &#x2F;   &#x2F; \</span><br><span class="line">  11  13  4</span><br><span class="line"> &#x2F;  \      \</span><br><span class="line">7    2      1</span><br></pre></td></tr></table></figure>

<p>返回 <code>true</code>, 因为存在目标和为 22 的根节点到叶子节点的路径 <code>5-&gt;4-&gt;11-&gt;2</code>。</p>
<p>此题可以转化为 是否存在从当前结点 root 的子结点到叶子结点的路径，满足路径和为 sum - root.val 。若当前结点为叶子结点，那么我们直接判断 sum 是否等于 val 即可。如果不是叶子结点，我们递归地调用方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPathSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//注意根结点为空的条件。</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//判断路径总和</span></span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> sum == root.val;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//递归</span></span><br><span class="line">        <span class="keyword">return</span> hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度O(n)，空间复杂度O(log n)，最坏O(n)。</p>
<p>我们还可以使用广度优先搜索的方式，记录从根结点到当前结点的路径和。我们使用两个队列。分别存储将要遍历的结点，以及根结点到这些结点的路径和。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPathSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;TreeNode&gt; qt = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        Queue&lt;Integer&gt; qi = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        qt.offer(root);</span><br><span class="line">        qi.offer(root.val);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!qt.isEmpty())&#123;</span><br><span class="line">            TreeNode now = qt.poll();</span><br><span class="line">            <span class="keyword">int</span> val = qi.poll();</span><br><span class="line">            <span class="keyword">if</span>(now.left == <span class="keyword">null</span> &amp;&amp; now.right == <span class="keyword">null</span> &amp;&amp; val == sum)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(now.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                qt.offer(now.left);</span><br><span class="line">                qi.offer(now.left.val + val);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(now.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                qt.offer(now.right);</span><br><span class="line">                qi.offer(now.right.val + val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度O(n)，空间复杂度O(n)。</p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode Easy</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>跳水板</title>
    <url>/2020/07/08/%E8%B7%B3%E6%B0%B4%E6%9D%BF/</url>
    <content><![CDATA[<h4 id="面试题-16-11-跳水板"><a href="#面试题-16-11-跳水板" class="headerlink" title="面试题 16.11. 跳水板"></a><a href="https://leetcode-cn.com/problems/diving-board-lcci/" target="_blank" rel="noopener">面试题 16.11. 跳水板</a></h4><p>你正在使用一堆木板建造跳水板。有两种类型的木板，其中长度较短的木板长度为<code>shorter</code>，长度较长的木板长度为<code>longer</code>。你必须正好使用<code>k</code>块木板。编写一个方法，生成跳水板所有可能的长度。</p>
<p>返回的长度需要从小到大排列。</p>
<a id="more"></a>

<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">shorter &#x3D; 1</span><br><span class="line">longer &#x3D; 2</span><br><span class="line">k &#x3D; 3</span><br><span class="line">输出： &#123;3,4,5,6&#125;</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>0 &lt; shorter &lt;= longer</li>
<li>0 &lt;= k &lt;= 100000</li>
</ul>
<p>提示中给出了相关信息，我们考虑特殊情况：</p>
<ol>
<li>k == 0，直接返回一个空数组；</li>
<li>shorter == longer，直接返回 shorter * k，只存在这一个长度。</li>
</ol>
<p>剩下的一般情况 shorter &lt; longer 且 k != 0，我们直接可以使用一次循环即可，数组第一个元素为 shorter * k，第二个元素为 shorter * (k - 1) + longer，第三个元素为 shorter * (k - 2) + longer * 2 … 最后一个元素为 longer * k，一共 k + 1 个元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] divingBoard(<span class="keyword">int</span> shorter, <span class="keyword">int</span> longer, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(shorter == longer)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;shorter * k&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[k + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= k; i++)&#123;</span><br><span class="line">            ans[i] = shorter * (k - i) + longer * i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度O(n)，空间复杂度O(1)。</p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode Easy</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>跳跃游戏</title>
    <url>/2020/07/01/%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F/</url>
    <content><![CDATA[<h4 id="55-跳跃游戏"><a href="#55-跳跃游戏" class="headerlink" title="55. 跳跃游戏"></a><a href="https://leetcode-cn.com/problems/jump-game/" target="_blank" rel="noopener">55. 跳跃游戏</a></h4><p>给定一个非负整数数组，你最初位于数组的第一个位置。</p>
<p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p>
<p>判断你是否能够到达最后一个位置。</p>
 <a id="more"></a>

<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [2,3,1,1,4]</span><br><span class="line">输出: true</span><br><span class="line">解释: 我们可以先跳 1 步，从位置 0 到达 位置 1, 然后再从位置 1 跳 3 步到达最后一个位置。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [3,2,1,0,4]</span><br><span class="line">输出: false</span><br><span class="line">解释: 无论怎样，你总会到达索引为 3 的位置。但该位置的最大跳跃长度是 0 ， 所以你永远不可能到达最后一个位置。</span><br></pre></td></tr></table></figure>

<p>对于数组中任意一个位置 i，最远到达的位置为 i + nums[i] 。实时维护一个可到达的最远位置 rightmax，如果rightmax 大于数组最后一个位置的下标即可返回true。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canJump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rightmax = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; ++i)&#123;</span><br><span class="line">                 <span class="comment">//最远可到达 rightmax </span></span><br><span class="line">            <span class="keyword">if</span>(i &lt;= rightmax)&#123;</span><br><span class="line">            	<span class="comment">//实时更新 rightmax 的值</span></span><br><span class="line">            rightmax = Math.max(rightmax , i+nums[i]);</span><br><span class="line">                <span class="comment">//大于最后一个位置的下标返回 true</span></span><br><span class="line">            <span class="keyword">if</span>(rightmax &gt;= n-<span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度O(n)，空间复杂度O(1)。</p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode Medium</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>转变数组后最接近目标值的数组和</title>
    <url>/2020/04/27/%E8%BD%AC%E5%8F%98%E6%95%B0%E7%BB%84%E5%90%8E%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9B%AE%E6%A0%87%E5%80%BC%E7%9A%84%E6%95%B0%E7%BB%84%E5%92%8C/</url>
    <content><![CDATA[<h4 id="1300-转变数组后最接近目标值的数组和"><a href="#1300-转变数组后最接近目标值的数组和" class="headerlink" title="1300. 转变数组后最接近目标值的数组和"></a><a href="https://leetcode-cn.com/problems/sum-of-mutated-array-closest-to-target/" target="_blank" rel="noopener">1300. 转变数组后最接近目标值的数组和</a></h4><p>给你一个整数数组 <code>arr</code> 和一个目标值 <code>target</code> ，请你返回一个整数 <code>value</code> ，使得将数组中所有大于 <code>value</code> 的值变成 <code>value</code> 后，数组的和最接近 <code>target</code> （最接近表示两者之差的绝对值最小）。</p>
<p>如果有多种使得和最接近 <code>target</code> 的方案，请你返回这些整数中的最小值。</p>
<p>请注意，答案不一定是 <code>arr</code> 中的数字。</p>
 <a id="more"></a>

<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：arr &#x3D; [4,9,3], target &#x3D; 10</span><br><span class="line">输出：3</span><br><span class="line">解释：当选择 value 为 3 时，数组会变成 [3, 3, 3]，和为 9 ，这是最接近 target 的方案。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：arr &#x3D; [2,3,5], target &#x3D; 10</span><br><span class="line">输出：5</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：arr &#x3D; [60864,25176,27249,21296,20204], target &#x3D; 56803</span><br><span class="line">输出：11361</span><br></pre></td></tr></table></figure>

<p> <strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= arr.length &lt;= 10^4</code></li>
<li><code>1 &lt;= arr[i], target &lt;= 10^5</code></li>
</ul>
<p>选择一个 value ，将整数数组 arr 中小于 value 的值保留，大于 value 的值变为 value，求修改后的数组的和，当数组的和最接近 target 是，value 就是我们需要找到的结果。显然，此题在数组有序时求比某一个 value 小的值时间复杂度更低，我们首先将数组排序，并生成前缀和数组，这样在 O(1)时间内就可求出数组中小于 value 的值的和，更进一步，已知数组的长度，可以求出修改后的数组的和。</p>
<p>value 的最小值为 1，最大值为数组 arr 的最大值，枚举每一个 value ，使用二分查找找出 value 在数组中的下标，求取修改后的数组和。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findBestValue</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//排序并生成前缀数组</span></span><br><span class="line">        Arrays.sort(arr);</span><br><span class="line">        <span class="keyword">int</span> len = arr.length;</span><br><span class="line">        <span class="keyword">int</span>[] prefix = <span class="keyword">new</span> <span class="keyword">int</span>[len + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len; ++i)&#123;</span><br><span class="line">            prefix[i] = prefix[i - <span class="number">1</span>] + arr[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>, diff = target;</span><br><span class="line">        <span class="comment">//枚举每一个 value</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= arr[len - <span class="number">1</span>]; i++)&#123;</span><br><span class="line">            <span class="comment">//搜索数组中每个 value(i) 的下标</span></span><br><span class="line">            <span class="keyword">int</span> index = Arrays.binarySearch(arr, i);</span><br><span class="line">            <span class="comment">//未找到，将index 恢复为 i</span></span><br><span class="line">            <span class="keyword">if</span>(index &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                index = - index - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//计算修改后的数组和，并记录最佳结果</span></span><br><span class="line">            <span class="keyword">int</span> cur = prefix[index] + (len - index) * i;</span><br><span class="line">            <span class="keyword">if</span>(Math.abs(cur - target) &lt; diff)&#123;</span><br><span class="line">                ans = i;</span><br><span class="line">                diff = Math.abs(cur - target);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度 O((N + C) logN)，其中 N 是数组 arr 的长度，C 是一个常数，为数组 arr 中的最大值。</p>
<p>空间复杂度 O(N)，前缀和数组使用 O(N) 的空间，排序需要 O(logN)的栈空间。</p>
<p>我们可以观察到，上述中的 value 从 1 到数组最大值 arr[len - 1]单调递增，所求出的修改后的数组和也是单调递增的，那么我们可以使用二分查找替代外层循环，来寻找最佳的 value值。</p>
<p>我们可以找出 value 使得数组的和最接近 target 且<strong>不大于</strong> target，记为 value_lower，找出另一个 value 使得数组的和最接近 target 且<strong>大于</strong> target，记为value_upper，最后的结果肯定是这两者中的一个。由于数组的和随着 value 的增大严格单调递增，value_lower 是最接近且不大于 target ，value_lower 是最接近且大于 target，所以 <code>value_upper = value_lower + 1</code>，所以只用一次二分查找来找到 value_lower即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findBestValue</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//计算前缀和</span></span><br><span class="line">        Arrays.sort(arr);</span><br><span class="line">        <span class="keyword">int</span> len = arr.length;</span><br><span class="line">        <span class="keyword">int</span>[] prefix = <span class="keyword">new</span> <span class="keyword">int</span>[len + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len; ++i)&#123;</span><br><span class="line">            prefix[i] = prefix[i - <span class="number">1</span>] + arr[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = arr[len - <span class="number">1</span>], ans = -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//二分查找寻找 value_lower</span></span><br><span class="line">        <span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> index = Arrays.binarySearch(arr, mid);</span><br><span class="line">            <span class="keyword">if</span>(index &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                index = - index - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> cur = prefix[index] + (len - index) * mid;</span><br><span class="line">            <span class="keyword">if</span>(cur &lt;= target)&#123;</span><br><span class="line">                ans = mid;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//比较计算 value_lower 和 value_upper 修改后的数组和</span></span><br><span class="line">        <span class="keyword">int</span> lower = <span class="number">0</span>, upper = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> n : arr)&#123;</span><br><span class="line">            lower += Math.min(n, ans);</span><br><span class="line">            upper += Math.min(n, ans + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//返回距离 target 最近的value值</span></span><br><span class="line">        <span class="keyword">return</span> Math.abs(lower - target) &lt;= Math.abs(upper - target) ? ans : ans + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度 O(N logN)，其中 N 是数组 arr 的长度。</p>
<p>空间复杂度 O(N)，前缀和数组使用 O(N) 的空间，排序需要 O(logN)的栈空间。</p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode Medium</tag>
        <tag>二分查找</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>递增子序列</title>
    <url>/2020/08/25/%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<h4 id="491-递增子序列"><a href="#491-递增子序列" class="headerlink" title="491. 递增子序列"></a><a href="https://leetcode-cn.com/problems/increasing-subsequences/" target="_blank" rel="noopener">491. 递增子序列</a></h4><p>给定一个整型数组, 你的任务是找到所有该数组的递增子序列，递增子序列的长度至少是2。</p>
<a id="more"></a>

<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [4, 6, 7, 7]</span><br><span class="line">输出: [[4, 6], [4, 7], [4, 6, 7], [4, 6, 7, 7], [6, 7], [6, 7, 7], [7,7], [4,7,7]]</span><br></pre></td></tr></table></figure>

<p><strong>说明:</strong></p>
<ol>
<li>给定数组的长度不会超过15。</li>
<li>数组中的整数范围是 [-100,100]。</li>
<li>给定数组中可能包含重复数字，相等的数字应该被视为递增的一种情况。</li>
</ol>
<p>我们可以枚举出所有的子序列，然后判断当前的子序列是否是非严格递增的。对于数组中的每个数来说都有<strong>选中</strong>和<strong>不选中</strong>两种状态。长度为 n 的序列选择子序列一共有 2 ^ n 种情况。我们可以使用递归的方法实现二进制枚举，然后判断是否合法，我们可以得到这样的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">List&lt;Integer&gt; temp = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cur == nums.length) &#123;</span><br><span class="line">        <span class="comment">// 判断是否合法，如果合法判断是否重复，将满足条件的加入答案</span></span><br><span class="line">        <span class="keyword">if</span> (isValid() &amp;&amp; notVisited()) &#123;</span><br><span class="line">            ans.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(temp));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果选择当前元素</span></span><br><span class="line">    temp.add(nums[cur]);</span><br><span class="line">    dfs(cur + <span class="number">1</span>, nums);</span><br><span class="line">    temp.remove(temp.size() - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 如果不选择当前元素</span></span><br><span class="line">    dfs(cur + <span class="number">1</span>, nums);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用一个临时数组 temp 保存当前选出的子序列，用 cur 来表示当前位置的下标，在 执行<code>dfs(cur, nums)</code>之前，[0, cur - 1]区间内的所有元素都被考虑过，[cur, n]区间内的元素还未被考虑。我们考虑 cur 位置选或者不选，如果选择当前元素，将当前元素加入 temp，然后递归下一个位置，在递归结束后，把 temp 的最后一个元素删除进行回溯；如果不选择当前元素，直接递归下一个位置。</p>
<p>我们可以对选择和不选择做一些简单的限定，就可以让枚举出来的序列都是合法且不重复：</p>
<ul>
<li><p>只有当前的元素大于等于上一个选择的元素时才能选择这个元素，这样枚举出来的所有元素都是合法的。</p>
</li>
<li><p>如何保证没有重复呢？我们给不选择做一个限定条件，只有当当前的元素不等于上一个选择的元素的时候，才考虑不选择当前元素，直接递归后面的元素。如果有两个相同的元素，我们有四种情况:</p>
<ol>
<li>选前者，选后者</li>
<li>选前者，不选后者</li>
<li>不选前者，选后者</li>
<li>不选前者，不选后者</li>
</ol>
<p>其中第二种和第三种情况是等价的，这样限制后，舍弃了第二种，保留了第三种。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; temp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; findSubsequences(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        dfs(<span class="number">0</span>, Integer.MIN_VALUE, nums);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">int</span> last, <span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">        <span class="comment">//遍历到末尾</span></span><br><span class="line">        <span class="keyword">if</span>(cur == nums.length)&#123;</span><br><span class="line">            <span class="keyword">if</span>(temp.size() &gt;= <span class="number">2</span>)&#123;</span><br><span class="line">                ans.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(temp));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//当前元素大于等于前一个选择的元素</span></span><br><span class="line">        <span class="keyword">if</span>(nums[cur] &gt;= last)&#123;</span><br><span class="line">            temp.add(nums[cur]);</span><br><span class="line">            dfs(cur + <span class="number">1</span>, nums[cur], nums);</span><br><span class="line">            temp.remove(temp.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//当前元素不等于前一个选择的元素才考虑不选择当前元素，去重</span></span><br><span class="line">        <span class="keyword">if</span>(nums[cur] != last)&#123;</span><br><span class="line">            dfs(cur + <span class="number">1</span>, last, nums);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度O(n * 2 ^ n)，枚举子序列O(2 ^ n)，保存答案O(n)。</p>
<p>空间复杂度O(n)。</p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode Medium</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>重复的子字符串</title>
    <url>/2020/08/24/%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<h4 id="459-重复的子字符串"><a href="#459-重复的子字符串" class="headerlink" title="459. 重复的子字符串"></a><a href="https://leetcode-cn.com/problems/repeated-substring-pattern/" target="_blank" rel="noopener">459. 重复的子字符串</a></h4><p>给定一个非空的字符串，判断它是否可以由它的一个子串重复多次构成。给定的字符串只含有小写英文字母，并且长度不超过10000。</p>
<a id="more"></a>

<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;abab&quot;</span><br><span class="line"></span><br><span class="line">输出: True</span><br><span class="line"></span><br><span class="line">解释: 可由子字符串 &quot;ab&quot; 重复两次构成。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;aba&quot;</span><br><span class="line"></span><br><span class="line">输出: False</span><br></pre></td></tr></table></figure>

<p><strong>示例 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;abcabcabcabc&quot;</span><br><span class="line"></span><br><span class="line">输出: True</span><br><span class="line"></span><br><span class="line">解释: 可由子字符串 &quot;abc&quot; 重复四次构成。 (或者子字符串 &quot;abcabc&quot; 重复两次构成。)</span><br></pre></td></tr></table></figure>

<p><strong>方法一：枚举</strong></p>
<p>如果一个长度为 n 的字符串可以由它的一个长度为 n‘ 的子串 s’ 重复多次构成，那么：</p>
<ul>
<li>n 一定是 n‘ 的倍数；</li>
<li>s’ 一定是 s 的前缀；</li>
<li>对于任意的 <code>i∈[n&#39;, n)</code>，有 <code>s[i] = s[i - n&#39;]</code>。</li>
</ul>
<p>我们枚举子串的长度 n’ ，同时判断 s[i] 和 s[i - n’] 是否相等。子串的长度 n’ 属于 [1, n / 2]，长度为 n 的字符串至少要由两个重复子串构成。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">repeatedSubstringPattern</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n / <span class="number">2</span>; i++)&#123;</span><br><span class="line">            <span class="comment">//字符串长度不能整除子串的长度，continue</span></span><br><span class="line">            <span class="keyword">if</span>(n % i != <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">		</span><br><span class="line">            <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">//判断子串s[0 ... i - 1] 是否为重复的子串</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; n; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s.charAt(j) != s.charAt(j - i))&#123;</span><br><span class="line">                    flag = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度O(n^2)，空间复杂度O(n)。</p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode Easy</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>通配符匹配</title>
    <url>/2020/07/05/%E9%80%9A%E9%85%8D%E7%AC%A6%E5%8C%B9%E9%85%8D/</url>
    <content><![CDATA[<h4 id="44-通配符匹配"><a href="#44-通配符匹配" class="headerlink" title="44. 通配符匹配"></a><a href="https://leetcode-cn.com/problems/wildcard-matching/" target="_blank" rel="noopener">44. 通配符匹配</a></h4><p>给定一个字符串 (<code>s</code>) 和一个字符模式 (<code>p</code>) ，实现一个支持 <code>&#39;?&#39;</code> 和 <code>&#39;*&#39;</code> 的通配符匹配。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#39;?&#39; 可以匹配任何单个字符。</span><br><span class="line">&#39;*&#39; 可以匹配任意字符串（包括空字符串）。</span><br></pre></td></tr></table></figure>

<p>两个字符串<strong>完全匹配</strong>才算匹配成功。</p>
<a id="more"></a>

<p><strong>说明:</strong></p>
<ul>
<li><code>s</code> 可能为空，且只包含从 <code>a-z</code> 的小写字母。</li>
<li><code>p</code> 可能为空，且只包含从 <code>a-z</code> 的小写字母，以及字符 <code>?</code> 和 <code>*</code>。</li>
</ul>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">s &#x3D; &quot;aa&quot;</span><br><span class="line">p &#x3D; &quot;a&quot;</span><br><span class="line">输出: false</span><br><span class="line">解释: &quot;a&quot; 无法匹配 &quot;aa&quot; 整个字符串。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">s &#x3D; &quot;aa&quot;</span><br><span class="line">p &#x3D; &quot;*&quot;</span><br><span class="line">输出: true</span><br><span class="line">解释: &#39;*&#39; 可以匹配任意字符串。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">s &#x3D; &quot;cb&quot;</span><br><span class="line">p &#x3D; &quot;?a&quot;</span><br><span class="line">输出: false</span><br><span class="line">解释: &#39;?&#39; 可以匹配 &#39;c&#39;, 但第二个 &#39;a&#39; 无法匹配 &#39;b&#39;。</span><br></pre></td></tr></table></figure>

<p><strong>示例 4:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">s &#x3D; &quot;adceb&quot;</span><br><span class="line">p &#x3D; &quot;*a*b&quot;</span><br><span class="line">输出: true</span><br><span class="line">解释: 第一个 &#39;*&#39; 可以匹配空字符串, 第二个 &#39;*&#39; 可以匹配字符串 &quot;dce&quot;.</span><br></pre></td></tr></table></figure>

<p><strong>示例 5:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">s &#x3D; &quot;acdcb&quot;</span><br><span class="line">p &#x3D; &quot;a*c?b&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>

<p>在匹配的过程中我们可以分为两类：</p>
<ul>
<li>单字符匹配，s 和 p 中的字母相等，或 p 中的一个 ？匹配任意一个字母。</li>
<li>多字符匹配，p 中的 * 匹配 s 中任意多个字母。</li>
</ul>
<p>由于多字符匹配的存在我们需要枚举所有匹配的情况，我们用 <code>dp[i][j]</code> 来表示字符串 s  的前 i 个字符和模式 p 的前 j 个字符是否能匹配。在进行转移的时候，我们可以考虑模式 p 的第 j 个字符 pj，</p>
<p>与之对应的是字符串 s 中第 i 个字符 si：</p>
<ul>
<li>pj 是小写字母，那么 si 也必须为小写字母，<code>dp[i][j] = (pj == si) &amp;&amp; dp[i - 1][j - 1]</code></li>
<li>pj 是问号，任意匹配 si，<code>dp[i][j] = dp[i - 1][j - 1]</code></li>
<li>pj 是星号，可以匹配零或任意多个小写字母，当匹配 s 中零个小写字母时：<code>dp[i][j] = dp[i][j - 1]</code>，不使用这个星号；当匹配 s 中任意多个小写字母时，<code>dp[i][j] = dp[i - 1][j]</code>，使用星号匹配 s 中的一个字符（星号未被去掉，可以继续匹配）。</li>
</ul>
<p>我们需要处理边界情况：</p>
<ol>
<li>当 s  和 p 全为空，返回true，<code>dp[0][0] = true</code>;</li>
<li>p 为空，s 不为空，<code>dp[i][0] = false (1 &lt;= i &lt;= p.length)</code>；</li>
<li>s 为空，p 不为空，当且仅当 p 中全为星号时才为 true。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = s.length(), n = p.length();</span><br><span class="line">        <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">//s 和 p 都为空</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//s 为空，p 不为空</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p.charAt(i - <span class="number">1</span>) == <span class="string">'*'</span>)&#123;</span><br><span class="line">                dp[<span class="number">0</span>][i] = <span class="keyword">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">                <span class="comment">//pj 为字母或问号</span></span><br><span class="line">                <span class="keyword">if</span>(s.charAt(i - <span class="number">1</span>) == p.charAt(j - <span class="number">1</span>) || p.charAt(j - <span class="number">1</span>) == <span class="string">'?'</span>)&#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">				<span class="comment">//pj 为星号</span></span><br><span class="line">                <span class="keyword">if</span>(p.charAt(j - <span class="number">1</span>) == <span class="string">'*'</span>)&#123;</span><br><span class="line">                    dp[i][j] = dp[i][j - <span class="number">1</span>] || dp[i - <span class="number">1</span>][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度O(mn)，空间复杂度O(mn)。</p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode Hard</tag>
        <tag>字符串</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>重构</title>
    <url>/2021/04/11/%E9%87%8D%E6%9E%84/</url>
    <content><![CDATA[<h2 id="代码的坏味道"><a href="#代码的坏味道" class="headerlink" title="代码的坏味道"></a>代码的坏味道</h2><h3 id="Duplicated-Code（重复代码）"><a href="#Duplicated-Code（重复代码）" class="headerlink" title="Duplicated Code（重复代码）"></a>Duplicated Code（重复代码）</h3><p>如果你在一个以上的地方看见相同的程序结构，将它们合二为一。</p>
<h3 id="Long-Method（过长函数）"><a href="#Long-Method（过长函数）" class="headerlink" title="Long Method（过长函数）"></a>Long Method（过长函数）</h3><p>将过长的函数分解为若干个小函数。</p>
<a id="more"></a>

<h3 id="Large-Class（过大的类）"><a href="#Large-Class（过大的类）" class="headerlink" title="Large Class（过大的类）"></a>Large Class（过大的类）</h3><p>单个类要做的事情太多，将其分解为几个类。</p>
<h3 id="Long-Parameter-List（过长参数列）"><a href="#Long-Parameter-List（过长参数列）" class="headerlink" title="Long Parameter List（过长参数列）"></a>Long Parameter List（过长参数列）</h3><p>如果参数太多，考虑使用参数对象。</p>
<h3 id="Divergent-Change（发散式变化）"><a href="#Divergent-Change（发散式变化）" class="headerlink" title="Divergent Change（发散式变化）"></a>Divergent Change（发散式变化）</h3><p>某个类经常因为不同的原因在不同的方向上发生变化。当你看见<strong>一个类</strong>说：“新加入一个数据库，我必须修改三个函数”</p>
<h3 id="Shotgun-Surgery（霰弹式修改）"><a href="#Shotgun-Surgery（霰弹式修改）" class="headerlink" title="Shotgun Surgery（霰弹式修改）"></a>Shotgun Surgery（霰弹式修改）</h3><p>如果每遇到某种变化，你都必须在许多<strong>不同</strong>的类中做出许多小修改。</p>
<h3 id="Feature-Envy（依恋情结）"><a href="#Feature-Envy（依恋情结）" class="headerlink" title="Feature Envy（依恋情结）"></a>Feature Envy（依恋情结）</h3><p>函数对某个类的兴趣高过于对自己所处类的兴趣。</p>
<h3 id="Data-Clumps（数据泥团）"><a href="#Data-Clumps（数据泥团）" class="headerlink" title="Data Clumps（数据泥团）"></a>Data Clumps（数据泥团）</h3><p>常在许多地方看到成群的数据，考虑将其抽取为类。</p>
<h3 id="Primitive-Obsession（基本类型偏执）"><a href="#Primitive-Obsession（基本类型偏执）" class="headerlink" title="Primitive Obsession（基本类型偏执）"></a>Primitive Obsession（基本类型偏执）</h3><p>尝试将原本单独存在的数据值替换为对象</p>
<h3 id="Switch-Statements（Switch-语句）"><a href="#Switch-Statements（Switch-语句）" class="headerlink" title="Switch Statements（Switch 语句）"></a>Switch Statements（Switch 语句）</h3><p>大多数时候，一看到 Switch ，就应该考虑使用<strong>多态</strong>来替换它。</p>
<h3 id="Parallel-Inheritance-Hierarchies（平行继承体系）"><a href="#Parallel-Inheritance-Hierarchies（平行继承体系）" class="headerlink" title="Parallel Inheritance Hierarchies（平行继承体系）"></a>Parallel Inheritance Hierarchies（平行继承体系）</h3><p>每当你为某个类增加一个子类，也必须为另一个类增加一个子类。消除策略：让一个继承体系的实例引用另一个继承体系的实例。</p>
<h3 id="Lazy-Class（冗余类）"><a href="#Lazy-Class（冗余类）" class="headerlink" title="Lazy Class（冗余类）"></a>Lazy Class（冗余类）</h3><p>删除它。</p>
<h3 id="Speculative-Generality（夸夸其谈未来性）"><a href="#Speculative-Generality（夸夸其谈未来性）" class="headerlink" title="Speculative Generality（夸夸其谈未来性）"></a>Speculative Generality（夸夸其谈未来性）</h3><p>删掉无用的函数和linshi函数中多余的参数。</p>
<h3 id="Temporary-Field（令人迷惑的暂时字段）"><a href="#Temporary-Field（令人迷惑的暂时字段）" class="headerlink" title="Temporary Field（令人迷惑的暂时字段）"></a>Temporary Field（令人迷惑的暂时字段）</h3><p>类中某个实例变量仅为某种特定情况而设置，通常你认为对象在所有时候都需要它的所有变量，在变量未被使用的情况下猜测其设置目的，会让你发疯的！将这些变量抽取为类。</p>
<h3 id="Message-Chains（过度耦合的消息链）"><a href="#Message-Chains（过度耦合的消息链）" class="headerlink" title="Message Chains（过度耦合的消息链）"></a>Message Chains（过度耦合的消息链）</h3><p>用户向一个对象请求另一个对象，然后再向后者请求另一个都西昂，然后再请求另一个对象 ……… 这就是消息链。</p>
<h3 id="Middle-Man（中间人）"><a href="#Middle-Man（中间人）" class="headerlink" title="Middle Man（中间人）"></a>Middle Man（中间人）</h3><p>某个类接口有一半的函数都委托给其他类，这是就应该去掉 Middle Man，直接和真正负责的对象打交道。</p>
<h3 id="Inappropriate-Intimacy（狎昵关系）"><a href="#Inappropriate-Intimacy（狎昵关系）" class="headerlink" title="Inappropriate Intimacy（狎昵关系）"></a>Inappropriate Intimacy（狎昵关系）</h3><p>两个类过于亲密，花费太多时间去探究彼此的 private 成分。应该将这两个类分开，帮它们划清界限。</p>
<h3 id="Alternative-Classes-with-Different-Interfaces（异曲同工的类）"><a href="#Alternative-Classes-with-Different-Interfaces（异曲同工的类）" class="headerlink" title="Alternative Classes with Different Interfaces（异曲同工的类）"></a>Alternative Classes with Different Interfaces（异曲同工的类）</h3><p>两个函数做着同样的事情，却有不同的签名，尝试根据它们的用途进行重命名。</p>
<h3 id="Data-Class（纯稚的数据类）"><a href="#Data-Class（纯稚的数据类）" class="headerlink" title="Data Class（纯稚的数据类）"></a>Data Class（纯稚的数据类）</h3><p>拥有一些字段，以及用于访问这些字段的函数。</p>
<h3 id="Refused-Bequest（被拒绝的捐赠）"><a href="#Refused-Bequest（被拒绝的捐赠）" class="headerlink" title="Refused Bequest（被拒绝的捐赠）"></a>Refused Bequest（被拒绝的捐赠）</h3><p>子类不想或不需要继承超类的函数和数据。</p>
<h3 id="Comments（过多的注释）"><a href="#Comments（过多的注释）" class="headerlink" title="Comments（过多的注释）"></a>Comments（过多的注释）</h3><p> 一段代码中有长长的注释，尝试重构复杂的地方。</p>
<h3 id="Incomplete-Library-Class（不完美的库类）"><a href="#Incomplete-Library-Class（不完美的库类）" class="headerlink" title="Incomplete Library Class（不完美的库类）"></a>Incomplete Library Class（不完美的库类）</h3><p>想要对库类添加或修改，可以引入本地扩展。</p>
<h2 id="重新组织函数"><a href="#重新组织函数" class="headerlink" title="重新组织函数"></a>重新组织函数</h2><h3 id="Extract-Method（提炼函数）"><a href="#Extract-Method（提炼函数）" class="headerlink" title="Extract Method（提炼函数）"></a>Extract Method（提炼函数）</h3><p>你有一段代码可以被组织在一起并独立出来。<strong>将这段代码放进一个独立函数中，并让函数名称解释该函数的用途。</strong></p>
<h3 id="Inline-Method（内联函数）"><a href="#Inline-Method（内联函数）" class="headerlink" title="Inline Method（内联函数）"></a>Inline Method（内联函数）</h3><p>一个函数的本体与名称同样清楚易懂。<strong>在函数调用点插入函数本体，然后删除函数。</strong></p>
<h3 id="Inline-Temp（内联临时变量）"><a href="#Inline-Temp（内联临时变量）" class="headerlink" title="Inline Temp（内联临时变量）"></a>Inline Temp（内联临时变量）</h3><p>你有一个临时变量，只被一个简单表达式肤质一次，而它妨碍了其他重构手法。</p>
<p><strong>将所有对该变量的引用动作，替换为对它赋值的表达式自身。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> basePrice = anOrder.basePrice();</span><br><span class="line"><span class="keyword">return</span> basePrice &gt; <span class="number">100</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> anOrder.basePrice() &gt; <span class="number">100</span>;</span><br></pre></td></tr></table></figure>



<h3 id="Return-Temp-With-Query（以查询取代临时变量）"><a href="#Return-Temp-With-Query（以查询取代临时变量）" class="headerlink" title="Return Temp With Query（以查询取代临时变量）"></a>Return Temp With Query（以查询取代临时变量）</h3><p>你的此程序以一个临时变量保存某一表达式的运算结果。</p>
<p><strong>将这个表达式提炼到一个独立函数中。将这个临时变量的所有引用点替换为对新函数的调用。此后，新函数就可被其他函数使用。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> basePrice = _quantity * _itemPrice;</span><br><span class="line"><span class="keyword">if</span>(basePrice &gt; <span class="number">1000</span>)</span><br><span class="line">    <span class="keyword">return</span> basePrice * <span class="number">0.95</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> basePrice * <span class="number">0.99</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(basePrice() &gt; <span class="number">1000</span>)</span><br><span class="line">    <span class="keyword">return</span> basePrice() * <span class="number">0.95</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> basePrice() * <span class="number">0.99</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">basePrice</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _quantity * _itemPrice;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Introduce-Explaining-Variable（引用解释性变量）"><a href="#Introduce-Explaining-Variable（引用解释性变量）" class="headerlink" title="Introduce Explaining Variable（引用解释性变量）"></a>Introduce Explaining Variable（引用解释性变量）</h3><p>你有一个复杂的表达式，<strong>将该复杂表达式（或其中一部分）的结果放进一个临时变量，以此变量名称来解释表达式用途。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>((platform.toUpperCase().indexOf(<span class="string">'MAC'</span>) &gt; -<span class="number">1</span>) &amp;&amp;</span><br><span class="line">  (browser.toUpperCase().indexOf(<span class="string">'IE'</span>) &gt; -<span class="number">1</span>) &amp;&amp;</span><br><span class="line">  wasInitialized() &amp;&amp; resize &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">//do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> isMacOS = platform.toUpperCase().indexOf(<span class="string">'MAC'</span>) &gt; -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> isIEBrowser = browser.toUpperCase().indexOf(<span class="string">'IE'</span>) &gt; -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> wasResized = resize &gt; <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(isMacOS &amp;&amp; isIEBrowser &amp;&amp; wasInitialized() &amp;&amp; wasResized)&#123;</span><br><span class="line"><span class="comment">// do something&#125;</span></span><br></pre></td></tr></table></figure>



<h3 id="Split-Temporary-Variable（分解临时变量）"><a href="#Split-Temporary-Variable（分解临时变量）" class="headerlink" title="Split Temporary Variable（分解临时变量）"></a>Split Temporary Variable（分解临时变量）</h3><p>你的程序有某个临时变量被赋值超过一次，它既不是循环变量，也不被用于收集计算结果。<strong>针对每次赋值，创造一个独立、对应的临时变量。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> temp = <span class="number">2</span> * (_height + _width);</span><br><span class="line">System.out.println(temp);</span><br><span class="line">temp = _height * _width;</span><br><span class="line">System.out.println(temp);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">double</span> perimeter = <span class="number">2</span> * (_height + _width);</span><br><span class="line">System.out.println(perimeter);</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">double</span> area = _height * _width;</span><br><span class="line">System.out.println(area);</span><br></pre></td></tr></table></figure>



<h3 id="Remove-Assignments-to-Parameters（移除对参数的赋值）"><a href="#Remove-Assignments-to-Parameters（移除对参数的赋值）" class="headerlink" title="Remove Assignments to Parameters（移除对参数的赋值）"></a>Remove Assignments to Parameters（移除对参数的赋值）</h3><p>代码对一个参数进行赋值。<strong>以一个临时变量取代该参数的位置</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">discount</span><span class="params">(<span class="keyword">int</span> inputVal, <span class="keyword">int</span> quantity, <span class="keyword">int</span> yearToDate)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(inputVal &gt; <span class="number">50</span>) inputVal -= <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">discount</span><span class="params">(<span class="keyword">int</span> inputVal, <span class="keyword">int</span> quantity, <span class="keyword">int</span> yearToDate)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = inputVal;</span><br><span class="line">    <span class="keyword">if</span>(result &gt; <span class="number">50</span>) result -= <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Replace-Method-with-Object（以函数对象取代函数）"><a href="#Replace-Method-with-Object（以函数对象取代函数）" class="headerlink" title="Replace Method with Object（以函数对象取代函数）"></a>Replace Method with Object（以函数对象取代函数）</h3><p>你有一个大型函数，其中对局部变量的使用使你无法采用<strong><em>Extract Method</em></strong>。</p>
<p><strong>将这个函数放进一个单独对象中，如此一来局部变量就成了对象内的字段。然后你可以在同一个对象中将这个大型函数分解为多个小函数。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Order</span></span>&#123;</span><br><span class="line">    <span class="comment">//长函数</span></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">price</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">double</span> primaryBasePrice;</span><br><span class="line">        <span class="keyword">double</span> secondaryBasePrice;</span><br><span class="line">        <span class="keyword">double</span> tertiaryBasePrice;</span><br><span class="line">        <span class="comment">// long computation</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Order</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">price</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PriceCalculator().compute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PriceCalculator</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> primaryBasePrice;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> secondaryBasePrice;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> tertiaryBasePrice;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">compute</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//long computation</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Subsititute-Algorithm（替换算法）"><a href="#Subsititute-Algorithm（替换算法）" class="headerlink" title="Subsititute Algorithm（替换算法）"></a>Subsititute Algorithm（替换算法）</h3><p>你想要把某个算法替换为另一个更清晰的算法。<strong>将函数本体替换为另一个算法。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">String <span class="title">foundPerson</span><span class="params">(String[] people)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; people.length(); i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(people[i].equals(<span class="string">"Don"</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Don"</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(people[i].equals(<span class="string">"John"</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"John"</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(people[i].equals(<span class="string">"Kent"</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Kent"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">String <span class="title">foundPerson</span><span class="params">(String[] people)</span></span>&#123;</span><br><span class="line">    List&lt;String&gt; candidates = Arrays.asList(<span class="keyword">new</span> String[]&#123;<span class="string">"Don"</span>, <span class="string">"John"</span>, <span class="string">"Kent"</span>&#125;);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; people.length(); i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(candidates.contains(people[i]))&#123;</span><br><span class="line">            <span class="keyword">return</span> people[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="在对象之间搬移特性"><a href="#在对象之间搬移特性" class="headerlink" title="在对象之间搬移特性"></a>在对象之间搬移特性</h2><h3 id="Move-Method（搬移函数）"><a href="#Move-Method（搬移函数）" class="headerlink" title="Move Method（搬移函数）"></a>Move Method（搬移函数）</h3><p>你的程序中，有个函数与其驻类之外的另一个类进行更多交流：调用后者，或被后者调用。</p>
<p>在该函数最常引用的类中建立一个有着类似行为的新函数。将旧函数变成一个单独的委托函数，或者将旧函数完全移除。</p>
<h3 id="Move-Field（搬移字段）"><a href="#Move-Field（搬移字段）" class="headerlink" title="Move Field（搬移字段）"></a>Move Field（搬移字段）</h3><p>在你的程序中，某个字段被其所驻类之外的另一个类更多地用到。</p>
<p><strong>在目标类新建一个字段，修改源字段地所有用户，令它们改用新字段。</strong></p>
<h3 id="Extract-Class（提炼类）"><a href="#Extract-Class（提炼类）" class="headerlink" title="Extract Class（提炼类）"></a>Extract Class（提炼类）</h3><p>某个类做了应该由两个类做的事。</p>
<p><strong>建立一个新类，将相关的字段和函数从旧类搬移到新类。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String officeAreaCode;</span><br><span class="line">    <span class="keyword">private</span> String officeNumber;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">getTelephoneNumber</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="string">"("</span> + officeAreaCode + <span class="string">")"</span> + officeNumber);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> TelephoneNumber tel;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">getTelephoneNumber</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> tel.getTelephoneNumber();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TelephoneNumber</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String officeAreaCode;</span><br><span class="line">    <span class="keyword">private</span> String officeNumber;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">getTelephoneNumber</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="string">"("</span> + officeAreaCode + <span class="string">")"</span> + officeNumber);</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Inline-Class（将类内联化）"><a href="#Inline-Class（将类内联化）" class="headerlink" title="Inline Class（将类内联化）"></a>Inline Class（将类内联化）</h3><p>某个类没有做太多事情。<strong>将这个类的所有特性搬移到另一个类中，然后移除原类。</strong></p>
<p>刚好与<strong><em>Extract Class</em></strong>相反。</p>
<h3 id="Hide-Delegate（隐藏“委托关系”）"><a href="#Hide-Delegate（隐藏“委托关系”）" class="headerlink" title="Hide Delegate（隐藏“委托关系”）"></a>Hide Delegate（隐藏“委托关系”）</h3><p>客户通过一个委托类来调用另一个对象。<strong>在服务类上建立客户所需的所有函数，用以隐藏委托关系。</strong></p>
<p>如果某个客户先通过服务对象的字段得到另一个对象，然后调用后者的函数，那么客户就必须知晓这一层委托关系。万一委托关系发生变化，客户也得相应变化。你可以在服务对象上放置一个简单的委托函数，将委托关系隐藏起来，然后去除这种依赖。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Department department;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Department <span class="title">getDepartmeent</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> department;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Department</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Person manager;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Persion <span class="title">getManager</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> manager;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果客户希望知道某人的经理是谁，他必须先取得 Department 对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">manager = john.getDepartment().getManager();</span><br></pre></td></tr></table></figure>

<p>这样就对客户暴露了 Department 的工作原理，我们在 Person 中建立一个简单的委托函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Person <span class="title">getManager</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> department.getManager();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后客户直接调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">manager = john.getManager();</span><br></pre></td></tr></table></figure>



<h3 id="Remove-Middle-Man（移除中间人）"><a href="#Remove-Middle-Man（移除中间人）" class="headerlink" title="Remove Middle Man（移除中间人）"></a>Remove Middle Man（移除中间人）</h3><p>某个类做了过多的简单委托动作。<strong>让客户直接调用委托类。</strong></p>
<p>在 <strong><em>Hide Delegate</em></strong> 中这层封装也是有代价的，它的代价就是：每当客户需要使用受托类的新特性时，你就必须在服务端添加一个简单委托函数。随着受托类的特性越来越多，这一过程会让你痛苦不已。这个时候你就应该让客户直接调用受托类。</p>
<h3 id="Introduce-Foreign-Method（引入外加函数）"><a href="#Introduce-Foreign-Method（引入外加函数）" class="headerlink" title="Introduce Foreign Method（引入外加函数）"></a>Introduce Foreign Method（引入外加函数）</h3><p>你需要为提供服务的类增加一个函数，但你无法修改这个类。<strong>在客户类中建立一个函数，并以第一参数形式传入一个服务类实例。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Date newStart = <span class="keyword">new</span> Date(previousEnd.getYear(), previousEnd.getMonth(), previousEnd.getDate() + <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Date <span class="keyword">new</span> Start = nextDay(previousEnd);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Date <span class="title">nextDay</span><span class="params">(Date arg)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Date(arg.getYear(), arg.getMonth(), arg.getDate() + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果可以修改源码，可以自行添加一个新函数；如果不能，就得在客户端编码，补足你要的那个函数。</p>
<p>如果你发现自己为一个服务类建立了大量外加函数，或者发现有许多类都需要同样的外加函数，就不应该再使用本项重构，而应该使用<strong><em>Introduce Local Extension</em></strong>。</p>
<h3 id="Introduce-Local-Extension（引入本地扩展）"><a href="#Introduce-Local-Extension（引入本地扩展）" class="headerlink" title="Introduce Local Extension（引入本地扩展）"></a>Introduce Local Extension（引入本地扩展）</h3><p>你需要为服务类提供一些额外函数，但你无法修改这个类。</p>
<p><strong>建立一个新类，使它包含这些额外函数。让这个扩展品成为源类的子类或包装类。</strong></p>
<p>我们需要将这些额外函数组织在一起，放到一个恰当地方去。有两种标准对象技术——<strong>子类化（subclassing）</strong>和<strong>包装（wrapping）。</strong>将子类和包装类统称为本地扩展（Local Extension）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//子类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MfDateSub</span> <span class="keyword">extends</span> <span class="title">Date</span></span>&#123;</span><br><span class="line">    MfDateSub(String dateString)&#123;</span><br><span class="line">        <span class="keyword">super</span>(dateString);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">Date <span class="title">nextDay</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Date(getYear(), getMonth(), getDate() + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//包装类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MfDateWrap</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Date original;</span><br><span class="line">    MfDateWrap(String dateString)&#123;</span><br><span class="line">        original = <span class="keyword">new</span> Date(dateString);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    MfDateWrap(Date arg)&#123;</span><br><span class="line">        original = arg;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getYear</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> original.getYear();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMonth</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> original.getMonth();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 省略其他对 Date 类函数的包装</span></span><br><span class="line">    </span><br><span class="line">    <span class="function">Date <span class="title">nextDay</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Date(getYear(), getMonth(), getDate() + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="重新组织数据"><a href="#重新组织数据" class="headerlink" title="重新组织数据"></a>重新组织数据</h2><h3 id="Self-Encapsulate-Field（自封装字段）"><a href="#Self-Encapsulate-Field（自封装字段）" class="headerlink" title="Self Encapsulate Field（自封装字段）"></a>Self Encapsulate Field（自封装字段）</h3><p>你直接访问一个字段，但与字段之间的耦合关系逐渐变得笨拙。<strong>为这个字段建立设值/取值函数，并只以这些函数来访问字段。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> low, high;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">includes</span><span class="params">(<span class="keyword">int</span> arg)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arg &gt;= low &amp;&amp; arg &lt;= high;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> low, hign;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">includes</span><span class="params">(<span class="keyword">int</span> arg)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arg &gt;= getLow() &amp;&amp; arg &lt;= getHigh();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Replace-Data-Value-with-Object（以对象取代数据值）"><a href="#Replace-Data-Value-with-Object（以对象取代数据值）" class="headerlink" title="Replace Data Value with Object（以对象取代数据值）"></a>Replace Data Value with Object（以对象取代数据值）</h3><p>你有一个数据项，需要与其他数据和行为一起使用才有意义。<strong>将数据项变成对象。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Order</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String customer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Order</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Customer customer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Customer</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Change-Value-to-Reference（将值对象改为引用对象）"><a href="#Change-Value-to-Reference（将值对象改为引用对象）" class="headerlink" title="Change Value to Reference（将值对象改为引用对象）"></a>Change Value to Reference（将值对象改为引用对象）</h3><p>你从一个类衍生出许多彼此相等的实例，希望将它们替换为同一个对象。<strong>将这个值对象变成引用对象。</strong></p>
<p>在<strong><em>Replace Data Value with Object</em></strong>中，留下了一个重构后的程序。到目前为止，Customer 对象还是值对象。就算多份订单属于同一用户，但每个 Order 对象还是拥有各自的 Customer 对象。我希望一个用户可以有多个订单，所有 Order 对象共同拥有同一个 Customer 对象<strong>（每一个客户名称只该对应一个Customer对象）</strong>。</p>
<p>首先使用<strong><em>Replace Constructor with Factory Method</em></strong>。这样，就可以控制 Customer 对象的创建过程。在 Customer 类中定义这个工厂函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Customer</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Customer <span class="title">create</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Customer(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后更改调用点：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Order</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Order</span><span class="params">(String customer)</span></span>&#123;</span><br><span class="line">        customer = Customer.create(customer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后把 Customer 类的构造函数改为 private。</p>
<p>在 Customer 类中使用 HashMap 存储 Customer 对象，并更改工厂方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Customer</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, Customer&gt; instances = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">store</span><span class="params">()</span></span>&#123;</span><br><span class="line">        instances.put(<span class="keyword">this</span>.getName(), <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//直接写死几个数据(应该从数据库读取)</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loadCustomer</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Customer(<span class="string">"a"</span>).store();</span><br><span class="line">        <span class="keyword">new</span> Customer(<span class="string">"b"</span>).store();</span><br><span class="line">        <span class="keyword">new</span> Customer(<span class="string">"c"</span>).store();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//工厂方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Customer <span class="title">getNamed</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (Customer) instances.get(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Change-Reference-to-Value（将引用对象改为值对象）"><a href="#Change-Reference-to-Value（将引用对象改为值对象）" class="headerlink" title="Change Reference to Value（将引用对象改为值对象）"></a>Change Reference to Value（将引用对象改为值对象）</h3><p>你有一个引用对象，很小且<strong>不可变</strong>，而且不易管理。<strong>将它变成一个值对象（类没有修改对象数据的函数）。</strong></p>
<h3 id="Replace-Array-with-Object（以对象取代数组）"><a href="#Replace-Array-with-Object（以对象取代数组）" class="headerlink" title="Replace Array with Object（以对象取代数组）"></a>Replace Array with Object（以对象取代数组）</h3><p>你有一个数组，其中的元素各自代表不同的东西。<strong>以对象替换数组，对于数组中的每个元素，以一个字段来表示。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] row = <span class="keyword">new</span> String[<span class="number">3</span>];</span><br><span class="line">row[<span class="number">0</span>] = <span class="string">"Liverpool"</span>;</span><br><span class="line">row[<span class="number">1</span>] = <span class="string">"15"</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Performance p = <span class="keyword">new</span> Performance();</span><br><span class="line">p.setName(<span class="string">"Livepool"</span>);</span><br><span class="line">p.setWins(<span class="string">"15"</span>);</span><br></pre></td></tr></table></figure>



<h3 id="Duplicate-Observed-Data-（复制“被监视数据”）"><a href="#Duplicate-Observed-Data-（复制“被监视数据”）" class="headerlink" title="Duplicate Observed Data （复制“被监视数据”）"></a>Duplicate Observed Data （复制“被监视数据”）</h3><p>你有一些领域（Model）数据置身于 GUI 控件中，而领域函数需要访问这些函数。</p>
<p>将该数据复制到一个领域对象中。建立一个Observer 模式，用以同步领域对象和 GUI 对象内的重复数据。</p>
<h3 id="Change-Unidirectional-Association-to-Bidirectional（将单向关联改为双向关联）"><a href="#Change-Unidirectional-Association-to-Bidirectional（将单向关联改为双向关联）" class="headerlink" title="Change Unidirectional Association to Bidirectional（将单向关联改为双向关联）"></a>Change Unidirectional Association to Bidirectional（将单向关联改为双向关联）</h3><p>两个类都需要使用对方特性，但其间只有一条单向连接。<strong>添加一个反向指针，并使修改函数（指改变双方关系的函数）能够同时更新两条连接。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一个用户可以有多个订单</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Order</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Customer customer;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setCustomer</span><span class="params">(Customer arg)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(customer != <span class="keyword">null</span>)</span><br><span class="line">            customer.friendOrders().remove(<span class="keyword">this</span>);</span><br><span class="line">        customer = arg;</span><br><span class="line">        <span class="keyword">if</span>(customer != <span class="keyword">null</span>)</span><br><span class="line">            customer.friendOrders().add(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Customer</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Set&lt;Order&gt; orders = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="function">Set&lt;Order&gt; <span class="title">friengOrders</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> orders;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Change-Bidirectional-Association-to-Unidirectional-（将双向关联改为单向关联）"><a href="#Change-Bidirectional-Association-to-Unidirectional-（将双向关联改为单向关联）" class="headerlink" title="Change Bidirectional Association to Unidirectional （将双向关联改为单向关联）"></a>Change Bidirectional Association to Unidirectional （将双向关联改为单向关联）</h3><p>两个类之间有双向关联，但其中一个类如今不再需要另一个类的特性。<strong>去除不必要的关联。</strong></p>
<p>双向关联很有用，但你也为必须为它付出代价，那就是维护双向连接、确保对象被正确创建和删除而增加的复杂度。大量双向连接也容易造成“僵尸对象”：某个对象本来已经死亡了，却仍然保留在系统中，因为对它的引用还没有完全清除。</p>
<h3 id="Replace-Magic-Number-with-Symbolic-Constant（以字面常量取代魔法数）"><a href="#Replace-Magic-Number-with-Symbolic-Constant（以字面常量取代魔法数）" class="headerlink" title="Replace Magic Number with Symbolic Constant（以字面常量取代魔法数）"></a>Replace Magic Number with Symbolic Constant（以字面常量取代魔法数）</h3><p>你有一个字面数值，带有特别意义。<strong>创建一个常量，根据其意义为它命名，并将上述的字面数值替换为这个常量。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">potentialEnergy</span><span class="params">(<span class="keyword">double</span> mass, <span class="keyword">double</span> height)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mass * <span class="number">9.81</span> * height;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">double</span> GRAVITATIONAL_CONSTANT = <span class="number">9.81</span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">potentialEnergy</span><span class="params">(<span class="keyword">double</span> mass, <span class="keyword">double</span> height)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mass * GRAVITATIONAL_CONSTANT * height;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Encapsulate-Field（封装字段）"><a href="#Encapsulate-Field（封装字段）" class="headerlink" title="Encapsulate Field（封装字段）"></a>Encapsulate Field（封装字段）</h3><p>你的类中存在一个 public 字段。<strong>将它声明为 private，并提供相应的访问函数。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String name;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Encapsulate-Collection（封装集合）"><a href="#Encapsulate-Collection（封装集合）" class="headerlink" title="Encapsulate Collection（封装集合）"></a>Encapsulate Collection（封装集合）</h3><p>有个函数返回一个集合。<strong>让这个函数返回该集合的一个只读副本，并在这个类中提供添加/移除集合元素的函数。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    List&lt;String&gt; skills = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    String[] getSkills()&#123;</span><br><span class="line">        <span class="keyword">return</span> (String[])skills.toArray(<span class="keyword">new</span> String[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setSkill</span><span class="params">(<span class="keyword">int</span> index, String newSkill)</span></span>&#123;</span><br><span class="line">        skill.set(index, newSkill);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Replace-Record-with-Data-Class（以数据类取代记录）"><a href="#Replace-Record-with-Data-Class（以数据类取代记录）" class="headerlink" title="Replace Record with Data Class（以数据类取代记录）"></a>Replace Record with Data Class（以数据类取代记录）</h3><p>你需要面对传统编程环境中的记录结构。为该记录创建一个 POJO。</p>
<h3 id="Replace-Type-Code-with-Class（以类取代类型码）"><a href="#Replace-Type-Code-with-Class（以类取代类型码）" class="headerlink" title="Replace Type Code with Class（以类取代类型码）"></a>Replace Type Code with Class（以类取代类型码）</h3><p>类之中有一个数值类型码，但它不影响类的行为。<strong>以一个新的类替换该数值类型码。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> O = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> A = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> B = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> AB = <span class="number">3</span>;</span><br><span class="line">    privaet <span class="keyword">int</span> bloodGroup;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> BloodGroup bloddGroup;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BloodGroup</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> BloodGroup O = <span class="keyword">new</span> BloodGroup(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> BloodGroup A = <span class="keyword">new</span> BloodGroup(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> BloodGroup B = <span class="keyword">new</span> BloodGroup(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> BloodGroup AB = <span class="keyword">new</span> BloodGroup(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> BloodGroup[] values = &#123;O,A,B,AB&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> code;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">BloodGroup</span><span class="params">(<span class="keyword">int</span> code)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.code = code;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Replace-Type-Code-with-Subclasses（以子类取代类型码）"><a href="#Replace-Type-Code-with-Subclasses（以子类取代类型码）" class="headerlink" title="Replace Type Code with Subclasses（以子类取代类型码）"></a>Replace Type Code with Subclasses（以子类取代类型码）</h3><p>你有一个不可变的类型码，它会影响类的行为。<strong>以子类取代这个类型码。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ENGINEER = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SALESMAN = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MANAGER = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> type;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Engineer</span> <span class="keyword">extends</span> <span class="title">Employee</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getType</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Employee.ENGINEER;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//其他两个不写了</span></span><br></pre></td></tr></table></figure>



<h3 id="Replace-Type-Code-with-State-Strategy-（以State-Strategy取代类型码）"><a href="#Replace-Type-Code-with-State-Strategy-（以State-Strategy取代类型码）" class="headerlink" title="Replace Type Code with State/Strategy （以State/Strategy取代类型码）"></a>Replace Type Code with State/Strategy （以State/Strategy取代类型码）</h3><p>你有一个类型码，它会影响类的行为，但你无法通过继承手法消除它。<strong>以状态对象取代类型码。</strong></p>
<p>继续使用上面的 Employee 例子。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">EmployeeType</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">getTypeCode</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">extends</span> <span class="title">EmployeeType</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getTypeCode</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Employee.ENGNIEER;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//剩余两个省略</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ENGINEER = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SALESMAN = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MANAGER = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">private</span> EmployeeType type;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getType</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> type.getTypeCode();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setType</span><span class="params">(<span class="keyword">int</span> arg)</span></span>&#123;</span><br><span class="line">        <span class="keyword">switch</span>(arg)&#123;</span><br><span class="line">            <span class="keyword">case</span> ENGNIEER:</span><br><span class="line">                type = <span class="keyword">new</span> Engineer();<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> SALESMAN:</span><br><span class="line">                type = <span class="keyword">new</span> Salesman();<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MANAGER:</span><br><span class="line">                type = <span class="keyword">new</span> Manager();<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Incorrect Employee Code"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Replace-Subclass-with-Field（以字段取代子类）"><a href="#Replace-Subclass-with-Field（以字段取代子类）" class="headerlink" title="Replace Subclass with Field（以字段取代子类）"></a>Replace Subclass with Field（以字段取代子类）</h3><p>你的各个子类的唯一差别只在“返回常量数据”的函数上。<strong>修改这些函数，使它们返回超类中的某个（新增）字段，然后销毁子类。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">char</span> <span class="title">getCode</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Male</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">char</span> <span class="title">getCode</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'M'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Female</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">char</span> <span class="title">getCode</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'F'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> code;</span><br><span class="line">    Person(<span class="keyword">char</span> code)&#123;</span><br><span class="line">        <span class="keyword">this</span>.code = code;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">static</span> Person <span class="title">createMale</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Person(<span class="string">'M'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">static</span> Person <span class="title">createFemale</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Person(<span class="string">'F'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="简化条件表达式"><a href="#简化条件表达式" class="headerlink" title="简化条件表达式"></a>简化条件表达式</h2><h3 id="Decompose-Conditional（分解条件表达式）"><a href="#Decompose-Conditional（分解条件表达式）" class="headerlink" title="Decompose Conditional（分解条件表达式）"></a>Decompose Conditional（分解条件表达式）</h3><p>你有一个复杂的条件（if - then - else）语句。<strong>从 if、then、else 三个段落中分别提炼处独立函数。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(date.before (SUMMER_START) || date.after(SUMMER_END))</span><br><span class="line">    charge = quantity * winterRate + winterServiceCharge;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    charge = quantity * summerRate;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(notSummer(date))</span><br><span class="line">    charge = winterCharge(quantity);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    charge = summerCharge(quantity);</span><br></pre></td></tr></table></figure>



<h3 id="Consolidate-Conditional-Expression（合并条件表达式）"><a href="#Consolidate-Conditional-Expression（合并条件表达式）" class="headerlink" title="Consolidate Conditional Expression（合并条件表达式）"></a>Consolidate Conditional Expression（合并条件表达式）</h3><p>你有一系列条件测试，都得到相同结果。<strong>将这些测试合并为一个条件表达式，并将这个条件表达式提炼为一个独立函数。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">disabilityAmount</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(seniority &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(monthsDisabled &gt; <span class="number">12</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(isPartTime) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// compute the disability amount</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">disabilityAmount</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(isNotEligibleForDisability()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// compute the disability amount</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isNotEligibleForDisability</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> seniority &lt; <span class="number">2</span> || monthsDisabled &gt; <span class="number">12</span> || isPartTime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Consolidate-Duplicate-Conditional-Fragments（合并重复的条件片段）"><a href="#Consolidate-Duplicate-Conditional-Fragments（合并重复的条件片段）" class="headerlink" title="Consolidate Duplicate Conditional Fragments（合并重复的条件片段）"></a>Consolidate Duplicate Conditional Fragments（合并重复的条件片段）</h3><p>在条件表达式的每个分支上有着相同的一段代码。<strong>将这段重复代码搬移到条件表达式之外。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(isSpecialDeal())&#123;</span><br><span class="line">    total = price * <span class="number">0.95</span>;</span><br><span class="line">    send();</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    total = price * <span class="number">0.98</span>;</span><br><span class="line">    send();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(isSpecialDeal())</span><br><span class="line">    total = price * <span class="number">0.95</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    total = price * <span class="number">0.98</span>;</span><br><span class="line">send();</span><br></pre></td></tr></table></figure>



<h3 id="Remove-Control-Flag（移除控制标记）"><a href="#Remove-Control-Flag（移除控制标记）" class="headerlink" title="Remove Control Flag（移除控制标记）"></a>Remove Control Flag（移除控制标记）</h3><p>在一系列布尔表达式中，某个变量带有“控制标记（control flag）的作用。<strong>以 break 语句或 return 语句取代控制标记。</strong></p>
<h3 id="Replace-Nested-Conditional-with-Guard-Classes（以卫语句取代嵌套条件表达式）"><a href="#Replace-Nested-Conditional-with-Guard-Classes（以卫语句取代嵌套条件表达式）" class="headerlink" title="Replace Nested Conditional with Guard Classes（以卫语句取代嵌套条件表达式）"></a>Replace Nested Conditional with Guard Classes（以卫语句取代嵌套条件表达式）</h3><p>函数中的条件逻辑使人难以看清正常的执行路径。<strong>使用卫语句（单独检查语句）</strong>表现所有特殊情况。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">getPayAmount</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> result;</span><br><span class="line">    <span class="keyword">if</span>(isDead) result = deadAmount();</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(isSeparated) result = separatedAmount();</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(isRetired) result = retiredAmount();</span><br><span class="line">            <span class="keyword">else</span> result = normalPayment();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">getPayAmount</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(isDead) <span class="keyword">return</span> deadAmount();</span><br><span class="line">    <span class="keyword">if</span>(isSeparated) <span class="keyword">return</span> separatedAmount();</span><br><span class="line">    <span class="keyword">if</span>(isRetired) <span class="keyword">return</span> retiredAmount();</span><br><span class="line">    <span class="keyword">return</span> normalAmount();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Replace-Conditional-with-Polymorphism（以多态取代条件表达式）"><a href="#Replace-Conditional-with-Polymorphism（以多态取代条件表达式）" class="headerlink" title="Replace Conditional with Polymorphism（以多态取代条件表达式）"></a>Replace Conditional with Polymorphism（以多态取代条件表达式）</h3><p>你手上有个条件表达式，它根据对象类型的不同而选择不同的行为。<strong>将这个条件表达式的每个分支放进一个子类的覆写函数中，然后将原始函数声明为抽象函数。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">getSpeed</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(type)&#123;</span><br><span class="line">        <span class="keyword">case</span> EUROPEAN : <span class="keyword">return</span> getBaseSpeed();</span><br><span class="line">        <span class="keyword">case</span> AFRICAN: <span class="keyword">return</span> getBaseSpeed() - getLoadFactor() * numberOfCoconuts;</span><br><span class="line">        <span class="keyword">case</span> NORWEGIAN_BLUE: <span class="keyword">return</span> isNailed ? <span class="number">0</span> : getBaseSpeed(voltage);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Bird</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">double</span> <span class="title">getSpeed</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">European</span> <span class="keyword">extends</span> <span class="title">Bird</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getSpeed</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getSpeed();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//剩下两个类省略</span></span><br></pre></td></tr></table></figure>



<h3 id="Introduce-Null-Object（引入-Null-对象）"><a href="#Introduce-Null-Object（引入-Null-对象）" class="headerlink" title="Introduce Null Object（引入 Null 对象）"></a>Introduce Null Object（引入 Null 对象）</h3><p>你需要再三检查某独享是否为 null。<strong>将 null 值替换为 null 对象。</strong></p>
<h3 id="Introduce-Assertion（引入断言）"><a href="#Introduce-Assertion（引入断言）" class="headerlink" title="Introduce Assertion（引入断言）"></a>Introduce Assertion（引入断言）</h3><p>某一段代码需要对程序状态做出某种假设。<strong>以断言明确表现这种假设。</strong></p>
<p>断言的失败应该导致一个非受控异常。程序最后的成品往往将断言统统删除。</p>
<h2 id="简化函数调用"><a href="#简化函数调用" class="headerlink" title="简化函数调用"></a>简化函数调用</h2><h3 id="Remove-Method（函数改名）"><a href="#Remove-Method（函数改名）" class="headerlink" title="Remove Method（函数改名）"></a>Remove Method（函数改名）</h3><p>函数的名称未能揭示函数的用途。<strong>修改函数名称。</strong></p>
<h3 id="Add-Parameter（添加参数）"><a href="#Add-Parameter（添加参数）" class="headerlink" title="Add Parameter（添加参数）"></a>Add Parameter（添加参数）</h3><p>某个函数需要从调用端得到更多信息。<strong>为此函数添加一个对象参数，让该对象带进函数所需信息。</strong></p>
<h3 id="Remove-Parameter（移除参数）"><a href="#Remove-Parameter（移除参数）" class="headerlink" title="Remove Parameter（移除参数）"></a>Remove Parameter（移除参数）</h3><p>函数本体不再需要某个参数。<strong>将该参数去除。</strong></p>
<h3 id="Separate-Query-from-Modifier（将查询函数和修改函数分离）"><a href="#Separate-Query-from-Modifier（将查询函数和修改函数分离）" class="headerlink" title="Separate Query from Modifier（将查询函数和修改函数分离）"></a>Separate Query from Modifier（将查询函数和修改函数分离）</h3><p>某个函数既返回对象状态值，又修改对象状态。<strong>建立两个不同的函数，其中一个负责查询，另一个负责修改。</strong></p>
<h3 id="Parameterize-Method（令函数携带参数）"><a href="#Parameterize-Method（令函数携带参数）" class="headerlink" title="Parameterize Method（令函数携带参数）"></a>Parameterize Method（令函数携带参数）</h3><p>若干函数做了类似的工作，但在函数本体中却包含了不同的值。<strong>建立单一函数，以参数表达那些不同的值。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fivePercentRaise</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">tenPercentRaise</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">raise</span><span class="params">(<span class="keyword">double</span> percentage)</span></span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Replace-Parameter-with-Explicit-Methods（以明确函数取代参数）"><a href="#Replace-Parameter-with-Explicit-Methods（以明确函数取代参数）" class="headerlink" title="Replace Parameter with Explicit Methods（以明确函数取代参数）"></a>Replace Parameter with Explicit Methods（以明确函数取代参数）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setValue</span><span class="params">(String name, <span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(name.equals(<span class="string">"height"</span>))&#123;</span><br><span class="line">        height = value;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(name.equals(<span class="string">"width"</span>))&#123;</span><br><span class="line">        width = value;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setHeight</span><span class="params">(<span class="keyword">int</span> arg)</span></span>&#123;</span><br><span class="line">    height = arg;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setWidth</span><span class="params">(<span class="keyword">int</span> arg)</span></span>&#123;</span><br><span class="line">    width = arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Preserve-Whole-Object（保持对象完整）"><a href="#Preserve-Whole-Object（保持对象完整）" class="headerlink" title="Preserve Whole Object（保持对象完整）"></a>Preserve Whole Object（保持对象完整）</h3><p>你从某个对象中取出若干值，将它们作为某一次函数调用时的参数。<strong>改为传递整个对象。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> low = daysTempRange().getLow();</span><br><span class="line"><span class="keyword">int</span> high = daysTemoRange().getHigh();</span><br><span class="line">withinPlan = plan.withinRange(low, high);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">withinPlan = plan,withinRange(daysTempRange());</span><br></pre></td></tr></table></figure>



<h3 id="Replace-Parameter-with-Methods（以函数取代函数）"><a href="#Replace-Parameter-with-Methods（以函数取代函数）" class="headerlink" title="Replace Parameter with Methods（以函数取代函数）"></a>Replace Parameter with Methods（以函数取代函数）</h3><p>对象调用某个函数，并将所得结果作为参数，传递给另一个函数。而接受该参数的函数本身也能调用前一个函数。<strong>让参数接受者去除该项参数，并直接调用前一个函数。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> basePrice = quantity * itemPrice;</span><br><span class="line">discountLevel = getDiscountLevel();</span><br><span class="line"><span class="keyword">double</span> finalPrice = discountedPrice(basePrice, discountLevel);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> basePrice = quantity * itemPrice;</span><br><span class="line"><span class="keyword">double</span> finalPrice = discountedPrice(basePrice);</span><br><span class="line"><span class="comment">// 让 discountedPrice 直接调用 getDiscountLevel 函数</span></span><br></pre></td></tr></table></figure>



<h3 id="Introduce-Parameter-Object（引入参数对象）"><a href="#Introduce-Parameter-Object（引入参数对象）" class="headerlink" title="Introduce Parameter Object（引入参数对象）"></a>Introduce Parameter Object（引入参数对象）</h3><p>某些参数总是很自然地同时出现。<strong>以一个对象取代这些参数。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Customer</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">amountInvoicedIn</span><span class="params">(Date start, Date end)</span></span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Customer</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">amountInvoicedIn</span><span class="params">(DateRange dateRange)</span></span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Remove-Setting-Method（移除设值函数）"><a href="#Remove-Setting-Method（移除设值函数）" class="headerlink" title="Remove Setting Method（移除设值函数）"></a>Remove Setting Method（移除设值函数）</h3><p>类中的某个字段应该在对象创建时被设值，然后就不再改变。<strong>去掉该字段的所有设值函数。</strong></p>
<h3 id="Hide-Method（隐藏函数）"><a href="#Hide-Method（隐藏函数）" class="headerlink" title="Hide Method（隐藏函数）"></a>Hide Method（隐藏函数）</h3><p>有一个函数，从来没有被其他任何类用到。<strong>将这个函数修改为 private。</strong></p>
<h3 id="Replace-Constructor-with-Factory-Method（以工厂函数取代构造函数）"><a href="#Replace-Constructor-with-Factory-Method（以工厂函数取代构造函数）" class="headerlink" title="Replace Constructor with Factory Method（以工厂函数取代构造函数）"></a>Replace Constructor with Factory Method（以工厂函数取代构造函数）</h3><p>你希望在创建对象时不仅仅是做简单的建构动作。<strong>将构造函数替换为工厂函数。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Employee(<span class="keyword">int</span> type)&#123;</span><br><span class="line">    <span class="keyword">this</span>.type = type;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> Employee <span class="title">create</span><span class="params">(<span class="keyword">int</span> type)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Employee(type);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Encapsulate-Downcast（封装向下转型）"><a href="#Encapsulate-Downcast（封装向下转型）" class="headerlink" title="Encapsulate Downcast（封装向下转型）"></a>Encapsulate Downcast（封装向下转型）</h3><p>某个函数返回的对象，需要函数调用者执行向下转型（downcast）。<strong>将向下转型动作移到函数中。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Object <span class="title">lastReading</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> readings.lastElement();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Reading <span class="title">lastReading</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (Reading)readings.lastElement();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Replace-Error-Code-with-Exception（以异常取代错误码）"><a href="#Replace-Error-Code-with-Exception（以异常取代错误码）" class="headerlink" title="Replace Error Code with Exception（以异常取代错误码）"></a>Replace Error Code with Exception（以异常取代错误码）</h3><p>某个函数返回一个特定的代码，用以表示某种特殊情况。<strong>改用异常。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">withdraw</span><span class="params">(<span class="keyword">int</span> amount)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(amount &gt; balance)&#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        balance -= amount;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">withdraw</span><span class="params">(<span class="keyword">int</span> amount)</span> <span class="keyword">throws</span> BalaceException</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(amount &gt; balance) <span class="keyword">throw</span> <span class="keyword">new</span> BalanceException();</span><br><span class="line">    balance -= amount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Replace-Exception-with-Test（以测试取代异常）"><a href="#Replace-Exception-with-Test（以测试取代异常）" class="headerlink" title="Replace Exception with Test（以测试取代异常）"></a>Replace Exception with Test（以测试取代异常）</h3><p>面对一个调用着可以预先检查的条件，你抛出了一个异常。<strong>修改调用者，使它在调用函数之气那先做检查。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">getValueForPeriod</span><span class="params">(<span class="keyword">int</span> periodNumber)</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value[periodNumber];</span><br><span class="line">    &#125; <span class="keyword">catch</span>(ArrayIndexOutOfBoundsException e)&#123; <span class="comment">// 滥用异常</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">getValueForPeriod</span><span class="params">(<span class="keyword">int</span> periodNumber)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(periodNumber &gt;= values.length) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> values[periodNumber];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="处理概括关系（继承关系）"><a href="#处理概括关系（继承关系）" class="headerlink" title="处理概括关系（继承关系）"></a>处理概括关系（继承关系）</h2><h3 id="Pull-Up-Field（字段上移）"><a href="#Pull-Up-Field（字段上移）" class="headerlink" title="Pull Up Field（字段上移）"></a>Pull Up Field（字段上移）</h3><p>两个子类拥有相同的字段。<strong>将该字段移至超类。</strong></p>
<h3 id="Pull-Up-Method（函数上移）"><a href="#Pull-Up-Method（函数上移）" class="headerlink" title="Pull Up Method（函数上移）"></a>Pull Up Method（函数上移）</h3><p>有些函数，在各个子类中产生完全相同的结果。<strong>将该函数移至超类。</strong></p>
<h3 id="Pull-Up-Constructor-Body（构造函数本体上移）"><a href="#Pull-Up-Constructor-Body（构造函数本体上移）" class="headerlink" title="Pull Up Constructor Body（构造函数本体上移）"></a>Pull Up Constructor Body（构造函数本体上移）</h3><p>你在各个子类中拥有一些构造函数，它们的本体几乎完全一致。<strong>在超类中新建一个构造函数，并在子类构造函数中调用它。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Manager</span> <span class="keyword">extends</span> <span class="title">Employee</span></span>&#123;</span><br><span class="line">    Manager(String name, String id, <span class="keyword">int</span> grade)&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.grade = grade;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Manager</span> <span class="keyword">extends</span> <span class="title">Employee</span></span>&#123;</span><br><span class="line">    Manager(String name, String id, <span class="keyword">int</span> grade)&#123;</span><br><span class="line">        <span class="keyword">super</span>(name, id);</span><br><span class="line">        <span class="keyword">this</span>.grade = grade;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Push-Down-Method（函数下移）"><a href="#Push-Down-Method（函数下移）" class="headerlink" title="Push Down Method（函数下移）"></a>Push Down Method（函数下移）</h3><p>超类中的某个函数只与部分（而非全部）子类有关。<strong>将这个函数移到相关的那些子类去。</strong></p>
<h3 id="Push-Down-Field（字段下移）"><a href="#Push-Down-Field（字段下移）" class="headerlink" title="Push Down Field（字段下移）"></a>Push Down Field（字段下移）</h3><p>超类中的某些字段只被部分（而非全部）子类用到。<strong>将这个字段移到需要它的那些子类去。</strong></p>
<h3 id="Extract-Subclass（提炼子类）"><a href="#Extract-Subclass（提炼子类）" class="headerlink" title="Extract Subclass（提炼子类）"></a>Extract Subclass（提炼子类）</h3><p>类中的某些特性只被某些（而非全部）实例用到。<strong>新建一个子类，将上面所说的那一部分特性移到子类中。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JobItem</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getTotalPrice</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">unitPrice</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">    <span class="function">Employee <span class="title">getEmployee</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JobItem</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getTotalPrice</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">unitPrice</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LaborItem</span> <span class="keyword">extends</span> <span class="title">JobItem</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">unitPrice</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">    <span class="function">Employee <span class="title">getEmployee</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Extract-Superclass（提炼超类）"><a href="#Extract-Superclass（提炼超类）" class="headerlink" title="Extract Superclass（提炼超类）"></a>Extract Superclass（提炼超类）</h3><p>两个类有相似特性。<strong>为这两个类建立一个超类，将相同特性移至超类。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Department</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getTotalAnnualCost</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">    <span class="function">String <span class="title">getName</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getHeadCount</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getAnnualCost</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">    <span class="function">String <span class="title">getName</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">getId</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Party</span></span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">double</span> <span class="title">getAnnualCost</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> String <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">extends</span> <span class="title">Party</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getAnnualCost</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">getId</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Department</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getAnnualCost</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getHeadCount</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Extract-Interface（提炼接口）"><a href="#Extract-Interface（提炼接口）" class="headerlink" title="Extract Interface（提炼接口）"></a>Extract Interface（提炼接口）</h3><p>若干客户使用类接口中的同一子集，或者两个类的接口有部分相同。<strong>将相同的子集提炼到独立接口中。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span></span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">getRate</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">    <span class="function">String <span class="title">hasSpecialSkill</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">    <span class="function">String <span class="title">getName</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">    String getDepartment&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Billable</span></span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">getRate</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">hasSpecialSkill</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">Billable</span></span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">getRate</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">    <span class="function">String <span class="title">hasSpecialSkill</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">    <span class="function">String <span class="title">getName</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">    String getDepartment&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Collapse-Hierarchy（折叠继承体系）"><a href="#Collapse-Hierarchy（折叠继承体系）" class="headerlink" title="Collapse Hierarchy（折叠继承体系）"></a>Collapse Hierarchy（折叠继承体系）</h3><p>超类与子类之间无太大区别。<strong>将它们合为一体。</strong></p>
<h3 id="Form-Template-Method（塑造模板函数）"><a href="#Form-Template-Method（塑造模板函数）" class="headerlink" title="Form Template Method（塑造模板函数）"></a>Form Template Method（塑造模板函数）</h3><p>你有一些子类，其中相应的某些函数以相同顺序执行类似的操作，但各个操作的细节上有所不同。</p>
<p><strong>将这些操作分别放金独立函数中，并保持它们都有相同的签名，于是原函数也就变得相同了。然后将原函数上移至超类。</strong></p>
<h3 id="Replace-Inheritance-with-Delegation（以委托取代继承）"><a href="#Replace-Inheritance-with-Delegation（以委托取代继承）" class="headerlink" title="Replace Inheritance with Delegation（以委托取代继承）"></a>Replace Inheritance with Delegation（以委托取代继承）</h3><p>某个子类只使用超类接口中的一部分，或是根本不需要继承而来得数据。<strong>在子类中新建一个字段用以保存超类；调整子类函数，令它改而委托超类；然后去掉两者之间的继承关系。</strong></p>
<h3 id="Replace-Delegation-with-Inheritance（以继承取代委托）"><a href="#Replace-Delegation-with-Inheritance（以继承取代委托）" class="headerlink" title="Replace Delegation with Inheritance（以继承取代委托）"></a>Replace Delegation with Inheritance（以继承取代委托）</h3><p>你在两个类之间使用委托关系，并经常为整个接口编写许多极简单的委托函数。<strong>让委托类继承受托类。</strong></p>
<h2 id="大型重构"><a href="#大型重构" class="headerlink" title="大型重构"></a>大型重构</h2><h3 id="Tease-Apart-Inheritance（梳理并分解继承体系）"><a href="#Tease-Apart-Inheritance（梳理并分解继承体系）" class="headerlink" title="Tease Apart Inheritance（梳理并分解继承体系）"></a>Tease Apart Inheritance（梳理并分解继承体系）</h3><p>某个继承体系同时承担两项责任。<strong>建立两个继承体系，并通过委托关系让其中一个可以调用另一个。</strong></p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20201016150252385.png" alt="image-20201016150252385"></p>
<h3 id="Convert-Procedural-Design-to-Objects（将过程化设计转换为对象设计）"><a href="#Convert-Procedural-Design-to-Objects（将过程化设计转换为对象设计）" class="headerlink" title="Convert Procedural Design to Objects（将过程化设计转换为对象设计）"></a>Convert Procedural Design to Objects（将过程化设计转换为对象设计）</h3><p>你手上有一些传统过程化风格的代码。<strong>将数据记录变成对象，将大块的行为分成小块，并将行为移入相关对象中。</strong></p>
<h3 id="Separate-Domain-from-Presentation（将领域和表述-显示分离）"><a href="#Separate-Domain-from-Presentation（将领域和表述-显示分离）" class="headerlink" title="Separate Domain from Presentation（将领域和表述/显示分离）"></a>Separate Domain from Presentation（将领域和表述/显示分离）</h3><p>某些 GUI 类中包含了领域逻辑。<strong>将领域逻辑分离出来，为它们建立独立的领域类。</strong></p>
<p>MVC 模式最核心的价值在于：它将用户界面代码（即视图；也是“展示层”）和领域逻辑（即模型）分离了。展现类只含用以处理用户界面的逻辑；领域类不含任何与程序外观的代码，只含业务逻辑相关代码。</p>
<h3 id="Extract-Hierarchy（提炼继承体系）"><a href="#Extract-Hierarchy（提炼继承体系）" class="headerlink" title="Extract Hierarchy（提炼继承体系）"></a>Extract Hierarchy（提炼继承体系）</h3><p>你有某个类做了太多工作，其中一部分工作是以大量条件表达式完成的。<strong>建立继承体系，以一个子类表示一种特殊情况。</strong></p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
  </entry>
  <entry>
    <title>连续的子数组和</title>
    <url>/2021/06/03/%E8%BF%9E%E7%BB%AD%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C/</url>
    <content><![CDATA[<h4 id="523-连续的子数组和"><a href="#523-连续的子数组和" class="headerlink" title="523. 连续的子数组和"></a><a href="https://leetcode-cn.com/problems/continuous-subarray-sum/" target="_blank" rel="noopener">523. 连续的子数组和</a></h4><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，编写一个函数来判断该数组是否含有同时满足下述条件的连续子数组：</p>
<ul>
<li>子数组大小 <strong>至少为 2</strong> ，且</li>
<li>子数组元素总和为 <code>k</code> 的倍数。</li>
</ul>
<p>如果存在，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>
<p>如果存在一个整数 <code>n</code> ，令整数 <code>x</code> 符合 <code>x = n * k</code> ，则称 <code>x</code> 是 <code>k</code> 的一个倍数。</p>
 <a id="more"></a>

<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [23,2,4,6,7], k &#x3D; 6</span><br><span class="line">输出：true</span><br><span class="line">解释：[2,4] 是一个大小为 2 的子数组，并且和为 6 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [23,2,6,4,7], k &#x3D; 6</span><br><span class="line">输出：true</span><br><span class="line">解释：[23, 2, 6, 4, 7] 是大小为 5 的子数组，并且和为 42 。 </span><br><span class="line">42 是 6 的倍数，因为 42 &#x3D; 7 * 6 且 7 是一个整数。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [23,2,6,4,7], k &#x3D; 13</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>

<p> <strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 105</code></li>
<li><code>0 &lt;= nums[i] &lt;= 109</code></li>
<li><code>0 &lt;= sum(nums[i]) &lt;= 231 - 1</code></li>
<li><code>1 &lt;= k &lt;= 231 - 1</code></li>
</ul>
<p><strong>方法一：前缀和+哈希表</strong></p>
<p>使用暴力直接枚举所有大小大于 2 的子数组，判断子数组和是否为 k 的倍数。这样做时间复杂度为 O(n^3)。</p>
<p>我们可以使用前缀和，这样就可以在 O(1) 时间内判断子数组和是否为 k 的倍数。</p>
<p>用 prefixSum[i] 表示 nums  从下标 0  到下标 i 的前缀和，则 nums 从下标 p + 1 到下标 q 的子数组长度为 q - p，该子数组的元素和为 prefixSum[q] - prefixSum[p]。</p>
<p>如果 prefixSum[q] - prefixSun[p] 为 k 的倍数，且 q - p &gt;= 2，则上述子数组即满足大小至少为 2 且元素和为 k 的倍数。</p>
<p>我们只需保存<strong>每个下标对应的前缀和除 k 的余数</strong>即可，使用哈希表存储每个余数第一次出现的下标。</p>
<p>规定空的前缀的结束下标为 -1，在哈希表中存入键值对(0, -1)。从小到大依次遍历每个 i ，计算每个下标对应的前缀和除以 k 的余数，并维护哈希表。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkSubarraySum</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> remainder = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            remainder = (remainder + nums[i]) % k; <span class="comment">//计算前缀和除 k 的余数</span></span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(remainder))&#123;<span class="comment">//如果存在余数，直接减去见面这个子数组就能得到和为 k 的倍数的子数组</span></span><br><span class="line">                <span class="keyword">int</span> preIndex = map.get(remainder);</span><br><span class="line">                <span class="keyword">if</span>(i - preIndex &gt;= <span class="number">2</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                map.put(remainder, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度O(m)，m 是数组 nums 的长度</li>
<li>空间复杂度最大O(m)</li>
</ul>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode Medium</tag>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title>钥匙和房间</title>
    <url>/2020/08/31/%E9%92%A5%E5%8C%99%E5%92%8C%E6%88%BF%E9%97%B4/</url>
    <content><![CDATA[<h4 id="841-钥匙和房间"><a href="#841-钥匙和房间" class="headerlink" title="841. 钥匙和房间"></a><a href="https://leetcode-cn.com/problems/keys-and-rooms/" target="_blank" rel="noopener">841. 钥匙和房间</a></h4><p>有 <code>N</code> 个房间，开始时你位于 <code>0</code> 号房间。每个房间有不同的号码：<code>0，1，2，...，N-1</code>，并且房间里可能有一些钥匙能使你进入下一个房间。</p>
<p>在形式上，对于每个房间 <code>i</code> 都有一个钥匙列表 <code>rooms[i]</code>，每个钥匙 <code>rooms[i][j]</code> 由 <code>[0,1，...，N-1]</code> 中的一个整数表示，其中 <code>N = rooms.length</code>。 钥匙 <code>rooms[i][j] = v</code> 可以打开编号为 <code>v</code> 的房间。</p>
<p>最初，除 <code>0</code> 号房间外的其余所有房间都被锁住。</p>
<p>你可以自由地在房间之间来回走动。</p>
<p>如果能进入每个房间返回 <code>true</code>，否则返回 <code>false</code>。</p>
<a id="more"></a>

<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [[1],[2],[3],[]]</span><br><span class="line">输出: true</span><br><span class="line">解释:  </span><br><span class="line">我们从 0 号房间开始，拿到钥匙 1。</span><br><span class="line">之后我们去 1 号房间，拿到钥匙 2。</span><br><span class="line">然后我们去 2 号房间，拿到钥匙 3。</span><br><span class="line">最后我们去了 3 号房间。</span><br><span class="line">由于我们能够进入每个房间，我们返回 true。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[[1,3],[3,0,1],[2],[0]]</span><br><span class="line">输出：false</span><br><span class="line">解释：我们不能进入 2 号房间。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ol>
<li><code>1 &lt;= rooms.length &lt;= 1000</code></li>
<li><code>0 &lt;= rooms[i].length &lt;= 1000</code></li>
<li>所有房间中的钥匙数量总计不超过 <code>3000</code>。</li>
</ol>
<p>当 x 号房间中有 y 号房间的钥匙时，我们就可以从 x 号房间去住 y 号房间。如果我们将这 n 个房间看成有向图中的 n 个节点，那么上述关系就可以看作是图中的 x 号点到 y 号点的一条有向边。</p>
<p>这样，问题就变成给定一张有向图，询问从 0 号结点出发能否到达所有的结点。</p>
<p><strong>方法一：DFS</strong></p>
<p>使用 visited 数组来标记已访问过的结点，最后判断是否存在没有访问过的结点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canVisitAllRooms</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; rooms)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = rooms.size();</span><br><span class="line">        <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[m];</span><br><span class="line">        <span class="comment">//从 0 号结点开始 DFS</span></span><br><span class="line">        dfs(rooms, visited, <span class="number">0</span>);</span><br><span class="line">		<span class="comment">//判断是否存在未访问的结点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!visited[i])&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; rooms, <span class="keyword">boolean</span>[] visited, <span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(visited[index])&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        visited[index] = <span class="keyword">true</span>;</span><br><span class="line">        List&lt;Integer&gt; room = rooms.get(index);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; room.size(); i++)&#123;</span><br><span class="line">            dfs(rooms, visited, room.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度O(n + m)，其中 n 是房间的数量，m 是所有房间中钥匙数量的总数。</p>
<p>空间复杂度O(n)，其中 n 是房间的数量。</p>
<p><strong>方法二：BFS</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canVisitAllRooms</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; rooms)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = rooms.size();</span><br><span class="line">        <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[m];</span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        queue.offer(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">//从 0 号结点开始 BFS</span></span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> index = queue.poll();</span><br><span class="line">            <span class="keyword">if</span>(!visited[index])&#123;</span><br><span class="line">                visited[index] = <span class="keyword">true</span>;</span><br><span class="line">                List&lt;Integer&gt; room = rooms.get(index);</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; room.size(); i++)&#123;</span><br><span class="line">                    queue.offer(room.get(i));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//判断是否存在未访问的结点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!visited[i])&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度O(n + m)，其中 n 是房间的数量，m 是所有房间中钥匙数量的总数。</p>
<p>空间复杂度O(n)，其中 n 是房间的数量。</p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode Medium</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>长度最小的子数组</title>
    <url>/2020/07/01/%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h4 id="209-长度最小的子数组"><a href="#209-长度最小的子数组" class="headerlink" title="209. 长度最小的子数组"></a><a href="https://leetcode-cn.com/problems/minimum-size-subarray-sum/" target="_blank" rel="noopener">209. 长度最小的子数组</a></h4><p>给定一个含有 <strong>n</strong> 个正整数的数组和一个正整数 <strong>s ，</strong>找出该数组中满足其和 <strong>≥ s</strong> 的长度最小的连续子数组，并返回其长度<strong>。</strong>如果不存在符合条件的连续子数组，返回 0。</p>
 <a id="more"></a>

<p><strong>示例:</strong> </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: s &#x3D; 7, nums &#x3D; [2,3,1,2,4,3]</span><br><span class="line">输出: 2</span><br><span class="line">解释: 子数组 [4,3] 是该条件下的长度最小的连续子数组。</span><br></pre></td></tr></table></figure>

<p><strong>方法一：暴力法</strong></p>
<p>我们直接枚举子数组的起始点和结束点，计算子数组的和，求解答案。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length, ans = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; n; j++)&#123;</span><br><span class="line">                sum += nums[j];</span><br><span class="line">                <span class="keyword">if</span>(sum &gt;= s)&#123;</span><br><span class="line">                    <span class="comment">//更新最小长度</span></span><br><span class="line">                    ans = Math.min(ans, j - i + <span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 无答案时返回 0 </span></span><br><span class="line">        <span class="keyword">return</span> ans == Integer.MAX_VALUE ? <span class="number">0</span> : ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度O(n^2)，空间复杂度O(1)。</p>
<p><strong>方法二：双指针</strong></p>
<p>在方法一中我们有许多重复计算，我们使用两个指针 start  和 end ，它们都初始化为 0 ，定义 sum 为子数组 nums[start … end] 的和，每一次迭代将 nums[end] 加到 sum ，当 sum &gt;= s 时更新子数组的最小长度，然后将 nums[start] 从 sum 中减去并将 start 右移，直到 sum &lt; s，重复以上步骤，直到 end 遍历到数组末尾。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length, ans = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>, end = <span class="number">0</span>, sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(end &lt; n)&#123;</span><br><span class="line">            sum += nums[end];</span><br><span class="line">            <span class="keyword">while</span>(sum &gt;= s)&#123;</span><br><span class="line">                ans = Math.min(ans, end - start + <span class="number">1</span>);</span><br><span class="line">                sum -= nums[start];</span><br><span class="line">                ++start;</span><br><span class="line">            &#125;</span><br><span class="line">            ++end;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans == Integer.MAX_VALUE ? <span class="number">0</span> : ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度O(n^2)，空间复杂度O(1)。</p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode Medium</tag>
        <tag>双指针</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>除自身以外数组的乘积</title>
    <url>/2020/07/01/%E9%99%A4%E8%87%AA%E8%BA%AB%E4%BB%A5%E5%A4%96%E6%95%B0%E7%BB%84%E7%9A%84%E4%B9%98%E7%A7%AF/</url>
    <content><![CDATA[<h4 id="238-除自身以外数组的乘积"><a href="#238-除自身以外数组的乘积" class="headerlink" title="238. 除自身以外数组的乘积"></a><a href="https://leetcode-cn.com/problems/product-of-array-except-self/" target="_blank" rel="noopener">238. 除自身以外数组的乘积</a></h4><p>给你一个长度为 <em>n</em> 的整数数组 <code>nums</code>，其中 <em>n</em> &gt; 1，返回输出数组 <code>output</code> ，其中 <code>output[i]</code> 等于 <code>nums</code> 中除 <code>nums[i]</code> 之外其余各元素的乘积。</p>
 <a id="more"></a>

<p> <strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,2,3,4]</span><br><span class="line">输出: [24,12,8,6]</span><br></pre></td></tr></table></figure>

<p> <strong>提示：</strong>题目数据保证数组之中任意元素的全部前缀元素和后缀（甚至是整个数组）的乘积都在 32 位整数范围内。</p>
<p><strong>说明:</strong> 请<strong>不要使用除法，</strong>且在 O(<em>n</em>) 时间复杂度内完成此题。</p>
<p><strong>进阶：</strong><br>你可以在常数空间复杂度内完成这个题目吗？（ 出于对空间复杂度分析的目的，输出数组<strong>不被视为</strong>额外空间。）</p>
<p>一看到这个题，我们立刻想到求出数组中所有元素的乘积然后除以对应位置的元素，得到除自身以外的数组的乘积，但是很遗憾，我们并不能使用除法。</p>
<p>看到题目的提示中前缀和后缀，我们想到除自身以外数组的乘积就是数组中一个元素的前缀积乘后缀积，示例中元素 1 的前缀元素为 1 ，后缀元素为 2，3，4，最后得到结果 1 * 24 = 24。元素 3 的前缀元素为 1， 2，后缀元素为 4，最后得到结果 2 * 4 = 8。</p>
<p>我们可以先生成前缀积数组和后缀积数组，求两数组中对应位置元素的积就得到最后的答案。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] productExceptSelf(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">int</span>[] L = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        <span class="keyword">int</span>[] R = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生成前缀数组</span></span><br><span class="line">        L[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++)&#123;</span><br><span class="line">            L[i] = L[i - <span class="number">1</span>] * nums[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生成后缀数组</span></span><br><span class="line">        R[len - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = len - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            R[i] = R[i + <span class="number">1</span>] * nums[i + <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; len; i++)&#123;</span><br><span class="line">            ans[i] = L[i] * R[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度 O(n)，空间复杂度O(n)。</p>
<p>我们可以直接使用 ans 数组来代替前缀数组，最后直接使用 ans 数组乘后缀数组得到结果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] productExceptSelf(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] R = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生成前缀数组</span></span><br><span class="line">        ans[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++)&#123;</span><br><span class="line">            ans[i] = ans[i - <span class="number">1</span>] * nums[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生成后缀数组</span></span><br><span class="line">        R[len - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = len - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            R[i] = R[i + <span class="number">1</span>] * nums[i + <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; len; i++)&#123;</span><br><span class="line">            ans[i] *= R[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间和空间复杂度不变。</p>
<p>更进一步，我们可以使用一个元素 R 来代替 后缀数组，在每次遍历时更新 R 的值即可实现和后缀数组相同的效果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] productExceptSelf(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        <span class="keyword">int</span> R = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 生成前缀数组</span></span><br><span class="line">        ans[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++)&#123;</span><br><span class="line">            ans[i] = ans[i - <span class="number">1</span>] * nums[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = len - <span class="number">1</span> ; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            ans[i] *= R;</span><br><span class="line">            R *= nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度 O(n)，空间复杂度O(1)。</p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode Medium</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>除数博弈</title>
    <url>/2020/07/24/%E9%99%A4%E6%95%B0%E5%8D%9A%E5%BC%88/</url>
    <content><![CDATA[<h4 id="1025-除数博弈"><a href="#1025-除数博弈" class="headerlink" title="1025. 除数博弈"></a><a href="https://leetcode-cn.com/problems/divisor-game/" target="_blank" rel="noopener">1025. 除数博弈</a></h4><p>爱丽丝和鲍勃一起玩游戏，他们轮流行动。爱丽丝先手开局。</p>
<p>最初，黑板上有一个数字 <code>N</code> 。在每个玩家的回合，玩家需要执行以下操作：</p>
<ul>
<li>选出任一 <code>x</code>，满足 <code>0 &lt; x &lt; N</code> 且 <code>N % x == 0</code> 。</li>
<li>用 <code>N - x</code> 替换黑板上的数字 <code>N</code> 。</li>
</ul>
<p>如果玩家无法执行这些操作，就会输掉游戏。</p>
<p>只有在爱丽丝在游戏中取得胜利时才返回 <code>True</code>，否则返回 <code>false</code>。假设两个玩家都以最佳状态参与游戏。</p>
<a id="more"></a>

<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：2</span><br><span class="line">输出：true</span><br><span class="line">解释：爱丽丝选择 1，鲍勃无法进行操作。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：3</span><br><span class="line">输出：false</span><br><span class="line">解释：爱丽丝选择 1，鲍勃也选择 1，然后爱丽丝无法进行操作。</span><br></pre></td></tr></table></figure>

<p> <strong>提示：</strong></p>
<ol>
<li><code>1 &lt;= N &lt;= 1000</code></li>
</ol>
<p>我们尝试写几项：</p>
<ul>
<li><p>N = 1，区间(0, 1)中没有整数是 n 的因数，所以 Alice 败。</p>
</li>
<li><p>N = 2，Alice 选择 1，N 变为 1，Bob 不能继续操作，Alice 胜。</p>
</li>
<li><p>N = 3，Alice 选择 1，N 变为 2，根据 N = 2的结论，Bob 胜，Alice 败。</p>
</li>
<li><p>N = 4，Alice 可选择 1 或 2，当 Alice 选择 2 时 根据 N = 2的结论 ，Alice 败，Alice 选择 1 时，根据 N = 3 的结论，Alice 胜。</p>
</li>
<li><p>N = 5 ，Alice 选择 1 ，根据 N = 4 的结论，Alice 败。 </p>
</li>
</ul>
<p>我们定义 <code>f[i]</code> 表示当数字为 i 时，先手处于必胜态还是必败态，true 代表先手胜，false 代表先手败。当 N = i 时，Alice 在 <code>(0, i)</code>中选择一个因数 j ，使得<code>i % j == 0</code>，且 <code>f[i - j] = false</code>（Bob先手必败），那么 Alice 就可获胜。否则 Alice 败。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">divisorGame</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span>[] f = <span class="keyword">new</span> <span class="keyword">boolean</span>[N + <span class="number">2</span>];</span><br><span class="line">        f[<span class="number">1</span>] = <span class="keyword">false</span>;</span><br><span class="line">        f[<span class="number">2</span>] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= N; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>((i % j == <span class="number">0</span>) &amp;&amp; !f[i - j])&#123;</span><br><span class="line">                    f[i] = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[N];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度O(n^2)，空间复杂度O(n)。</p>
<p>看到前面几项的规律，我们猜测 N 为 奇数时 Alice（先手）必败，N 为偶数时，Alice 必胜。</p>
<p>证明：</p>
<ol>
<li>N = 1 和 N = 2 时结论成立。</li>
<li>N &gt; 2 时，假设 N &lt;= k 时该结论成立，则 N = k + 1 时：<ul>
<li>如果 k 为偶数，则 k + 1 为奇数，x 是 k + 1 的因数，只能为奇数，奇数减去奇数得到偶数，且 k + 1 - x &lt;= k，轮到 Bob 时都是偶数，根据假设，N &lt;= k时，偶数先手必胜，则 Bob 必胜，Alice 必败。</li>
<li>如果 k 为奇数，则 k + 1 为偶数，x 是 k + 1的因数，x 可为奇数和偶数，若 Alice 减去一个奇数，k + 1 - x 一定是个奇数，根据假设 Bob 必败，Alice 必胜。当 x 为偶数时，Alice 必败。故 Alice 选择 x 为奇数。</li>
</ul>
</li>
</ol>
<p>综上，猜想正确。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">divisorGame</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (N &amp; <span class="number">1</span>) == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度O(1)，空间复杂度O(1)。</p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>Leetcode Easy</tag>
      </tags>
  </entry>
  <entry>
    <title>预测赢家</title>
    <url>/2020/09/01/%E9%A2%84%E6%B5%8B%E8%B5%A2%E5%AE%B6/</url>
    <content><![CDATA[<h4 id="486-预测赢家"><a href="#486-预测赢家" class="headerlink" title="486. 预测赢家"></a><a href="https://leetcode-cn.com/problems/predict-the-winner/" target="_blank" rel="noopener">486. 预测赢家</a></h4><p>给定一个表示分数的非负整数数组。 玩家 1 从数组任意一端拿取一个分数，随后玩家 2 继续从剩余数组任意一端拿取分数，然后玩家 1 拿，…… 。每次一个玩家只能拿取一个分数，分数被拿取之后不再可取。直到没有剩余分数可取时游戏结束。最终获得分数总和最多的玩家获胜。</p>
<p>给定一个表示分数的数组，预测玩家1是否会成为赢家。你可以假设每个玩家的玩法都会使他的分数最大化。</p>
 <a id="more"></a>

<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[1, 5, 2]</span><br><span class="line">输出：False</span><br><span class="line">解释：一开始，玩家1可以从1和2中进行选择。</span><br><span class="line">如果他选择 2（或者 1 ），那么玩家 2 可以从 1（或者 2 ）和 5 中进行选择。如果玩家 2 选择了 5 ，那么玩家 1 则只剩下 1（或者 2 ）可选。</span><br><span class="line">所以，玩家 1 的最终分数为 1 + 2 &#x3D; 3，而玩家 2 为 5 。</span><br><span class="line">因此，玩家 1 永远不会成为赢家，返回 False 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[1, 5, 233, 7]</span><br><span class="line">输出：True</span><br><span class="line">解释：玩家 1 一开始选择 1 。然后玩家 2 必须从 5 和 7 中进行选择。无论玩家 2 选择了哪个，玩家 1 都可以选择 233 。</span><br><span class="line">     最终，玩家 1（234 分）比玩家 2（12 分）获得更多的分数，所以返回 True，表示玩家 1 可以成为赢家。</span><br></pre></td></tr></table></figure>

<p> <strong>提示：</strong></p>
<ul>
<li>1 &lt;= 给定的数组长度 &lt;= 20.</li>
<li>数组里所有分数都为非负数且不会大于 10000000 。</li>
<li>如果最终两个玩家的分数相等，那么玩家 1 仍为赢家。</li>
</ul>
<p><strong>方法一：递归</strong></p>
<p>为了判断哪个玩家可以获胜，我们计算一个总分，为先手和后手得分之差。当数组中所有数字被拿取时，如果总分大于等于 0，则先手获胜，反之则后手获胜。</p>
<p>每次可以从数组头和数组尾拿取一个数字，然后轮到另一个玩家在剩下的部分选取数字。计算总分时，需要记录当前玩家是先手还是后手，判断当前玩家的 得分应该记为正还是负。当数组中剩下的数字多于一个时，当前玩家会选择最优的方案，使自己的分数最大化，因此对两种方案分别计算当前玩家可以得到的分数，其中的最大值为当前玩家最多可以得到的分数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">PredictTheWinner</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> total(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>, <span class="number">1</span>) &gt;= <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//turn 为 1 代表先手，为 -1 代表后手</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">total</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span> turn)</span></span>&#123;</span><br><span class="line">        <span class="comment">//数组中只剩一个元素</span></span><br><span class="line">        <span class="keyword">if</span>(start == end)&#123;</span><br><span class="line">            <span class="keyword">return</span> nums[start] * turn;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//当前玩家选择数组头的元素</span></span><br><span class="line">        <span class="keyword">int</span> scoreStart = total(nums, start + <span class="number">1</span>, end, -turn) + nums[start] * turn;</span><br><span class="line">        <span class="comment">//当前玩家选择数组尾的元素</span></span><br><span class="line">        <span class="keyword">int</span> scoreEnd = total(nums, start, end - <span class="number">1</span>, -turn) + nums[end] * turn;</span><br><span class="line">		<span class="comment">//当为先手时，选择分数最大的；当为后手时，选择分数最小的</span></span><br><span class="line">        <span class="keyword">return</span> Math.max(scoreStart * turn, scoreEnd * turn) * turn;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20200901102235086.png" alt="image-20200901102235086"></p>
<p>时间复杂度O(2^n)，n 是数组的长度。</p>
<p>空间复杂度O(n)，n 是数组的长度。</p>
<p><strong>方法二：动态规划</strong></p>
<p>定义二维数组 dp，其行数和列数都等于数组的长度，<code>dp[i][j]</code> 表示当前数组剩下的部分为下标 i  到下标 j时，当前玩家与另一个玩家的分数只差的最大值，注意当前玩家不一定是先手。</p>
<p>只有当 i &lt;= j 时才有意义，当 i = j 时，只剩一个数字，当前玩家只能拿取这个数字，因此对于所有 <code>0 &lt;= i &lt; nums.length</code>，都有<code>dp[i][i] = nums[i]</code>。</p>
<p>当 <code>i &lt; j</code> 时，当前玩家可以选择 nums[i] 或 nums[j]，然后轮到另一个玩家在数组剩下的部分选取数字。在两种方案中，当前玩家会选择最优的方案，使自己的分数最大化。得到转台方程：<br>$$<br>dp[i][j] = max(nums[i] - dp[i + 1][j], nums[j] - dp[i][j - 1])<br>$$<br><code>nums[i] - dp[i + 1][j]</code>代表选择数组头的元素减去另一个玩家的分数之差，<code>nums[j] - dp[i][j - 1]</code>代表选择数组尾的元素减去另一个玩家的分数之差。</p>
<p>最后判断 <code>dp[0][nums.length - 1]</code>的值，如果大于等于 0 则先手得分大于后手得分，先手赢，反之则后手赢。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">PredictTheWinner</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = nums.length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[length][length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++)&#123;</span><br><span class="line">            dp[i][i] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = length - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; length; j++)&#123;</span><br><span class="line">                dp[i][j] = Math.max(nums[i] - dp[i + <span class="number">1</span>][j], nums[j] - dp[i][j - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][length - <span class="number">1</span>] &gt;= <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度O(n^2)，n 是数组的长度。</p>
<p>空间复杂度O(n^2)，n 是数组的长度。</p>
<p>我们可以对空间复杂度进行优化.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">PredictTheWinner</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = nums.length;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++)&#123;</span><br><span class="line">            dp[i] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = length - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; length; j++)&#123;</span><br><span class="line">                dp[j] = Math.max(nums[i] - dp[j], nums[j] - dp[j - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[length - <span class="number">1</span>] &gt;= <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度O(n^2)，n 是数组的长度。</p>
<p>空间复杂度O(n)，n 是数组的长度。</p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode Medium</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>顺时针打印矩阵</title>
    <url>/2020/04/09/%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5/</url>
    <content><![CDATA[<h4 id="面试题29-顺时针打印矩阵"><a href="#面试题29-顺时针打印矩阵" class="headerlink" title="面试题29. 顺时针打印矩阵"></a><a href="https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/" target="_blank" rel="noopener">面试题29. 顺时针打印矩阵</a></h4><p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。</p>
 <a id="more"></a>

<p> <strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：matrix &#x3D; [[1,2,3],[4,5,6],[7,8,9]]</span><br><span class="line">输出：[1,2,3,6,9,8,7,4,5]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：matrix &#x3D; [[1,2,3,4],[5,6,7,8],[9,10,11,12]]</span><br><span class="line">输出：[1,2,3,4,8,12,11,10,9,5,6,7]</span><br></pre></td></tr></table></figure>

<p><strong>限制：</strong></p>
<ul>
<li><code>0 &lt;= matrix.length &lt;= 100</code></li>
<li><code>0 &lt;= matrix[i].length &lt;= 100</code></li>
</ul>
<p>方法一：模拟</p>
<p>可以模拟打印矩阵的路径，初始位置是矩阵的左上角，初始方向是向右，当越界或者进入访问过的位置就顺时针旋转进入另一个方向。</p>
<p>判断是否访问过数组中的某一个元素需要一个 visited 数组，当元素被访问过时将其设置为 true。当路径的长度等于矩阵中元素数量时，结束循环。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] spiralOrder(<span class="keyword">int</span>[][] matrix) &#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> rows = matrix.length, cols = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">boolean</span>[][] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[rows][cols];</span><br><span class="line">        <span class="keyword">int</span> total = rows * cols;</span><br><span class="line">        <span class="keyword">int</span>[] order = <span class="keyword">new</span> <span class="keyword">int</span>[total];</span><br><span class="line">        <span class="keyword">int</span> row = <span class="number">0</span>, col = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//矩阵顺时针旋转遍历方向：右、下、左、上</span></span><br><span class="line">        <span class="keyword">int</span>[][] directions = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">int</span> directionIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; total; i++)&#123;</span><br><span class="line">            order[i] = matrix[row][col];</span><br><span class="line">            visited[row][col] = <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">//获得下一行的横纵坐标</span></span><br><span class="line">            <span class="keyword">int</span> nextRow = row + directions[directionIndex][<span class="number">0</span>], nextCol = col + directions[directionIndex][<span class="number">1</span>];</span><br><span class="line">            <span class="comment">//判断下一个坐标是否访问过或者越界</span></span><br><span class="line">            <span class="keyword">if</span>(nextRow &lt; <span class="number">0</span> || nextRow &gt;= rows || nextCol &lt; <span class="number">0</span> || nextCol &gt;= cols || visited[nextRow][nextCol])&#123;</span><br><span class="line">                <span class="comment">//顺时针旋转</span></span><br><span class="line">                directionIndex = (directionIndex + <span class="number">1</span>) % <span class="number">4</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//更新下一个需要访问的坐标</span></span><br><span class="line">            row += directions[directionIndex][<span class="number">0</span>];</span><br><span class="line">            col += directions[directionIndex][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> order;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度 O(mn)，空间复杂度O(mn)。</p>
<p>方法二：按层模拟</p>
<p>可以将矩阵看成若干层，首先打印最外层的元素，其次打印次外层的元素，直到打印最内层的元素。</p>
<p>对于每层，从左上方开始以顺时针的顺序遍历所有元素。假设当前层的左上角位于(top, left)，右下角位于(bottom, right)，按照如下顺序遍历当前层的元素。</p>
<ol>
<li><p>从左到右遍历上侧元素，依次为(top, left) 到 (top, right)</p>
</li>
<li><p>从上到下遍历右侧元素，依次为(top + 1, right) 到(bottom, right)。</p>
</li>
<li><p>如果 left &lt; right 且 top &lt; bottom ，则从右向左遍历下侧元素，依次为(bottom, right - 1) 到 (bottom, left + 1)，以及从下到上遍历左侧元素，依次为 (bottom, left) 到 (top + 1, left)。</p>
</li>
</ol>
<p>遍历完当前层的元素之后，将 left 和 top 分别增加 1 ，将 right 和 bottom 分别减少 1，进入下一层遍历。</p>
<p>下图来自 <a href="https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/solution/shun-shi-zhen-da-yin-ju-zhen-by-leetcode-solution/" target="_blank" rel="noopener">Leetcode</a>。</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/oznBqb5HX2FDQfP.png" alt="image-20200605105850949"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] spiralOrder(<span class="keyword">int</span>[][] matrix) &#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> rows = matrix.length, cols = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span>[] order = <span class="keyword">new</span> <span class="keyword">int</span>[rows * cols];</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = cols - <span class="number">1</span>, top = <span class="number">0</span>, bottom = rows - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right &amp;&amp; top &lt;= bottom)&#123;</span><br><span class="line">            <span class="comment">//遍历上侧元素</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> c = left; c &lt;= right; c++)&#123;</span><br><span class="line">                order[index++] = matrix[top][c];</span><br><span class="line">            &#125;</span><br><span class="line">			<span class="comment">//遍历右侧元素</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> r = top + <span class="number">1</span>; r &lt;= bottom; r++)&#123;</span><br><span class="line">                order[index++] = matrix[r][right];</span><br><span class="line">            &#125;</span><br><span class="line">			<span class="comment">// 不满足 left &lt; right &amp;&amp; top &lt; bottom 代表只有一行或者一列，遍历上侧和右侧元素即可。</span></span><br><span class="line">            <span class="keyword">if</span>(left &lt; right &amp;&amp; top &lt; bottom)&#123;</span><br><span class="line">                <span class="comment">//遍历下侧元素</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> c = right - <span class="number">1</span>; c &gt; left; c--)&#123;</span><br><span class="line">                    order[index++] = matrix[bottom][c];</span><br><span class="line">                &#125;</span><br><span class="line">				<span class="comment">//遍历左侧元素</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> r = bottom; r &gt; top; r--)&#123;</span><br><span class="line">                    order[index++] = matrix[r][left];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//进入下一层</span></span><br><span class="line">            left++ ;</span><br><span class="line">            right-- ;</span><br><span class="line">            top++ ;</span><br><span class="line">            bottom-- ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> order;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度 O(mn)，空间复杂度O(1)。</p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode Easy</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>验证二叉树的前序序列化</title>
    <url>/2021/03/12/%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E5%BA%8F%E5%88%97%E5%8C%96/</url>
    <content><![CDATA[<h4 id="331-验证二叉树的前序序列化"><a href="#331-验证二叉树的前序序列化" class="headerlink" title="331. 验证二叉树的前序序列化"></a><a href="https://leetcode-cn.com/problems/verify-preorder-serialization-of-a-binary-tree/" target="_blank" rel="noopener">331. 验证二叉树的前序序列化</a></h4><p>序列化二叉树的一种方法是使用前序遍历。当我们遇到一个非空节点时，我们可以记录下这个节点的值。如果它是一个空节点，我们可以使用一个标记值记录，例如 <code>#</code>。</p>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">     _9_</span><br><span class="line">    &#x2F;   \</span><br><span class="line">   3     2</span><br><span class="line">  &#x2F; \   &#x2F; \</span><br><span class="line"> 4   1  #  6</span><br><span class="line">&#x2F; \ &#x2F; \   &#x2F; \</span><br><span class="line"># # # #   # #</span><br></pre></td></tr></table></figure>

<p>例如，上面的二叉树可以被序列化为字符串 <code>&quot;9,3,4,#,#,1,#,#,2,#,6,#,#&quot;</code>，其中 <code>#</code> 代表一个空节点。</p>
<p>给定一串以逗号分隔的序列，验证它是否是正确的二叉树的前序序列化。编写一个在不重构树的条件下的可行算法。</p>
<p>每个以逗号分隔的字符或为一个整数或为一个表示 <code>null</code> 指针的 <code>&#39;#&#39;</code> 。</p>
<p>你可以认为输入格式总是有效的，例如它永远不会包含两个连续的逗号，比如 <code>&quot;1,,3&quot;</code> 。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;9,3,4,#,#,1,#,#,2,#,6,#,#&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;1,#&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>

<p><strong>示例 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;9,#,#,1&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>

<p><strong>方法一：递归</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidSerialization</span><span class="params">(String preorder)</span> </span>&#123;</span><br><span class="line">        String[] arr = preorder.split(<span class="string">","</span>);</span><br><span class="line">        <span class="keyword">return</span> helper(arr) &amp;&amp; i == arr.length - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">helper</span><span class="params">(String[] arr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = arr.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(arr[i].equals(<span class="string">"#"</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> i == arr.length - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!arr[i].equals(<span class="string">"#"</span>) &amp;&amp; i + <span class="number">2</span> &lt; len</span><br><span class="line">                &amp;&amp; arr[i + <span class="number">1</span>].equals(<span class="string">"#"</span>) &amp;&amp; arr[i + <span class="number">2</span>].equals(<span class="string">"#"</span>))&#123;</span><br><span class="line">            i += <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(i + <span class="number">2</span> &gt;= len)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> left = <span class="keyword">false</span>, right = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        i += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(arr[i].equals(<span class="string">"#"</span>))&#123;</span><br><span class="line">            left = <span class="keyword">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            left = helper(arr);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!left)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        i += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(arr[i].equals(<span class="string">"#"</span>))&#123;</span><br><span class="line">            right = <span class="keyword">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            right = helper(arr);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>方法二：栈</strong></p>
<p>我们定义一个概念叫做槽位，一个槽位可被看作<strong>当前二叉树中正在等待被节点填充</strong>的那些位置。</p>
<p>每当遇到一个结点时：</p>
<ul>
<li>遇到空结点，消耗一个槽位；</li>
<li>遇到非空结点，消耗一个槽位，增加两个子节点的槽位。</li>
</ul>
<p>此外还需要对根节点进行处理。</p>
<p>我们使用栈来维护槽位的变化，栈中的每个元素代表了对应节点处<strong>剩余槽位的数量</strong>，栈顶元素代表下一步可用的槽位。每当遇到空结点时，仅将栈顶元素减 1 ，遇到非空节点时，将栈顶元素减 1 后，再向栈中压入一个 2 。无论何时，如果栈顶元素变为 0，立刻将栈顶弹出。结束后，如果栈为空，则序列合法，在遍历过程中，如果槽位数量不足，则序列不合法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidSerialization</span><span class="params">(String preorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = preorder.length();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        Deque&lt;Integer&gt; stack = <span class="keyword">new</span> LinkedList();</span><br><span class="line">        stack.push(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">while</span>(i &lt; n)&#123;</span><br><span class="line">            <span class="keyword">if</span>(stack.isEmpty())&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(preorder.charAt(i) == <span class="string">','</span>)&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(preorder.charAt(i) == <span class="string">'#'</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> top = stack.pop() - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(top &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    stack.push(top);</span><br><span class="line">                &#125;</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">while</span>(i &lt; n &amp;&amp; preorder.charAt(i) != <span class="string">','</span>)&#123;</span><br><span class="line">                    ++i;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> top = stack.pop() - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(top &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    stack.push(top);</span><br><span class="line">                &#125;</span><br><span class="line">                stack.push(<span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度O(n)</li>
<li>空间复杂度O(n)</li>
</ul>
<p><strong>方法三：计数</strong></p>
<p>如果将方法二中栈中元素看成一个整体，即所有剩余槽位的数量，也能维护槽位的变化。因此我们只用维护一个计数器，代表栈中所有元素之和。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidSerialization</span><span class="params">(String preorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = preorder.length();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> slots = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; n)&#123;</span><br><span class="line">            <span class="keyword">if</span>(slots == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(preorder.charAt(i) == <span class="string">','</span>)&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(preorder.charAt(i) == <span class="string">'#'</span>)&#123;</span><br><span class="line">                slots--;</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">while</span>(i &lt; n &amp;&amp; preorder.charAt(i) != <span class="string">','</span>)&#123;</span><br><span class="line">                    ++i;</span><br><span class="line">                &#125;</span><br><span class="line">                slots++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slots == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度O(n)</li>
<li>空间复杂度O(1)</li>
</ul>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode Medium</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>验证栈序列</title>
    <url>/2020/07/20/%E9%AA%8C%E8%AF%81%E6%A0%88%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<h4 id="946-验证栈序列"><a href="#946-验证栈序列" class="headerlink" title="946. 验证栈序列"></a><a href="https://leetcode-cn.com/problems/validate-stack-sequences/" target="_blank" rel="noopener">946. 验证栈序列</a></h4><p>给定 <code>pushed</code> 和 <code>popped</code> 两个序列，每个序列中的 <strong>值都不重复</strong>，只有当它们可能是在最初空栈上进行的推入 push 和弹出 pop 操作序列的结果时，返回 <code>true</code>；否则，返回 <code>false</code> 。</p>
 <a id="more"></a>

<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：pushed &#x3D; [1,2,3,4,5], popped &#x3D; [4,5,3,2,1]</span><br><span class="line">输出：true</span><br><span class="line">解释：我们可以按以下顺序执行：</span><br><span class="line">push(1), push(2), push(3), push(4), pop() -&gt; 4,</span><br><span class="line">push(5), pop() -&gt; 5, pop() -&gt; 3, pop() -&gt; 2, pop() -&gt; 1</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：pushed &#x3D; [1,2,3,4,5], popped &#x3D; [4,3,5,1,2]</span><br><span class="line">输出：false</span><br><span class="line">解释：1 不能在 2 之前弹出。</span><br></pre></td></tr></table></figure>

<p> <strong>提示：</strong></p>
<ol>
<li><code>0 &lt;= pushed.length == popped.length &lt;= 1000</code></li>
<li><code>0 &lt;= pushed[i], popped[i] &lt; 1000</code></li>
<li><code>pushed</code> 是 <code>popped</code> 的排列。</li>
</ol>
<p><strong>方法一：模拟</strong></p>
<p>我们模拟做题过程中判断是否为出栈序列的方法，将入栈序列中的元素依次入栈，在入栈的过程中，如果栈顶元素与出栈序列的第一个元素相同则将栈顶元素弹出，直到最后栈中元素为空。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">validateStackSequences</span><span class="params">(<span class="keyword">int</span>[] pushed, <span class="keyword">int</span>[] popped)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = pushed.length, n = popped.length;</span><br><span class="line">        <span class="comment">//入栈序列长度与出栈序列长度不相同</span></span><br><span class="line">        <span class="keyword">if</span>(m != n)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        LinkedList&lt;Integer&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//是否出栈完成</span></span><br><span class="line">        <span class="keyword">while</span>(j != n)&#123;</span><br><span class="line">            <span class="comment">//入栈元素与出栈元素不相同，添加元素</span></span><br><span class="line">            <span class="keyword">while</span>(i &lt; m &amp;&amp; pushed[i] != popped[j])&#123;</span><br><span class="line">                stack.addLast(pushed[i++]);</span><br><span class="line">            &#125;</span><br><span class="line">			<span class="comment">//入栈元素与出栈元素相同，先将其入栈，然后再出栈</span></span><br><span class="line">            <span class="keyword">if</span>(i &lt; m &amp;&amp; pushed[i] == popped[j])&#123;</span><br><span class="line">                stack.addLast(pushed[i++]);</span><br><span class="line">            &#125;</span><br><span class="line">			<span class="comment">//栈顶元素与出栈元素相同则出栈</span></span><br><span class="line">            <span class="keyword">while</span>(stack.size() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(stack.peekLast() == popped[j])&#123;</span><br><span class="line">                    stack.removeLast();</span><br><span class="line">                    j++;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//无元素入栈，栈顶元素与出栈元素不相同</span></span><br><span class="line">                    <span class="keyword">if</span>(i == m)</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">else</span><span class="comment">//还有元素入栈，跳出循环，继续进行进栈操作</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度O(n)，空间复杂度O(1)。</p>
<p><strong>方法二：贪心</strong></p>
<p>将 pushed 队列中每个数都 push 到栈中，同时检查这个数是不是 popped 序列中下一个要 pop 的值，如果是，就要把它 pop 出来。</p>
<p>最后，检查是否所有的值都 pop 出来了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">validateStackSequences</span><span class="params">(<span class="keyword">int</span>[] pushed, <span class="keyword">int</span>[] popped)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = pushed.length;</span><br><span class="line">        LinkedList&lt;Integer&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x : pushed)&#123;</span><br><span class="line">            stack.addLast(x);</span><br><span class="line">            <span class="keyword">while</span>(stack.size() != <span class="number">0</span> &amp;&amp; stack.peekLast() == popped[j])&#123;</span><br><span class="line">                stack.removeLast();</span><br><span class="line">                ++j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> j == m;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度O(n)，空间复杂度O(1)。</p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode Medium</tag>
        <tag>贪心</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>颜色分类</title>
    <url>/2020/10/07/%E9%A2%9C%E8%89%B2%E5%88%86%E7%B1%BB/</url>
    <content><![CDATA[<h4 id="75-颜色分类"><a href="#75-颜色分类" class="headerlink" title="75. 颜色分类"></a><a href="https://leetcode-cn.com/problems/sort-colors/" target="_blank" rel="noopener">75. 颜色分类</a></h4><p>给定一个包含红色、白色和蓝色，一共 <em>n</em> 个元素的数组，<strong><a href="https://baike.baidu.com/item/原地算法" target="_blank" rel="noopener">原地</a></strong>对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。</p>
<p>此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。</p>
<p><strong>注意:</strong><br>不能使用代码库中的排序函数来解决这道题。</p>
<a id="more"></a>

<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [2,0,2,1,1,0]</span><br><span class="line">输出: [0,0,1,1,2,2]</span><br></pre></td></tr></table></figure>

<p><strong>进阶：</strong></p>
<ul>
<li>一个直观的解决方案是使用计数排序的两趟扫描算法。<br>首先，迭代计算出0、1 和 2 元素的个数，然后按照0、1、2的排序，重写当前数组。</li>
<li>你能想出一个仅使用常数空间的一趟扫描算法吗？</li>
</ul>
<p><strong>方法一：单指针</strong></p>
<p>使用两次遍历，第一次遍历将所有的 0 交换到数组头部，第二次遍历将所有的 1 交换到数组头部的 0 之后。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sortColors</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span> ptr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">                nums[i] = nums[ptr];</span><br><span class="line">                nums[ptr] = temp;</span><br><span class="line">                ++ptr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = ptr; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">                nums[i] = nums[ptr];</span><br><span class="line">                nums[ptr] = temp;</span><br><span class="line">                ++ptr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法二：双指针</strong></p>
<p>使用 p0 指针维护数组前部的 0 ，使用 p2 指针维护数组后部的 2 。在遍历的过程中，我们需要找出所有的 0 交换至数组的头部，找出所有的 2 交换至数组的尾部。</p>
<p>从左到右遍历整个数组，设当前遍历到的位置为 i ，对应的元素为 nums[i]；</p>
<ul>
<li>如果 nums[i] = 0，将其与 nums[p0] 交换，将 p0 后移一个位置；</li>
<li>如果 nums[i] = 2，将其与 nums[p2] 交换，将 p2 前移一个位置；</li>
</ul>
<p>对于第二种情况，交换后 nums[i] 可能为 2 ，也可能为 0。当我们找到 2 时，需要<strong>不断</strong>地将其与 nums[p2] 进行交换，直到新的 nums[i] 不为 2。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sortColors</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span> p0 = <span class="number">0</span>, p2 = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= p2; ++i)&#123;</span><br><span class="line">            <span class="keyword">while</span>(i &lt;= p2 &amp;&amp; nums[i] == <span class="number">2</span>)&#123;</span><br><span class="line">                nums[i] = nums[p2];</span><br><span class="line">                nums[p2] = <span class="number">2</span>;</span><br><span class="line">                --p2;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(nums[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                nums[i] = nums[p0];</span><br><span class="line">                nums[p0] = <span class="number">0</span>;</span><br><span class="line">                ++p0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode Medium</tag>
        <tag>双指针</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>魔术索引</title>
    <url>/2020/07/31/%E9%AD%94%E6%9C%AF%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<h4 id="面试题-08-03-魔术索引"><a href="#面试题-08-03-魔术索引" class="headerlink" title="面试题 08.03. 魔术索引"></a><a href="https://leetcode-cn.com/problems/magic-index-lcci/" target="_blank" rel="noopener">面试题 08.03. 魔术索引</a></h4><p>魔术索引。 在数组<code>A[0...n-1]</code>中，有所谓的魔术索引，满足条件<code>A[i] = i</code>。给定一个有序整数数组，编写一种方法找出魔术索引，若有的话，在数组A中找出一个魔术索引，如果没有，则返回-1。若有多个魔术索引，返回索引值最小的一个。</p>
<a id="more"></a>

<p><strong>示例1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [0, 2, 3, 4, 5]</span><br><span class="line">输出：0</span><br><span class="line">说明: 0下标的元素为0</span><br></pre></td></tr></table></figure>

<p><strong>示例2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [1, 1, 1]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>

<p><strong>提示:</strong></p>
<ol>
<li>nums长度在[1, 1000000]之间</li>
</ol>
<p>我们直接遍历一次数组即可求出最小的索引。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMagicIndex</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == i)&#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度O(n)，空间复杂度O(1)。</p>
<p>但给的是有序数组，我们可以进行一点优化。</p>
<p>以示例二为例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">元素：1  1  1</span><br><span class="line">下标：0  1  2</span><br><span class="line">     ^</span><br><span class="line">     i</span><br></pre></td></tr></table></figure>

<p>当 i = 0 时，我们有 nums[0] &gt; 0，i 不是最小索引。由于数组递增，nums[0] 之后的元素都大于等于 nums[0]，下标小于 nums[0] 的元素中不存在最小索引，否则数组就不满足递增关系。</p>
<p>当我们遍历到第 i 个元素时，如果<code>nums[i] &gt; i</code>，由于数组的递增关系，<code>[0, nums[i])</code>范围内的元素不可能为最小索引，直接令<code>i = nums[i]</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMagicIndex</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(flag &lt; nums.length)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[flag] == flag)&#123;</span><br><span class="line">                <span class="keyword">return</span> flag;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[flag] &gt; flag)&#123;</span><br><span class="line">                flag = nums[flag]; <span class="comment">//去掉不需要比较的元素</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                flag++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度最坏O(n)，空间复杂度O(1)。</p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode Easy</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring实战</title>
    <url>/2020/04/04/Spring%E5%AE%9E%E6%88%98/</url>
    <content><![CDATA[<h1 id="Spring之旅"><a href="#Spring之旅" class="headerlink" title="Spring之旅"></a>Spring之旅</h1><p>Spring是一个开源框架，Spring根本使命：简化Java开发。</p>
<p>为了简化java开发的复杂性，Spring使用如下4种策略：</p>
<p>1、基于POJO(Plain Old Java Object 简单Java对象 )的轻量级和最小侵入性编程。</p>
<p>2、通过依赖注入和面向接口实现松耦合。</p>
<p>3、基于切面和惯例进行声明式编程。</p>
<p>4、通过切面和模板减少样板式代码。</p>
<p>这里以一个骑士出征的例子来解释一些相关概念</p>
<p>首先定义一个骑士接口，其中有一个embarkOnQuest方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> hoo.knights;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Knight</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//开始行动</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">embarkOnQuest</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>然后再定义一个远征行动接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> hoo.knights;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Quest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">embark</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>下一步定义一个拯救少女行动类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> hoo.knights;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RescueDamselQuest</span> <span class="keyword">implements</span> <span class="title">Quest</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">embark</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//开始行动拯救少女</span></span><br><span class="line">        System.out.println(<span class="string">"Embarking on a quest to rescue the damsel"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>再定义一个屠杀巨龙行动类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> hoo.knights;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.PrintStream;</span><br><span class="line"></span><br><span class="line"><span class="comment">//杀巨龙行动</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SlayDragonQuest</span> <span class="keyword">implements</span> <span class="title">Quest</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> PrintStream printStream;</span><br><span class="line">    <span class="comment">//依赖注入</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SlayDragonQuest</span><span class="params">(PrintStream printStream)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.printStream = printStream;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">embark</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        printStream.println(<span class="string">"Embarking on quest to slay the dragon"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来定义一个英勇的骑士类实现骑士接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">javapackage hoo.knights;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BraveKnight</span> <span class="keyword">implements</span> <span class="title">Knight</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Quest quest;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//依赖注入，而不是BraveKnight含有Quest对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BraveKnight</span><span class="params">(Quest quest)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.quest = quest;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">embarkOnQuest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        quest.embark();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>到这里有人可能就写成下面这样</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> hoo.knights;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BraveKnight</span> <span class="keyword">implements</span> <span class="title">Knight</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Quest quest;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BraveKnight</span><span class="params">()</span></span>&#123;</span><br><span class="line">        quest = <span class="keyword">new</span> RescueDamselQuest();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">embarkOnQuest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        quest.embark();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>但是有一种情况：骑士不仅仅可以去杀龙还可以去拯救少女这里将它写死就不太合适，采用传递一个Quest对象，只要实现了Quest类的接口，任何类都可以传进来，骑士就可以去做很多行动，不是只执行一个任务。</p>
<p>这是依赖注入(DI)的一种方式：构造器注入</p>
<p>同样SlayDragonQuest类中也有依赖注入：将一个PrintStream对象注入到SlayDragonQuest中。</p>
<p>骑士出征之前和之后需要法师的吟唱，骑士类拥有法师类对象似乎不是一个好的选择，法师不应该被骑士拥有，有的骑士也不想法师吟唱这里先定义一个法师类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> hoo.knights;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintStream;</span><br><span class="line"></span><br><span class="line"><span class="comment">//法师吟唱类 骑士出征之前之后需要法师吟唱</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Minstrel</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> PrintStream printStream;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Minstrel</span><span class="params">(PrintStream printStream)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.printStream = printStream;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//AOP 应用</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">singBeforeQuest</span><span class="params">()</span></span>&#123;</span><br><span class="line">        printStream.println(<span class="string">"Fa la la,the knight is so brave!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">singAfterQuest</span><span class="params">()</span></span>&#123;</span><br><span class="line">        printStream.println(<span class="string">"Tee hee hee , the brave knight did embark on a quest"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>法师的吟唱是骑士的出征非关键因素，这里利用AOP来实现法师吟唱模块化。</p>
<p>有多个Quest对象可以被注入到BraveKnight中，到底选择哪一个来注入呢？？</p>
<p>这里利用XML来正确装配这些对象。</p>
<p>装配的方式有：自动装配、XML显式装配、Java显式装配。</p>
<p>先定义knight.xml来解决骑士到底要做什么的问题。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span><br><span class="line">&lt;beans xmlns=<span class="string">"http://www.springframework.org/schema/beans"</span></span><br><span class="line">       xmlns:xsi=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line">       xsi:schemaLocation=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span><br><span class="line">&lt;bean id=<span class="string">"knight"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"hoo.knights.BraveKnight"</span>&gt;</span><br><span class="line">    &lt;constructor-arg ref=<span class="string">"quest"</span>/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">    &lt;bean id=<span class="string">"quest"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"hoo.knights.SlayDragonQuest"</span>&gt;</span><br><span class="line">        &lt;constructor-arg value=<span class="string">"#&#123;T(System).out&#125;"</span>/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>



<p>使用<bean></bean>声明一个bean 其中id为自己指定的名字 class为bean的类</p>
<p><constructor-arg> 元素为构造器参数 ref为依赖的bean，第一个constructor元素就决定了将一个id为quest的bean注入到id为knight的对象中。第二个constructor元素中 value代表将一个System.out值传入构造器。</p>
<p>第一个constructor元素就决定了骑士去杀龙而不是拯救少女。</p>
<p>等等，法师吟唱在哪？？？</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span><br><span class="line">&lt;beans xmlns=<span class="string">"http://www.springframework.org/schema/beans"</span></span><br><span class="line">       xmlns:xsi=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> xmlns:aop=<span class="string">"http://www.springframework.org/schema/aop"</span></span><br><span class="line">       xsi:schemaLocation=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd"</span>&gt;</span><br><span class="line">    &lt;bean id=<span class="string">"knight"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"hoo.knights.BraveKnight"</span>&gt;</span><br><span class="line">        &lt;constructor-arg ref=<span class="string">"quest"</span>/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=<span class="string">"quest"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"hoo.knights.SlayDragonQuest"</span>&gt;</span><br><span class="line">        &lt;constructor-arg value=<span class="string">"#&#123;T(System).out&#125;"</span>/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=<span class="string">"minstrel"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"hoo.knights.Minstrel"</span>&gt;</span><br><span class="line">        &lt;constructor-arg value=<span class="string">"#&#123;T(System).out&#125;"</span>/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;aop:config&gt;</span><br><span class="line">        &lt;aop:aspect ref=<span class="string">"minstrel"</span>&gt;</span><br><span class="line">            &lt;aop:pointcut id=<span class="string">"embark"</span> expression=<span class="string">"execution(* *.embarkOnQuest(..))"</span>/&gt;</span><br><span class="line">            </span><br><span class="line">            &lt;aop:before pointcut-ref=<span class="string">"embark"</span> method=<span class="string">"singBeforeQuest"</span>/&gt;</span><br><span class="line"></span><br><span class="line">            &lt;aop:after pointcut-ref=<span class="string">"embark"</span> method=<span class="string">"singAfterQuest"</span>/&gt;</span><br><span class="line">        &lt;/aop:aspect&gt;</span><br><span class="line">    &lt;/aop:config&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>



<p>&lt;aop:aspect ref=”minstrel”&gt;这一句将法师类声明为一个切面(AOP)。</p>
<p>pointcut定义了一个切入点，before决定在切入点之前做什么，after决定在切入点之后做什么。</p>
<p>来到验证阶段，看看骑士到底干了啥事？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> hoo.knights;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KnightMain</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="comment">//ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext("minstrel.xml");</span></span><br><span class="line">        ClassPathXmlApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"knight.xml"</span>);</span><br><span class="line">        Knight knight = context.getBean(Knight<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        knight.embarkOnQuest();</span><br><span class="line">        context.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>ClassPathXmlApplicationContext 从xml文件中读取bean装配信息。</p>
<p>注释的第一行决定了法师要出来吟唱，通过控制台可以看到法师出来吟唱了，并且骑士执行的是杀龙的行动。</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/iZRbHgK6a12jsmz.png" alt="img"></p>
<p>法师吟唱</p>
<p>没有注释的第二行决定法师不出来吟唱，执行的也是杀龙任务，也可以将xml里面的配置改为拯救少女，可能这个骑士他不喜欢拯救少女吧。</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/OnfcdCHIohMaiSx.png" alt="img"></p>
<p>法师不吟唱</p>
<p>这个例子 初步展示了DI、AOP的思想。</p>
<h1 id="装配Bean"><a href="#装配Bean" class="headerlink" title="装配Bean"></a>装配Bean</h1><p>Bean – 一种表达实体和信息的规范，便于封装重用。</p>
<p>Bean有以下特点：</p>
<p>1、所有属性为private  2、提供默认构造方法  3、提供Setter和Getter  4、实现Serializable接口</p>
<p>Spring装配Bean三种方式： XML显式配置、Java显式配置、自动装配。</p>
<p><strong>一、自动装配</strong></p>
<p>Spring通过以下两个角度来实现自动化装配</p>
<p>1、组件扫描：Spring会自动发现应用上下文中所创建的bean</p>
<p>2、自动装配：Spring自动满足bean之间的依赖</p>
<p>接下来以一个CD播放器的例子来演示自动装配</p>
<p>首先定义媒体播放器和CD两个接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> soundsystem;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MediaPlayer</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">play</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">package</span> soundsystem;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CompactDisc</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">play</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>定义CD播放器类实现媒体播放器接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> soundsystem;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CDPlayer</span> <span class="keyword">implements</span> <span class="title">MediaPlayer</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> CompactDisc cd;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CDPlayer</span><span class="params">(CompactDisc cd)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cd = cd;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cd.play();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>@Component注解表明该类会作为组件类，并告知Spring为这个类创建bean</p>
<p>@Autowired注解表明当Spring创建CDPlayer bean 的时候，会通过这个构造器来进行实例化并且会传入一个可设置给CompactDisc类型的bean。</p>
<p>@Autowired注解可以用在类的任何方法上，还可以用于成员变量上。@Inject源于Java依赖注入规范，在大多场景下可与@Autowired互换。</p>
<p>然后定义一个SgtPeppers类，它实现了CompactDisc接口，也是一个组件类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> soundsystem;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SgtPeppers</span> <span class="keyword">implements</span> <span class="title">CompactDisc</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String title = <span class="string">"Sgt. Pepper's Lonely Hearts Club Band"</span>;</span><br><span class="line">    <span class="keyword">private</span> String artist = <span class="string">"The Beatles"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Playing "</span>+title+<span class="string">" by "</span>+artist);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>最后定义一个CDPlayer配置类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> soundsystem;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.*;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 启用组件扫描</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CDPlayerConfig</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>@Configuration代表这是一个配置类</p>
<p>@ComponentScan表示启用组件扫描</p>
<p>组件扫描可以在一个CD播放器一张CD的时候正常工作，但是在有两张CD的时候就不能正常工作了，因为它不知道应该播放哪一张CD，这里我们只有一张披头士的CD，关于多张CD的情况留到后面处理。 </p>
<p>我们也可以用xml来实现组件扫描</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:c</span>=<span class="string">"http://www.springframework.org/schema/c"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:p</span>=<span class="string">"http://www.springframework.org/schema/p"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">      http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"soundsystem"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>&lt;context:component-scan base-package=”soundsystem” /&gt;表示会在soundsystem这个包内找合适的bean注入到CDplayer</p>
<p>现在定义CDPlayerTest类测试一下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> soundsystem;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.junit.Assert.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Rule;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.contrib.java.lang.system.StandardOutputStreamLog;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.ContextConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringJUnit4ClassRunner;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith</span>(SpringJUnit4ClassRunner<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">ContextConfiguration</span>(<span class="title">classes</span> </span>= CDPlayerConfig<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">CDPlayerTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Rule</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> StandardOutputStreamLog log = <span class="keyword">new</span> StandardOutputStreamLog();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MediaPlayer player;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> CompactDisc cd;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cdShouldNotNull</span><span class="params">()</span></span>&#123;</span><br><span class="line">        assertNotNull(cd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span></span>&#123;</span><br><span class="line">        player.play();</span><br><span class="line">        assertEquals(<span class="string">"Playing Sgt. Pepper's Lonely Hearts Club Band by The Beatles\n"</span>,log.getLog());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>@ContextConfiguration(classes = CDPlayerConfig.class)会使用CDPlayerConfig这个类来配置应用上下文。</p>
<p>下面试试使用XML配置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> soundsystem;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.junit.Assert.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Rule;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.contrib.java.lang.system.StandardOutputStreamLog;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.ContextConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringJUnit4ClassRunner;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith</span>(SpringJUnit4ClassRunner<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">ContextConfiguration</span>(<span class="title">locations</span> </span>= <span class="string">"classpath:soundsystem.xml"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CDPlayerXMLConfigTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Rule</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> StandardOutputStreamLog log = <span class="keyword">new</span> StandardOutputStreamLog();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MediaPlayer player;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> CompactDisc cd;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cdShouldNotNull</span><span class="params">()</span></span>&#123;</span><br><span class="line">        assertNotNull(cd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span></span>&#123;</span><br><span class="line">        player.play();</span><br><span class="line">        assertEquals(<span class="string">"Playing Sgt. Pepper's Lonely Hearts Club Band by The Beatles\n"</span>,log.getLog());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>@ContextConfiguration(locations =”classpath:soundsystem.xml”)会使用soundsystem.xml来配置应用上下文。</p>
<p><strong>二、Java显式配置</strong></p>
<p>媒体播放器和CD接口保持不变</p>
<p>接下来看看CD播放器类与自动装配有什么不同之处</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> soundsystem;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CDPlayer</span> <span class="keyword">implements</span> <span class="title">MediaPlayer</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> CompactDisc cd;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">CDPlayer</span><span class="params">(CompactDisc cd)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.cd = cd;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cd.play();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>与自动装配比较可以发现类声明上面少了@Component注解 我们没有将CDPlayer声明为一个组件类</p>
<p>SgtPeppers类也没有@Component注解</p>
<p>重点来看看CDplayerConfig类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> soundsystem;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CDPlayerConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CompactDisc <span class="title">compactDisc</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SgtPeppers();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CDPlayer <span class="title">cdPlayer</span><span class="params">(CompactDisc cd)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CDPlayer(cd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这里没有@ComponentScan注解然后在配置类中自己定义了两个bean从第一个bean可以看到如果需要注入CompactDisc bean的时候注入的是SgtPeppers类对象，需要注入CDPlayer bean 时注入的时候注入的是CdPlayer对象。</p>
<p>总结一下：Java显式配置与自动装配主要区别在配置类上，Java配置需要显示地声明bean，自动装配配置类有@ComponentScan注解，它会自动扫描带有@Component注解的bean来将其注入到合适的地方。</p>
<p><strong>三、XML显式配置</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:c</span>=<span class="string">"http://www.springframework.org/schema/c"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"compactDisc"</span> <span class="attr">class</span>=<span class="string">"soundsystem.SgtPeppers"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"cdPlayer"</span> <span class="attr">class</span>=<span class="string">"soundsystem.CDPlayer"</span> <span class="attr">c:cd-ref</span>=<span class="string">"compactDisc"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"compactDisc"</span> <span class="attr">class</span>=<span class="string">"soundsystem.SgtPeppers"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>上述的一行XML配置和上面的一段CDConfig Java配置起到的作用是一样的。</p>
<p>XML中参数的声明是由<constructor-arg>标签来实现，想要注入一个集合可以使用<list>标签包裹集合内所有项</p>
<p>使用<value>标签包裹集合内的一项。</p>
<p>&lt;bean id=”compactDisc”</p>
<p>   class=”soundsystem.BlankDisc”</p>
<p>   c:_0=”Sgt. Pepper’s Lonely Hearts Club Band”</p>
<p>   c:_1=”The Beatles”&gt;</p>
<p>c:_0代表构造器的第一个参数，c:_1代表构造器的第二个参数。</p>
<p><strong>四、混合配置</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> soundsystem;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Import</span>(CDPlayerConfig<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line">@ImportResource("classpath:cd-config.xml")</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SoundSystemConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 加粗的两个注解从一个Java配置类和一个XML文档加载应用上下文。</p>
<h1 id="Java高级装配"><a href="#Java高级装配" class="headerlink" title="Java高级装配"></a>Java高级装配</h1><p><strong>一、环境与profile</strong></p>
<p>开发软件的时候需要将一个应用从一个环境迁移到另一个环境，不同的环境数据库配置、加密算法以及外部系统的集成可能会变化。</p>
<p>Spring为解决环境问题引入了bean profile功能，要使用profile首先要将不同的bean定义或整理到一个或多个profile之中，在应用部署到每个环境时要确保对应的profile处于激活状态。</p>
<p>下面以一个数据库配置为例</p>
<p>在开发环境我们使用H2数据库，在生产环境我们使用JNDI从容器中获取数据库配置</p>
<p>我们可以使用Java或XML配置profile</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.myapp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Profile;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.datasource.embedded.EmbeddedDatabaseBuilder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.datasource.embedded.EmbeddedDatabaseType;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jndi.JndiObjectFactoryBean;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.sql.DataSource;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataSourceConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Profile</span>(<span class="string">"dev"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">embeddedDataSource</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> EmbeddedDatabaseBuilder().setType(EmbeddedDatabaseType.H2)</span><br><span class="line">                .addScript(<span class="string">"classpath:schema.sql"</span>).addScript(<span class="string">"classpath:test-data.sql"</span>).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Profile</span>(<span class="string">"prod"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">jndiDataSource</span><span class="params">()</span></span>&#123;</span><br><span class="line">        JndiObjectFactoryBean jndiObjectFactoryBean = <span class="keyword">new</span> JndiObjectFactoryBean();</span><br><span class="line">        jndiObjectFactoryBean.setJndiName(<span class="string">"jndi/myDS"</span>);</span><br><span class="line">        jndiObjectFactoryBean.setResourceRef(<span class="keyword">true</span>);</span><br><span class="line">        jndiObjectFactoryBean.setProxyInterface(javax.sql.DataSource<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="keyword">return</span> (DataSource)jndiObjectFactoryBean.getObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>与一般的配置相似，多加了一个profile，参数是环境名称。</p>
<p>下面是XML配置</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span><br><span class="line">&lt;beans xmlns=<span class="string">"http://www.springframework.org/schema/beans"</span></span><br><span class="line">       xmlns:xsi=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> xmlns:jdbc=<span class="string">"http://www.springframework.org/schema/jdbc"</span></span><br><span class="line">       xmlns:jee=<span class="string">"http://www.springframework.org/schema/jee"</span> xmlns:p=<span class="string">"http://www.springframework.org/schema/p"</span></span><br><span class="line">       xsi:schemaLocation=<span class="string">"</span></span><br><span class="line"><span class="string">    http://www.springframework.org/schema/jee</span></span><br><span class="line"><span class="string">    http://www.springframework.org/schema/jee/spring-jee.xsd</span></span><br><span class="line"><span class="string">    http://www.springframework.org/schema/jdbc</span></span><br><span class="line"><span class="string">    http://www.springframework.org/schema/jdbc/spring-jdbc.xsd</span></span><br><span class="line"><span class="string">    http://www.springframework.org/schema/beans</span></span><br><span class="line"><span class="string">    http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;beans profile=<span class="string">"dev"</span>&gt;</span><br><span class="line">        &lt;jdbc:embedded-database id=<span class="string">"dataSource"</span> type=<span class="string">"H2"</span>&gt;</span><br><span class="line">            &lt;jdbc:script location=<span class="string">"classpath:schema.sql"</span>/&gt;</span><br><span class="line">            &lt;jdbc:script location=<span class="string">"test-data.sql"</span>/&gt;</span><br><span class="line">        &lt;/jdbc:embedded-database&gt;</span><br><span class="line">    &lt;/beans&gt;</span><br><span class="line"></span><br><span class="line">    &lt;beans profile=<span class="string">"prod"</span>&gt;</span><br><span class="line">        &lt;jee:jndi-lookup id=<span class="string">"dataSource"</span></span><br><span class="line">                         lazy-init=<span class="string">"true"</span></span><br><span class="line">                         jndi-name=<span class="string">"jdbc/myDatabase"</span></span><br><span class="line">                         resource-ref=<span class="string">"true"</span></span><br><span class="line">                         proxy-<span class="class"><span class="keyword">interface</span></span>=<span class="string">"javax.sql.DataSource"</span>/&gt;</span><br><span class="line">    &lt;/beans&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>



<p>接下来写一个测试类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.myapp.DataSourceConfig;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.junit.Assert.*;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.core.JdbcTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.core.RowMapper;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.ActiveProfiles;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.ContextConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringJUnit4ClassRunner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.sql.DataSource;</span><br><span class="line"><span class="keyword">import</span> java.sql.ResultSet;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataSourceConfigTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@RunWith</span>(SpringJUnit4ClassRunner<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    @<span class="title">ContextConfiguration</span>(<span class="title">classes</span> </span>= DataSourceConfig<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line">    @ActiveProfiles("dev")</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DevDataSourceTest</span></span>&#123;</span><br><span class="line">        <span class="meta">@Autowired</span></span><br><span class="line">        <span class="keyword">private</span> DataSource dataSource;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Test</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shouldBeEmbeddedDataSource</span><span class="params">()</span></span>&#123;</span><br><span class="line">            assertNotNull(dataSource);</span><br><span class="line">            JdbcTemplate jdbc = <span class="keyword">new</span> JdbcTemplate(dataSource);</span><br><span class="line">            List&lt;String&gt; results = jdbc.query(<span class="string">"select id , name from Things"</span>, <span class="keyword">new</span> RowMapper&lt;String&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> String <span class="title">mapRow</span><span class="params">(ResultSet rs, <span class="keyword">int</span> rowNum)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> rs.getLong(<span class="string">"id"</span>)+<span class="string">":"</span>+rs.getString(<span class="string">"name"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            assertEquals(<span class="number">1</span>,results.size());</span><br><span class="line">            assertEquals(<span class="string">"1:A"</span>,results.get(<span class="number">0</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p>可以看到我们使用Java配置上下文，也可改为使用XML注解，@ActiveProfiles(“dev”)代表激活开发环境profile。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="meta">@RunWith</span>(SpringJUnit4ClassRunner<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line">    @ContextConfiguration("classpath:datasource-config.xml")</span><br><span class="line">    <span class="meta">@ActiveProfiles</span>(<span class="string">"prod"</span>)</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductionDataSourceTest_XMLConfig</span></span>&#123;</span><br><span class="line">        <span class="meta">@Autowired</span>(required = <span class="keyword">false</span>)</span><br><span class="line">        <span class="keyword">private</span> DataSource dataSource;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Test</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shouldBeEmbeddedDatasource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// should be null, because there isn't a datasource configured in JNDI</span></span><br><span class="line">            assertNull(dataSource);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>可以看到我们使用Java配置上下文，也可改为使用XML注解，@ActiveProfiles(“prod”)代表激活生产环境profile。</p>
<p><strong>二、条件化的Bean</strong></p>
<p>假设你希望一个或多个bean只有在特定的类路径下包含特定的库时才创建，或者我们希望某个bean只有当另外一个特定的bean也声明了之后才会创建。我们还有可能要求某个特定的环境变量设置之后才会创建某个bean。</p>
<p>我们先定义一个MagicBean</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hubuma.restfun;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MagicBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后是它的配置类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hubuma.restfun;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Conditional;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MagicConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Conditional</span>(MagicExistsCondition<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">MagicBean</span> <span class="title">magicBean</span>()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MagicBean();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>@Conditional会通过Condition接口进行条件对比，从而实现条件化创建bean，设置给@Conditional的类可以是任意实现Condition接口的类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hubuma.restfun;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.env.Environment;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.type.AnnotatedTypeMetadata;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MagicExistsCondition</span> <span class="keyword">implements</span> <span class="title">Condition</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(ConditionContext context, AnnotatedTypeMetadata metadata)</span> </span>&#123;</span><br><span class="line">        Environment env = context.getEnvironment();</span><br><span class="line">        <span class="keyword">return</span> env.containsProperty(<span class="string">"magic"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>matches方法表示需要检查环境中是否存在名为magic 的环境属性，若存在则创建bean。</p>
<p><strong>三、处理自动装配的歧义性</strong></p>
<p>自动装配再仅有一个bean匹配所需要的结果时才有效。</p>
<p>假设我们使用@Autowired注解标注了getDessert()方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDessert</span><span class="params">(Dessert dessert)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.dessert  = dessert;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Dessert是一个接口，并且有三个类实现了这个接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cake</span> <span class="title">imlements</span> <span class="title">Dessert</span></span>&#123;...&#125;</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cookies</span> <span class="keyword">implements</span> <span class="title">Dessert</span></span>&#123;...&#125;</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IceCream</span> <span class="keyword">implements</span> <span class="title">Dessert</span></span>&#123;...&#125;</span><br></pre></td></tr></table></figure>

<p>在组件扫描的时候，能够发现他们并创建为Spring应用上下文里的bean，当Spring尝试装配setDessert()中的Dessert参数时，它并没有唯一的、无歧义的可选值，Spring此时会抛出NoUniqueBeanDefinitionException。</p>
<p>我们可以使用@Primary注解来将一个可选的bean设为首选项。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Primary</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IceCream</span> <span class="keyword">implements</span> <span class="title">Dessert</span></span>&#123;...&#125;</span><br></pre></td></tr></table></figure>

<p>解决自动装配歧义性问题，限定符是一个更强大的机制。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="meta">@Qualifier</span>(<span class="string">"iceCream"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDessert</span><span class="params">(Dessert dessert)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.dessert  = dessert;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>指定注入setDessert方法的是IceCream 类的实例。@Qualifier注解所设置的参数就是想要注入bean的ID，所有使用@Component注解的声明的类都会创建为bean，并且bean的ID为首字母变为小写的类名。</p>
<p>我们可以设置自己的限定符</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Qualifier</span>(<span class="string">"cold"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IceCream</span> <span class="keyword">implements</span> <span class="title">Dessert</span></span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="meta">@Qualifier</span>(<span class="string">"cold"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDessert</span><span class="params">(Dessert dessert)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.dessert  = dessert;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样注入setDessert的就是IceCream类的实例了。</p>
<p>当有两个cold限定符的时候一个cold限定符就不够用了，但是Java不允许在同一个条目上重复出现相同类型的多个注解我们不能使用两条@Qualifier注解来实现限定，此时我们只能自己声明注解然后进行限定。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.CONSTRUCTOR,ElementType.FIELD,ElementType.METHOD,ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Qualifier</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Cold &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.CONSTRUCTOR,ElementType.FIELD,ElementType.METHOD,ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Qualifier</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Creamy &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在方法或类上使用@Cold和@Creamy注解即可限定。</p>
<p><strong>四、bean的作用域</strong></p>
<p>Spring定义了多种作用域，可以基于这些作用域创建bean，包括：</p>
<p>单例（Singleton）在整个应用中只创建bean的一个实例。</p>
<p>原型（ProtoType）每次注入或通过Spring应用上下文获取的时候都会创建一个新的bean实例。</p>
<p>会话（Session）在Web应用中，为每个会话创建一个bean实例。</p>
<p>请求（Request）在Web应用中，为每个请求创建一个bean实例。</p>
<p>默认创建是以单例模式创建的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UniqueThing</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以原型模式创建</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Scope</span>(ConfigurableBeanFactory.SCOPE_PROTOTYPE)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotePad</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>五、运行时值注入</strong></p>
<p>当讨论依赖注入时我们通常讨论的是将一个bean注入到另一个bean的属性或构造器中，但bean装配的另一个方面是将一个值注入到bean的属性或构造器参数中。</p>
<p>定义一个BlankDisc类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.soundsystem;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlankDisc</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String title;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String artist;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BlankDisc</span><span class="params">(String title, String artist)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.title = title;</span><br><span class="line">        <span class="keyword">this</span>.artist = artist;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getTitle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> title;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getArtist</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> artist;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>app.properties文件内容</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">disc.title=Sgt. Peppers Lonely Hearts Club Band</span><br><span class="line">disc.artist=The Beatles</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.soundsystem;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.PropertySource;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.env.Environment;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@PropertySource</span>(<span class="string">"app.properties"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnvironmentConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    Environment env;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BlankDisc <span class="title">blankDisc</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BlankDisc(env.getProperty(<span class="string">"disc.title"</span>),env.getProperty(<span class="string">"disc.artist"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>app.properties文件会被加载到Spring的Environment中然后可以从中检索属性。</p>
<p>值注入还可以有默认值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">BlankDiscblankDisc</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> BlankDisc(env.getProperty(<span class="string">"disc.title"</span>,<span class="string">"Rattle and Hum"</span>),</span><br><span class="line">            env.getProperty(<span class="string">"disc.artist"</span>,<span class="string">"U2"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用SpEL表达式来进行装配</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">BlankDisc</span><span class="params">(@Value(<span class="string">"#systemProperties['disc.title']"</span>)</span> String title,</span></span><br><span class="line"><span class="function">                 @<span class="title">Value</span><span class="params">(<span class="string">"#systemProperties['disc.artist']"</span>)</span>  String artist) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.title = title;</span><br><span class="line">    <span class="keyword">this</span>.artist = artist;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SpEL表示浮点值 #{3.1.4159}</p>
<p>表示String#{‘Hello’}</p>
<p>表示boolean类型#{false}</p>
<p>SpEL能做的一件基础事情就是通过ID引用其他bean</p>
<p>#{sgtPeppers}</p>
<p>#{sgtPeppers.artist}</p>
<p>我们还可以调用bean上的方法</p>
<p>#{artistSelector.selectArtist()}</p>
<p>这里只介绍了SpEL的部分知识，具体的看手册。</p>
<h1 id="面向切面的Spring"><a href="#面向切面的Spring" class="headerlink" title="面向切面的Spring"></a>面向切面的Spring</h1><p>我们知道如何使用依赖注入（DI）管理和配置我们的应用对象，DI有助于应用对象之间的解耦，而AOP可以实现横切关注点与他们所影响的对象之间的解耦。切面能帮助我们模块化横切关注点，横切关注点可以被描述为影响应用多处的功能。</p>
<p>定义AOP术语，描述切面的术语有通知，切点和连接点。</p>
<p>通知定义了切面是什么以及切面何时开始使用。除了描述切面要完成的工作，通知还解决了何时执行这个工作的问题。它应该应用在某个方法被调用之前？之后？之前和之后都调用？还是只在方法抛出异常时调用？</p>
<p>Spring切面可以应用5种类型的通知：</p>
<p>前置通知：在目标方法被调用之前调用通知功能；</p>
<p>后置通知：在目标方法完成之后调用通知功能；</p>
<p>返回通知：在目标方法成功执行之后调用通知功能；</p>
<p>异常通知：在目标方法抛出异常后调用的通知功能；</p>
<p>环绕通知：通知包裹了被通知的方法，在被通知的方法调用之前和调用之后执行自定义的行为。</p>
<p>我们的应用可能有数千计的时机应用通知。这些时机被称为连接点。连接点是在应用执行过程中能够插入切面的一个点，这个点可以是调用方法时，抛出异常时，甚至修改一个字段时，切面代码可以利用这些点插入到应用正常的流程之中，并添加新的行为。</p>
<p>如果说通知定义了切面的“什么”和“何时”的话，那么切点就定义了“何处”切点的定义会匹配通知所要织入的一个或多个连接点。我们通常使用明确的类和方法名称，或是利用正则表达式来匹配通知所要织入的一个或多个连接点。</p>
<p>切面是通知和切点的结合。通知和切点共同定义了切面的全部内容–它是什么，在何时和何处完成其功能。</p>
<p>织入是把切面应用到目标对象并创建新的代理对象的过程。</p>
<p>我们先定义一个Performance接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> concert;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Performance</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">perform</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再定义一个它的实现类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> concert;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcertPerformance</span> <span class="keyword">implements</span> <span class="title">Performance</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">perform</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Performing..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>重点是这里的Audience类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> concert;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.ProceedingJoinPoint;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Audience</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut</span>(value = <span class="string">"execution(* concert.Performance.perform(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">performance</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"performance()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">silenceCellPhone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"silencing cellPhone"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@After</span>(<span class="string">"performance()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPerformance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"after performance"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterThrowing</span>(<span class="string">"performance()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">demanRefund</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"demanding a refund"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 环绕通知</span></span><br><span class="line">    <span class="meta">@Around</span>(<span class="string">"performance()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">watchPerformance</span><span class="params">(ProceedingJoinPoint joinPoint)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"around before performance..."</span>);</span><br><span class="line">            joinPoint.proceed();</span><br><span class="line">            System.out.println(<span class="string">"around after performance..."</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Throwable t) &#123;</span><br><span class="line">            t.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>@Aspect声明这是一个Aspect注解驱动的切面。</p>
<p>@Poincut定义了一个切点，execution(* concert.Performance.perform(..))代表perform这个方法执行时将会声明为一个切点</p>
<p>“ * ” 代表任意返回值类型，“ .. ”代表任意参数类型。也可以写成 * *.perform(..)代表任意类的perform方法。</p>
<p>@Before，@After，@AfterThrowing，分别是前置，后置，异常通知。</p>
<p>@Around声明一个环绕通知</p>
<p>这还不够，我们需要一个配置类，来启用自动代理功能。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> concert;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.EnableAspectJAutoProxy;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(basePackages = &#123;<span class="string">"concert"</span>&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcertConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Performance <span class="title">performance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ConcertPerformance();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Audience <span class="title">audience</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Audience();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>@EnableAspectJAutoProxy注解启动了自动代理功能，这里我们声明了两个Bean。</p>
<p>接下来测试一下，AOPTest类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> concert;</span><br><span class="line"><span class="keyword">import</span> concert.ConcertConfig;</span><br><span class="line"><span class="keyword">import</span> concert.Performance;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.ContextConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringJUnit4ClassRunner;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith</span>(SpringJUnit4ClassRunner<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">ContextConfiguration</span>(<span class="title">classes</span></span>= &#123;ConcertConfig<span class="class">.<span class="keyword">class</span>&#125;)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">AOPTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Performance performance;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        performance.perform();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>performance对象会自动注入到AOPTest类中。</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/7VN2CGTRIXMWFHO.png" alt="img"></p>
<p>切面运行结果</p>
<p>这里详细写一下IDEA 配置AspectJ的步骤：</p>
<p>1、启用IDEA AspectJ plugin File—Settings–Plugins，搜索栏内搜索AspectJ，启用支持，注意这里只有Ultimate版才会有。</p>
<p>2、添加依赖</p>
<p>build.gradle添加</p>
<p>compile”org.springframework:spring-context:4.0.7.RELEASE”</p>
<p>compile”org.springframework:spring-test:4.0.7.RELEASE”</p>
<p>compile group:’org.aspectj’,name:’aspectjtools’,version:’1.8.9’</p>
<p>testCompile”org.springframework:spring-test:4.0.7.RELEASE”</p>
<p>implementation’junit:junit:4.12’</p>
<h1 id="Spring-JDBC征服数据库"><a href="#Spring-JDBC征服数据库" class="headerlink" title="Spring+JDBC征服数据库"></a>Spring+JDBC征服数据库</h1><p>Spring将数据访问过程中固定的和可变的部分明确划分为两个不同的类，<strong>模板(template)</strong>和<strong>回调(callback)</strong>。模板管理过程中固定的部分，回调处理自定义的数据访问代码。</p>
<p>Spring的模板类处理数据访问的固定部分–事务控制、管理资源以及处理异常。同时，应用程序相关的数据访问–语句、绑定参数以及整理结果集在回调的实现中处理。</p>
<p>以Spittr这个应用来演示JDBC。</p>
<p>我们先定义Spitter和Spittle两个实体类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> spittr.domain;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Spitter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> String fullname;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> updateByEmail;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Spitter</span><span class="params">(Long id, String username, String password, String fullname, String email, <span class="keyword">boolean</span> updateByEmail)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.username = username;</span><br><span class="line">        <span class="keyword">this</span>.password = password;</span><br><span class="line">        <span class="keyword">this</span>.fullname = fullname;</span><br><span class="line">        <span class="keyword">this</span>.email = email;</span><br><span class="line">        <span class="keyword">this</span>.updateByEmail = updateByEmail;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUsername</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPassword</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getFullname</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> fullname;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getEmail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> email;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isUpdateByEmail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> updateByEmail;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> spittr.domain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Spittle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Spitter spitter;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String message;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Date postedDate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Spittle</span><span class="params">(Long id, Spitter spitter, String message, Date postedDate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.spitter = spitter;</span><br><span class="line">        <span class="keyword">this</span>.message = message;</span><br><span class="line">        <span class="keyword">this</span>.postedDate = postedDate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Spitter <span class="title">getSpitter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> spitter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Date <span class="title">getPostedDate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> postedDate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>然后定义SpittleRepository、SpitterRepository两个接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> spittr.db;</span><br><span class="line"><span class="keyword">import</span> spittr.domain.Spittle;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SpittleRepository</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">count</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">List&lt;Spittle&gt; <span class="title">findRecent</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">List&lt;Spittle&gt; <span class="title">findRecent</span><span class="params">(<span class="keyword">int</span> count)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Spittle <span class="title">findOne</span><span class="params">(<span class="keyword">long</span> id)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Spittle <span class="title">save</span><span class="params">(Spittle spittle)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">List&lt;Spittle&gt; <span class="title">findBySpitterId</span><span class="params">(<span class="keyword">long</span> id)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">delete</span><span class="params">(<span class="keyword">long</span> id)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> spittr.db;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> spittr.domain.Spitter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SpitterRepository</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">count</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Spitter <span class="title">save</span><span class="params">(Spitter spitter)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Spitter <span class="title">findOne</span><span class="params">(<span class="keyword">long</span> id)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Spitter <span class="title">findByUsername</span><span class="params">(String username)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">List&lt;Spitter&gt; <span class="title">findAll</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>Spring的JDBC框架承担了资源管理和异常处理的工作，从而简化了JDBC代码，让我们只需编写从数据库读写数据的必要代码。</p>
<p>Spring为JDBC提供了三个模板供选择：</p>
<p>JdbcTemplate:最基本的Spring JDBC 模板，支持简单的JDBC数据库访问功能以及基于索引参数的查询。</p>
<p>NamedParameterJdbcTemplate：使用该模板类进行查询时可以将值以命名参数的形式绑定到SQL中，而不是简单的使用索引参数。</p>
<p>对于大多数JDBC任务来说，JdbcTemplate就是最好的方案。</p>
<p>我们定义JdbcSpitterRepository实现SpitterRepository接口，定义JdbcSpittleRepository实现SpittleRepository接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> spittr.db.jdbc;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.core.JdbcTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.core.RowMapper;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.core.simple.SimpleJdbcInsert;</span><br><span class="line"><span class="keyword">import</span> spittr.db.SpitterRepository;</span><br><span class="line"><span class="keyword">import</span> spittr.domain.Spitter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.ResultSet;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcSpitterRepository</span> <span class="keyword">implements</span> <span class="title">SpitterRepository</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> JdbcTemplate jdbcTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String INSERT_SPITTER = <span class="string">"insert into Spitter(username,password,fullname,email,updateByEmail) values(?,?,?,?,?) "</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SELECT_SPITTER = <span class="string">"select id,username,password,fullname,email,updateByEmail from Spitter "</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JdbcSpitterRepository</span><span class="params">(JdbcTemplate jdbcTemplate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.jdbcTemplate = jdbcTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Spitter <span class="title">save</span><span class="params">(Spitter spitter)</span> </span>&#123;</span><br><span class="line">        Long id = spitter.getId();</span><br><span class="line">        <span class="keyword">if</span>(id == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">long</span> spitterId = insertSpitterAndReturnId(spitter);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Spitter(spitterId,spitter.getUsername(),spitter.getPassword(),spitter.getFullname(),spitter.getEmail(),spitter.isUpdateByEmail());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">         jdbcTemplate.update(<span class="string">"update Spitter set username=?, password=?, fullname=?, email=?, updateByEmail=? where id =? "</span>,</span><br><span class="line">                 spitter.getUsername(),</span><br><span class="line">                 spitter.getPassword(),</span><br><span class="line">                 spitter.getFullname(),</span><br><span class="line">                 spitter.getEmail(),</span><br><span class="line">                 spitter.isUpdateByEmail(),</span><br><span class="line">                 id);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> spitter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">insertSpitterAndReturnId</span><span class="params">(Spitter spitter)</span></span>&#123;</span><br><span class="line">        SimpleJdbcInsert jdbcInsert = <span class="keyword">new</span> SimpleJdbcInsert(jdbcTemplate).withTableName(<span class="string">"Spitter"</span>);</span><br><span class="line">        jdbcInsert.setGeneratedKeyName(<span class="string">"id"</span>);</span><br><span class="line">        Map&lt;String, Object&gt;args = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        args.put(<span class="string">"username"</span>,spitter.getUsername());</span><br><span class="line">        args.put(<span class="string">"password"</span>,spitter.getPassword());</span><br><span class="line">        args.put(<span class="string">"fullname"</span>,spitter.getFullname());</span><br><span class="line">        args.put(<span class="string">"email"</span>,spitter.getEmail());</span><br><span class="line">        args.put(<span class="string">"updateByEmail"</span>,spitter.isUpdateByEmail());</span><br><span class="line">        <span class="keyword">long</span> spitterId = jdbcInsert.executeAndReturnKey(args).longValue();</span><br><span class="line">        <span class="keyword">return</span> spitterId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertSpitter</span><span class="params">(Spitter spitter)</span></span>&#123;</span><br><span class="line">        jdbcTemplate.update(INSERT_SPITTER,</span><br><span class="line">                spitter.getUsername(),</span><br><span class="line">                spitter.getPassword(),</span><br><span class="line">                spitter.getFullname(),</span><br><span class="line">                spitter.getEmail(),</span><br><span class="line">                spitter.isUpdateByEmail());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Spitter <span class="title">findOne</span><span class="params">(<span class="keyword">long</span> id)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> jdbcTemplate.queryForObject(SELECT_SPITTER+<span class="string">"where id = ?"</span>,<span class="keyword">new</span> SpitterRowMapper(),id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Spitter&gt; <span class="title">findAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> jdbcTemplate.query(SELECT_SPITTER+<span class="string">"order by id"</span>,<span class="keyword">new</span> SpitterRowMapper());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">count</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> jdbcTemplate.queryForLong(<span class="string">"select count(id) from spitter"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Spitter <span class="title">findByUsername</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> jdbcTemplate.queryForObject(SELECT_SPITTER+<span class="string">"where username = ?"</span>,<span class="keyword">new</span> SpitterRowMapper(),username);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SpitterRowMapper</span> <span class="keyword">implements</span> <span class="title">RowMapper</span>&lt;<span class="title">Spitter</span>&gt;</span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Spitter <span class="title">mapRow</span><span class="params">(ResultSet rs, <span class="keyword">int</span> rowNum)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Spitter(rs.getLong(<span class="string">"id"</span>),rs.getString(<span class="string">"username"</span>),rs.getString(<span class="string">"password"</span>),</span><br><span class="line">                    rs.getString(<span class="string">"fullname"</span>),rs.getString(<span class="string">"email"</span>),rs.getBoolean(<span class="string">"updateByEmail"</span>));</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> spittr.db.jdbc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.dao.DataAccessException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.core.JdbcTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.core.RowMapper;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.core.simple.SimpleJdbcInsert;</span><br><span class="line"><span class="keyword">import</span> spittr.db.SpittleRepository;</span><br><span class="line"><span class="keyword">import</span> spittr.domain.Spitter;</span><br><span class="line"><span class="keyword">import</span> spittr.domain.Spittle;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.ResultSet;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcSpittleRepository</span> <span class="keyword">implements</span> <span class="title">SpittleRepository</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SELECT_SPITTLE = <span class="string">"select sp.id, s.id as spitterId, s.username, s.password, s.fullname, s.email, s.updateByEmail, sp.message, sp.postedTime from Spitter s, Spittle sp where s.id = sp.spitter"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SELECT_SPITTLE_BY_ID = SELECT_SPITTLE+<span class="string">" and sp.id=?"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SELECT_SPITTLE_BY_SPITTER_ID = SELECT_SPITTLE+<span class="string">" and s.id=? order by sp.postedTime desc"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SELECT_RECENT_SPITTLES = SELECT_SPITTLE+<span class="string">" order by sp.postedTime desc limit ?"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> JdbcTemplate jdbcTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JdbcSpittleRepository</span><span class="params">(JdbcTemplate jdbcTemplate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.jdbcTemplate = jdbcTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">count</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> jdbcTemplate.queryForLong(<span class="string">"select count(id) from Spittle"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Spittle <span class="title">findOne</span><span class="params">(<span class="keyword">long</span> id)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> jdbcTemplate.queryForObject(SELECT_SPITTLE_BY_ID,<span class="keyword">new</span> SpittleRowMapper(),id);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (DataAccessException e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Spittle <span class="title">save</span><span class="params">(Spittle spittle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> spittleId = insertSpittleAndReturnId(spittle);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Spittle(spittleId,spittle.getSpitter(),spittle.getMessage(),spittle.getPostedDate());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Spittle&gt; <span class="title">findBySpitterId</span><span class="params">(<span class="keyword">long</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> jdbcTemplate.query(SELECT_SPITTLE_BY_SPITTER_ID,<span class="keyword">new</span> SpittleRowMapper(),id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Spittle&gt; <span class="title">findRecent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> findRecent(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Spittle&gt; <span class="title">findRecent</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> jdbcTemplate.query(SELECT_RECENT_SPITTLES,<span class="keyword">new</span> SpittleRowMapper(),count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(<span class="keyword">long</span> id)</span> </span>&#123;</span><br><span class="line">        jdbcTemplate.update(<span class="string">"delete from Spittle where id = ?"</span>,id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">insertSpittleAndReturnId</span><span class="params">(Spittle spittle)</span></span>&#123;</span><br><span class="line">        SimpleJdbcInsert jdbcInsert = <span class="keyword">new</span> SimpleJdbcInsert(jdbcTemplate).withTableName(<span class="string">"Spittle"</span>);</span><br><span class="line">        jdbcInsert.setGeneratedKeyName(<span class="string">"id"</span>);</span><br><span class="line">        Map&lt;String,Object&gt; args = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        args.put(<span class="string">"spitter"</span>,spittle.getSpitter().getId());</span><br><span class="line">        args.put(<span class="string">"message"</span>,spittle.getMessage());</span><br><span class="line">        args.put(<span class="string">"postedTime"</span>,spittle.getPostedDate());</span><br><span class="line">        <span class="keyword">long</span> spittleId = jdbcInsert.executeAndReturnKey(args).longValue();</span><br><span class="line">        <span class="keyword">return</span> spittleId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SpittleRowMapper</span> <span class="keyword">implements</span> <span class="title">RowMapper</span>&lt;<span class="title">Spittle</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Spittle <span class="title">mapRow</span><span class="params">(ResultSet rs, <span class="keyword">int</span> rowNum)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Spittle(rs.getLong(<span class="string">"id"</span>),</span><br><span class="line">                    <span class="keyword">new</span> Spitter(rs.getLong(<span class="string">"spitterId"</span>),rs.getString(<span class="string">"username"</span>),</span><br><span class="line">                            rs.getString(<span class="string">"password"</span>),rs.getString(<span class="string">"fullname"</span>),</span><br><span class="line">                            rs.getString(<span class="string">"email"</span>),rs.getBoolean(<span class="string">"updateByEmail"</span>)),</span><br><span class="line">                    rs.getString(<span class="string">"message"</span>),rs.getTimestamp(<span class="string">"postedTime"</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>可以看到Spring中JDBC将获取连接，捕获异常都封装在JdbcTemplate中让我们更关注数据操作代码。对于增删改查四个方面，JdbcTemplate都为我们封装了一系列的函数。</p>
<p>SimpleJdbcInsert 可以简化我们的插入操作，指定一个数据库中的表名，然后传入一个Map，Key为数据表中的表项名，Value为插入的值，并可以指定一个返回的值。</p>
<p>通过update方法来实现删改。</p>
<p>查询基本类型例如Long等有对应的queryForLong方法等，若要将查询结果处理成为对象或对象集合，我们需要实现RowMapper接口实现将查询结果的一行映射为对象。</p>
<p>其实以上的代码我们并不能运行，因为我们还没有指定数据库数据源我们写一个JdbcConfig配置类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> spittr.jdbc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.core.JdbcTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.datasource.DataSourceTransactionManager;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.datasource.embedded.EmbeddedDatabaseBuilder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.datasource.embedded.EmbeddedDatabaseType;</span><br><span class="line"><span class="keyword">import</span> org.springframework.transaction.PlatformTransactionManager;</span><br><span class="line"><span class="keyword">import</span> spittr.db.jdbc.JdbcSpitterRepository;</span><br><span class="line"><span class="keyword">import</span> spittr.db.jdbc.JdbcSpittleRepository;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.sql.DataSource;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> EmbeddedDatabaseBuilder()</span><br><span class="line">                .setType(EmbeddedDatabaseType.H2)</span><br><span class="line">                .addScripts(<span class="string">"classpath:spittr/db/jdbc/schema.sql"</span>,<span class="string">"classpath:spittr/db/jdbc/test-data.sql"</span>)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> JdbcTemplate <span class="title">jdbcTemplate</span><span class="params">(DataSource dataSource)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JdbcTemplate(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> JdbcSpitterRepository <span class="title">spitterRepository</span><span class="params">(JdbcTemplate jdbcTemplate)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JdbcSpitterRepository(jdbcTemplate);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> JdbcSpittleRepository <span class="title">spittleRepository</span><span class="params">(JdbcTemplate jdbcTemplate)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JdbcSpittleRepository(jdbcTemplate);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PlatformTransactionManager <span class="title">transactionManager</span><span class="params">(DataSource dataSource)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DataSourceTransactionManager(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>我们使用EmbeddedDatabaseBuilder来新建一个嵌入式数据库，这里我们选择H2，addScripts方法可以执行我们写好的SQL脚本。</p>
<p>将数据源注入到JdbcTemplate就可以使用它了，是不是很方便？？</p>
<p>我们还可以使用DriverManagerDataSource来配置基于JDBC驱动的数据源。</p>
<p>我们定义了dataSource、jdbcTemplate、spitterRepository、spittleRepository和transactionManager五个bean，dataSource bean 用来注入到jdbcTemplate bean中，jdbcTemplate bean 用来注入到用到它的repository实现中。spitterRepository和spittleRepository bean 用来注入到使用到它们的类。transactionManager bean 用来实现 事务管理，这里我们没有用到它。</p>
<p>下面是测试类的一部分。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> spittr.jdbc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.junit.Assert.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.BeforeClass;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.ContextConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringJUnit4ClassRunner;</span><br><span class="line"><span class="keyword">import</span> org.springframework.transaction.annotation.Transactional;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> spittr.db.jdbc.JdbcSpitterRepository;</span><br><span class="line"><span class="keyword">import</span> spittr.domain.Spitter;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith</span>(SpringJUnit4ClassRunner<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">ContextConfiguration</span>(<span class="title">classes</span></span>=JdbcConfig<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">JdbcSpitterRepositoryTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  JdbcSpitterRepository spitterRepository;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">count</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    assertEquals(<span class="number">4</span>, spitterRepository.count());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="meta">@Transactional</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;Spitter&gt; spitters = spitterRepository.findAll();</span><br><span class="line">    assertEquals(<span class="number">4</span>, spitters.size());</span><br><span class="line">    assertSpitter(<span class="number">0</span>, spitters.get(<span class="number">0</span>));</span><br><span class="line">    assertSpitter(<span class="number">1</span>, spitters.get(<span class="number">1</span>));</span><br><span class="line">    assertSpitter(<span class="number">2</span>, spitters.get(<span class="number">2</span>));</span><br><span class="line">    assertSpitter(<span class="number">3</span>, spitters.get(<span class="number">3</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>我们使用JdbcConfig类配置应用上下文，自动装配相应的repository实现。</p>
<p>这里需要注意的是@Transactional注解当它置于方法前时表示该方法使用事务处理，当它置于类前时表示该类的所有方法都使用事务处理。</p>
<h1 id="使用对象-关系映射持久化数据"><a href="#使用对象-关系映射持久化数据" class="headerlink" title="使用对象-关系映射持久化数据"></a>使用对象-关系映射持久化数据</h1><p>在数据持久化的世界中，JDBC就像自行车，对于份内的工作它能完成的很好。随着应用程序越来越复杂，对持久化的要求也越来越复杂。我们需要将对象的属性映射到数据库的列上，并且需要自动生成语句和查询，这样我们就能从无休止的问号字符串中解脱出来。</p>
<p><strong>一、Hibernate</strong></p>
<p>还是以Spittr应用为例来具体阐述Hibernate的使用。</p>
<p>我们定义Spitter、Spittle两个实体类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> spittr.domain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.persistence.Column;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.Entity;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.GeneratedValue;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.GenerationType;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.Id;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Spitter</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="title">Spitter</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Id</span></span><br><span class="line">   <span class="meta">@GeneratedValue</span>(strategy=GenerationType.IDENTITY)</span><br><span class="line">   <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Column</span>(name=<span class="string">"username"</span>)</span><br><span class="line">   <span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Column</span>(name=<span class="string">"password"</span>)</span><br><span class="line">   <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Column</span>(name=<span class="string">"fullname"</span>)</span><br><span class="line">   <span class="keyword">private</span> String fullName;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Column</span>(name=<span class="string">"email"</span>)</span><br><span class="line">   <span class="keyword">private</span> String email;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Column</span>(name=<span class="string">"updateByEmail"</span>)</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">boolean</span> updateByEmail;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Spitter</span><span class="params">(Long id, String username, String password, String fullName,</span></span></span><br><span class="line"><span class="function"><span class="params">         String email, <span class="keyword">boolean</span> updateByEmail)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.id = id;</span><br><span class="line">      <span class="keyword">this</span>.username = username;</span><br><span class="line">      <span class="keyword">this</span>.password = password;</span><br><span class="line">      <span class="keyword">this</span>.fullName = fullName;</span><br><span class="line">      <span class="keyword">this</span>.email = email;</span><br><span class="line">      <span class="keyword">this</span>.updateByEmail = updateByEmail;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Long <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> id;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">getUsername</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> username;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">getPassword</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> password;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">getFullName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> fullName;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">getEmail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> email;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isUpdateByEmail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> updateByEmail;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> spittr.domain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.persistence.Column;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.Entity;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.GeneratedValue;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.GenerationType;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.Id;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.JoinColumn;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.ManyToOne;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Spittle</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="title">Spittle</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">   </span><br><span class="line">   <span class="meta">@Id</span></span><br><span class="line">   <span class="meta">@GeneratedValue</span>(strategy=GenerationType.IDENTITY)</span><br><span class="line">   <span class="keyword">private</span> Long id;</span><br><span class="line">   </span><br><span class="line">   <span class="meta">@ManyToOne</span></span><br><span class="line">   <span class="meta">@JoinColumn</span>(name=<span class="string">"spitter"</span>)</span><br><span class="line">   <span class="keyword">private</span> Spitter spitter;</span><br><span class="line">   </span><br><span class="line">   <span class="meta">@Column</span></span><br><span class="line">   <span class="keyword">private</span> String message;</span><br><span class="line">   </span><br><span class="line">   <span class="meta">@Column</span></span><br><span class="line">   <span class="keyword">private</span> Date postedTime;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Spittle</span><span class="params">(Long id, Spitter spitter, String message, Date postedTime)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.id = id;</span><br><span class="line">      <span class="keyword">this</span>.spitter = spitter;</span><br><span class="line">      <span class="keyword">this</span>.message = message;</span><br><span class="line">      <span class="keyword">this</span>.postedTime = postedTime;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Long <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.id;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">getMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.message;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Date <span class="title">getPostedTime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.postedTime;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Spitter <span class="title">getSpitter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.spitter;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>@Entity注解表示这是一个实体类，@Id注解代表这是数据表的primary key ,@GeneratedValue代表这是自动生成的列，</p>
<p>@Column注解将数据表的一列与类的属性绑定，不指定name属性则代表和变量名相同，@ManyToOne注解代表会有多个Spittle参照同一个Spitter， @JoinColumn注解代表参考spitter列。</p>
<p>这样就实现了类属性和数据表项的绑定。</p>
<p>同样我们定义SpitterRepository、SpittleRepository接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> spittr.db;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> spittr.domain.Spitter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SpitterRepository</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">long</span> <span class="title">count</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">Spitter <span class="title">save</span><span class="params">(Spitter spitter)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">Spitter <span class="title">findOne</span><span class="params">(<span class="keyword">long</span> id)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">Spitter <span class="title">findByUsername</span><span class="params">(String username)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">List&lt;Spitter&gt; <span class="title">findAll</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> spittr.db;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> spittr.domain.Spittle;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SpittleRepository</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">long</span> <span class="title">count</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">List&lt;Spittle&gt; <span class="title">findRecent</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">List&lt;Spittle&gt; <span class="title">findRecent</span><span class="params">(<span class="keyword">int</span> count)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">Spittle <span class="title">findOne</span><span class="params">(<span class="keyword">long</span> id)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">Spittle <span class="title">save</span><span class="params">(Spittle spittle)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">List&lt;Spittle&gt; <span class="title">findBySpitterId</span><span class="params">(<span class="keyword">long</span> spitterId)</span></span>;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">delete</span><span class="params">(<span class="keyword">long</span> id)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>我们先看看如何配置Hibernate 下面是RepositoryTestConfig.java。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> spittr.db.hibernate4;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.inject.Inject;</span><br><span class="line"><span class="keyword">import</span> javax.sql.DataSource;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.hibernate.SessionFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.datasource.embedded.EmbeddedDatabase;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.datasource.embedded.EmbeddedDatabaseBuilder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.datasource.embedded.EmbeddedDatabaseType;</span><br><span class="line"><span class="keyword">import</span> org.springframework.orm.hibernate4.HibernateTransactionManager;</span><br><span class="line"><span class="keyword">import</span> org.springframework.orm.hibernate4.LocalSessionFactoryBean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.transaction.PlatformTransactionManager;</span><br><span class="line"><span class="keyword">import</span> org.springframework.transaction.annotation.EnableTransactionManagement;</span><br><span class="line"><span class="keyword">import</span> org.springframework.transaction.annotation.TransactionManagementConfigurer;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableTransactionManagement</span></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RepositoryTestConfig</span> <span class="keyword">implements</span> <span class="title">TransactionManagementConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Inject</span></span><br><span class="line">  <span class="keyword">private</span> SessionFactory sessionFactory;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    EmbeddedDatabaseBuilder edb = <span class="keyword">new</span> EmbeddedDatabaseBuilder();</span><br><span class="line">    edb.setType(EmbeddedDatabaseType.H2);</span><br><span class="line">    edb.addScript(<span class="string">"spittr/db/hibernate4/schema.sql"</span>);</span><br><span class="line">    edb.addScript(<span class="string">"spittr/db/hibernate4/test-data.sql"</span>);</span><br><span class="line">    EmbeddedDatabase embeddedDatabase = edb.build();</span><br><span class="line">    <span class="keyword">return</span> embeddedDatabase;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> PlatformTransactionManager <span class="title">annotationDrivenTransactionManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(sessionFactory);</span><br><span class="line">    HibernateTransactionManager transactionManager = <span class="keyword">new</span> HibernateTransactionManager();</span><br><span class="line">    transactionManager.setSessionFactory(sessionFactory);</span><br><span class="line">    <span class="keyword">return</span> transactionManager;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> SessionFactory <span class="title">sessionFactoryBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      LocalSessionFactoryBean lsfb = <span class="keyword">new</span> LocalSessionFactoryBean();</span><br><span class="line">      lsfb.setDataSource(dataSource());</span><br><span class="line">      lsfb.setPackagesToScan(<span class="string">"spittr.domain"</span>);</span><br><span class="line">      Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line">      props.setProperty(<span class="string">"dialect"</span>, <span class="string">"org.hibernate.dialect.H2Dialect"</span>);</span><br><span class="line">      lsfb.setHibernateProperties(props);</span><br><span class="line">      lsfb.afterPropertiesSet();</span><br><span class="line">      SessionFactory object = lsfb.getObject();</span><br><span class="line">      <span class="keyword">return</span> object;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这里我们声明它是一个配置类并且启用了组件扫描和事务管理。</p>
<p>@Inject和@Autowired基本相同，同样dataBase bean为数据源配置，annotationDrivenTransactionManager bean 为事务处理，</p>
<p>使用Hibernate所需要的主要接口时org.hibernate.Session。Session接口提供了基本的数据访问功能，如保存、更新、删除以及从数据库加载对象的功能。通过Hibernate的Session接口，应用程序的Repository能够满足所有的持久化需求。</p>
<p>SessionFactory主要负责Hibernate Session的打开，关闭以及管理。</p>
<p>dataSource和hibernateProperties属性声明了从哪里获取数据库连接以及要使用哪一种数据库。这里不再列出Hibernate配置文件，使用packageToScan属性告诉Spring扫描一个或多个包以查找域类，这些类表明要使用Hibernate进行持久化，这些类可以使用的注解包括JPA的@Entity或@MappedSuperclass以及Hibernate的Entity。</p>
<p>了解完Hibernate的配置之后我们开始编写HibernateSpitterRepository和HibernateSpittleRepository他们分别实现SpitterRepository接口和SpittleRepository接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> spittr.db.hibernate4;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.inject.Inject;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.hibernate.Session;</span><br><span class="line"><span class="keyword">import</span> org.hibernate.SessionFactory;</span><br><span class="line"><span class="keyword">import</span> org.hibernate.criterion.Restrictions;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Repository;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> spittr.db.SpitterRepository;</span><br><span class="line"><span class="keyword">import</span> spittr.domain.Spitter;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HibernateSpitterRepository</span> <span class="keyword">implements</span> <span class="title">SpitterRepository</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> SessionFactory sessionFactory;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Inject</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">HibernateSpitterRepository</span><span class="params">(SessionFactory sessionFactory)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.sessionFactory = sessionFactory;      <span class="comment">//&lt;co id="co_InjectSessionFactory"/&gt;</span></span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">private</span> Session <span class="title">currentSession</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> sessionFactory.getCurrentSession();<span class="comment">//&lt;co id="co_RetrieveCurrentSession"/&gt;</span></span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">count</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> findAll().size();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Spitter <span class="title">save</span><span class="params">(Spitter spitter)</span> </span>&#123;</span><br><span class="line">      Serializable id = currentSession().save(spitter);  <span class="comment">//&lt;co id="co_UseCurrentSession"/&gt;</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Spitter((Long) id, </span><br><span class="line">            spitter.getUsername(), </span><br><span class="line">            spitter.getPassword(), </span><br><span class="line">            spitter.getFullName(), </span><br><span class="line">            spitter.getEmail(), </span><br><span class="line">            spitter.isUpdateByEmail());</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Spitter <span class="title">findOne</span><span class="params">(<span class="keyword">long</span> id)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> (Spitter) currentSession().get(Spitter<span class="class">.<span class="keyword">class</span>, <span class="title">id</span>)</span>; </span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Spitter <span class="title">findByUsername</span><span class="params">(String username)</span> </span>&#123;      </span><br><span class="line">      <span class="keyword">return</span> (Spitter) currentSession() </span><br><span class="line">            .createCriteria(Spitter<span class="class">.<span class="keyword">class</span>) </span></span><br><span class="line">            .add(Restrictions.eq("username", username))</span><br><span class="line">            .list().get(<span class="number">0</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> List&lt;Spitter&gt; <span class="title">findAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> (List&lt;Spitter&gt;) currentSession() </span><br><span class="line">            .createCriteria(Spitter<span class="class">.<span class="keyword">class</span>).<span class="title">list</span>()</span>; </span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> spittr.db.hibernate4;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.inject.Inject;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.hibernate.Criteria;</span><br><span class="line"><span class="keyword">import</span> org.hibernate.Session;</span><br><span class="line"><span class="keyword">import</span> org.hibernate.SessionFactory;</span><br><span class="line"><span class="keyword">import</span> org.hibernate.criterion.Order;</span><br><span class="line"><span class="keyword">import</span> org.hibernate.criterion.Restrictions;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Repository;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> spittr.db.SpittleRepository;</span><br><span class="line"><span class="keyword">import</span> spittr.domain.Spittle;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HibernateSpittleRepository</span> <span class="keyword">implements</span> <span class="title">SpittleRepository</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> SessionFactory sessionFactory;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Inject</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">HibernateSpittleRepository</span><span class="params">(SessionFactory sessionFactory)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.sessionFactory = sessionFactory;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">private</span> Session <span class="title">currentSession</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> sessionFactory.getCurrentSession();<span class="comment">//&lt;co id="co_RetrieveCurrentSession"/&gt;</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">count</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> findAll().size(); </span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> List&lt;Spittle&gt; <span class="title">findRecent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> findRecent(<span class="number">10</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> List&lt;Spittle&gt; <span class="title">findRecent</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> (List&lt;Spittle&gt;) spittleCriteria()</span><br><span class="line">            .setMaxResults(count)</span><br><span class="line">            .list();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Spittle <span class="title">findOne</span><span class="params">(<span class="keyword">long</span> id)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> (Spittle) currentSession().get(Spittle<span class="class">.<span class="keyword">class</span>, <span class="title">id</span>)</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Spittle <span class="title">save</span><span class="params">(Spittle spittle)</span> </span>&#123;</span><br><span class="line">      Serializable id = currentSession().save(spittle);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Spittle(</span><br><span class="line">         (Long) id, </span><br><span class="line">         spittle.getSpitter(), </span><br><span class="line">         spittle.getMessage(), </span><br><span class="line">         spittle.getPostedTime());</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> List&lt;Spittle&gt; <span class="title">findBySpitterId</span><span class="params">(<span class="keyword">long</span> spitterId)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> spittleCriteria()</span><br><span class="line">            .add(Restrictions.eq(<span class="string">"spitter.id"</span>, spitterId))</span><br><span class="line">            .list();</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(<span class="keyword">long</span> id)</span> </span>&#123;</span><br><span class="line">      currentSession().delete(findOne(id));</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> List&lt;Spittle&gt; <span class="title">findAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> (List&lt;Spittle&gt;) spittleCriteria().list(); </span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">private</span> Criteria <span class="title">spittleCriteria</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> currentSession() </span><br><span class="line">            .createCriteria(Spittle<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line">            .addOrder(Order.desc("postedTime"));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>我们将一个SessionFactory注入到HibernateSpitterRepository和HibernateSpittleRepository的sessionFactory属性中，在currentSession()方法中我们使用这个sessionFactory来获取当前事务的Session。</p>
<p>我们使用了@Repository注解，它能够被组件扫描扫描到，不必显示声明，它还会捕获平台相关的异常，然后使用Spring统一非检查型异常重新抛出。</p>
<p>数据类同数据库的表存在对应关系，使用Hibernate操作数据类时，Hibernate会将之转换为对数据库中对应表的操作。</p>
<p>org.hibernate.Criteria接口表示特定持久类的一个查询。Session是 Criteria实例的工厂。currentSession()</p>
<p>.createCriteria(Spittle.class)表示Spittle类的一个查询。参见：<a href="http://www.baike.com/wiki/criteria&prd=jinshan" target="_blank" rel="noopener">http://www.baike.com/wiki/criteria</a></p>
<p>session.save()方法返回一个生成的id，该id为Serializable类型。</p>
<p>下面是测试的一部分</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> spittr.db.hibernate4;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.junit.Assert.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.BeforeClass;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.ContextConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringJUnit4ClassRunner;</span><br><span class="line"><span class="keyword">import</span> org.springframework.transaction.annotation.Transactional;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> spittr.db.SpitterRepository;</span><br><span class="line"><span class="keyword">import</span> spittr.domain.Spitter;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith</span>(SpringJUnit4ClassRunner<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">ContextConfiguration</span>(<span class="title">classes</span> </span>= RepositoryTestConfig<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">SpitterRepositoryTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  SpitterRepository spitterRepository;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="meta">@Transactional</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">count</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    assertEquals(<span class="number">4</span>, spitterRepository.count());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="meta">@Transactional</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;Spitter&gt; spitters = spitterRepository.findAll();</span><br><span class="line">    assertEquals(<span class="number">4</span>, spitters.size());</span><br><span class="line">    assertSpitter(<span class="number">0</span>, spitters.get(<span class="number">0</span>));</span><br><span class="line">    assertSpitter(<span class="number">1</span>, spitters.get(<span class="number">1</span>));</span><br><span class="line">    assertSpitter(<span class="number">2</span>, spitters.get(<span class="number">2</span>));</span><br><span class="line">    assertSpitter(<span class="number">3</span>, spitters.get(<span class="number">3</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>二、JPA-Hibernate</strong></p>
<p>我们尝试开发基于JPA的Repository。Java持久化API（Java Persistence API，JPA）诞生在EJB2实体Bean的废墟之上，并成为下一代Java持久化标准。JPA是基于POJO的持久化机制。</p>
<p>以Spittr应用为例，我们首先看看JpaConfig类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> spittr.db.jpa;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.inject.Inject;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.EntityManagerFactory;</span><br><span class="line"><span class="keyword">import</span> javax.sql.DataSource;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.datasource.embedded.EmbeddedDatabase;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.datasource.embedded.EmbeddedDatabaseBuilder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.datasource.embedded.EmbeddedDatabaseType;</span><br><span class="line"><span class="keyword">import</span> org.springframework.orm.jpa.JpaTransactionManager;</span><br><span class="line"><span class="keyword">import</span> org.springframework.orm.jpa.JpaVendorAdapter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.orm.jpa.vendor.Database;</span><br><span class="line"><span class="keyword">import</span> org.springframework.orm.jpa.vendor.HibernateJpaVendorAdapter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.transaction.PlatformTransactionManager;</span><br><span class="line"><span class="keyword">import</span> org.springframework.transaction.annotation.EnableTransactionManagement;</span><br><span class="line"><span class="keyword">import</span> org.springframework.transaction.annotation.TransactionManagementConfigurer;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JpaConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    EmbeddedDatabaseBuilder edb = <span class="keyword">new</span> EmbeddedDatabaseBuilder();</span><br><span class="line">    edb.setType(EmbeddedDatabaseType.H2);</span><br><span class="line">    edb.addScript(<span class="string">"spittr/db/jpa/schema.sql"</span>);</span><br><span class="line">    edb.addScript(<span class="string">"spittr/db/jpa/test-data.sql"</span>);</span><br><span class="line">    EmbeddedDatabase embeddedDatabase = edb.build();</span><br><span class="line">    <span class="keyword">return</span> embeddedDatabase;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> LocalContainerEntityManagerFactoryBean <span class="title">emf</span><span class="params">(DataSource dataSource, JpaVendorAdapter jpaVendorAdapter)</span> </span>&#123;</span><br><span class="line">    LocalContainerEntityManagerFactoryBean emf = <span class="keyword">new</span> LocalContainerEntityManagerFactoryBean();</span><br><span class="line">    emf.setDataSource(dataSource);</span><br><span class="line">    emf.setPersistenceUnitName(<span class="string">"spittr"</span>);</span><br><span class="line">    emf.setJpaVendorAdapter(jpaVendorAdapter);</span><br><span class="line">    emf.setPackagesToScan(<span class="string">"spittr.domain"</span>);</span><br><span class="line">    <span class="keyword">return</span> emf;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> JpaVendorAdapter <span class="title">jpaVendorAdapter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    HibernateJpaVendorAdapter adapter = <span class="keyword">new</span> HibernateJpaVendorAdapter();</span><br><span class="line">    adapter.setDatabase(Database.H2);</span><br><span class="line">    adapter.setShowSql(<span class="keyword">true</span>);</span><br><span class="line">    adapter.setGenerateDdl(<span class="keyword">false</span>);</span><br><span class="line">    adapter.setDatabasePlatform(<span class="string">"org.hibernate.dialect.H2Dialect"</span>);</span><br><span class="line">    <span class="keyword">return</span> adapter;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  <span class="meta">@Configuration</span></span><br><span class="line">  <span class="meta">@EnableTransactionManagement</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionConfig</span> <span class="keyword">implements</span> <span class="title">TransactionManagementConfigurer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    <span class="keyword">private</span> EntityManagerFactory emf;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PlatformTransactionManager <span class="title">annotationDrivenTransactionManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      JpaTransactionManager transactionManager = <span class="keyword">new</span> JpaTransactionManager();</span><br><span class="line">      transactionManager.setEntityManagerFactory(emf);</span><br><span class="line">      <span class="keyword">return</span> transactionManager;</span><br><span class="line">    &#125;    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>基于JPA的应用程序需要使用EntityManagerFactory的实现类来获得EntityManager实例。JPA定义了应用程序管理类型和容器管理类型的实体管理器，这两种实体管理器实现了同一个EntityManager接口。关键的区别不在于EntityManager本身，而是在于EntityManager的创建和管理方式。顾名思义，前者由应用程序创建和管理，后者由Java EE创建和管理。</p>
<p>JpaVendorAdapter 属性用于指明所使用的是哪一个厂商的JPA实现。</p>
<p>使用LocalContainerEntityManagerFactoryBean来配置容器管理类型的JPA。</p>
<p>接下来编写基于JPA的Repository：JpaSpitterRepository、JpaSpittleRepository</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> spittr.db.jpa;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.persistence.EntityManager;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.PersistenceContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Repository;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> spittr.db.SpitterRepository;</span><br><span class="line"><span class="keyword">import</span> spittr.domain.Spitter;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JpaSpitterRepository</span> <span class="keyword">implements</span> <span class="title">SpitterRepository</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@PersistenceContext</span></span><br><span class="line">   <span class="keyword">private</span> EntityManager entityManager;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">count</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> findAll().size();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Spitter <span class="title">save</span><span class="params">(Spitter spitter)</span> </span>&#123;</span><br><span class="line">      entityManager.persist(spitter);</span><br><span class="line">      <span class="keyword">return</span> spitter;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Spitter <span class="title">findOne</span><span class="params">(<span class="keyword">long</span> id)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> entityManager.find(Spitter<span class="class">.<span class="keyword">class</span>, <span class="title">id</span>)</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Spitter <span class="title">findByUsername</span><span class="params">(String username)</span> </span>&#123;      </span><br><span class="line">      <span class="keyword">return</span> (Spitter) entityManager.createQuery(<span class="string">"select s from Spitter s where s.username=?"</span>).setParameter(<span class="number">1</span>, username).getSingleResult();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> List&lt;Spitter&gt; <span class="title">findAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> (List&lt;Spitter&gt;) entityManager.createQuery(<span class="string">"select s from Spitter s"</span>).getResultList();</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> spittr.db.jpa;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.persistence.EntityManager;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.PersistenceContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Repository;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> spittr.db.SpittleRepository;</span><br><span class="line"><span class="keyword">import</span> spittr.domain.Spittle;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JpaSpittleRepository</span> <span class="keyword">implements</span> <span class="title">SpittleRepository</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@PersistenceContext</span></span><br><span class="line">  <span class="keyword">private</span> EntityManager entityManager;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">count</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> findAll().size();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> List&lt;Spittle&gt; <span class="title">findRecent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> findRecent(<span class="number">10</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> List&lt;Spittle&gt; <span class="title">findRecent</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (List&lt;Spittle&gt;) entityManager.createQuery(<span class="string">"select s from Spittle s order by s.postedTime desc"</span>)</span><br><span class="line">        .setMaxResults(count)</span><br><span class="line">        .getResultList();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Spittle <span class="title">findOne</span><span class="params">(<span class="keyword">long</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> entityManager.find(Spittle<span class="class">.<span class="keyword">class</span>, <span class="title">id</span>)</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Spittle <span class="title">save</span><span class="params">(Spittle spittle)</span> </span>&#123;</span><br><span class="line">    entityManager.persist(spittle);</span><br><span class="line">    <span class="keyword">return</span> spittle;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> List&lt;Spittle&gt; <span class="title">findBySpitterId</span><span class="params">(<span class="keyword">long</span> spitterId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (List&lt;Spittle&gt;) entityManager.createQuery(<span class="string">"select s from Spittle s, Spitter sp where s.spitter = sp and sp.id=? order by s.postedTime desc"</span>)</span><br><span class="line">        .setParameter(<span class="number">1</span>, spitterId)</span><br><span class="line">        .getResultList();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(<span class="keyword">long</span> id)</span> </span>&#123;</span><br><span class="line">    entityManager.remove(findOne(id));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> List&lt;Spittle&gt; <span class="title">findAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (List&lt;Spittle&gt;) entityManager.createQuery(<span class="string">"select s from Spittle s"</span>).getResultList();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于EntityManager并不是线程安全的，一般并不适合注入到Repository这样共享的单例Bean中，我们使用@PersistanceContext注解解决这个问题。@PersistanceContext并没有注入一个真正的EntityManager，而是给了它一个EntityManager的代理。真正的EntityManager是与当前事务相关联的那一个，如果不存在，就会创建一个新的。@Transactional表明这个Repository中的持久化方法是在事务上下文中执行的。</p>
<p>以下是测试类部分代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> spittr.db.jpa;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.junit.Assert.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.BeforeClass;</span><br><span class="line"><span class="keyword">import</span> org.junit.Ignore;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.ContextConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringJUnit4ClassRunner;</span><br><span class="line"><span class="keyword">import</span> org.springframework.transaction.annotation.Transactional;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> spittr.db.SpitterRepository;</span><br><span class="line"><span class="keyword">import</span> spittr.domain.Spitter;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith</span>(SpringJUnit4ClassRunner<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">ContextConfiguration</span>(<span class="title">classes</span></span>=JpaConfig<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">SpitterRepositoryTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Autowired</span></span><br><span class="line">   SpitterRepository spitterRepository;</span><br><span class="line">   </span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="meta">@Transactional</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">count</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      assertEquals(<span class="number">4</span>, spitterRepository.count());</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="meta">@Transactional</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      List&lt;Spitter&gt; spitters = spitterRepository.findAll();</span><br><span class="line">      assertEquals(<span class="number">4</span>, spitters.size());</span><br><span class="line">      assertSpitter(<span class="number">0</span>, spitters.get(<span class="number">0</span>));</span><br><span class="line">      assertSpitter(<span class="number">1</span>, spitters.get(<span class="number">1</span>));</span><br><span class="line">      assertSpitter(<span class="number">2</span>, spitters.get(<span class="number">2</span>));</span><br><span class="line">      assertSpitter(<span class="number">3</span>, spitters.get(<span class="number">3</span>));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>三、借助Spring Data实现自动化的JPA Repository</strong></p>
<p>尽管JPA-Hibernate代码已经很简单，但依然会有直接与EntityManager交互来查询数据库。我们借助Spring Data，以接口定义的方式创建Repository。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> spittr.db;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.jpa.repository.JpaRepository;</span><br><span class="line"><span class="keyword">import</span> spittr.domain.Spitter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SpitterRepository</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">Spitter</span>, <span class="title">Long</span>&gt;, <span class="title">SpitterSweeper</span> </span>&#123;</span><br><span class="line">   <span class="function">Spitter <span class="title">findByUsername</span><span class="params">(String username)</span></span>;</span><br><span class="line">   <span class="function">List&lt;Spitter&gt; <span class="title">findByUsernameOrFullNameLike</span><span class="params">(String username, String fullName)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> spittr.db;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.jpa.repository.JpaRepository;</span><br><span class="line"><span class="keyword">import</span> spittr.domain.Spittle;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SpittleRepository</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">Spittle</span>, <span class="title">Long</span>&gt;, <span class="title">SpittleRepositoryCustom</span> </span>&#123;</span><br><span class="line">  <span class="function">List&lt;Spittle&gt; <span class="title">findBySpitterId</span><span class="params">(<span class="keyword">long</span> spitterId)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这里我们并不需要实现findBySpittleId方法，findByUsername方法，findByUsernameOrFullNameLike方法，方法签名已经告诉Spring Data JPA足够的信息来创建这个方法的实现了。</p>
<p>编写Spring Data JPA Repository 的关键在于要从一组接口中选一个进行扩展，这里SpittleRepository扩展了Spring Data JPA 的JpaRepository。通过这种方式，JpaRepository进行了参数化，所以它就能知道这是一个用来持久化Spitter对象的Repository，并且Spitter对象的ID类型为Long。</p>
<p>接下来我们看看自定义查询方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> spittr.db;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SpitterSweeper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">int</span> <span class="title">eliteSweep</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> spittr.db;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.persistence.EntityManager;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.PersistenceContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpitterRepositoryImpl</span> <span class="keyword">implements</span> <span class="title">SpitterSweeper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@PersistenceContext</span></span><br><span class="line">   <span class="keyword">private</span> EntityManager em;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">eliteSweep</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     String update = </span><br><span class="line">         <span class="string">"UPDATE Spitter spitter "</span> +</span><br><span class="line">             <span class="string">"SET spitter.status = 'Elite' "</span> +</span><br><span class="line">             <span class="string">"WHERE spitter.status = 'Newbie' "</span> +</span><br><span class="line">             <span class="string">"AND spitter.id IN ("</span> +</span><br><span class="line">             <span class="string">"SELECT s FROM Spitter s WHERE ("</span> +</span><br><span class="line">             <span class="string">"  SELECT COUNT(spittles) FROM s.spittles spittles) &gt; 10000"</span> +</span><br><span class="line">             <span class="string">")"</span>;</span><br><span class="line">      <span class="keyword">return</span> em.createQuery(update).executeUpdate();</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>复杂查询可以自己编写。</p>
<p>配置Spring Data JPA</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> spittr.db;</span><br><span class="line"><span class="keyword">import</span> javax.sql.DataSource;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.jpa.repository.config.EnableJpaRepositories;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.datasource.embedded.EmbeddedDatabaseBuilder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.orm.jpa.JpaTransactionManager;</span><br><span class="line"><span class="keyword">import</span> org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.orm.jpa.vendor.Database;</span><br><span class="line"><span class="keyword">import</span> org.springframework.orm.jpa.vendor.HibernateJpaVendorAdapter;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableJpaRepositories</span>(<span class="string">"spitter.db"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringDataJpaConfig</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> EmbeddedDatabaseBuilder()</span><br><span class="line">        .addScript(<span class="string">"classpath:/com/habuma/spitter/db/jpa/schema.sql"</span>)</span><br><span class="line">        .addScript(<span class="string">"classpath:/com/habuma/spitter/db/jpa/test-data.sql"</span>)</span><br><span class="line">        .build();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> JpaTransactionManager <span class="title">transactionManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> JpaTransactionManager(); <span class="comment">// does this need an emf???</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> HibernateJpaVendorAdapter <span class="title">jpaVendorAdapter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    HibernateJpaVendorAdapter adapter = <span class="keyword">new</span> HibernateJpaVendorAdapter();</span><br><span class="line">    adapter.setDatabase(Database.H2);</span><br><span class="line">    adapter.setShowSql(<span class="keyword">false</span>);</span><br><span class="line">    adapter.setGenerateDdl(<span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">return</span> adapter;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">emf</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LocalContainerEntityManagerFactoryBean emf = <span class="keyword">new</span> LocalContainerEntityManagerFactoryBean();</span><br><span class="line">    emf.setDataSource(dataSource());</span><br><span class="line">    emf.setPersistenceUnitName(<span class="string">"spitter"</span>);</span><br><span class="line">    emf.setJpaVendorAdapter(jpaVendorAdapter());</span><br><span class="line">    <span class="keyword">return</span> emf;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>@EnableJpaRepositories(“spitter.db”)会扫描spittr.db包查找扩展自Spring Data JPA Repository接口的所有接口，如果发现了扩展自Repository的接口，他会自动（在应用启动的时候）生成这个接口的实现。</p>
<h1 id="使用NoSQL数据库"><a href="#使用NoSQL数据库" class="headerlink" title="使用NoSQL数据库"></a>使用NoSQL数据库</h1><p><strong>一、使用MongoDB持久化文档数据</strong>  </p>
<p>  有一些数据的最佳表现形式是文档，也就是说，不要把这些数据分散到多个表、节点或实体中，将这些信息收集到一个非规范化（也就是文档）的结构中更有意义。如果数据之间有明显的关联关系，文档数据库就不太适合了。</p>
<p>我们在一个购物订单系统中学习MongoDB。接下来我们要配置Spring Data MongoDB</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> orders.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.mongodb.Mongo;</span><br><span class="line"><span class="keyword">import</span> com.mongodb.MongoClient;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.mongodb.config.AbstractMongoConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.mongodb.repository.config.EnableMongoRepositories;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableMongoRepositories</span>(basePackages = <span class="string">"orders.db"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MongoConfig</span> <span class="keyword">extends</span> <span class="title">AbstractMongoConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Mongo <span class="title">mongo</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MongoClient();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">getDatabaseName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"OrdersDB"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>通过@EnableMongoRepository注解启用Spring Data 的自动化MongoDB repository生成功能，我们让配置类扩展AbstractMongoConfiguration并重载mongo()方法，getDatabaseName()方法，mongo()方法会直接返回一个MongoClient实例而不是声明MongoFactory bean 和MongoTemplate bean。使用MongoClient更加简单。这里需要一个运行在本地的MongoDB 服务器，MongoClient监听的默认的端口27017，如果需要更改端口在MongoClient构造方法中指定端口即可。</p>
<p>下面是Order类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> orders;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.data.annotation.Id;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.mongodb.core.mapping.Document;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.mongodb.core.mapping.Field;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedHashSet;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Document</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Order</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Field</span>(<span class="string">"customer"</span>)</span><br><span class="line">    <span class="keyword">private</span> String customer;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String type;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Collection&lt;Item&gt; items = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getCustomer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> customer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCustomer</span><span class="params">(String customer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.customer = customer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setType</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.type = type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Collection&lt;Item&gt; <span class="title">getItems</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> items;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setItems</span><span class="params">(Collection&lt;Item&gt; items)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.items = items;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>我们可以看到Order类使用了@Document注解，这样它就能借助MongoTemplate或自动生成的Repository进行持久化，其id属性上使用了@Id注解用来指定它作为文档的ID，除此之外，customer属性上使用了@Field注解，这样在文档持久化的时候customer属性会映射为customer的域。同时items属性它指的是订单中具体条目的集合，在传统的关系型数据库中，这些条目会在另一个数据表中，通过外键进行引用，items域上可能还会有使用JPA的@OneToMany注解。</p>
<p>下面是Item类，Item类本身没有任何注解。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> orders;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Item</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Order order;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String product;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> price;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> quantity;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Order <span class="title">getOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> order;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getProduct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> product;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getPrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getQuantity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> quantity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setProduct</span><span class="params">(String product)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.product = product;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPrice</span><span class="params">(<span class="keyword">double</span> price)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setQuantity</span><span class="params">(<span class="keyword">int</span> quantity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.quantity = quantity;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们定义OrderRepository扩展MongoRepository,它和Spring Data JPA一样，扩展了Repository的接口将会在运行时自动生成实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> orders.db;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> orders.Order;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.mongodb.repository.MongoRepository;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.mongodb.repository.Query;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OrderRepository</span> <span class="keyword">extends</span> <span class="title">MongoRepository</span>&lt;<span class="title">Order</span>,<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">List&lt;Order&gt; <span class="title">findByCustomer</span><span class="params">(String customer)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">List&lt;Order&gt; <span class="title">findByCustomerLike</span><span class="params">(String customer)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">List&lt;Order&gt; <span class="title">findByCustomerAndType</span><span class="params">(String customer,String type)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">List&lt;Order&gt; <span class="title">getByType</span><span class="params">(String type)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Query</span>(<span class="string">"&#123;customer:'Chuck Wagon'&#125;"</span>)</span><br><span class="line">    <span class="function">List&lt;Order&gt; <span class="title">findChucksOrders</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line">下面是测试类</span><br><span class="line"><span class="keyword">package</span> orders;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.junit.Assert.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> orders.config.MongoConfig;</span><br><span class="line"><span class="keyword">import</span> orders.db.OrderRepository;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Before;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.mongodb.core.MongoOperations;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.ContextConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringJUnit4ClassRunner;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ContextConfiguration</span>(classes=MongoConfig<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">RunWith</span>(<span class="title">SpringJUnit4ClassRunner</span>.<span class="title">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">MongoDbTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Autowired</span></span><br><span class="line">   <span class="keyword">private</span> OrderRepository orderRepository;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Autowired</span> MongoOperations mongoOps;</span><br><span class="line">   </span><br><span class="line">   <span class="meta">@Before</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cleanup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// Deleting all orders (just in case something is left over from a previous failed run)</span></span><br><span class="line">      orderRepository.deleteAll();</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMongoRepository</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      assertEquals(<span class="number">0</span>, orderRepository.count());</span><br><span class="line">      Order order = createAnOrder();</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// Saving an order</span></span><br><span class="line">      Order savedOrder = orderRepository.save(order);       </span><br><span class="line">      assertEquals(<span class="number">1</span>, orderRepository.count());</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// Finding an order by ID</span></span><br><span class="line">      Order foundOrder = orderRepository.findOne(savedOrder.getId());</span><br><span class="line">      assertEquals(<span class="string">"Chuck Wagon"</span>, foundOrder.getCustomer());</span><br><span class="line">      assertEquals(<span class="number">2</span>, foundOrder.getItems().size());</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Finding an order by a single field value</span></span><br><span class="line">      List&lt;Order&gt; chucksOrders = orderRepository.findByCustomer(<span class="string">"Chuck Wagon"</span>);</span><br><span class="line">      assertEquals(<span class="number">1</span>, chucksOrders.size());</span><br><span class="line">      assertEquals(<span class="string">"Chuck Wagon"</span>, chucksOrders.get(<span class="number">0</span>).getCustomer());</span><br><span class="line">      assertEquals(<span class="number">2</span>, chucksOrders.get(<span class="number">0</span>).getItems().size());</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Finding an order by a single field value like</span></span><br><span class="line">      List&lt;Order&gt; chuckLikeOrders = orderRepository.findByCustomerLike(<span class="string">"Chuck"</span>);</span><br><span class="line">      assertEquals(<span class="number">1</span>, chuckLikeOrders.size());</span><br><span class="line">      assertEquals(<span class="string">"Chuck Wagon"</span>, chuckLikeOrders.get(<span class="number">0</span>).getCustomer());</span><br><span class="line">      assertEquals(<span class="number">2</span>, chuckLikeOrders.get(<span class="number">0</span>).getItems().size());</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Finding an order by multiple field values</span></span><br><span class="line">      List&lt;Order&gt; chucksWebOrders = orderRepository.findByCustomerAndType(<span class="string">"Chuck Wagon"</span>, <span class="string">"WEB"</span>);</span><br><span class="line">      assertEquals(<span class="number">1</span>, chucksWebOrders.size());</span><br><span class="line">      assertEquals(<span class="string">"Chuck Wagon"</span>, chucksWebOrders.get(<span class="number">0</span>).getCustomer());</span><br><span class="line">      assertEquals(<span class="number">2</span>, chucksWebOrders.get(<span class="number">0</span>).getItems().size());</span><br><span class="line"></span><br><span class="line">      List&lt;Order&gt; chucksPhoneOrders = orderRepository.findByCustomerAndType(<span class="string">"Chuck Wagon"</span>, <span class="string">"PHONE"</span>);</span><br><span class="line">      assertEquals(<span class="number">0</span>, chucksPhoneOrders.size());</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Finding an order by a custom query method</span></span><br><span class="line">      List&lt;Order&gt; chucksOrders2 = orderRepository.findChucksOrders();</span><br><span class="line">      assertEquals(<span class="number">1</span>, chucksOrders2.size());</span><br><span class="line">      assertEquals(<span class="string">"Chuck Wagon"</span>, chucksOrders2.get(<span class="number">0</span>).getCustomer());</span><br><span class="line">      assertEquals(<span class="number">2</span>, chucksOrders2.get(<span class="number">0</span>).getItems().size());</span><br><span class="line">      </span><br><span class="line">      </span><br><span class="line">      <span class="comment">// Deleting an order</span></span><br><span class="line">      orderRepository.delete(savedOrder.getId());</span><br><span class="line">      assertEquals(<span class="number">0</span>, orderRepository.count());     </span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> Order <span class="title">createAnOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      Order order = <span class="keyword">new</span> Order();</span><br><span class="line">      order.setCustomer(<span class="string">"Chuck Wagon"</span>);</span><br><span class="line">      order.setType(<span class="string">"WEB"</span>);</span><br><span class="line">      Item item1 = <span class="keyword">new</span> Item();</span><br><span class="line">      item1.setProduct(<span class="string">"Spring in Action"</span>);</span><br><span class="line">      item1.setQuantity(<span class="number">2</span>);</span><br><span class="line">      item1.setPrice(<span class="number">29.99</span>);</span><br><span class="line">      Item item2 = <span class="keyword">new</span> Item();</span><br><span class="line">      item2.setProduct(<span class="string">"Module Java"</span>);</span><br><span class="line">      item2.setQuantity(<span class="number">31</span>);</span><br><span class="line">      item2.setPrice(<span class="number">29.95</span>);</span><br><span class="line">      order.setItems(Arrays.asList(item1, item2));</span><br><span class="line">      <span class="keyword">return</span> order;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>二、使用Neo4j操作位图数据</strong></p>
<p>  文档型数据库会将数据存储到粗粒度的文档中，图数据库会将数据存储到多个细粒度的节点中，这些节点之间通过关系建立关联。Spring Data Neo4j提供了将Java对象映射到节点和关联关系的注解、面向模板的Neo4j访问方式以及Repository’实现的自动化生成功能。</p>
<p>配置Spring Data Neo4j的关键在于声明GraphDatabaseService bean 和启用Neo4j Repository自动生成功能。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> orders.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.neo4j.graphdb.GraphDatabaseService;</span><br><span class="line"><span class="keyword">import</span> org.neo4j.graphdb.factory.GraphDatabaseFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.neo4j.config.EnableNeo4jRepositories;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.neo4j.config.Neo4jConfiguration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableNeo</span>4jRepositories(basePackages = <span class="string">"orders.db"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Neo4jConfig</span> <span class="keyword">extends</span> <span class="title">Neo4jConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Neo4jConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      setBasePackage(<span class="string">"orders"</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Bean</span>(destroyMethod=<span class="string">"shutdown"</span>)</span><br><span class="line">   <span class="function"><span class="keyword">public</span> GraphDatabaseService <span class="title">graphDatabaseService</span><span class="params">()</span> </span>&#123;   </span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> GraphDatabaseFactory()</span><br><span class="line">            .newEmbeddedDatabase(<span class="string">"/tmp/graphdb"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>@EnableNeo4jRepositories注解能够让Spring Data Neo4j自动生成 Neo4j的Repository实现。定义GraphDatabaseService bean使用GraphDatabaseFactory 来创建嵌入式的Neo4j数据库。</p>
<p>Neo4j定义了两种类型的实体：节点和关联关系。节点反映了应用中的事物，而关联关系定义了这些事物是如何联系在一起的。</p>
<p>Order、Item是两个节点他们之间的关系是Order has items </p>
<p>下面我们为Order添加注解，使其成为图数据库中的一个节点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> orders;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedHashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.data.neo4j.annotation.GraphId;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.neo4j.annotation.NodeEntity;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.neo4j.annotation.RelatedTo;</span><br><span class="line"></span><br><span class="line"><span class="meta">@NodeEntity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Order</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">   <span class="meta">@GraphId</span></span><br><span class="line">   <span class="keyword">private</span> Long id;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">private</span> String customer;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">private</span> String type;</span><br><span class="line">   </span><br><span class="line">   <span class="meta">@RelatedTo</span>(type=<span class="string">"HAS_ITEMS"</span>)</span><br><span class="line">   <span class="keyword">private</span> Set&lt;Item&gt; items = <span class="keyword">new</span> LinkedHashSet&lt;Item&gt;();</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">getCustomer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> customer;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCustomer</span><span class="params">(String customer)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.customer = customer;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">getType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> type;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setType</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.type = type;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Collection&lt;Item&gt; <span class="title">getItems</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> items;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setItems</span><span class="params">(Set&lt;Item&gt; items)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.items = items;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Long <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> id;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> @NodeEntity注解代表这是一个节点，@GraphId注解代表这是一个图Id，@RelatedTo(type=”HAS_ITEMS”)注解代表Order与一个Item的Set存在关系。</p>
<p>Item也是图数据库中的节点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> orders;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.data.neo4j.annotation.GraphId;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.neo4j.annotation.NodeEntity;</span><br><span class="line"></span><br><span class="line"><span class="meta">@NodeEntity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Item</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">   <span class="meta">@GraphId</span></span><br><span class="line">   <span class="keyword">private</span> Long id;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">private</span> Order order;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> String product;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">double</span> price;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> quantity;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> Order <span class="title">getOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> order;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">getProduct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> product;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setProduct</span><span class="params">(String product)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.product = product;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getPrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> price;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPrice</span><span class="params">(<span class="keyword">double</span> price)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.price = price;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getQuantity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> quantity;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setQuantity</span><span class="params">(<span class="keyword">int</span> quantity)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.quantity = quantity;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Long <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> id;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 同样我们需要创建自动化的Neo4j Repository</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> orders.db;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> orders.Order;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.data.neo4j.repository.GraphRepository;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OrderRepository</span> <span class="keyword">extends</span> <span class="title">GraphRepository</span>&lt;<span class="title">Order</span>&gt; </span>&#123;</span><br><span class="line">   </span><br><span class="line">   <span class="function">List&lt;Order&gt; <span class="title">findByCustomer</span><span class="params">(String customer)</span></span>;</span><br><span class="line">   </span><br><span class="line">   <span class="function">List&lt;Order&gt; <span class="title">findByCustomerLike</span><span class="params">(String customer)</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="function">List&lt;Order&gt; <span class="title">findByCustomerAndType</span><span class="params">(String customer, String type)</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="function">List&lt;Order&gt; <span class="title">getByType</span><span class="params">(String type)</span></span>;</span><br><span class="line">      </span><br><span class="line"><span class="comment">// @Query("&#123;customer:'Chuck Wagon'&#125;")</span></span><br><span class="line"><span class="comment">// List&lt;Order&gt; findChucksOrders();</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">下面是测试类</span><br><span class="line"><span class="keyword">package</span> orders;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.junit.Assert.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> orders.config.Neo4jConfig;</span><br><span class="line"><span class="keyword">import</span> orders.db.OrderRepository;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Before;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.ContextConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringJUnit4ClassRunner;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ContextConfiguration</span>(classes=Neo4jConfig<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">RunWith</span>(<span class="title">SpringJUnit4ClassRunner</span>.<span class="title">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">Neo4jTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Autowired</span></span><br><span class="line">   <span class="keyword">private</span> OrderRepository orderRepository;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Before</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cleanup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// Deleting all orders (just in case something is left over from a previous failed run)</span></span><br><span class="line">      orderRepository.deleteAll();</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testNeo4jRepository</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      assertEquals(<span class="number">0</span>, orderRepository.count());</span><br><span class="line">      Order order = createAnOrder();</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// Saving an order</span></span><br><span class="line">      Order savedOrder = orderRepository.save(order);       </span><br><span class="line">      assertEquals(<span class="number">1</span>, orderRepository.count());</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// Finding an order by ID</span></span><br><span class="line">      Order foundOrder = orderRepository.findOne(savedOrder.getId());</span><br><span class="line">      assertEquals(<span class="string">"Chuck Wagon"</span>, foundOrder.getCustomer());</span><br><span class="line">      assertEquals(<span class="number">2</span>, foundOrder.getItems().size());</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Finding an order by a single field value</span></span><br><span class="line">      List&lt;Order&gt; chucksOrders = orderRepository.findByCustomer(<span class="string">"Chuck Wagon"</span>);</span><br><span class="line">      assertEquals(<span class="number">1</span>, chucksOrders.size());</span><br><span class="line">      assertEquals(<span class="string">"Chuck Wagon"</span>, chucksOrders.get(<span class="number">0</span>).getCustomer());</span><br><span class="line">      assertEquals(<span class="number">2</span>, chucksOrders.get(<span class="number">0</span>).getItems().size());</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Finding an order by a single field value like</span></span><br><span class="line">      List&lt;Order&gt; chuckLikeOrders = orderRepository.findByCustomerLike(<span class="string">"Chuck.*"</span>);</span><br><span class="line">      assertEquals(<span class="number">1</span>, chuckLikeOrders.size());</span><br><span class="line">      assertEquals(<span class="string">"Chuck Wagon"</span>, chuckLikeOrders.get(<span class="number">0</span>).getCustomer());</span><br><span class="line">      assertEquals(<span class="number">2</span>, chuckLikeOrders.get(<span class="number">0</span>).getItems().size());</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Finding an order by multiple field values</span></span><br><span class="line">      List&lt;Order&gt; chucksWebOrders = orderRepository.findByCustomerAndType(<span class="string">"Chuck Wagon"</span>, <span class="string">"WEB"</span>);</span><br><span class="line">      assertEquals(<span class="number">1</span>, chucksWebOrders.size());</span><br><span class="line">      assertEquals(<span class="string">"Chuck Wagon"</span>, chucksWebOrders.get(<span class="number">0</span>).getCustomer());</span><br><span class="line">      assertEquals(<span class="number">2</span>, chucksWebOrders.get(<span class="number">0</span>).getItems().size());</span><br><span class="line"></span><br><span class="line">      List&lt;Order&gt; chucksPhoneOrders = orderRepository.findByCustomerAndType(<span class="string">"Chuck Wagon"</span>, <span class="string">"PHONE"</span>);</span><br><span class="line">      assertEquals(<span class="number">0</span>, chucksPhoneOrders.size());</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Finding an order by a custom query method</span></span><br><span class="line"><span class="comment">//    List&lt;Order&gt; chucksOrders2 = orderRepository.findChucksOrders();</span></span><br><span class="line"><span class="comment">//    assertEquals(1, chucksOrders2.size());</span></span><br><span class="line"><span class="comment">//    assertEquals("Chuck Wagon", chucksOrders2.get(0).getCustomer());</span></span><br><span class="line"><span class="comment">//    assertEquals(2, chucksOrders2.get(0).getItems().size());</span></span><br><span class="line">      </span><br><span class="line">      </span><br><span class="line">      <span class="comment">// Deleting an order</span></span><br><span class="line">      orderRepository.delete(savedOrder.getId());</span><br><span class="line">      assertEquals(<span class="number">0</span>, orderRepository.count());     </span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> Order <span class="title">createAnOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      Order order = <span class="keyword">new</span> Order();</span><br><span class="line">      order.setCustomer(<span class="string">"Chuck Wagon"</span>);</span><br><span class="line">      order.setType(<span class="string">"WEB"</span>);</span><br><span class="line">      Item item1 = <span class="keyword">new</span> Item();</span><br><span class="line">      item1.setProduct(<span class="string">"Spring in Action"</span>);</span><br><span class="line">      item1.setQuantity(<span class="number">2</span>);</span><br><span class="line">      item1.setPrice(<span class="number">29.99</span>);</span><br><span class="line">      Item item2 = <span class="keyword">new</span> Item();</span><br><span class="line">      item2.setProduct(<span class="string">"Module Java"</span>);</span><br><span class="line">      item2.setQuantity(<span class="number">31</span>);</span><br><span class="line">      item2.setPrice(<span class="number">29.95</span>);</span><br><span class="line">      order.setItems(<span class="keyword">new</span> HashSet&lt;Item&gt;(Arrays.asList(item1, item2)));</span><br><span class="line">      <span class="keyword">return</span> order;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 三、使用Redis操作键值对数据</p>
<p>Redis是一种特殊类型的数据库，它被称之为key-value存储，key-value存储与哈希Map有很大的相似性，可以把它理解为持久化的哈希Map。<br>连接Redis</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cart;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.connection.RedisConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.connection.jedis.JedisConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> RedisConnectionFactory <span class="title">redisCF</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> JedisConnectionFactory();</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> RedisTemplate&lt;String, Product&gt; <span class="title">redisTemplate</span><span class="params">(RedisConnectionFactory cf)</span> </span>&#123;</span><br><span class="line">      RedisTemplate&lt;String, Product&gt; redis = <span class="keyword">new</span> RedisTemplate&lt;String, Product&gt;();</span><br><span class="line">      redis.setConnectionFactory(cf);</span><br><span class="line">      <span class="keyword">return</span> redis;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们配置RedisConnectionFactory bean 通过默认构造器创建的连接工厂会向localhost上的6379端口创建连接。顾名思义，Redis连接工厂会生成到Redis key-value存储的连接，我们使用RedisTemplate简化数据访问，能够让我们持久化各种类型的key和value。<br>将RedisConnectionFactory bean 注入到 RedisTemlate中，RedisTemplate使用两个类型进行参数化，第一个是key的类型，第二个是value的类型。</p>
<p>下面是Product类，实现了Serializable接口，因为Redis存储对象时需要将其序列化，取出时需要反序列化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cart;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Product</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">private</span> String sku;</span><br><span class="line">   <span class="keyword">private</span> String name;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">float</span> price;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">getSku</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> sku;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSku</span><span class="params">(String sku)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.sku = sku;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> name;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.name = name;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">getPrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> price;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPrice</span><span class="params">(<span class="keyword">float</span> price)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.price = price;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是测试类的一部分</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cart;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.junit.Assert.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.After;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.connection.RedisConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.BoundListOperations;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.StringRedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.StringRedisSerializer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.ContextConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringJUnit4ClassRunner;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith</span>(SpringJUnit4ClassRunner<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">ContextConfiguration</span>(<span class="title">classes</span></span>=RedisConfig<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">CartTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * IMPORTANT: This test class requires that a Redis server be running on </span></span><br><span class="line"><span class="comment">    *            localhost and listening on port 6379 (the default port).</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   </span><br><span class="line">   <span class="meta">@Autowired</span></span><br><span class="line">   <span class="keyword">private</span> RedisConnectionFactory cf;</span><br><span class="line">   </span><br><span class="line">   <span class="meta">@Autowired</span></span><br><span class="line">   <span class="keyword">private</span> RedisTemplate&lt;String, Product&gt; redis;</span><br><span class="line">   </span><br><span class="line">   <span class="meta">@After</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cleanUp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      redis.delete(<span class="string">"9781617291203"</span>);</span><br><span class="line">      redis.delete(<span class="string">"cart"</span>);</span><br><span class="line">      redis.delete(<span class="string">"cart1"</span>);</span><br><span class="line">      redis.delete(<span class="string">"cart2"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">workingWithSimpleValues</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      Product product = <span class="keyword">new</span> Product();</span><br><span class="line">      product.setSku(<span class="string">"9781617291203"</span>);</span><br><span class="line">      product.setName(<span class="string">"Spring in Action"</span>);</span><br><span class="line">      product.setPrice(<span class="number">39.99f</span>);</span><br><span class="line">      </span><br><span class="line">      redis.opsForValue().set(product.getSku(), product);</span><br><span class="line">      </span><br><span class="line">      Product found = redis.opsForValue().get(product.getSku());</span><br><span class="line">      assertEquals(product.getSku(), found.getSku());</span><br><span class="line">      assertEquals(product.getName(), found.getName());</span><br><span class="line">      assertEquals(product.getPrice(), found.getPrice(), <span class="number">0.005</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="缓存数据"><a href="#缓存数据" class="headerlink" title="缓存数据"></a>缓存数据</h1><p>​    缓存（Caching）可以存储经常会用到的信息，这样每次需要的时候，这些信息是立即可用的。尽管Spring本身没有实现缓存解决方案，但它对缓存功能提供了声明式的支持，能够与多种流行的缓存实现进行集成。</p>
<p>在往bean上添加缓存注解之前，必须要启用Spring对注解驱动缓存的支持。如果我们使用Java配置的话，可以在其中的一个配置类上加上@EnableCaching，这样的话就能启用注解驱动的缓存。</p>
<p>我们以Spittr 应用的Repository JDBC实现来演示缓存的使用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> spittr.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> net.sf.ehcache.CacheManager;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.cache.annotation.EnableCaching;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cache.ehcache.EhCacheCacheManager;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cache.ehcache.EhCacheManagerFactoryBean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.io.ClassPathResource;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableCaching</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CachingConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> EhCacheCacheManager <span class="title">cacheManager</span><span class="params">(CacheManager cm)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> EhCacheCacheManager(cm);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> EhCacheManagerFactoryBean <span class="title">ehcache</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    EhCacheManagerFactoryBean ehCacheFactoryBean = <span class="keyword">new</span> EhCacheManagerFactoryBean();</span><br><span class="line">    ehCacheFactoryBean.setConfigLocation(<span class="keyword">new</span> ClassPathResource(<span class="string">"spittr/cache/ehcache.xml"</span>));</span><br><span class="line">    <span class="keyword">return</span> ehCacheFactoryBean;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>cacheManager()方法创建了一个EhCacheManager的实例，这是通过传入EhCache CacheManager实例实现的。稍微有些诡异的注入会让人感到迷惑，这是因为Spring和EhCache都定义了CacheManager类型。需要明确的是，EhCache的CacheManager要被注入到Spring的EhCacheManager之中。</p>
<p>我们使用EhCache的CacheManager来进行注入，所以也必须声明一个CacheManager bean。为了对其进行简化，Spring提供了EhCacheManagerFactoryBean 来生成EnCache 的CacheManager。方法ehcache()会创建并返回一个EhCacheManagerFactoryBean实例。因为它是一个工厂bean，所以注册在Spring应用上下文的并不是EhCacheManagerFactoryBean，而是CacheManager的一个实例。</p>
<p>下面是 ehcache.xml。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ehcache</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">cache</span> <span class="attr">name</span>=<span class="string">"spittleCache"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">maxBytesLocalHeap</span>=<span class="string">"50m"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">timeToLiveSeconds</span>=<span class="string">"100"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">cache</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ehcache</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>我们使用注解为SpittleRepository声明缓存规则</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> spittr.db;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.cache.annotation.CacheEvict;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cache.annotation.CachePut;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cache.annotation.Cacheable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> spittr.domain.Spittle;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SpittleRepository</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">long</span> <span class="title">count</span><span class="params">()</span></span>;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Cacheable</span>(<span class="string">"spittleCache"</span>)</span><br><span class="line">  <span class="function">List&lt;Spittle&gt; <span class="title">findRecent</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">List&lt;Spittle&gt; <span class="title">findRecent</span><span class="params">(<span class="keyword">int</span> count)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Cacheable</span>(<span class="string">"spittleCache"</span>)</span><br><span class="line">  <span class="function">Spittle <span class="title">findOne</span><span class="params">(<span class="keyword">long</span> id)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@CachePut</span>(value=<span class="string">"spittleCache"</span>, key=<span class="string">"#result.id"</span>)</span><br><span class="line">  <span class="function">Spittle <span class="title">save</span><span class="params">(Spittle spittle)</span></span>;</span><br><span class="line">    </span><br><span class="line">  <span class="meta">@Cacheable</span>(<span class="string">"spittleCache"</span>)</span><br><span class="line">  <span class="function">List&lt;Spittle&gt; <span class="title">findBySpitterId</span><span class="params">(<span class="keyword">long</span> spitterId)</span></span>;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@CacheEvict</span>(value=<span class="string">"spittleCache"</span>,condition=<span class="string">""</span>)</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">delete</span><span class="params">(<span class="keyword">long</span> id)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>Spring提供了四个注解来声明缓存规则<br>@Cacheable 表明Spring在调用方法之前，首先应该在缓存中查找方法的返回值，如果这个值找到，就会返回缓存的值，否则的话，这个方法就会被调用，返回值会房贷缓存之中。<br>@CachePut 表明Spring应该将方法的返回值放入缓存之中，在方法的调用前并不会检查缓存，方法始终都会被调用。<br>@CacheEvict 表明Spring应该在缓存中清除一个或多个条目。<br>@Caching 这是一个分组的注解，能够同时应用多个其他的缓存注解。<br>将注解放在方法前即可启用缓存。</p>
<h1 id="借助Spring-Boot-简化-Spring-开发"><a href="#借助Spring-Boot-简化-Spring-开发" class="headerlink" title="借助Spring Boot 简化 Spring 开发"></a>借助Spring Boot 简化 Spring 开发</h1><p>Spring Boot 是令人兴奋的新项目，它提供了四个主要的特性，能够改变开发Spring应用程序的方式。</p>
<p>1、Spring Boot Starter： 他将常用的依赖分组进行了整合，将其合并到一个依赖中，这样就可以一次性添加到项目的Maven或Gradle构建中。</p>
<p>2、自动配置： Spring Boot 的自动配置特性利用了Spring 4对条件化配置的支持，合理地推测应用所需的bean 并自动化配置它们。</p>
<p>3、命令行接口： Spring 的 CLI 发挥了Groovy 编程语言的优势，并结合自动配置进一步简化 Spring 应用的开发。</p>
<p>4、Actuator： 它为Spring Boot 应用添加了一定的管理特性。</p>
<p>我们要从头开始编写一个新的 Spring 应用。这是一个 Web 项目，所以需要 Spring MVC 。同时还要有 REST API 将资源暴露为 JSON ，所以在构建中需要包含Jackson JSON 库</p>
<p>首先让我们从添加依赖开始，新建一个 Gradle 项目，在 build.gradle dependency 添加以下内容：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">compile(<span class="string">"org.springframework.boot:spring-boot-starter-web:1.1.4.RELEASE"</span>)</span><br><span class="line">compile(<span class="string">"org.springframework.boot:spring-boot-starter-jdbc:1.1.4.RELEASE"</span>)</span><br><span class="line">compile(<span class="string">"org.thymeleaf:thymeleaf-spring4:2.1.2.RELEASE"</span>)</span><br><span class="line">compile(<span class="string">"com.h2database:h2:1.3.174"</span>)</span><br></pre></td></tr></table></figure>

<p>Spring Boot 的 Starter 减少了构建中的依赖列表的长度，而 Spring Boot 的自动配置功能则缩减了 Spring 配置的数量。它在实现时，会考虑应用中的其他因素并推断你所需要的 Spring 配置。</p>
<p>Spring Boot Starter 也会触发自动配置。例如在 Spring Boot 应用中，如果我们想使用 Spring MVC 的话，所需要做的仅仅是将 Web Starter 作为依赖放入到构建中。将 Web Starter 放入到构建中以后，它会自动添加 Spring MVC 依赖。如果 Spring Boot 的 Web 自动配置探测到 Spring MVC 位于类路径下，它将会自动配置支持 Spring MVC 的多个 bean，包括视图解析器、资源处理器、以及消息转换器等等。</p>
<p>Spring Boot CLI 充分利用了Spring Boot Starter 和自动配置的魔力，并添加了一些 Groovy 的功能，它简化了 Spring 的开发流程，通过 CLI ，我们能够运行一个或多个 Groovy 脚本，并查看它是如何运行的。在应用的运行过程中，CLI 能够自动导入 Spring 类型并解析依赖。</p>
<p>Spring Boot Actuator 为 Spring Boot 项目带来了很多有用的特性，包括：</p>
<p>1、管理端点；</p>
<p>2、合理的异常处理以及默认的“/error”映射端点；</p>
<p>3、获取应用信息的“Info”端点；</p>
<p>4、当启用Spring Security 时，会有一个审计事件框架。</p>
<p>这里我们开发一个 Contacts 应用。</p>
<p>ContactController 为 Contacts 应用处理基本的 Web 请求。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> contacts;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMethod;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContactController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ContactRepository contactRepo;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ContactController</span><span class="params">(ContactRepository contactRepo)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.contactRepo = contactRepo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(method = RequestMethod.GET)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">home</span><span class="params">(Map&lt;String,Object&gt; model)</span></span>&#123;</span><br><span class="line">        List&lt;Contact&gt; contacts = contactRepo.findAll();</span><br><span class="line">        model.put(<span class="string">"contacts"</span>,contacts);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"home"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(method = RequestMethod.POST)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">submit</span><span class="params">(Contact contact)</span></span>&#123;</span><br><span class="line">        contactRepo.save(contact);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"redirect:/"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>home()方法使用注入的 ContactRepository 来获取所有 Contact 对象的列表，并将它们放到模型当中，然后把请求转交给home视图。这个视图将会展现联系人的列表以及添加新的Contact 表单。submit()方法将会处理表单提交的POST请求，保存Contact，并重定向到首页。</p>
<p>Contact 是一个简单的POJO</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> contacts;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Contact</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String firstName;</span><br><span class="line">    <span class="keyword">private</span> String lastName;</span><br><span class="line">    <span class="keyword">private</span> String phoneNumber;</span><br><span class="line">    <span class="keyword">private</span> String emailAddress;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(Long id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getFirstName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> firstName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFirstName</span><span class="params">(String firstName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.firstName = firstName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getLastName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> lastName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLastName</span><span class="params">(String lastName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.lastName = lastName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPhoneNumber</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> phoneNumber;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPhoneNumber</span><span class="params">(String phoneNumber)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.phoneNumber = phoneNumber;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getEmailAddress</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> emailAddress;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEmailAddress</span><span class="params">(String emailAddress)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.emailAddress = emailAddress;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>按照传统的方式，Java Web 应用会使用JSP作为视图层的技术。但是，Thymeleaf 的原生模板比 JSP 更加便于使用，而且它能够让我们以 HTML 的形式编写模板。鉴于此，我们会使用Thymeleaf 来定义 Contacts 应用的home视图。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">xmlns:th</span>=<span class="string">"http://www.thymeleaf.org"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Spring Boot Contacts<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">th:href</span>=<span class="string">"@&#123;/style.css&#125;"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>Spring Boot Contacts<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">"POST"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"firstName"</span>&gt;</span>First Name:<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"firstName"</span>&gt;</span><span class="tag">&lt;/<span class="name">input</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"lastName"</span>&gt;</span>Last Name:<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"lastName"</span>&gt;</span><span class="tag">&lt;/<span class="name">input</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"phoneNumber"</span>&gt;</span>Phone #:<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"phoneNumber"</span>&gt;</span><span class="tag">&lt;/<span class="name">input</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"emailAddress"</span>&gt;</span>Email:<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"emailAddress"</span>&gt;</span><span class="tag">&lt;/<span class="name">input</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span>&gt;</span><span class="tag">&lt;/<span class="name">input</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span> <span class="attr">th:each</span>=<span class="string">"contact : $&#123;contacts&#125;"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">"$&#123;contact.firstName&#125;"</span>&gt;</span>First<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">"$&#123;contact.lastName&#125;"</span>&gt;</span>Last<span class="tag">&lt;/<span class="name">span</span>&gt;</span> :</span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">"$&#123;contact.phoneNumber&#125;"</span>&gt;</span>phoneNumber<span class="tag">&lt;/<span class="name">span</span>&gt;</span>,</span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">"$&#123;contact.emailAddress&#125;"</span>&gt;</span>emailAddress<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>只要我们将 Thymeleaf 添加到项目的类路径下，就启用了 Spring Boot 的自动配置。当应用运行时，Spring Boot 将会探测到类路径中的Thymeleaf，然后会自动配置视图解析器，模板解析器以及模板引擎，这些都是在 Spring MVC 中使用 Thymeleaf所需要的。因此，在我们的应用中，不需要使用显示 Spring 配置的方式来定义 Thymeleaf。</p>
<p>ContactController 中 home() 方法返回的逻辑视图名为 home ，因此模板文件名为 home.html，自动配置的模板解析器会在指定的目录下查找Thymeleaf模板，这个目录也就是相对根类目录下的templates目录下 ，所以在Maven或Gradle项目中，我们需要将home.html放到“src / main / resources / templates” 中。这个模板中使用了style.css文件，我们倾向于将静态资源放入“src / main / resources / public”目录下。</p>
<p>style.css</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#eeeeee</span>;</span><br><span class="line">  <span class="attribute">font-family</span>: sans-serif;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">label</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">120px</span>;</span><br><span class="line">  <span class="attribute">text-align</span>: right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>持久化数据</p>
<p>ContactRepository 能够从数据库中存取 Contact</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> contacts;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.core.JdbcTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.core.RowMapper;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Repository;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.ResultSet;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContactRepository</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> JdbcTemplate jdbc;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ContactRepository</span><span class="params">(JdbcTemplate jdbc)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.jdbc = jdbc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Contact&gt; <span class="title">findAll</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> jdbc.query(<span class="string">"select id, firstName, lastName, phoneNumber, emailAddress from contacts order by lastName"</span>,</span><br><span class="line">                <span class="keyword">new</span> RowMapper&lt;Contact&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Contact <span class="title">mapRow</span><span class="params">(ResultSet rs, <span class="keyword">int</span> rowNum)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">                        Contact c = <span class="keyword">new</span> Contact();</span><br><span class="line">                        c.setId(rs.getLong(<span class="number">1</span>));</span><br><span class="line">                        c.setFirstName(rs.getString(<span class="number">2</span>));</span><br><span class="line">                        c.setLastName(rs.getString(<span class="number">3</span>));</span><br><span class="line">                        c.setPhoneNumber(rs.getString(<span class="number">4</span>));</span><br><span class="line">                        c.setEmailAddress(rs.getString(<span class="number">5</span>));</span><br><span class="line">                        <span class="keyword">return</span> c;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(Contact contact)</span></span>&#123;</span><br><span class="line">        jdbc.update(<span class="string">"insert into contacts(firstName,lastName,phoneNumber,emailAddress) values(?,?,?,?)"</span>,</span><br><span class="line">                contact.getFirstName(),contact.getLastName(),contact.getPhoneNumber(),contact.getEmailAddress());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ContactRepository使用了@Repository注解，在组件扫描的时候他会被发现并创建为 Spring 应用上下文中的 bean。</p>
<p>JdbcTemplate 呢？我们难道不用再Spring应用上下文中声明JdbcTemplate bean 吗？为了声明它， 我们是不是需要声明一个H2 DataSource？</p>
<p>一切都不需要！！当 Spring Boot 嗅探到 Spring 的 JDBC 模块和H2 在类路径下的时候，自动配置就会发挥作用，将会自动配置 JdbcTemplate bean 和 H2 DataSource bean。</p>
<p>我们需要自己创建contacts表的模式，Spring Boot 可不会知道 contacts 表会是什么样子。</p>
<p>我们将一个名为schema.sql的脚本文件放入类路径根下，也就是Maven或Gradle项目目录下的”src/main/resources“目录下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">create table <span class="title">contacts</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    id identity,</span></span></span><br><span class="line"><span class="function"><span class="params">    firstName varchar(<span class="number">30</span>)</span> not <span class="keyword">null</span>,</span></span><br><span class="line"><span class="function">    lastName <span class="title">varchar</span><span class="params">(<span class="number">50</span>)</span> not <span class="keyword">null</span>,</span></span><br><span class="line"><span class="function">    phoneNumber <span class="title">varchar</span><span class="params">(<span class="number">13</span>)</span>,</span></span><br><span class="line"><span class="function">    emailAddress <span class="title">varchar</span><span class="params">(<span class="number">30</span>)</span></span></span><br><span class="line"><span class="function">)</span>;</span><br></pre></td></tr></table></figure>



<p>我们需要一个特定的类来启动Spring Boot 项目。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> contacts;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.EnableAutoConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(Application<span class="class">.<span class="keyword">class</span>,<span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>点击运行，打开浏览器输入localhost:8080就能进入Contacts应用。</p>
<p> <img src="https://gitee.com/hoo334/picgo/raw/master//img/jOsdNFPVnmoxHiL.png" alt=""></p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
  </entry>
  <entry>
    <title>设计模式</title>
    <url>/2020/04/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h2><p>对象怎么来</p>
<p>这些设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用 new 运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。</p>
<h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><p>　　工厂模式（Factory Pattern）是Java 中最常用的设计模式之一。提供了一种创建对象大的最佳方式。我们在创建对象时不会对客户端暴露创建逻辑，通过一个共同的接口来指向新创建的对象。</p>
<p>　</p>
<p><strong>介绍</strong></p>
<p>　　<strong>意图</strong>：定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。</p>
<p>　　<strong>主要解决</strong>：接口选择的问题。</p>
<p>　　<strong>何时使用</strong>：不同条件下创建不同实例时。</p>
<p>　　<strong>如何解决</strong>：让其子类实现工厂接口，返回的也是一个抽象的产品。</p>
<p>　　应用实例： 1、您需要一辆汽车，可以直接从工厂里面提货，而不用去管这辆汽车是怎么做出来的，以及这个汽车里面的具体实现。 2、Hibernate 换数据库只需换方言和驱动就可以。</p>
<p>　　优点： 1、一个调用者想创建一个对象，只要知道其名称就可以了。 2、扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。 3、屏蔽产品的具体实现，调用者只关心产品的接口。</p>
<p>　　缺点：每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。这并不是什么好事。</p>
<p>　　使用场景<strong>：</strong> 1、日志记录器：记录可能记录到本地硬盘、系统事件、远程服务器等，用户可以选择记录日志到什么地方。 2、数据库访问，当用户不知道最后系统采用哪一类数据库，以及数据库可能有变化时。 3、设计一个连接服务器的框架，需要三个协议，”POP3”、”IMAP”、”HTTP”，可以把这三个作为产品类，共同实现一个接口。</p>
<p>　　<strong>注意事项</strong>：复杂对象生成适合使用工厂模式，简单对象直接new。</p>
<p><strong>实现</strong></p>
<p>　　我们将创建一个 <em>Shape</em> 接口和实现 <em>Shape</em> 接口的实体类。下一步是定义工厂类 <em>ShapeFactory<em>。</em>FactoryPatternDemo*，我们的演示类使用 *ShapeFactory</em> 来获取 <em>Shape</em> 对象。它将向 <em>ShapeFactory</em> 传递信息（<em>CIRCLE / RECTANGLE / SQUARE</em>），以便获取它所需对象的类型。</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/gtuCzOImlK4UyG8.png" alt="img"></p>
<p> 　1、创建一个Shape接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　2、创建 Rectangle、Circle和Square 实体类实现Shape接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Rectangle::draw()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Circle::draw()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Square::draw()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　3、创建一个工厂，生成基于给定信息的实体类对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShapeFactory</span> </span>&#123;</span><br><span class="line">    <span class="comment">//使用getShape方法获取形状对象。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Shape <span class="title">getShape</span><span class="params">(String shapeType)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(shapeType == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(shapeType.equalsIgnoreCase(<span class="string">"circle"</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Circle();</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(shapeType.equalsIgnoreCase(<span class="string">"square"</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Square();</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(shapeType.equalsIgnoreCase(<span class="string">"rectangle"</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Rectangle();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　4、使用该工厂，通过传递类型信息来获取实体类的对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FactoryPatternDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ShapeFactory sf = <span class="keyword">new</span> ShapeFactory();</span><br><span class="line"></span><br><span class="line">        Shape s1 = sf.getShape(<span class="string">"circle"</span>);</span><br><span class="line">        <span class="keyword">if</span>(s1 != <span class="keyword">null</span>)s1.draw();</span><br><span class="line"></span><br><span class="line">        Shape s2 = sf.getShape(<span class="string">"rectangle"</span>);</span><br><span class="line">        <span class="keyword">if</span>(s2 != <span class="keyword">null</span>)s2.draw();</span><br><span class="line"></span><br><span class="line">        Shape s3 = sf.getShape(<span class="string">"square"</span>);</span><br><span class="line">        <span class="keyword">if</span>(s3 != <span class="keyword">null</span>)s3.draw();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　输出：</p>
<p>　　Circle::draw()<br>　　Rectangle::draw()<br>　　Square::draw()</p>
<p>　　在已知获取对象的类型下，我们可以将Shape 对象强制转换为 Circle、Rectangle和Square对象，来使用特定实体类的特有方法。</p>
<p> 参考：<a href="https://www.runoob.com/design-pattern/factory-pattern.html" target="_blank" rel="noopener">https://www.runoob.com/design-pattern/factory-pattern.html</a></p>
<h3 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h3><p>　　抽象工厂模式（Abstract Factory Pattrn）是围绕一个超级工厂创建其他工厂。该超级工厂称为其他工厂的工厂。提供了一种创建对象的最佳方式。</p>
<p>　　在抽象工厂模式中，接口是负责创建一个相关对象的工厂，不需要显式指定它们的类。每个生成的工厂都能按照工厂模式提供对象。</p>
<p>　</p>
<p><strong>介绍</strong></p>
<p>　　<strong>意图</strong>：提供一个创建一系列相关或相互依赖对象的接口，无需指定它们具体的类。</p>
<p>　　<strong>主要解决</strong>：主要解决接口选择的问题。</p>
<p>　　<strong>何时使用</strong>：系统的产品有多于一个的产品族，而系统只消费其中某一族的产品。</p>
<p>　　<strong>如何解决</strong>：在一个产品族里面定义多个产品。</p>
<p>　　<strong>关键代码</strong>：在一个工厂里聚合多个同类产品。</p>
<p>　　应用实例<strong>：</strong>工作了，为了参加一些聚会，肯定有两套或多套衣服吧，比如说有商务装（成套，一系列具体产品）、时尚装（成套，一系列具体产品），甚至对于一个家庭来说，可能有商务女装、商务男装、时尚女装、时尚男装，这些也都是成套的，即一系列具体产品。假设一种情况（现实中是不存在的，要不然，没法进入共产主义了，但有利于说明抽象工厂模式），在您的家中，某一个衣柜（具体工厂）只能存放某一种这样的衣服（成套，一系列具体产品），每次拿这种成套的衣服时也自然要从这个衣柜中取出了。用 OOP 的思想去理解，所有的衣柜（具体工厂）都是衣柜类的（抽象工厂）某一个，而每一件成套的衣服又包括具体的上衣（某一具体产品），裤子（某一具体产品），这些具体的上衣其实也都是上衣（抽象产品），具体的裤子也都是裤子（另一个抽象产品）。</p>
<p>　　优点<strong>：</strong>当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象。</p>
<p>　　缺点<strong>：</strong>产品族扩展非常困难，要增加一个系列的某一产品，既要在抽象的 Creator 里加代码，又要在具体的里面加代码。</p>
<p>　　使用场景<strong>：</strong> 1、QQ 换皮肤，一整套一起换。 2、生成不同操作系统的程序。</p>
<p>　　<strong>注意事项：</strong>产品族难扩展，产品等级易扩展。</p>
<p><strong>实现</strong></p>
<p>　　我们将创建 <em>Shape</em> 和 <em>Color</em> 接口和实现这些接口的实体类。下一步是创建抽象工厂类 <em>AbstractFactory*。接着定义工厂类 *ShapeFactory</em> 和 <em>ColorFactory<em>，这两个工厂类都是扩展了 *AbstractFactory</em>。然后创建一个工厂创造器/生成器类 <em>FactoryProducer*</em>AbstractFactoryPatternDemo*，我们的演示类使用 *FactoryProducer</em> 来获取 <em>AbstractFactory</em> 对象。它将向 <em>AbstractFactory</em> 传递形状信息 <em>Shape<em>（</em>CIRCLE / RECTANGLE / SQUARE*），以便获取它所需对象的类型。同时它还向 *AbstractFactory</em> 传递颜色信息 <em>Color</em>（<em>RED / GREEN / BLUE</em>），以便获取它所需对象的类型。</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/moT4EKUNQRlXwOc.png" alt="img"></p>
<p> 　1、新建Shape，Color两个接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Color</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">fill</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　2、为这两个接口分别添加几个实体类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Rectangle::draw()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Circle::draw()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Square::draw()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Blue</span> <span class="keyword">implements</span> <span class="title">Color</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fill</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Blue::fill()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Green</span> <span class="keyword">implements</span> <span class="title">Color</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fill</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Green::fill()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Red</span> <span class="keyword">implements</span> <span class="title">Color</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fill</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Red::fill()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　3、为 Color 和 Shape 对象创建抽象类来获取工厂。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Color <span class="title">getColor</span><span class="params">(String color)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Shape <span class="title">getShape</span><span class="params">(String shape)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　4、创建扩展了 AbstractFactory 的工厂类，基于给定的信息生成实体类的对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShapeFactory</span> <span class="keyword">extends</span> <span class="title">AbstractFactory</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Color <span class="title">getColor</span><span class="params">(String color)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用getShape方法获取形状对象。</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Shape <span class="title">getShape</span><span class="params">(String shape)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(shape == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(shape.equalsIgnoreCase(<span class="string">"circle"</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Circle();</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(shape.equalsIgnoreCase(<span class="string">"square"</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Square();</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(shape.equalsIgnoreCase(<span class="string">"rectangle"</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Rectangle();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ColorFactory</span> <span class="keyword">extends</span> <span class="title">AbstractFactory</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Shape <span class="title">getShape</span><span class="params">(String shapeType)</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Color <span class="title">getColor</span><span class="params">(String color)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(color == <span class="keyword">null</span>)&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      &#125;        </span><br><span class="line">      <span class="keyword">if</span>(color.equalsIgnoreCase(<span class="string">"RED"</span>))&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> Red();</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(color.equalsIgnoreCase(<span class="string">"GREEN"</span>))&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> Green();</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(color.equalsIgnoreCase(<span class="string">"BLUE"</span>))&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> Blue();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　5、创建一个工厂创造器/生成器类，通过传递形状或颜色信息来获取工厂（工厂的工厂）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FactoryProducer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AbstractFactory <span class="title">getFactory</span><span class="params">(String choice)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(choice.equalsIgnoreCase(<span class="string">"color"</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ColorFactory();</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(choice.equalsIgnoreCase(<span class="string">"shape"</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ShapeFactory();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　6、使用 FactoryProducer 来获取 AbstractFactory，通过传递类型信息来获取实体类的对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractFactoryDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取形状工厂</span></span><br><span class="line">        AbstractFactory shapeFactory = FactoryProducer.getFactory(<span class="string">"shape"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(shapeFactory != <span class="keyword">null</span>)&#123;</span><br><span class="line">            Shape s1 = shapeFactory.getShape(<span class="string">"circle"</span>);</span><br><span class="line">            <span class="keyword">if</span>(s1 != <span class="keyword">null</span>)s1.draw();</span><br><span class="line"></span><br><span class="line">            Shape s2 = shapeFactory.getShape(<span class="string">"rectangle"</span>);</span><br><span class="line">            <span class="keyword">if</span>(s2 != <span class="keyword">null</span>)s2.draw();</span><br><span class="line"></span><br><span class="line">            Shape s3 = shapeFactory.getShape(<span class="string">"square"</span>);</span><br><span class="line">            <span class="keyword">if</span>(s3 != <span class="keyword">null</span>)s3.draw();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取颜色工厂</span></span><br><span class="line">        AbstractFactory colorFactory = FactoryProducer.getFactory(<span class="string">"color"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(colorFactory != <span class="keyword">null</span>)&#123;</span><br><span class="line">            Color c1 = colorFactory.getColor(<span class="string">"red"</span>);</span><br><span class="line">            <span class="keyword">if</span>(c1 != <span class="keyword">null</span>)c1.fill();</span><br><span class="line"></span><br><span class="line">            Color c2 = colorFactory.getColor(<span class="string">"blue"</span>);</span><br><span class="line">            <span class="keyword">if</span>(c2 != <span class="keyword">null</span>)c2.fill();</span><br><span class="line"></span><br><span class="line">            Color c3 = colorFactory.getColor(<span class="string">"green"</span>);</span><br><span class="line">            <span class="keyword">if</span>(c3 != <span class="keyword">null</span>)c3.fill();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　 输出：　</p>
<p>　　Circle::draw()<br>　　Rectangle::draw()<br>　　Square::draw()<br>　　Red::fill()<br>　　Blue::fill()<br>　　Green::fill()</p>
<p>参考：<a href="https://www.runoob.com/design-pattern/abstract-factory-pattern.html" target="_blank" rel="noopener">https://www.runoob.com/design-pattern/abstract-factory-pattern.html</a></p>
<h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p>　　单例模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。</p>
<p>　　注意：1）单例类中只能有一个实例</p>
<p>　　　　　2）单例类必须自己创建自己的唯一实例</p>
<p>　　　　　3）单例类必须给所有其他对象提供这一实例</p>
<p><strong>介绍</strong></p>
<p>　　意图：保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p>
<p>　　主要解决：一个全局使用的类频繁地创建与销毁。</p>
<p>　　何时使用：当您想控制实例数目，节省系统资源的时候。</p>
<p>　　如何解决：判断系统是否已经有这个单例，如果有则返回，没有则创建。</p>
<p>　　关键代码：构造函数是私有的。</p>
<p>　　应用实例：一个班级只有一个班主任。</p>
<p>　　优点：1）在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）。2）避免对资源的多重占用（比如写文件操作）。</p>
<p>　　缺点：没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。</p>
<p>　　应用场景：1）要求生产唯一序列号。2）WEB 中的计数器，不用每次刷新都在数据库里加一次，用单例先缓存起来。3）创建的一个对象需要消耗的资源过多，比如 I/O 与数据库的连接等。</p>
<p><strong>实现</strong></p>
<p>　　我们将创建一个 <em>SingleObject</em> 类。<em>SingleObject</em> 类有它的私有构造函数和本身的一个静态实例。<em>SingleObject</em> 类提供了一个静态方法，供外界获取它的静态实例。<em>SingletonPatternDemo*，我们的演示类使用 *SingleObject</em> 类来获取 <em>SingleObject</em> 对象。</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/Px9WFvJVqliNUpw.png" alt="img"></p>
<p> 　1、创建一个Singleton 类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleObject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingleObject instance = <span class="keyword">new</span> SingleObject();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingleObject</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingleObject <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showMessage</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello world!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　2、从 Singleton 类获取唯一的对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonPatternDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//不合法，构造函数不可见</span></span><br><span class="line">        <span class="comment">//SingleObject so = new SingleObject();</span></span><br><span class="line"></span><br><span class="line">        SingleObject so = SingleObject.getInstance();</span><br><span class="line">        so.showMessage();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　输出：hello world！</p>
<p><strong>单例模式的几种实现方式</strong></p>
<p>　　1、<strong>懒汉式不加锁</strong>，线程不安全。可能会有多个进程进入到 if 语句内，创建多个实例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 懒加载，线程不安全。</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonLazyUnlocked</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingletonLazyUnlocked instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonLazyUnlocked</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonLazyUnlocked <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance != <span class="keyword">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> SingletonLazyUnlocked();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　2、<strong>懒汉式加锁</strong>，线程安全。加synchronized影响效率。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 懒加载，线程安全。</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonLazyLocked</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingletonLazyLocked instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonLazyLocked</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> SingletonLazyLocked <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance != <span class="keyword">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> SingletonLazyLocked();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　3、<strong>饿汉式</strong>，线程安全。类加载时创建实例，容易产生垃圾对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 非懒加载，线程安全。</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHungry</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingletonHungry instance = <span class="keyword">new</span> SingletonHungry();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonHungry</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonHungry <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　4、<strong>双重校验锁</strong>（Double-Checked Locking）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 懒加载，线程安全</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonDCL</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> SingletonDCL instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonDCL</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonDCL <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (SingletonDCL<span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> SingletonDCL();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　第一次校验：如果创建了实例再去执行getInstance()方法不会去竞争锁，直接返回实例。</p>
<p>　　第二次校验：防止二次创建实例。如果没有第二个判空语句，在实例还没有创建的情况下，A 和 B 两个线程都要获得单例的对象。A ，B 都进入了第一个判空语句内，然后争夺锁，A获得了锁，实例化了一个对象，然后释放了锁，B获得了锁，由于没有第二个判空语句B 又创建了一次对象。</p>
<p>　　volatile 关键字的作用：防止指令重排优化。保证变量在多线程运行时的可见性，无法保证原子性。</p>
<p>　　5、<strong>静态内部类</strong></p>
<p>　　对静态域使用延迟初始化利用类加载机制来保证初始化 instance 时只有一个线程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 静态内部类懒加载</span></span><br><span class="line"><span class="comment">* 懒加载，线程安全</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonRegister</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> SingletonRegister INSTANCE = <span class="keyword">new</span> SingletonRegister();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonRegister</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> SingletonRegister <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　</p>
<p>　　6、<strong>枚举</strong></p>
<p>　　实现单例的最佳方法。更简洁，自动支持序列化机制防止多次实例化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> SingletonEnum &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 参考：<a href="https://www.runoob.com/design-pattern/singleton-pattern.html" target="_blank" rel="noopener">https://www.runoob.com/design-pattern/singleton-pattern.html</a></p>
<h3 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h3><p>　　建造者模式（Builder Pattern）使用多个简单的对一步一步构成一个复杂的对象，这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p>
<p>　　一个Builder 类会一步一步的构造最终的对象。该Builder 对象是独立于其他对象的。</p>
<p><strong>介绍</strong></p>
<p>　　<strong>意图</strong>：将一个复杂的构建与其表示分离，使得同样的构建过程可以创建不同的表示。</p>
<p>　　主要解决：在软件系统中，有时候面临着“一个复杂对象”的创建工作，其通常由各个部分的子对象用一定的算法构成；由于需求的变化，这个复杂对象的各个部分经常面临着剧烈的变化，但是将它们组合在一起的算法却相对稳定。</p>
<p>　　<strong>何时使用</strong>：一些基本部件不会变，而其组合经常变化的时候。</p>
<p>　　如何解决：将变与不变分离开。</p>
<p>　　关键代码：建造者：创建与提供实例，导演：管理建造出来的实例的依赖关系。</p>
<p>　　<strong>应用实例</strong>：1、去肯德基，汉堡，可乐，薯条，炸鸡等是不变的，而其组合是经常变化的，生成出所谓的“套餐”。2、Java 中的StringBuilder。</p>
<p>　　优点：1、建造者独立、易扩展。2、便于控制细节风险。</p>
<p>　　缺点：1、产品必须有共同点，范围有限制。2、如内部变化复杂，会有很多的建造类。</p>
<p>　　使用场景：1、需要生成的对象具有复杂的内部结构。2、需要生成的对象内部属性本身相互依赖。</p>
<p>　　<strong>注意事项</strong>：与工厂模式的区别是：建造者模式更加关注零件装配的顺序。</p>
<p><strong>实现</strong></p>
<p>　　我们假设一个快餐店的商业案例，其中，一个典型的套餐可以是一个汉堡（Burger）和一杯冷饮（Cold drink）。汉堡（Burger）可以是素食汉堡（Veg Burger）或鸡肉汉堡（Chicken Burger），它们是包在纸盒中。冷饮（Cold drink）可以是可口可乐（coke）或百事可乐（pepsi），它们是装在瓶子中。</p>
<p>我们将创建一个表示食物条目（比如汉堡和冷饮）的 <em>Item</em> 接口和实现 <em>Item</em> 接口的实体类，以及一个表示食物包装的 <em>Packing</em> 接口和实现 <em>Packing</em> 接口的实体类，汉堡是包在纸盒中，冷饮是装在瓶子中。</p>
<p>然后我们创建一个 <em>Meal</em> 类，带有 <em>Item</em> 的 <em>ArrayList</em> 和一个通过结合 <em>Item</em> 来创建不同类型的 <em>Meal</em> 对象的 <em>MealBuilder<em>。</em>BuilderPatternDemo*，我们的演示类使用 *MealBuilder</em> 来创建一个 <em>Meal。</em></p>
<p><em><img src="https://gitee.com/hoo334/picgo/raw/master//img/rHiuG6QpIcWTmYN.png" alt="img"></em></p>
<p> 　1、创建一个表示食物条目和食物包装的接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Item</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">name</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Packing <span class="title">packing</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">price</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Packing</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">pack</span><span class="params">()</span></span>; <span class="comment">//返回包装的名字</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　2、创建实现 Packing 接口的实体类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 包装纸类</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Wrapper</span> <span class="keyword">implements</span> <span class="title">Packing</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">pack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Wrapper"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 杯子类</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bottle</span> <span class="keyword">implements</span> <span class="title">Packing</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">pack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Bottle"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　3、创建实现 Item 接口的抽象类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 汉堡抽象类</span></span><br><span class="line"><span class="comment">* 汉堡都是用包装纸包装，价格不同。</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Burger</span> <span class="keyword">implements</span> <span class="title">Item</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Packing <span class="title">packing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Wrapper();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">float</span> <span class="title">price</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 冷饮抽象类，所有冷饮都是用杯子装，价格不同。</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ColdDrink</span> <span class="keyword">implements</span> <span class="title">Item</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Packing <span class="title">packing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Bottle();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">float</span> <span class="title">price</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　4、创建扩展了 Burger 和 ColdDrink 的实体类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VegBurger</span> <span class="keyword">extends</span> <span class="title">Burger</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">price</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">25.0f</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">name</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Veg Burger"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChickenBurger</span> <span class="keyword">extends</span> <span class="title">Burger</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">price</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">50.5f</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">name</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Chicken Burger"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Coke</span> <span class="keyword">extends</span> <span class="title">ColdDrink</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">price</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">30.0f</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">name</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Coke"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pepsi</span> <span class="keyword">extends</span> <span class="title">ColdDrink</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">price</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">35.0f</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">name</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Pepsi"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　5、创建一个 Meal 类，带有上面定义的 Item 对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Meal</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;Item&gt; items = <span class="keyword">new</span> ArrayList&lt;Item&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addItem</span><span class="params">(Item item)</span></span>&#123;</span><br><span class="line">        items.add(item);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">getCost</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">float</span> cost = <span class="number">0.0f</span>;</span><br><span class="line">        <span class="keyword">for</span> (Item item : items) &#123;</span><br><span class="line">            cost += item.price();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cost;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showItems</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Item item : items) &#123;</span><br><span class="line">            System.out.print(<span class="string">"Item: "</span>+item.name());</span><br><span class="line">            System.out.print(<span class="string">" Packing: "</span>+item.packing().pack());</span><br><span class="line">            System.out.println(<span class="string">" Price: "</span>+item.price());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　6、创建一个 MealBuilder 类，实际的 builder 类负责创建 Meal 对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MealBuilder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Meal <span class="title">prepareVegMeal</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Meal meal = <span class="keyword">new</span> Meal();</span><br><span class="line">        meal.addItem(<span class="keyword">new</span> VegBurger());</span><br><span class="line">        meal.addItem(<span class="keyword">new</span> Coke());</span><br><span class="line">        <span class="keyword">return</span> meal;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Meal <span class="title">prepareNonVegMeal</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Meal meal = <span class="keyword">new</span> Meal();</span><br><span class="line">        meal.addItem(<span class="keyword">new</span> ChickenBurger());</span><br><span class="line">        meal.addItem(<span class="keyword">new</span> Pepsi());</span><br><span class="line">        <span class="keyword">return</span> meal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　7、BuilderPatternDemo 使用 MealBuilder 来演示建造者模式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BuilderPatterDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MealBuilder mealBuilder = <span class="keyword">new</span> MealBuilder();</span><br><span class="line"></span><br><span class="line">        Meal vegMeal = mealBuilder.prepareVegMeal();</span><br><span class="line">        System.out.println(<span class="string">"Veg Meal"</span>);</span><br><span class="line">        vegMeal.showItems();</span><br><span class="line">        System.out.println(<span class="string">"Total Cost: "</span>+vegMeal.getCost());</span><br><span class="line"></span><br><span class="line">        Meal nonVegMeal = mealBuilder.prepareNonVegMeal();</span><br><span class="line">        System.out.println(<span class="string">"Non-Veg meal"</span>);</span><br><span class="line">        nonVegMeal.showItems();</span><br><span class="line">        System.out.println(<span class="string">"Total Cost: "</span>+nonVegMeal.getCost());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　输出：</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/vbdoVCnrMFiI69s.png" alt="img"></p>
<p> 参考：<a href="https://www.runoob.com/design-pattern/builder-pattern.html" target="_blank" rel="noopener">https://www.runoob.com/design-pattern/builder-pattern.html</a></p>
<h3 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h3><p>　　原型模式（Prototype Pattern）是用于创建重复的对象，同时又能保证性能。这种模式实现了一个原型接口，该接口用于创建当前对象的克隆。当创建对象的代价比较大时，则采用这种模式。</p>
<p><strong>介绍</strong></p>
<p>　　<strong>意图</strong>：用原型实例制定创建对象的种类，并且通过拷贝这些原型创建新的对象。</p>
<p>　　<strong>主要解决</strong>：在运行期建立和删除原型。</p>
<p>　　何时使用：1、当一个系统应独立于它的产品创建，构成和表示时。2、当要实例化的类是在运行时刻指定时，例如，通过动态加载。3、为了避免创建一个与产品类层次平行的工厂类层次时。4、当一个类的实例只能有几个不同状态中的一种时。建立相应数目的原型并克隆它们可能比每次用合适的状态手工实例化该类更方便。</p>
<p>　　如何解决：利用已有的一个原型对象，快速地生成和原型对象一样地实例。</p>
<p>　　<strong>关键代码</strong>：1、实现克隆操作，在JAVA 中继承 Cloneable ，重写Clone()。2、原型模式同样用于隔离类对象地使用者和具体类型（易变类）之间地耦合关系，它同样要求这些“易变类”拥有稳定的接口。</p>
<p>　　应用实例：1、细胞分裂。2、JAVA 中的Object clone() 方法。</p>
<p>　　优点：1、性能提高。2、逃避构造函数的约束。</p>
<p>　　缺点：1、配备克隆方法需要对类的功能进行通盘考虑，这对于全新的类不是很难，但对于已有的类不一定很容易，特别当一个类引用不支持串行化的间接对象，或者引用含有循环结构的时候。 2、必须实现 Cloneable 接口。</p>
<p>　　使用场景<strong>：</strong> 1、资源优化场景。 2、类初始化需要消化非常多的资源，这个资源包括数据、硬件资源等。 3、性能和安全要求的场景。 4、通过 new 产生一个对象需要非常繁琐的数据准备或访问权限，则可以使用原型模式。 5、一个对象多个修改者的场景。 6、一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值时，可以考虑使用原型模式拷贝多个对象供调用者使用。 7、在实际项目中，原型模式很少单独出现，一般是和工厂方法模式一起出现，通过 clone 的方法创建一个对象，然后由工厂方法提供给调用者。原型模式已经与 Java 融为浑然一体，大家可以随手拿来使用。</p>
<p>　　注意事项<strong>：</strong>与通过对一个类进行实例化来构造新对象不同的是，原型模式是通过拷贝一个现有对象生成新对象的。浅拷贝实现 Cloneable，重写，深拷贝是通过实现 Serializable 读取二进制流。</p>
<p>　　</p>
<p>实现</p>
<p>　　我们将创建一个抽象类 <em>Shape</em> 和扩展了 <em>Shape</em> 类的实体类。下一步是定义类 <em>ShapeCache*，该类把 shape 对象存储在一个 *Hashtable</em> 中，并在请求的时候返回它们的克隆。</p>
<p><em>PrototypePatternDemo*，我们的演示类使用 *ShapeCache</em> 类来获取 <em>Shape</em> 对象。</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/pRkV14JYWSr6F9g.png" alt="img"></p>
<p> 　1、创建一个实现了 Cloneable 接口的抽象类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Shape</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="keyword">protected</span> String type;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Object cloned = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            cloned = <span class="keyword">super</span>.clone();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cloned;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　2、创建继承了上面抽象类的实体类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Square</span><span class="params">()</span></span>&#123;</span><br><span class="line">        type = <span class="string">"Square"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Square::draw()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Rectangle</span><span class="params">()</span></span>&#123;</span><br><span class="line">        type = <span class="string">"Rectangle"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Rectangle::draw()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Circle</span><span class="params">()</span></span>&#123;</span><br><span class="line">        type = <span class="string">"Circle"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Circle::draw()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　3、创建一个类，从数据库中获取实体类，并把它们存储在一个 ConcurrentHashMap 中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentHashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShapeCache</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ConcurrentHashMap&lt;String,Shape&gt; shapeMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Shape <span class="title">getShape</span><span class="params">(String shapeId)</span></span>&#123;</span><br><span class="line">        Shape cachedShape = shapeMap.get(shapeId);</span><br><span class="line">        <span class="keyword">return</span> (Shape)cachedShape.clone();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对每种形状进行数据库查询，并创建该形状。</span></span><br><span class="line">    <span class="comment">//假设创建三种形状。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span>  <span class="title">loadCache</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Circle circle = <span class="keyword">new</span> Circle();</span><br><span class="line">        circle.setId(<span class="string">"1"</span>);</span><br><span class="line">        shapeMap.put(circle.getId(),circle);</span><br><span class="line"></span><br><span class="line">        Rectangle rectangle = <span class="keyword">new</span> Rectangle();</span><br><span class="line">        rectangle.setId(<span class="string">"2"</span>);</span><br><span class="line">        shapeMap.put(rectangle.getId(),rectangle);</span><br><span class="line"></span><br><span class="line">        Square square = <span class="keyword">new</span> Square();</span><br><span class="line">        square.setId(<span class="string">"3"</span>);</span><br><span class="line">        shapeMap.put(square.getId(),square);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　4、PrototypePatternDemo 使用 ShapeCache 类来获取存储在 ConcurrentHashMap 中的形状的克隆。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrototypePatternDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ShapeCache.loadCache();</span><br><span class="line"></span><br><span class="line">        Shape clonedShape = (Shape)ShapeCache.getShape(<span class="string">"1"</span>);</span><br><span class="line">        System.out.println(<span class="string">"Shape: "</span>+clonedShape.getType());</span><br><span class="line"></span><br><span class="line">        Shape clonedShape2 = (Shape)ShapeCache.getShape(<span class="string">"2"</span>);</span><br><span class="line">        System.out.println(<span class="string">"Shape: "</span>+clonedShape2.getType());</span><br><span class="line"></span><br><span class="line">        Shape clonedShape3 = (Shape)ShapeCache.getShape(<span class="string">"3"</span>);</span><br><span class="line">        System.out.println(<span class="string">"Shape: "</span>+clonedShape3.getType());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　输出：</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/u2HNXvUfjw5n3Pb.png" alt="img"></p>
<p> 参考：<a href="https://www.runoob.com/design-pattern/prototype-pattern.html" target="_blank" rel="noopener">https://www.runoob.com/design-pattern/prototype-pattern.html</a></p>
<h2 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h2><p>对象和谁有关</p>
<p>这些设计模式关注类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式。</p>
<h3 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h3><p>　　适配器模式（Adapter Pattern）是作为<strong>两个不兼容的接口之间的桥梁</strong>，它结合了两个独立接口的功能。这种模式涉及到一个单一的类，该类负责加入独立的或不兼容的接口功能。例如，读卡器是内存卡和电脑之间的适配器。</p>
<p><strong>介绍</strong></p>
<p><strong>意图：</strong>将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</p>
<p><strong>主要解决：</strong>主要解决在软件系统中，常常要将一些”现存的对象”放到新的环境中，而新环境要求的接口是现对象不能满足的。</p>
<p><strong>何时使用：</strong> 1、系统需要使用现有的类，而此类的接口不符合系统的需要。 2、想要建立一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作，这些源类不一定有一致的接口。 3、通过接口转换，将一个类插入另一个类系中。（比如老虎和飞禽，现在多了一个飞虎，在不增加实体的需求下，增加一个适配器，在里面包容一个虎对象，实现飞的接口。）</p>
<p><strong>如何解决：</strong>继承或依赖（推荐）。</p>
<p><strong>关键代码：</strong>适配器继承或依赖已有的对象，实现想要的目标接口。</p>
<p><strong>应用实例：</strong> 1、美国电器 110V，中国 220V，就要有一个适配器将 110V 转化为 220V。 2、JAVA JDK 1.1 提供了 Enumeration 接口，而在 1.2 中提供了 Iterator 接口，想要使用 1.2 的 JDK，则要将以前系统的 Enumeration 接口转化为 Iterator 接口，这时就需要适配器模式。 3、在 LINUX 上运行 WINDOWS 程序。 4、JAVA 中的 jdbc。</p>
<p><strong>优点：</strong> 1、可以让任何两个没有关联的类一起运行。 2、提高了类的复用。 3、增加了类的透明度。 4、灵活性好。</p>
<p><strong>缺点：</strong> 1、过多地使用适配器，会让系统非常零乱，不易整体进行把握。比如，明明看到调用的是 A 接口，其实内部被适配成了 B 接口的实现，一个系统如果太多出现这种情况，无异于一场灾难。因此如果不是很有必要，可以不使用适配器，而是直接对系统进行重构。 2.由于 JAVA 至多继承一个类，所以至多只能适配一个适配者类，而且目标类必须是抽象类。</p>
<p><strong>使用场景：</strong>有动机地修改一个正常运行的系统的接口，这时应该考虑使用适配器模式。</p>
<p><strong>注意事项：</strong>适配器不是在详细设计时添加的，而是解决正在服役的项目的问题。</p>
<p><strong>实现</strong></p>
<p>我们有一个 <em>MediaPlayer</em> 接口和一个实现了 <em>MediaPlayer</em> 接口的实体类 <em>AudioPlayer<em>。默认情况下，</em>AudioPlayer</em> 可以播放 mp3 格式的音频文件。</p>
<p>我们还有另一个接口 <em>AdvancedMediaPlayer</em> 和实现了 <em>AdvancedMediaPlayer</em> 接口的实体类。该类可以播放 vlc 和 mp4 格式的文件。</p>
<p>我们想要让 <em>AudioPlayer</em> 播放其他格式的音频文件。为了实现这个功能，我们需要创建一个实现了 <em>MediaPlayer</em> 接口的适配器类 <em>MediaAdapter*，并使用 *AdvancedMediaPlayer</em> 对象来播放所需的格式。</p>
<p><em>AudioPlayer</em> 使用适配器类 <em>MediaAdapter</em> 传递所需的音频类型，不需要知道能播放所需格式音频的实际类。<em>AdapterPatternDemo*，我们的演示类使用 *AudioPlayer</em> 类来播放各种格式。</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/AxBCiwfhDro5vUI.png" alt="img"></p>
<p> 　1、为媒体播放器和更高级的媒体播放器创建接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MediaPlayer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">(String audioType,String fileName)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AdvancedMediaPlayer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">playVlc</span><span class="params">(String fileName)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">playMp4</span><span class="params">(String fileName)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　2、创建实现了 AdvancedMediaPlayer 接口的实体类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mp4Player</span> <span class="keyword">implements</span> <span class="title">AdvancedMediaPlayer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">playVlc</span><span class="params">(String fileName)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">playMp4</span><span class="params">(String fileName)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Playing Mp4 file. name: "</span>+fileName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VlcPlayer</span> <span class="keyword">implements</span> <span class="title">AdvancedMediaPlayer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">playVlc</span><span class="params">(String fileName)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Playing vlc file. name: "</span>+fileName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">playMp4</span><span class="params">(String fileName)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　3、创建实现了 MediaPlayer 接口的<strong>适配器类（可以播放视频）</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MediaAdapter</span> <span class="keyword">implements</span> <span class="title">MediaPlayer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    AdvancedMediaPlayer advancedMusicPlayer;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MediaAdapter</span><span class="params">(String audioType)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(audioType.equalsIgnoreCase(<span class="string">"vlc"</span>))&#123;</span><br><span class="line">            advancedMusicPlayer = <span class="keyword">new</span> VlcPlayer();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(audioType.equalsIgnoreCase(<span class="string">"mp4"</span>))&#123;</span><br><span class="line">            advancedMusicPlayer = <span class="keyword">new</span> Mp4Player();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">(String audioType, String fileName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(audioType.equalsIgnoreCase(<span class="string">"vlc"</span>))&#123;</span><br><span class="line">            advancedMusicPlayer.playVlc(fileName);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(audioType.equalsIgnoreCase(<span class="string">"mp4"</span>))&#123;</span><br><span class="line">            advancedMusicPlayer.playMp4(fileName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　4、创建实现了 MediaPlayer 接口的实体类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AudioPlayer</span> <span class="keyword">implements</span> <span class="title">MediaPlayer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MediaAdapter mediaAdapter; <span class="comment">//添加一个媒体MediaAdapter 使得AudioPlayer 支持播放视频。</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">(String audioType, String fileName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(audioType.equalsIgnoreCase(<span class="string">"mp3"</span>))&#123;</span><br><span class="line">            System.out.println(<span class="string">"Playing mp3 file. name: "</span>+fileName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(audioType.equalsIgnoreCase(<span class="string">"vlc"</span>) || audioType.equalsIgnoreCase(<span class="string">"mp4"</span>))&#123;</span><br><span class="line">            mediaAdapter = <span class="keyword">new</span> MediaAdapter(audioType);</span><br><span class="line">            mediaAdapter.play(audioType,fileName);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"Invalid media. "</span>+audioType+<span class="string">" format not supported"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　5、使用 AudioPlayer 来播放不同类型的音频格式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AdapterPatternDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AudioPlayer audioPlayer = <span class="keyword">new</span> AudioPlayer();</span><br><span class="line"></span><br><span class="line">        audioPlayer.play(<span class="string">"mp3"</span>, <span class="string">"beyond the horizon.mp3"</span>);</span><br><span class="line">        audioPlayer.play(<span class="string">"mp4"</span>, <span class="string">"alone.mp4"</span>);</span><br><span class="line">        audioPlayer.play(<span class="string">"vlc"</span>, <span class="string">"far far away.vlc"</span>);</span><br><span class="line">        audioPlayer.play(<span class="string">"avi"</span>, <span class="string">"mind me.avi"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　输出：</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/qXJ7ojevdfKGLl5.png" alt="img"></p>
<p> 参考：<a href="https://www.runoob.com/design-pattern/adapter-pattern.html" target="_blank" rel="noopener">https://www.runoob.com/design-pattern/adapter-pattern.html</a></p>
<h3 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h3><p>桥接（Bridge）是用于<strong>把抽象化与实现化解耦，使二者可以独立变化</strong>。它通过提供抽象化和实现化之间的桥接结构，来实现二者的解耦。</p>
<p>这种模式涉及到一个作为桥接的接口，使得实体类的功能独立于接口实现类。这两种类型的类可被结构化改变而互不影响。</p>
<p>我们通过下面的实例来演示桥接模式（Bridge Pattern）的用法。其中，可以使用相同的抽象类方法但是不同的桥接实现类，来画出不同颜色的圆。</p>
<p><strong>介绍</strong></p>
<p><strong>意图：</strong>将抽象部分与实现部分分离，使它们都可以独立的变化。</p>
<p><strong>主要解决：</strong>在有多种可能会变化的情况下，用继承会造成类爆炸问题，扩展起来不灵活。</p>
<p><strong>何时使用：</strong>实现系统可能有多个角度分类，每一种角度都可能变化。</p>
<p><strong>如何解决：</strong>把这种多角度分类分离出来，让它们独立变化，减少它们之间耦合。</p>
<p><strong>关键代码：</strong>抽象类依赖实现类。</p>
<p><strong>应用实例：</strong> 1、猪八戒从天蓬元帅转世投胎到猪，转世投胎的机制将尘世划分为两个等级，即：灵魂和肉体，前者相当于抽象化，后者相当于实现化。生灵通过功能的委派，调用肉体对象的功能，使得生灵可以动态地选择。 2、墙上的开关，可以看到的开关是抽象的，不用管里面具体怎么实现的。</p>
<p><strong>优点：</strong> 1、抽象和实现的分离。 2、优秀的扩展能力。 3、实现细节对客户透明。</p>
<p><strong>缺点：</strong>桥接模式的引入会增加系统的理解与设计难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计与编程。</p>
<p><strong>使用场景：</strong> 1、如果一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性，避免在两个层次之间建立静态的继承联系，通过桥接模式可以使它们在抽象层建立一个关联关系。 2、对于那些不希望使用继承或因为多层次继承导致系统类的个数急剧增加的系统，桥接模式尤为适用。 3、一个类存在两个独立变化的维度，且这两个维度都需要进行扩展。</p>
<p><strong>注意事项：</strong>对于两个独立变化的维度，使用桥接模式再适合不过了。</p>
<p><strong>实现</strong></p>
<p>我们有一个作为桥接实现的 <em>DrawAPI</em> 接口和实现了 <em>DrawAPI</em> 接口的实体类 <em>RedCircle<em>、</em>GreenCircle<em>。</em>Shape</em> 是一个抽象类，将使用 <em>DrawAPI</em> 的对象。<em>BridgePatternDemo*，我们的演示类使用 *Shape</em> 类来画出不同颜色的圆。</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/glISfaxoyCGMEwv.png" alt="img"></p>
<p>1、创建桥接接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DrawAPI</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(<span class="keyword">int</span> radius, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、创建实现了 DrawAPI 接口的实体桥接实现类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlueCircle</span> <span class="keyword">implements</span> <span class="title">DrawAPI</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(<span class="keyword">int</span> radius, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Drawing Circle[ color: blue, radius: "</span>+radius+<span class="string">", x: "</span>+x+<span class="string">", y: "</span>+y+<span class="string">"]"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedCircle</span> <span class="keyword">implements</span> <span class="title">DrawAPI</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(<span class="keyword">int</span> radius, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Drawing Circle[ color: red, radius: "</span>+radius+<span class="string">", x: "</span>+x+<span class="string">", y: "</span>+y+<span class="string">"]"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、使用 DrawAPI 接口创建抽象类 Shape</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> DrawAPI drawAPI;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">Shape</span><span class="params">(DrawAPI drawAPI)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.drawAPI = drawAPI;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4、创建继承了 Shape 的实体类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> x, y, radius;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Circle</span><span class="params">(<span class="keyword">int</span> radius, <span class="keyword">int</span> x, <span class="keyword">int</span> y, DrawAPI drawAPI)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(drawAPI);</span><br><span class="line">        <span class="keyword">this</span>.radius = radius;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>&#123;</span><br><span class="line">        drawAPI.draw(radius,x,y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5、使用 Shape 和 DrawAPI 类画出不同的圆</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BridgePatternDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Shape redCircle = <span class="keyword">new</span> Circle(<span class="number">100</span>,<span class="number">100</span>,<span class="number">10</span>,<span class="keyword">new</span> RedCircle());</span><br><span class="line">        Shape blueCircle = <span class="keyword">new</span> Circle(<span class="number">100</span>,<span class="number">100</span>,<span class="number">10</span>,<span class="keyword">new</span> BlueCircle());</span><br><span class="line"></span><br><span class="line">        redCircle.draw();</span><br><span class="line">        blueCircle.draw();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/qZgEOrWUYe3VmzN.png" alt="img"></p>
<p>我们将Circle的抽象和具体的实现分离开，DrawAPI 作为桥接接口，具体的实现类实现 DrawAPI 的接口，当需要画各种类型的圆时通过 DrawAPI 来实现。对比传统的 RedCircle 继承 Circle 类 的方法比较起来，当继承 Circle 类的实体类多起来之后更加容易维护。</p>
<p>参考：<a href="https://www.runoob.com/design-pattern/bridge-pattern.html" target="_blank" rel="noopener">https://www.runoob.com/design-pattern/bridge-pattern.html</a></p>
<h3 id="过滤器模式"><a href="#过滤器模式" class="headerlink" title="过滤器模式"></a>过滤器模式</h3><p>过滤器模式（Filter Pattern）或标准模式（Criteria Pattern）是一种结构型模式，这种模式允许开发人员使用不同的标准来过滤一组对象，通过逻辑运算以解耦的方式把他们连接起来，它结合多个标准来获得单一标准。</p>
<p><strong>实现</strong></p>
<p>我们将创建一个 Person 对象、Cirteria 接口 和实现了该接口的实体类，来过滤 Person 对象的列表。CriteriaPatternDemo，我们的演示类使用 Criteria 对象，基于各种标准和它们的结合来过滤对象的列表。</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/Ur5lMxPp6IqJf8e.png" alt="img"></p>
<p> 1、创建一个 Person 类，在该类上应用标准。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String gender;</span><br><span class="line">    <span class="keyword">private</span> String maritalStatus;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, String gender, String maritalStatus)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.gender = gender;</span><br><span class="line">        <span class="keyword">this</span>.maritalStatus = maritalStatus;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getGender</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> gender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMaritalStatus</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> maritalStatus;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Person&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", gender='"</span> + gender + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", maritalStatus='"</span> + maritalStatus + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、为标准（Criteria）创建一个接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Criteria</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Person&gt; <span class="title">meetCriteria</span><span class="params">(List&lt;Person&gt; persons)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、创建实现了 Criteria 接口的实体类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CriteriaMale</span> <span class="keyword">implements</span> <span class="title">Criteria</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Person&gt; <span class="title">meetCriteria</span><span class="params">(List&lt;Person&gt; persons)</span> </span>&#123;</span><br><span class="line">        List&lt;Person&gt; malePersons = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Person person : persons) &#123;</span><br><span class="line">            <span class="keyword">if</span>(person.getGender().equalsIgnoreCase(<span class="string">"MALE"</span>))&#123;</span><br><span class="line">                malePersons.add(person);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> malePersons;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CriteriaFemale</span> <span class="keyword">implements</span> <span class="title">Criteria</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Person&gt; <span class="title">meetCriteria</span><span class="params">(List&lt;Person&gt; persons)</span> </span>&#123;</span><br><span class="line">        List&lt;Person&gt; femalePersons = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Person person : persons) &#123;</span><br><span class="line">            <span class="keyword">if</span>(person.getGender().equalsIgnoreCase(<span class="string">"FEMALE"</span>))&#123;</span><br><span class="line">                femalePersons.add(person);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> femalePersons;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CriteriaSingle</span> <span class="keyword">implements</span> <span class="title">Criteria</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Person&gt; <span class="title">meetCriteria</span><span class="params">(List&lt;Person&gt; persons)</span> </span>&#123;</span><br><span class="line">        List&lt;Person&gt; singlePersons = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Person person : persons) &#123;</span><br><span class="line">            <span class="keyword">if</span>(person.getMaritalStatus().equalsIgnoreCase(<span class="string">"SINGLE"</span>))&#123;</span><br><span class="line">                singlePersons.add(person);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singlePersons;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AndCriteria</span> <span class="keyword">implements</span> <span class="title">Criteria</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Criteria criteria;</span><br><span class="line">    <span class="keyword">private</span> Criteria otherCriteria;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AndCriteria</span><span class="params">(Criteria criteria, Criteria otherCriteria)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.criteria = criteria;</span><br><span class="line">        <span class="keyword">this</span>.otherCriteria = otherCriteria;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Person&gt; <span class="title">meetCriteria</span><span class="params">(List&lt;Person&gt; persons)</span> </span>&#123;</span><br><span class="line">        List&lt;Person&gt; firstCriteriaPersons = criteria.meetCriteria(persons);</span><br><span class="line">        <span class="keyword">return</span> otherCriteria.meetCriteria(firstCriteriaPersons);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrCriteria</span> <span class="keyword">implements</span> <span class="title">Criteria</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Criteria criteria;</span><br><span class="line">    <span class="keyword">private</span> Criteria otherCriteria;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OrCriteria</span><span class="params">(Criteria criteria, Criteria otherCriteria)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.criteria = criteria;</span><br><span class="line">        <span class="keyword">this</span>.otherCriteria = otherCriteria;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Person&gt; <span class="title">meetCriteria</span><span class="params">(List&lt;Person&gt; persons)</span> </span>&#123;</span><br><span class="line">        List&lt;Person&gt; firstCriteriaItems = criteria.meetCriteria(persons);</span><br><span class="line">        List&lt;Person&gt; otherCriteriaItems = otherCriteria.meetCriteria(persons);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Person person : otherCriteriaItems) &#123;</span><br><span class="line">            <span class="keyword">if</span>(! firstCriteriaItems.contains(person))&#123;</span><br><span class="line">                firstCriteriaItems.add(person);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> firstCriteriaItems;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4、使用不同的标准（Criteria）和它们的结合来过滤 Person 对象的列表</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CriteriaPatternDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Person&gt; persons = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        persons.add(<span class="keyword">new</span> Person(<span class="string">"Robert"</span>,<span class="string">"Male"</span>, <span class="string">"Single"</span>));</span><br><span class="line">        persons.add(<span class="keyword">new</span> Person(<span class="string">"John"</span>,<span class="string">"Male"</span>, <span class="string">"Married"</span>));</span><br><span class="line">        persons.add(<span class="keyword">new</span> Person(<span class="string">"Laura"</span>,<span class="string">"Female"</span>, <span class="string">"Married"</span>));</span><br><span class="line">        persons.add(<span class="keyword">new</span> Person(<span class="string">"Diana"</span>,<span class="string">"Female"</span>, <span class="string">"Single"</span>));</span><br><span class="line">        persons.add(<span class="keyword">new</span> Person(<span class="string">"Mike"</span>,<span class="string">"Male"</span>, <span class="string">"Single"</span>));</span><br><span class="line">        persons.add(<span class="keyword">new</span> Person(<span class="string">"Bobby"</span>,<span class="string">"Male"</span>, <span class="string">"Single"</span>));</span><br><span class="line"></span><br><span class="line">        Criteria male = <span class="keyword">new</span> CriteriaMale();</span><br><span class="line">        Criteria female = <span class="keyword">new</span> CriteriaFemale();</span><br><span class="line">        Criteria single = <span class="keyword">new</span> CriteriaSingle();</span><br><span class="line">        Criteria singleMale = <span class="keyword">new</span> AndCriteria(single,male);</span><br><span class="line">        Criteria singleOrFemale = <span class="keyword">new</span> OrCriteria(single,female);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"Males: "</span>);</span><br><span class="line">        printPersons(male.meetCriteria(persons));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"Females: "</span>);</span><br><span class="line">        printPersons(female.meetCriteria(persons));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"Single Males: "</span>);</span><br><span class="line">        printPersons(singleMale.meetCriteria(persons));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"Single Or Females: "</span>);</span><br><span class="line">        printPersons(singleOrFemale.meetCriteria(persons));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printPersons</span><span class="params">(List&lt;Person&gt; persons)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Person person : persons) &#123;</span><br><span class="line">            System.out.println(person);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/4SnAKm35FyvH7Jp.png" alt="img"></p>
<p> 我们为 Person 建造了多个 Criteria 并利用它们进行过滤。我们还可以将这些标准进行逻辑操作，使用多个标准来对对象进行过滤。</p>
<p>参考：<a href="https://www.runoob.com/design-pattern/filter-pattern.html" target="_blank" rel="noopener">https://www.runoob.com/design-pattern/filter-pattern.html</a></p>
<h3 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h3><p>组合模式（Composite Pattern），又叫部分整体模式，是用于把一组相似得对象当作一个单一得对象。组合模式依据树形结构来组合对象，用来表示部分以及整体层次。它创建了对象组的树形结构。</p>
<p><strong>介绍</strong></p>
<p><strong>意图：</strong>将对象组合成树形结构以表示”部分-整体”的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。</p>
<p><strong>主要解决：</strong>它在我们树型结构的问题中，模糊了简单元素和复杂元素的概念，客户程序可以像处理简单元素一样来处理复杂元素，从而使得客户程序与复杂元素的内部结构解耦。</p>
<p><strong>何时使用：</strong> 1、您想表示对象的部分-整体层次结构（树形结构）。 2、您希望用户忽略组合对象与单个对象的不同，用户将统一地使用组合结构中的所有对象。</p>
<p><strong>如何解决：</strong>树枝和叶子实现统一接口，树枝内部组合该接口。</p>
<p><strong>关键代码：</strong>树枝内部组合该接口，并且含有内部属性 List，里面放 Component。</p>
<p><strong>应用实例：</strong> 1、算术表达式包括操作数、操作符和另一个操作数，其中，另一个操作符也可以是操作数、操作符和另一个操作数。 2、在 JAVA AWT 和 SWING 中，对于 Button 和 Checkbox 是树叶，Container 是树枝。</p>
<p><strong>优点：</strong> 1、高层模块调用简单。 2、节点自由增加。</p>
<p><strong>缺点：</strong>在使用组合模式时，其叶子和树枝的声明都是实现类，而不是接口，违反了依赖倒置原则。</p>
<p><strong>使用场景：</strong>部分、整体场景，如树形菜单，文件、文件夹的管理。</p>
<p><strong>注意事项：</strong>定义时为具体类。</p>
<p><strong>实现</strong></p>
<p>我们有一个类 <em>Employee<em>，该类被当作组合模型类。</em>CompositePatternDemo*，我们的演示类使用 *Employee</em> 类来添加部门层次结构，并打印所有员工。</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/G528HhqwdeyRNTn.png" alt=""></p>
<p> 1、创建 Employee 类，该类带有 Employee 对象的列表。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String dept;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> salary;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Employee&gt; subordinates;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">(String name, String dept, <span class="keyword">int</span> salary)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.dept = dept;</span><br><span class="line">        <span class="keyword">this</span>.salary = salary;</span><br><span class="line">        <span class="keyword">this</span>.subordinates = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Employee employee)</span></span>&#123;</span><br><span class="line">        subordinates.add(employee);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Employee employee)</span></span>&#123;</span><br><span class="line">        subordinates.remove(employee);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Employee&gt; <span class="title">getSubordinates</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> subordinates;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Employee&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", dept='"</span> + dept + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", salary="</span> + salary +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、使用 Employee 类来创建和打印员工的层次结构。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompositePatternDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Employee CEO = <span class="keyword">new</span> Employee(<span class="string">"John"</span>,<span class="string">"CEO"</span>, <span class="number">30000</span>);</span><br><span class="line"></span><br><span class="line">        Employee headSales = <span class="keyword">new</span> Employee(<span class="string">"Robert"</span>,<span class="string">"Head Sales"</span>, <span class="number">20000</span>);</span><br><span class="line"></span><br><span class="line">        Employee headMarketing = <span class="keyword">new</span> Employee(<span class="string">"Michel"</span>,<span class="string">"Head Marketing"</span>, <span class="number">20000</span>);</span><br><span class="line"></span><br><span class="line">        Employee clerk1 = <span class="keyword">new</span> Employee(<span class="string">"Laura"</span>,<span class="string">"Marketing"</span>, <span class="number">10000</span>);</span><br><span class="line">        Employee clerk2 = <span class="keyword">new</span> Employee(<span class="string">"Bob"</span>,<span class="string">"Marketing"</span>, <span class="number">10000</span>);</span><br><span class="line"></span><br><span class="line">        Employee salesExecutive1 = <span class="keyword">new</span> Employee(<span class="string">"Richard"</span>,<span class="string">"Sales"</span>, <span class="number">10000</span>);</span><br><span class="line">        Employee salesExecutive2 = <span class="keyword">new</span> Employee(<span class="string">"Rob"</span>,<span class="string">"Sales"</span>, <span class="number">10000</span>);</span><br><span class="line"></span><br><span class="line">        CEO.add(headSales);</span><br><span class="line">        CEO.add(headMarketing);</span><br><span class="line"></span><br><span class="line">        headSales.add(salesExecutive1);</span><br><span class="line">        headSales.add(salesExecutive2);</span><br><span class="line"></span><br><span class="line">        headMarketing.add(clerk1);</span><br><span class="line">        headMarketing.add(clerk2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//打印所有员工</span></span><br><span class="line">        System.out.println(CEO+<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Employee headEmployee : CEO.getSubordinates()) &#123;</span><br><span class="line">            System.out.println(headEmployee);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (Employee e : headEmployee.getSubordinates()) &#123;</span><br><span class="line">                System.out.println(e);</span><br><span class="line">            &#125;</span><br><span class="line">　　　　　　　System.out.println(<span class="string">""</span>);</span><br><span class="line">&#125; &#125; &#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/XcaLMsK8qEr42ew.png" alt=""></p>
<p> CEO 直接管理销售主管和市场主管，销售主管和市场主管又分别管理自己手下的员工。</p>
<p>参考：<a href="https://www.runoob.com/design-pattern/composite-pattern.html" target="_blank" rel="noopener">https://www.runoob.com/design-pattern/composite-pattern.html</a></p>
<h3 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h3><p>装饰器模式（Decorator Pattern）允许向一个现有的对象添加新的功能，同时又不改变其结构。它是作为现有类的一个包装。</p>
<p>这种模式创建了一个装饰类，用来包装原有的类，并在保持类方法签名完整性的前提下，提供了额外的功能。</p>
<p><strong>介绍</strong></p>
<p><strong>意图：</strong>动态地给一个对象添加一些额外的职责。就增加功能来说，装饰器模式相比生成子类更为灵活。</p>
<p><strong>主要解决：</strong>一般的，我们为了扩展一个类经常使用继承方式实现，由于继承为类引入静态特征，并且随着扩展功能的增多，子类会很膨胀。</p>
<p><strong>何时使用：</strong>在不想增加很多子类的情况下扩展类。</p>
<p><strong>如何解决：</strong>将具体功能职责划分，同时继承装饰者模式。</p>
<p><strong>关键代码：</strong> 1、Component 类充当抽象角色，不应该具体实现。 2、修饰类引用和继承 Component 类，具体扩展类重写父类方法。</p>
<p><strong>应用实例：</strong> 1、孙悟空有 72 变，当他变成”庙宇”后，他的根本还是一只猴子，但是他又有了庙宇的功能。 2、不论一幅画有没有画框都可以挂在墙上，但是通常都是有画框的，并且实际上是画框被挂在墙上。在挂在墙上之前，画可以被蒙上玻璃，装到框子里；这时画、玻璃和画框形成了一个物体。</p>
<p><strong>优点：</strong>装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能。</p>
<p><strong>缺点：</strong>多层装饰比较复杂。</p>
<p><strong>使用场景：</strong> 1、扩展一个类的功能。 2、动态增加功能，动态撤销。</p>
<p><strong>注意事项：</strong>可代替继承。</p>
<p><strong>实现</strong></p>
<p>我们将创建一个 <em>Shape</em> 接口和实现了 <em>Shape</em> 接口的实体类。然后我们创建一个实现了 <em>Shape</em> 接口的抽象装饰类 <em>ShapeDecorator*，并把 *Shape</em> 对象作为它的实例变量。</p>
<p><em>RedShapeDecorator</em> 是实现了 <em>ShapeDecorator</em> 的实体类。</p>
<p><em>DecoratorPatternDemo*，我们的演示类使用 *RedShapeDecorator</em> 来装饰 <em>Shape</em> 对象。</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/h5SvMjW6mnIqJ7u.png" alt="img"></p>
<p> 1、创建一个接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、创建实现接口的实体类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Shape: Rectangle"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Shape: Circle"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、创建实现了 Shape 接口的抽象装饰类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ShapeDecorator</span> <span class="keyword">implements</span> <span class="title">Shape</span></span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> Shape shapeDecorator;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ShapeDecorator</span><span class="params">(Shape shapeDecorator)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.shapeDecorator = shapeDecorator;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        shapeDecorator.draw();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4、创建扩展了 ShapeDecorator 类的实体装饰类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedShapeDecorator</span> <span class="keyword">extends</span> <span class="title">ShapeDecorator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RedShapeDecorator</span><span class="params">(Shape shapeDecorator)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(shapeDecorator);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.draw();</span><br><span class="line">        setRedBorder(shapeDecorator);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setRedBorder</span><span class="params">(Shape decoratedShape)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Board Color: Red"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5、使用 RedShapeDecorator 来装饰 Shape 对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DecoratorPatternDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Shape circle = <span class="keyword">new</span> Circle();</span><br><span class="line">        ShapeDecorator redCircle = <span class="keyword">new</span> RedShapeDecorator(<span class="keyword">new</span> Circle());</span><br><span class="line">        ShapeDecorator redRectangle = <span class="keyword">new</span> RedShapeDecorator(<span class="keyword">new</span> Rectangle());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"Circle with normal boarder"</span>);</span><br><span class="line">        circle.draw();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"\nCircle of red boarder"</span>);</span><br><span class="line">        redCircle.draw();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"\nRectangle of red boarder"</span>);</span><br><span class="line">        redRectangle.draw();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/97bGozjSDYws2Zy.png" alt="img"></p>
<p> 我们使用 RedShapeDecorator 装饰类来对 Shape 对象扩展红色的功能，而不是使用RedCircle 继承 Circle 这种方法，避免了子类膨胀。</p>
<p>参考：<a href="https://www.runoob.com/design-pattern/decorator-pattern.html" target="_blank" rel="noopener">https://www.runoob.com/design-pattern/decorator-pattern.html</a></p>
<h3 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h3><p>外观模式（Facade Pattern）隐藏系统的复杂性，并向客户端提供了一个客户端可以访问系统的接口。它向现有的系统添加一个接口，来隐藏系统的复杂性。该类提供了客户端请求的简化方法和对现有系统类方法的委托调用。</p>
<p><strong>介绍</strong></p>
<p><strong>意图：</strong>为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。</p>
<p><strong>主要解决：</strong>降低访问复杂系统的内部子系统时的复杂度，简化客户端与之的接口。</p>
<p><strong>何时使用：</strong> 1、客户端不需要知道系统内部的复杂联系，整个系统只需提供一个”接待员”即可。 2、定义系统的入口。</p>
<p><strong>如何解决：</strong>客户端不与系统耦合，外观类与系统耦合。</p>
<p><strong>关键代码：</strong>在客户端和复杂系统之间再加一层，这一层将调用顺序、依赖关系等处理好。</p>
<p><strong>应用实例：</strong> 1、去医院看病，可能要去挂号、门诊、划价、取药，让患者或患者家属觉得很复杂，如果有提供接待人员，只让接待人员来处理，就很方便。 2、JAVA 的三层开发模式。</p>
<p><strong>优点：</strong> 1、减少系统相互依赖。 2、提高灵活性。 3、提高了安全性。</p>
<p><strong>缺点：</strong>不符合开闭原则，如果要改东西很麻烦，继承重写都不合适。</p>
<p><strong>使用场景：</strong> 1、为复杂的模块或子系统提供外界访问的模块。 2、子系统相对独立。 3、预防低水平人员带来的风险。</p>
<p><strong>注意事项：</strong>在层次化结构中，可以使用外观模式定义系统中每一层的入口。</p>
<p><strong>实现</strong></p>
<p>我们将创建一个 <em>Shape</em> 接口和实现了 <em>Shape</em> 接口的实体类。下一步是定义一个外观类 <em>ShapeMaker</em>。</p>
<p><em>ShapeMaker</em> 类使用实体类来代表用户对这些类的调用。<em>FacadePatternDemo*，我们的演示类使用 *ShapeMaker</em> 类来显示结果。</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/DMayPn4GSoKTuwm.png" alt="img"></p>
<p> 1、创建一个接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、创建实现接口的实体类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Cricle::draw()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="keyword">implements</span> <span class="title">Shape</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Rectangle::draw()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Square::draw()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、创建一个外观类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShapeMaker</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Shape circle;</span><br><span class="line">    <span class="keyword">private</span> Shape rectangle;</span><br><span class="line">    <span class="keyword">private</span> Shape square;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ShapeMaker</span><span class="params">()</span></span>&#123;</span><br><span class="line">        circle = <span class="keyword">new</span> Circle();</span><br><span class="line">        square = <span class="keyword">new</span> Square();</span><br><span class="line">        rectangle = <span class="keyword">new</span> Rectangle();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawCircle</span><span class="params">()</span></span>&#123;</span><br><span class="line">        circle.draw();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawRectangle</span><span class="params">()</span></span>&#123;</span><br><span class="line">        rectangle.draw();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawSquare</span><span class="params">()</span></span>&#123;</span><br><span class="line">        square.draw();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4、使用该外观类画出各种类型的形状</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FacadePatternDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ShapeMaker shapeMaker = <span class="keyword">new</span> ShapeMaker();</span><br><span class="line"></span><br><span class="line">        shapeMaker.drawCircle();</span><br><span class="line">        shapeMaker.drawRectangle();</span><br><span class="line">        shapeMaker.drawSquare();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/9XTsfaW8yUxkgF3.png" alt="img"></p>
<p> 我们通过 ShapeMaker 类屏蔽了底层的类的实现，仅仅调用接口就可画出各种形状。</p>
<p>参考：<a href="https://www.runoob.com/design-pattern/facade-pattern.html" target="_blank" rel="noopener">https://www.runoob.com/design-pattern/facade-pattern.html</a></p>
<h3 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h3><p>享元模式（Flyweight Pattern）主要用于减少创建对象的数量，以减少内存占用和提高性能。它减少对象数量从而改善应用所需的对象结构的方式。享元模式尝试重用现有的同类对象，如果未找到匹配的对象，则创建对象。</p>
<p><strong>介绍</strong></p>
<p><strong>意图：</strong>运用共享技术有效地支持大量细粒度的对象。</p>
<p><strong>主要解决：</strong>在有大量对象时，有可能会造成内存溢出，我们把其中共同的部分抽象出来，如果有相同的业务请求，直接返回在内存中已有的对象，避免重新创建。</p>
<p><strong>何时使用：</strong> 1、系统中有大量对象。 2、这些对象消耗大量内存。 3、这些对象的状态大部分可以外部化。 4、这些对象可以按照内蕴状态分为很多组，当把外蕴对象从对象中剔除出来时，每一组对象都可以用一个对象来代替。 5、系统不依赖于这些对象身份，这些对象是不可分辨的。</p>
<p><strong>如何解决：</strong>用唯一标识码判断，如果在内存中有，则返回这个唯一标识码所标识的对象。</p>
<p><strong>关键代码：</strong>用 HashMap 存储这些对象。</p>
<p><strong>应用实例：</strong> 1、JAVA 中的 String，如果有则返回，如果没有则创建一个字符串保存在字符串缓存池里面。 2、数据库的数据池。</p>
<p><strong>优点：</strong>大大减少对象的创建，降低系统的内存，使效率提高。</p>
<p><strong>缺点：</strong>提高了系统的复杂度，需要分离出外部状态和内部状态，而且外部状态具有固有化的性质，不应该随着内部状态的变化而变化，否则会造成系统的混乱。</p>
<p><strong>使用场景：</strong> 1、系统有大量相似对象。 2、需要缓冲池的场景。</p>
<p><strong>注意事项：</strong> 1、注意划分外部状态和内部状态，否则可能会引起线程安全问题。 2、这些类必须有一个工厂对象加以控制。</p>
<p><strong>实现</strong></p>
<p>我们将创建一个 <em>Shape</em> 接口和实现了 <em>Shape</em> 接口的实体类 <em>Circle</em>。下一步是定义工厂类 <em>ShapeFactory</em>。</p>
<p><em>ShapeFactory</em> 有一个 <em>Circle</em> 的 <em>HashMap*，其中键名为 *Circle</em> 对象的颜色。无论何时接收到请求，都会创建一个特定颜色的圆。<em>ShapeFactory</em> 检查它的 <em>HashMap</em> 中的 circle 对象，如果找到 <em>Circle</em> 对象，则返回该对象，否则将创建一个存储在 hashmap 中以备后续使用的新对象，并把该对象返回到客户端。</p>
<p><em>FlyWeightPatternDemo*，我们的演示类使用 *ShapeFactory</em> 来获取 <em>Shape</em> 对象。它将向 <em>ShapeFactory</em> 传递信息（<em>red / green / blue/ black / white</em>），以便获取它所需对象的颜色。</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/mkq83nVXFwSI6Kp.png" alt="img"></p>
<p> 1、创建一个接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、创建实现接口的实体类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String color;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> y;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> radius;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Circle</span><span class="params">(String color)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setX</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setY</span><span class="params">(<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRadius</span><span class="params">(<span class="keyword">int</span> radius)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.radius = radius;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"circle::draw() [color: "</span>+color+<span class="string">", x: "</span>+x+<span class="string">", y: "</span>+y+<span class="string">", radius: "</span>+radius+<span class="string">"]"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、创建一个工厂，生成基于给定信息的实体类的对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShapeFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> HashMap&lt;String,Shape&gt; circleMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Shape <span class="title">getShape</span><span class="params">(String color)</span></span>&#123;</span><br><span class="line">        Circle circle = (Circle)circleMap.get(color);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(circle == <span class="keyword">null</span>)&#123;</span><br><span class="line">            circle = <span class="keyword">new</span> Circle(color);</span><br><span class="line">            circleMap.put(color,circle);</span><br><span class="line">            System.out.println(<span class="string">"Creating circle of color: "</span>+color);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> circle;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4、使用该工厂，通过传递颜色信息来获取实体类的对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlyWeightDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String colors[]=&#123;<span class="string">"Red"</span>,<span class="string">"Green"</span>,<span class="string">"Blue"</span>,<span class="string">"White"</span>,<span class="string">"Black"</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            Circle circle = (Circle)ShapeFactory.getShape(getRandomColor());</span><br><span class="line">            circle.setRadius(<span class="number">100</span>);</span><br><span class="line">            circle.setX(getRandomX());</span><br><span class="line">            circle.setY(getRandomY());</span><br><span class="line">            circle.draw();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">getRandomColor</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> colors[(<span class="keyword">int</span>)Math.random()* colors.length];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getRandomX</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)(Math.random()*<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getRandomY</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)(Math.random()*<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/E7unTaG5r1qLNU6.png" alt="img"></p>
<p> 我们重用了 key 为红色的圆。</p>
<h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><p><strong>意图：</strong>为其他对象提供一种代理以控制对这个对象的访问。</p>
<p><strong>主要解决：</strong>在直接访问对象时带来的问题，比如说：要访问的对象在远程的机器上。在面向对象系统中，有些对象由于某些原因（比如对象创建开销很大，或者某些操作需要安全控制，或者需要进程外的访问），直接访问会给使用者或者系统结构带来很多麻烦，我们可以在访问此对象时加上一个对此对象的访问层。</p>
<p><strong>何时使用：</strong>想在访问一个类时做一些控制。</p>
<p><strong>如何解决：</strong>增加中间层。</p>
<p><strong>关键代码：</strong>实现与被代理类组合。</p>
<p><strong>应用实例：</strong> 1、Windows 里面的快捷方式。 2、猪八戒去找高翠兰结果是孙悟空变的，可以这样理解：把高翠兰的外貌抽象出来，高翠兰本人和孙悟空都实现了这个接口，猪八戒访问高翠兰的时候看不出来这个是孙悟空，所以说孙悟空是高翠兰代理类。 3、买火车票不一定在火车站买，也可以去代售点。 4、一张支票或银行存单是账户中资金的代理。支票在市场交易中用来代替现金，并提供对签发人账号上资金的控制。 5、spring aop。</p>
<p><strong>优点：</strong> 1、职责清晰。 2、高扩展性。 3、智能化。</p>
<p><strong>缺点：</strong> 1、由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢。 2、实现代理模式需要额外的工作，有些代理模式的实现非常复杂。</p>
<p><strong>使用场景：</strong>按职责来划分，通常有以下使用场景： 1、远程代理。 2、虚拟代理。 3、Copy-on-Write 代理。 4、保护（Protect or Access）代理。 5、Cache代理。 6、防火墙（Firewall）代理。 7、同步化（Synchronization）代理。 8、智能引用（Smart Reference）代理。</p>
<p><strong>注意事项：</strong> 1、和适配器模式的区别：适配器模式主要改变所考虑对象的接口，而代理模式不能改变所代理类的接口。 2、和装饰器模式的区别：装饰器模式为了增强功能，而代理模式是为了加以控制。</p>
<p><strong>实现</strong></p>
<p>我们将创建一个 <em>Image</em> 接口和实现了 <em>Image</em> 接口的实体类。<em>ProxyImage</em> 是一个代理类，减少 <em>RealImage</em> 对象加载的内存占用。</p>
<p><em>ProxyPatternDemo*，我们的演示类使用 *ProxyImage</em> 来获取要加载的 <em>Image</em> 对象，并按照需求进行显示。</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/sFxj37SopKEcz5T.png" alt="img"></p>
<p> 1、创建一个接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Image</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、创建实现接口得实体类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RealImage</span> <span class="keyword">implements</span> <span class="title">Image</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String filename;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RealImage</span><span class="params">(String filename)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.filename = filename;</span><br><span class="line">        loadFromDisk(filename);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Displaying "</span>+filename);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadFromDisk</span><span class="params">(String filename)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Loading "</span>+filename);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyImage</span> <span class="keyword">implements</span> <span class="title">Image</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> RealImage realImage;</span><br><span class="line">    <span class="keyword">private</span> String filename;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProxyImage</span><span class="params">(String filename)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.filename = filename;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(realImage == <span class="keyword">null</span>)&#123;</span><br><span class="line">            realImage = <span class="keyword">new</span> RealImage(filename);</span><br><span class="line">        &#125;</span><br><span class="line">        realImage.display();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、当被请求时，使用 ProxyImage 来获取 RealImage 类的对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyPatternDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Image image = <span class="keyword">new</span> ProxyImage(<span class="string">"test.jpg"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从磁盘加载</span></span><br><span class="line">        image.display();</span><br><span class="line">        <span class="comment">//不需要从磁盘加载</span></span><br><span class="line">        image.display();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/qnfFXHh23agZoIO.png" alt="img"></p>
<p> 参考：<a href="https://www.runoob.com/design-pattern/proxy-pattern.html" target="_blank" rel="noopener">https://www.runoob.com/design-pattern/proxy-pattern.html</a></p>
<h2 id="行为型模式"><a href="#行为型模式" class="headerlink" title="行为型模式"></a>行为型模式</h2><p>对象与对象在干嘛</p>
<p>这些设计模式特别关注对象之间的通信。</p>
<h3 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h3><p>责任链模式（Chain of Responsibility Pattern）为请求创建了一个接收者对象的链。这种模式给予请求的类型，对请求的发送者和接收者进行解耦。</p>
<p>在这种模式中，通常每个接收者都包含对另一个接收者的引用。如果一个对象不能处理该请求，那么它会把相同的请求传给下一个接收者，依此类推。</p>
<p><strong>介绍</strong></p>
<p><strong>意图：</strong>避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。</p>
<p><strong>主要解决：</strong>职责链上的处理者负责处理请求，客户只需要将请求发送到职责链上即可，无须关心请求的处理细节和请求的传递，所以职责链将请求的发送者和请求的处理者解耦了。</p>
<p><strong>何时使用：</strong>在处理消息的时候以过滤很多道。</p>
<p><strong>如何解决：</strong>拦截的类都实现统一接口。</p>
<p><strong>关键代码：</strong>Handler 里面聚合它自己，在 HandlerRequest 里判断是否合适，如果没达到条件则向下传递，向谁传递之前 set 进去。</p>
<p><strong>应用实例：</strong> 1、红楼梦中的”击鼓传花”。 2、JS 中的事件冒泡。 3、JAVA WEB 中 Apache Tomcat 对 Encoding 的处理，Struts2 的拦截器，jsp servlet 的 Filter。</p>
<p><strong>优点：</strong> 1、降低耦合度。它将请求的发送者和接收者解耦。 2、简化了对象。使得对象不需要知道链的结构。 3、增强给对象指派职责的灵活性。通过改变链内的成员或者调动它们的次序，允许动态地新增或者删除责任。 4、增加新的请求处理类很方便。</p>
<p><strong>缺点：</strong> 1、不能保证请求一定被接收。 2、系统性能将受到一定影响，而且在进行代码调试时不太方便，可能会造成循环调用。 3、可能不容易观察运行时的特征，有碍于除错。</p>
<p><strong>使用场景：</strong> 1、有多个对象可以处理同一个请求，具体哪个对象处理该请求由运行时刻自动确定。 2、在不明确指定接收者的情况下，向多个对象中的一个提交一个请求。 3、可动态指定一组对象处理请求。</p>
<p><strong>注意事项：</strong>在 JAVA WEB 中遇到很多应用。</p>
<p><strong>实现</strong></p>
<p>我们创建抽象类 <em>AbstractLogger</em>，带有详细的日志记录级别。然后我们创建三种类型的记录器，都扩展了 <em>AbstractLogger</em>。每个记录器消息的级别是否属于自己的级别，如果是则相应地打印出来，否则将不打印并把消息传给下一个记录器。</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/MXIskRUb7u6FYyr.png" alt="img"></p>
<p> 1、创建抽象的记录器类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractLogger</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> INFO = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> DEBUG = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> ERROR = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> level;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> AbstractLogger nextLogger;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNextLogger</span><span class="params">(AbstractLogger nextLogger)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.nextLogger = nextLogger;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logMessage</span><span class="params">(<span class="keyword">int</span> level, String message)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.level &lt;= level)&#123;</span><br><span class="line">            write(message);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nextLogger != <span class="keyword">null</span>)&#123;</span><br><span class="line">            nextLogger.logMessage(level,message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(String message)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、创建扩展了该记录器的实体类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsoleLogger</span> <span class="keyword">extends</span> <span class="title">AbstractLogger</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConsoleLogger</span><span class="params">(<span class="keyword">int</span> level)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.level = level;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Standard Console::Logger: "</span>+message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ErrorLogger</span> <span class="keyword">extends</span> <span class="title">AbstractLogger</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ErrorLogger</span><span class="params">(<span class="keyword">int</span> level)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.level = level;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Error Console::Logger: "</span>+message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileLogger</span> <span class="keyword">extends</span> <span class="title">AbstractLogger</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FileLogger</span><span class="params">(<span class="keyword">int</span> level)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.level = level;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"File::Logger: "</span>+message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、创建不同类型的记录器。赋予它们不同的错误级别，并在每个记录器中设置下一个记录器。每个记录器中的下一个记录器代表的是链的一部分。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChainPatternDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> AbstractLogger <span class="title">getChainOfLoggers</span><span class="params">()</span></span>&#123;</span><br><span class="line">        AbstractLogger errorLogger = <span class="keyword">new</span> ErrorLogger(AbstractLogger.ERROR);</span><br><span class="line">        AbstractLogger fileLogger = <span class="keyword">new</span> FileLogger(AbstractLogger.DEBUG);</span><br><span class="line">        AbstractLogger consoleLogger = <span class="keyword">new</span> ConsoleLogger(AbstractLogger.INFO);</span><br><span class="line"></span><br><span class="line">        errorLogger.setNextLogger(fileLogger);</span><br><span class="line">        fileLogger.setNextLogger(consoleLogger);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> errorLogger;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AbstractLogger loggerChain = getChainOfLoggers();</span><br><span class="line"></span><br><span class="line">        loggerChain.logMessage(AbstractLogger.INFO,<span class="string">"This is an information."</span>);</span><br><span class="line">        loggerChain.logMessage(AbstractLogger.DEBUG,<span class="string">"This is a debug level information."</span>);</span><br><span class="line">        loggerChain.logMessage(AbstractLogger.ERROR,<span class="string">"This is an error information."</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/782Gsvf6c4rCl9h.png" alt="img"></p>
<p> 责任链 Error – File – Console </p>
<p>参考：<a href="https://www.runoob.com/design-pattern/chain-of-responsibility-pattern.html" target="_blank" rel="noopener">https://www.runoob.com/design-pattern/chain-of-responsibility-pattern.html</a></p>
<h3 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h3><p>命令模式（Command Pattern）是一种数据驱动的设计模式，它属于行为型模式。请求以命令的形式包裹在对象中，并传给调用对象。调用对象寻找可以处理该命令的合适的对象，并把该命令传给相应的对象，该对象执行命令。</p>
<p><strong>介绍</strong></p>
<p><strong>意图：</strong>将一个请求封装成一个对象，从而使您可以用不同的请求对客户进行参数化。</p>
<p><strong>主要解决：</strong>在软件系统中，行为请求者与行为实现者通常是一种紧耦合的关系，但某些场合，比如需要对行为进行记录、撤销或重做、事务等处理时，这种无法抵御变化的紧耦合的设计就不太合适。</p>
<p><strong>何时使用：</strong>在某些场合，比如要对行为进行”记录、撤销/重做、事务”等处理，这种无法抵御变化的紧耦合是不合适的。在这种情况下，如何将”行为请求者”与”行为实现者”解耦？将一组行为抽象为对象，可以实现二者之间的松耦合。</p>
<p><strong>如何解决：</strong>通过调用者调用接受者执行命令，顺序：调用者→接受者→命令。</p>
<p><strong>关键代码：</strong>定义三个角色：1、received 真正的命令执行对象 2、Command 3、invoker 使用命令对象的入口</p>
<p><strong>应用实例：</strong>struts 1 中的 action 核心控制器 ActionServlet 只有一个，相当于 Invoker，而模型层的类会随着不同的应用有不同的模型类，相当于具体的 Command。</p>
<p><strong>优点：</strong> 1、降低了系统耦合度。 2、新的命令可以很容易添加到系统中去。</p>
<p><strong>缺点：</strong>使用命令模式可能会导致某些系统有过多的具体命令类。</p>
<p><strong>使用场景：</strong>认为是命令的地方都可以使用命令模式，比如： 1、GUI 中每一个按钮都是一条命令。 2、模拟 CMD。</p>
<p><strong>注意事项：</strong>系统需要支持命令的撤销(Undo)操作和恢复(Redo)操作，也可以考虑使用命令模式，见命令模式的扩展。</p>
<p><strong>实现</strong></p>
<p>我们首先创建作为命令的接口 <em>Order*，然后创建作为请求的 *Stock</em> 类。实体命令类 <em>BuyStock</em> 和 <em>SellStock*，实现了 *Order</em> 接口，将执行实际的命令处理。创建作为调用对象的类 <em>Broker</em>，它接受订单并能下订单。</p>
<p><em>Broker</em> 对象使用命令模式，基于命令的类型确定哪个对象执行哪个命令。<em>CommandPatternDemo*，我们的演示类使用 *Broker</em> 类来演示命令模式。</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/AeWPFhvN1DkM6KZ.png" alt="img"></p>
<p> 1、创建一个命令接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Order</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、创建一个请求类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Stock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name = <span class="string">"ABC"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> quantity = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buy</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Stick [ Name: "</span>+name+<span class="string">",Quantity: "</span>+quantity+<span class="string">" ] bought"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sell</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Stick [ Name: "</span>+name+<span class="string">",Quantity: "</span>+quantity+<span class="string">" ] sold"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、创建实现了 Order 接口的实体类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BuyStock</span> <span class="keyword">implements</span> <span class="title">Order</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Stock abcStock;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BuyStock</span><span class="params">(Stock abcStock)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.abcStock = abcStock;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>&#123;</span><br><span class="line">        abcStock.buy();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SellStock</span> <span class="keyword">implements</span> <span class="title">Order</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Stock abcStock;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SellStock</span><span class="params">(Stock abcStock)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.abcStock = abcStock;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        abcStock.sell();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4、创建命令调用类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Broker</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Order&gt; orderList = <span class="keyword">new</span> ArrayList&lt;Order&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">takeOrder</span><span class="params">(Order order)</span></span>&#123;</span><br><span class="line">        orderList.add(order);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">placeOrders</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Order order : orderList) &#123;</span><br><span class="line">            order.execute();</span><br><span class="line">        &#125;</span><br><span class="line">        orderList.clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5、使用Broker类来接收并执行命令</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommandPatternDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Stock abcStock = <span class="keyword">new</span> Stock();</span><br><span class="line"></span><br><span class="line">        BuyStock buyStockOrder = <span class="keyword">new</span> BuyStock(abcStock);</span><br><span class="line">        SellStock sellStockOrder = <span class="keyword">new</span> SellStock(abcStock);</span><br><span class="line"></span><br><span class="line">        Broker broker = <span class="keyword">new</span> Broker();</span><br><span class="line">        broker.takeOrder(buyStockOrder);</span><br><span class="line">        broker.takeOrder(sellStockOrder);</span><br><span class="line"></span><br><span class="line">        broker.placeOrders();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/IgkvH23pxEWoKDc.png" alt="img"></p>
<p> 参考：<a href="https://www.runoob.com/design-pattern/command-pattern.htm" target="_blank" rel="noopener">https://www.runoob.com/design-pattern/command-pattern.htm</a></p>
<h3 id="解释器模式"><a href="#解释器模式" class="headerlink" title="解释器模式"></a>解释器模式</h3><p>解释器模式（Interpreter Pattern）提供了评估语言的语法或表达式的方式。这种模式实现了一个表达式接口，该接口解释一个特定的上下文。这种模式被用在SQL解析、符号处理引擎等。</p>
<p><strong>介绍</strong></p>
<p><strong>意图：</strong>给定一个语言，定义它的文法表示，并定义一个解释器，这个解释器使用该标识来解释语言中的句子。</p>
<p><strong>主要解决：</strong>对于一些固定文法构建一个解释句子的解释器。</p>
<p><strong>何时使用：</strong>如果一种特定类型的问题发生的频率足够高，那么可能就值得将该问题的各个实例表述为一个简单语言中的句子。这样就可以构建一个解释器，该解释器通过解释这些句子来解决该问题。</p>
<p><strong>如何解决：</strong>构建语法树，定义终结符与非终结符。</p>
<p><strong>关键代码：</strong>构建环境类，包含解释器之外的一些全局信息，一般是 HashMap。</p>
<p><strong>应用实例：</strong>编译器、运算表达式计算。</p>
<p><strong>优点：</strong> 1、可扩展性比较好，灵活。 2、增加了新的解释表达式的方式。 3、易于实现简单文法。</p>
<p><strong>缺点：</strong> 1、可利用场景比较少。 2、对于复杂的文法比较难维护。 3、解释器模式会引起类膨胀。 4、解释器模式采用递归调用方法。</p>
<p><strong>使用场景：</strong> 1、可以将一个需要解释执行的语言中的句子表示为一个抽象语法树。 2、一些重复出现的问题可以用一种简单的语言来进行表达。 3、一个简单语法需要解释的场景。</p>
<p><strong>注意事项：</strong>可利用场景比较少，JAVA 中如果碰到可以用 expression4J 代替。</p>
<p><strong>实现</strong></p>
<p>我们将创建一个接口 <em>Expression</em> 和实现了 <em>Expression</em> 接口的实体类。定义作为上下文中主要解释器的 <em>TerminalExpression</em> 类。其他的类 <em>OrExpression<em>、</em>AndExpression</em> 用于创建组合式表达式。</p>
<p><em>InterpreterPatternDemo*，我们的演示类使用 *Expression</em> 类创建规则和演示表达式的解析。</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/xZSyeB81snaL2Pp.png" alt="img"></p>
<p> 1、创建一个表达式接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Expression</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">interpret</span><span class="params">(String context)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、创建实现了上述接口的实体类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TerminalExpression</span> <span class="keyword">implements</span> <span class="title">Expression</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String data;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TerminalExpression</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">interpret</span><span class="params">(String context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(context.contains(data))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AndExpression</span> <span class="keyword">implements</span> <span class="title">Expression</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Expression expr1 = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> Expression expr2 = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AndExpression</span><span class="params">(Expression expr1, Expression expr2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.expr1 = expr1;</span><br><span class="line">        <span class="keyword">this</span>.expr2 = expr2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">interpret</span><span class="params">(String context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> expr1.interpret(context) &amp;&amp; expr2.interpret(context);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrExpression</span> <span class="keyword">implements</span> <span class="title">Expression</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Expression expr1 = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> Expression expr2 = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OrExpression</span><span class="params">(Expression expr1, Expression expr2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.expr1 = expr1;</span><br><span class="line">        <span class="keyword">this</span>.expr2 = expr2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">interpret</span><span class="params">(String context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> expr1.interpret(context) || expr2.interpret(context);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、InterpreterPatternDemo 使用 Expression 类来创建规则，并解析它们。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterpreterPatternDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Expression <span class="title">getMaleExpression</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Expression robert = <span class="keyword">new</span> TerminalExpression(<span class="string">"Robert"</span>);</span><br><span class="line">        Expression john = <span class="keyword">new</span> TerminalExpression(<span class="string">"John"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> OrExpression(robert,john);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Expression <span class="title">getMarriedWomanExpression</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Expression julie = <span class="keyword">new</span> TerminalExpression(<span class="string">"Julie"</span>);</span><br><span class="line">        Expression married = <span class="keyword">new</span> TerminalExpression(<span class="string">"Married"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AndExpression(julie,married);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Expression isMale = getMaleExpression();</span><br><span class="line">    Expression isMarriedWoman = getMarriedWomanExpression();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"John is male? "</span>+isMale.interpret(<span class="string">"John"</span>));</span><br><span class="line">        System.out.println(<span class="string">"Julie is a married women? "</span>+isMarriedWoman.interpret(<span class="string">"Married Julie"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/47dmlKVrqYuaUxF.png" alt="img"></p>
<p> 参考：<a href="https://www.runoob.com/design-pattern/interpreter-pattern.html" target="_blank" rel="noopener">https://www.runoob.com/design-pattern/interpreter-pattern.html</a></p>
<h3 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h3><p>迭代器模式（Iterator Pattern ）用于顺序访问集合对象的元素，不需要知道集合对象的底层表示。</p>
<p><strong>介绍</strong></p>
<p><strong>意图：</strong>提供一种方法顺序访问一个聚合对象中各个元素, 而又无须暴露该对象的内部表示。</p>
<p><strong>主要解决：</strong>不同的方式来遍历整个整合对象。</p>
<p><strong>何时使用：</strong>遍历一个聚合对象。</p>
<p><strong>如何解决：</strong>把在元素之间游走的责任交给迭代器，而不是聚合对象。</p>
<p><strong>关键代码：</strong>定义接口：hasNext, next。</p>
<p><strong>应用实例：</strong>JAVA 中的 iterator。</p>
<p><strong>优点：</strong> 1、它支持以不同的方式遍历一个聚合对象。 2、迭代器简化了聚合类。 3、在同一个聚合上可以有多个遍历。 4、在迭代器模式中，增加新的聚合类和迭代器类都很方便，无须修改原有代码。</p>
<p><strong>缺点：</strong>由于迭代器模式将存储数据和遍历数据的职责分离，增加新的聚合类需要对应增加新的迭代器类，类的个数成对增加，这在一定程度上增加了系统的复杂性。</p>
<p><strong>使用场景：</strong> 1、访问一个聚合对象的内容而无须暴露它的内部表示。 2、需要为聚合对象提供多种遍历方式。 3、为遍历不同的聚合结构提供一个统一的接口。</p>
<p><strong>注意事项：</strong>迭代器模式就是分离了集合对象的遍历行为，抽象出一个迭代器类来负责，这样既可以做到不暴露集合的内部结构，又可让外部代码透明地访问集合内部的数据。</p>
<p><strong>实现</strong></p>
<p>我们将创建一个叙述导航方法的 <em>Iterator</em> 接口和一个返回迭代器的 <em>Container</em> 接口。实现了 <em>Container</em> 接口的实体类将负责实现 <em>Iterator</em> 接口。</p>
<p><em>IteratorPatternDemo*，我们的演示类使用实体类 *NamesRepository</em> 来打印 <em>NamesRepository</em> 中存储为集合的 <em>Names</em>。</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/1450462-20200317085452375-1651527493.png" alt="img"></p>
<p> 1、创建接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Container</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator <span class="title">getIterator</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、创建实现了 Container 接口的实体类。该类实现了 Iterator 接口的内部类 NameIterator。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NameRepository</span> <span class="keyword">implements</span> <span class="title">Container</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String[] names = &#123;<span class="string">"Robert"</span>,<span class="string">"John"</span>,<span class="string">"Julie"</span>,<span class="string">"Lora"</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator <span class="title">getIterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> NameIterator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">NameIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> index;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(index &lt; names.length)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.hasNext())&#123;</span><br><span class="line">                <span class="keyword">return</span> names[index++];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、使用 NameRepository 来获取迭代器，并打印名字。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IteratorPatternDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        NameRepository nameRepository = <span class="keyword">new</span> NameRepository();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(Iterator iter = nameRepository.getIterator(); iter.hasNext();)&#123;</span><br><span class="line">            String name = (String)iter.next();</span><br><span class="line">            System.out.println(<span class="string">"name: "</span>+name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/due5PJOoz3E1VUZ.png" alt="img"></p>
<p>参考：<a href="https://www.runoob.com/design-pattern/iterator-pattern.html" target="_blank" rel="noopener">https://www.runoob.com/design-pattern/iterator-pattern.html</a></p>
<h3 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h3><p>中介者模式（Mediator Pattern）是用来降低多个对象和类之间的通信复杂性。这种模式提供了一个中介类，该类通常处理不同类之间的通信，并支持松耦合，使代码易于维护。中介者模式属于行为型模式。</p>
<p><strong>介绍</strong></p>
<p><strong>意图：</strong>用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。</p>
<p><strong>主要解决：</strong>对象与对象之间存在大量的关联关系，这样势必会导致系统的结构变得很复杂，同时若一个对象发生改变，我们也需要跟踪与之相关联的对象，同时做出相应的处理。</p>
<p><strong>何时使用：</strong>多个类相互耦合，形成了网状结构。</p>
<p><strong>如何解决：</strong>将上述网状结构分离为星型结构。</p>
<p><strong>关键代码：</strong>对象 Colleague 之间的通信封装到一个类中单独处理。</p>
<p><strong>应用实例：</strong> 1、中国加入 WTO 之前是各个国家相互贸易，结构复杂，现在是各个国家通过 WTO 来互相贸易。 2、机场调度系统。 3、MVC 框架，其中C（控制器）就是 M（模型）和 V（视图）的中介者。</p>
<p><strong>优点：</strong> 1、降低了类的复杂度，将一对多转化成了一对一。 2、各个类之间的解耦。 3、符合迪米特原则。</p>
<p><strong>缺点：</strong>中介者会庞大，变得复杂难以维护。</p>
<p><strong>使用场景：</strong> 1、系统中对象之间存在比较复杂的引用关系，导致它们之间的依赖关系结构混乱而且难以复用该对象。 2、想通过一个中间类来封装多个类中的行为，而又不想生成太多的子类。</p>
<p><strong>注意事项：</strong>不应当在职责混乱的时候使用。</p>
<p><strong>实现</strong></p>
<p>我们通过聊天室实例来演示中介者模式。实例中，多个用户可以向聊天室发送消息，聊天室向所有的用户显示消息。我们将创建两个类 <em>ChatRoom</em> 和 <em>User<em>。</em>User</em> 对象使用 <em>ChatRoom</em> 方法来分享他们的消息。</p>
<p><em>MediatorPatternDemo*，我们的演示类使用 *User</em> 对象来显示他们之间的通信。</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/OhHFloWqvdMENpI.png" alt="img"></p>
<p> 1、创建中介类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChatRoom</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">showMessage</span><span class="params">(User user, String message)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> Date().toString()+<span class="string">"["</span>+user.getName()+<span class="string">"] :"</span>+message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、创建User类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line">        ChatRoom.showMessage(<span class="keyword">this</span>,message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、使用 User 对象来显示它们之间的通信</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MediatorPatternDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        User robert = <span class="keyword">new</span> User(<span class="string">"Robert"</span>);</span><br><span class="line">        User john = <span class="keyword">new</span> User(<span class="string">"John"</span>);</span><br><span class="line">        robert.sendMessage(<span class="string">"Hi, John"</span>);</span><br><span class="line">        john.sendMessage(<span class="string">"Hello, Robert"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/jNMSEFBdg6qp8m2.png" alt="img"></p>
<p>参考：<a href="https://www.runoob.com/design-pattern/mediator-pattern.html" target="_blank" rel="noopener">https://www.runoob.com/design-pattern/mediator-pattern.html</a></p>
<h3 id="备忘录模式"><a href="#备忘录模式" class="headerlink" title="备忘录模式"></a>备忘录模式</h3><p>备忘录模式（Memento Pattern）保存一个对象的某个状态，以便在适当时恢复对象。</p>
<p><strong>介绍</strong></p>
<p><strong>意图：</strong>在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。</p>
<p><strong>主要解决：</strong>所谓备忘录模式就是在不破坏封装的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样可以在以后将对象恢复到原先保存的状态。</p>
<p><strong>何时使用：</strong>很多时候我们总是需要记录一个对象的内部状态，这样做的目的就是为了允许用户取消不确定或者错误的操作，能够恢复到他原先的状态，使得他有”后悔药”可吃。</p>
<p><strong>如何解决：</strong>通过一个备忘录类专门存储对象状态。</p>
<p><strong>关键代码：</strong>客户不与备忘录类耦合，与备忘录管理类耦合。</p>
<p><strong>应用实例：</strong> 1、后悔药。 2、打游戏时的存档。 3、Windows 里的 ctri + z。 4、IE 中的后退。 4、数据库的事务管理。</p>
<p><strong>优点：</strong> 1、给用户提供了一种可以恢复状态的机制，可以使用户能够比较方便地回到某个历史的状态。 2、实现了信息的封装，使得用户不需要关心状态的保存细节。</p>
<p><strong>缺点：</strong>消耗资源。如果类的成员变量过多，势必会占用比较大的资源，而且每一次保存都会消耗一定的内存。</p>
<p><strong>使用场景：</strong> 1、需要保存/恢复数据的相关状态场景。 2、提供一个可回滚的操作。</p>
<p><strong>注意事项：</strong> 1、为了符合迪米特原则，还要增加一个管理备忘录的类。 2、为了节约内存，可使用原型模式+备忘录模式。</p>
<p><strong>实现</strong></p>
<p>备忘录模式使用三个类 <em>Memento<em>、</em>Originator</em> 和 <em>CareTaker</em>。Memento 包含了要被恢复的对象的状态。Originator 创建并在 Memento 对象中存储状态。Caretaker 对象负责从 Memento 中恢复对象的状态。</p>
<p><em>MementoPatternDemo*，我们的演示类使用 *CareTaker</em> 和 <em>Originator</em> 对象来显示对象的状态恢复。</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/pkLONuI2i1VD3gG.png" alt="img"></p>
<p> 1、创建 Memento 类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Memento</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String state;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Memento</span><span class="params">(String state)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.state = state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、创建 Originator 类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Originator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String state;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(String state)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.state = state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Memento <span class="title">saveStateToMemento</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Memento(state);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getStateFromMemento</span><span class="params">(Memento memento)</span></span>&#123;</span><br><span class="line">        state = memento.getState();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、创建 CareTaker 类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CareTaker</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;Memento&gt; mementoList = <span class="keyword">new</span> ArrayList&lt;Memento&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Memento state)</span></span>&#123;</span><br><span class="line">        mementoList.add(state);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Memento <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mementoList.get(index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4、使用 CareTaker 类和 Originator 对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MementoPatternDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Originator originator = <span class="keyword">new</span> Originator();</span><br><span class="line">        CareTaker careTaker = <span class="keyword">new</span> CareTaker();</span><br><span class="line"></span><br><span class="line">        originator.setState(<span class="string">"State #1"</span>);</span><br><span class="line">        originator.setState(<span class="string">"State #2"</span>);</span><br><span class="line">        careTaker.add(originator.saveStateToMemento());</span><br><span class="line">        originator.setState(<span class="string">"State #3"</span>);</span><br><span class="line">        careTaker.add(originator.saveStateToMemento());</span><br><span class="line">        originator.setState(<span class="string">"State #4"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"Current State: "</span>+originator.getState());</span><br><span class="line">        originator.getStateFromMemento(careTaker.get(<span class="number">0</span>));</span><br><span class="line">        System.out.println(<span class="string">"First saved state: "</span>+originator.getState());</span><br><span class="line">        originator.getStateFromMemento(careTaker.get(<span class="number">1</span>));</span><br><span class="line">        System.out.println(<span class="string">"Second saved state: "</span>+originator.getState());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/otRQndqHTA9iU1K.png" alt="img"></p>
<p> Memento 记录 Originator 对象的状态， CareTaker 对象负责保存 Memento 对象记录。</p>
<p>参考：<a href="https://www.runoob.com/design-pattern/memento-pattern.html" target="_blank" rel="noopener">https://www.runoob.com/design-pattern/memento-pattern.html</a></p>
<h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><p>当对象存在一对多关系时，则使用观察者模式（Observer Pattern）。比如，当一个对象被修改时，则会自动通知它的依赖对象。</p>
<p><strong>介绍</strong></p>
<p><strong>意图：</strong>定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。</p>
<p><strong>主要解决：</strong>一个对象状态改变给其他对象通知的问题，而且要考虑到易用和低耦合，保证高度的协作。</p>
<p><strong>何时使用：</strong>一个对象（目标对象）的状态发生改变，所有的依赖对象（观察者对象）都将得到通知，进行广播通知。</p>
<p><strong>如何解决：</strong>使用面向对象技术，可以将这种依赖关系弱化。</p>
<p><strong>关键代码：</strong>在抽象类里有一个 ArrayList 存放观察者们。</p>
<p><strong>应用实例：</strong> 1、拍卖的时候，拍卖师观察最高标价，然后通知给其他竞价者竞价。 2、西游记里面悟空请求菩萨降服红孩儿，菩萨洒了一地水招来一个老乌龟，这个乌龟就是观察者，他观察菩萨洒水这个动作。</p>
<p><strong>优点：</strong> 1、观察者和被观察者是抽象耦合的。 2、建立一套触发机制。</p>
<p><strong>缺点：</strong> 1、如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。 2、如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。 3、观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。</p>
<p><strong>使用场景：</strong></p>
<ul>
<li>一个抽象模型有两个方面，其中一个方面依赖于另一个方面。将这些方面封装在独立的对象中使它们可以各自独立地改变和复用。</li>
<li>一个对象的改变将导致其他一个或多个对象也发生改变，而不知道具体有多少对象将发生改变，可以降低对象之间的耦合度。</li>
<li>一个对象必须通知其他对象，而并不知道这些对象是谁。</li>
<li>需要在系统中创建一个触发链，A对象的行为将影响B对象，B对象的行为将影响C对象……，可以使用观察者模式创建一种链式触发机制。</li>
</ul>
<p><strong>注意事项：</strong> 1、JAVA 中已经有了对观察者模式的支持类。 2、避免循环引用。 3、如果顺序执行，某一观察者错误会导致系统卡壳，一般采用异步方式。</p>
<p><strong>实现</strong></p>
<p>观察者模式使用三个类 Subject、Observer 和 Client。Subject 对象带有绑定观察者到 Client 对象和从 Client 对象解绑观察者的方法。我们创建 <em>Subject</em> 类、<em>Observer</em> 抽象类和扩展了抽象类 <em>Observer</em> 的实体类。</p>
<p><em>ObserverPatternDemo*，我们的演示类使用 *Subject</em> 和实体类对象来演示观察者模式。</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/2ZDW8mdXlScM7jg.png" alt="img"></p>
<p> 1、创建 Subject 类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Observer&gt; observers = <span class="keyword">new</span> ArrayList&lt;Observer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> state;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(Observer observer)</span></span>&#123;</span><br><span class="line">        observers.add(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyAllObservers</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Observer observer : observers) &#123;</span><br><span class="line">            observer.update();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(<span class="keyword">int</span> state)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.state = state;</span><br><span class="line">        notifyAllObservers();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、创建 Observer 类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Subject subject;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、创建实体观察者类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryObserver</span> <span class="keyword">extends</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BinaryObserver</span><span class="params">(Subject subject)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.subject = subject;</span><br><span class="line">        <span class="keyword">this</span>.subject.attach(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Binary String: "</span>+Integer.toBinaryString(subject.getState()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HexObserver</span> <span class="keyword">extends</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HexObserver</span><span class="params">(Subject subject)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.subject = subject;</span><br><span class="line">        <span class="keyword">this</span>.subject.attach(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hex String: "</span>+Integer.toHexString(subject.getState()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OctalObserver</span> <span class="keyword">extends</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OctalObserver</span><span class="params">(Subject subject)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.subject = subject;</span><br><span class="line">        <span class="keyword">this</span>.subject.attach(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Octal String: "</span>+Integer.toOctalString(subject.getState()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4、使用 Subject 和实体观察者对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObserverPatternDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Subject subject = <span class="keyword">new</span> Subject();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> HexObserver(subject);</span><br><span class="line">        <span class="keyword">new</span> OctalObserver(subject);</span><br><span class="line">        <span class="keyword">new</span> BinaryObserver(subject);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"First state change: 15"</span>);</span><br><span class="line">        subject.setState(<span class="number">15</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"Second state change: 10"</span>);</span><br><span class="line">        subject.setState(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/Zm32V8BShouLqGA.png" alt="img"></p>
<p> 我们使用 BinaryObserver、OctalObserver 和 HexObserver 来“观察” Subject 对象的情况，当 Subject 的状态改变时就调用 notifyAllObservers()方法。</p>
<p>参考：<a href="https://www.runoob.com/design-pattern/state-pattern.html" target="_blank" rel="noopener">https://www.runoob.com/design-pattern/state-pattern.html</a></p>
<h3 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h3><p>在状态模式（State Pattern）中，类的行为是基于它的状态改变的。</p>
<p><strong>介绍</strong></p>
<p><strong>意图：</strong>允许对象在内部状态发生改变时改变它的行为，对象看起来好像修改了它的类。</p>
<p><strong>主要解决：</strong>对象的行为依赖于它的状态（属性），并且可以根据它的状态改变而改变它的相关行为。</p>
<p><strong>何时使用：</strong>代码中包含大量与对象状态有关的条件语句。</p>
<p><strong>如何解决：</strong>将各种具体的状态类抽象出来。</p>
<p><strong>关键代码：</strong>通常命令模式的接口中只有一个方法。而状态模式的接口中有一个或者多个方法。而且，状态模式的实现类的方法，一般返回值，或者是改变实例变量的值。也就是说，状态模式一般和对象的状态有关。实现类的方法有不同的功能，覆盖接口中的方法。状态模式和命令模式一样，也可以用于消除 if…else 等条件选择语句。</p>
<p><strong>应用实例：</strong> 1、打篮球的时候运动员可以有正常状态、不正常状态和超常状态。 2、曾侯乙编钟中，’钟是抽象接口’,’钟A’等是具体状态，’曾侯乙编钟’是具体环境（Context）。</p>
<p><strong>优点：</strong> 1、封装了转换规则。 2、枚举可能的状态，在枚举状态之前需要确定状态种类。 3、将所有与某个状态有关的行为放到一个类中，并且可以方便地增加新的状态，只需要改变对象状态即可改变对象的行为。 4、允许状态转换逻辑与状态对象合成一体，而不是某一个巨大的条件语句块。 5、可以让多个环境对象共享一个状态对象，从而减少系统中对象的个数。</p>
<p><strong>缺点：</strong> 1、状态模式的使用必然会增加系统类和对象的个数。 2、状态模式的结构与实现都较为复杂，如果使用不当将导致程序结构和代码的混乱。 3、状态模式对”开闭原则”的支持并不太好，对于可以切换状态的状态模式，增加新的状态类需要修改那些负责状态转换的源代码，否则无法切换到新增状态，而且修改某个状态类的行为也需修改对应类的源代码。</p>
<p><strong>使用场景：</strong> 1、行为随状态改变而改变的场景。 2、条件、分支语句的代替者。</p>
<p><strong>注意事项：</strong>在行为受状态约束的时候使用状态模式，而且状态不超过 5 个。</p>
<p><strong>实现</strong></p>
<p>我们将创建一个 <em>State</em> 接口和实现了 <em>State</em> 接口的实体状态类。<em>Context</em> 是一个带有某个状态的类。</p>
<p><em>StatePatternDemo*，我们的演示类使用 *Context</em> 和状态对象来演示 Context 在状态改变时的行为变化。</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/pFTBsYkxqvEe3mb.png" alt="img"></p>
<p> 1、创建一个接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">State</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAction</span><span class="params">(Context context)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、创建实现接口的实体类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StartState</span> <span class="keyword">implements</span> <span class="title">State</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAction</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Player is in start stage"</span>);</span><br><span class="line">        context.setState(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Start State"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StopState</span> <span class="keyword">implements</span> <span class="title">State</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAction</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Player is in stop state"</span>);</span><br><span class="line">        context.setState(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Stop State"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、创建 Context 类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> State state;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Context</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(State state)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.state = state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> State <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4、使用 Context 来查看当状态 State 改变时的行为变化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StatePatternDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Context context = <span class="keyword">new</span> Context();</span><br><span class="line"></span><br><span class="line">        StartState startState = <span class="keyword">new</span> StartState();</span><br><span class="line">        startState.doAction(context);</span><br><span class="line">        System.out.println(context.getState());</span><br><span class="line"></span><br><span class="line">        StopState stopState = <span class="keyword">new</span> StopState();</span><br><span class="line">        stopState.doAction(context);</span><br><span class="line">        System.out.println(context.getState());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当状态 State 改变后，对象的toString方法也发生了变化。</p>
<p>输出</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/HXnQLia8GxKF3Sj.png" alt="img"></p>
<p> 参考：<a href="https://www.runoob.com/design-pattern/state-pattern.html" target="_blank" rel="noopener">https://www.runoob.com/design-pattern/state-pattern.html</a></p>
<h3 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h3><p>在策略模式（Strategy Pattern）中，一个类的行为或其算法可以在运行时更改。在策略模式中，我们创建表示各种策略的对象和一个行为随着策略对象改变而改变的 Context 对象。策略模式改变 Context 对象的执行算法。</p>
<p><strong>介绍</strong></p>
<p><strong>意图：</strong>定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。</p>
<p><strong>主要解决：</strong>在有多种算法相似的情况下，使用 if…else 所带来的复杂和难以维护。</p>
<p><strong>何时使用：</strong>一个系统有许多许多类，而区分它们的只是他们直接的行为。</p>
<p><strong>如何解决：</strong>将这些算法封装成一个一个的类，任意地替换。</p>
<p><strong>关键代码：</strong>实现同一个接口。</p>
<p><strong>应用实例：</strong> 1、诸葛亮的锦囊妙计，每一个锦囊就是一个策略。 2、旅行的出游方式，选择骑自行车、坐汽车，每一种旅行方式都是一个策略。 3、JAVA AWT 中的 LayoutManager。</p>
<p><strong>优点：</strong> 1、算法可以自由切换。 2、避免使用多重条件判断。 3、扩展性良好。</p>
<p><strong>缺点：</strong> 1、策略类会增多。 2、所有策略类都需要对外暴露。</p>
<p><strong>使用场景：</strong> 1、如果在一个系统里面有许多类，它们之间的区别仅在于它们的行为，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为。 2、一个系统需要动态地在几种算法中选择一种。 3、如果一个对象有很多的行为，如果不用恰当的模式，这些行为就只好使用多重的条件选择语句来实现。</p>
<p><strong>注意事项：</strong>如果一个系统的策略多于四个，就需要考虑使用混合模式，解决策略类膨胀的问题。</p>
<p><strong>实现</strong></p>
<p>我们将创建一个定义活动的 <em>Strategy</em> 接口和实现了 <em>Strategy</em> 接口的实体策略类。<em>Context</em> 是一个使用了某种策略的类。</p>
<p><em>StrategyPatternDemo*，我们的演示类使用 *Context</em> 和策略对象来演示 Context 在它所配置或使用的策略改变时的行为变化。</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/TomPAhiWzBE6tYV.png" alt="img"></p>
<p> 1、创建一个接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">doOperation</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、创建实现接口的实体类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OperationAdd</span> <span class="keyword">implements</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">doOperation</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> num1 + num2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OperationSubtract</span> <span class="keyword">implements</span> <span class="title">Strategy</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">doOperation</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> num1 - num2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OperationMultiply</span> <span class="keyword">implements</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">doOperation</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> num1 * num2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、创建Context类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Strategy strategy;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Context</span><span class="params">(Strategy strategy)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.strategy = strategy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">executeStrategy</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> strategy.doOperation(num1, num2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4、使用Context来查看当它改变策略 Strategy 时的行为变化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StrategyPatternDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Context context = <span class="keyword">new</span> Context(<span class="keyword">new</span> OperationAdd());</span><br><span class="line">        System.out.println(<span class="string">"10 + 5 = "</span>+context.executeStrategy(<span class="number">10</span>,<span class="number">5</span>));</span><br><span class="line"></span><br><span class="line">        context = <span class="keyword">new</span> Context(<span class="keyword">new</span> OperationSubtract());</span><br><span class="line">        System.out.println(<span class="string">"10 - 5 = "</span>+context.executeStrategy(<span class="number">10</span>,<span class="number">5</span>));</span><br><span class="line"></span><br><span class="line">        context = <span class="keyword">new</span> Context(<span class="keyword">new</span> OperationMultiply());</span><br><span class="line">        System.out.println(<span class="string">"10 * 5 = "</span>+context.executeStrategy(<span class="number">10</span>,<span class="number">5</span>));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/fWpuAV12iFE6jTR.png" alt="img"></p>
<p>参考：<a href="https://www.runoob.com/design-pattern/strategy-pattern.html" target="_blank" rel="noopener">https://www.runoob.com/design-pattern/strategy-pattern.html</a></p>
<h3 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h3><p>在访问者模式（Visitor Pattern）中，我们使用了一个访问者类，它改变了元素类的执行算法。通过这种方式，元素的执行算法可以随着访问者改变而改变。根据模式，元素对象已接收访问者对象，这样访问者对象就可以处理元素对象上的操作。</p>
<p><strong>介绍</strong></p>
<p><strong>意图：</strong>主要将数据结构与数据操作分离。</p>
<p><strong>主要解决：</strong>稳定的数据结构和易变的操作耦合问题。</p>
<p><strong>何时使用：</strong>需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免让这些操作”污染”这些对象的类，使用访问者模式将这些封装到类中。</p>
<p><strong>如何解决：</strong>在被访问的类里面加一个对外提供接待访问者的接口。</p>
<p><strong>关键代码：</strong>在数据基础类里面有一个方法接受访问者，将自身引用传入访问者。</p>
<p><strong>应用实例：</strong>您在朋友家做客，您是访问者，朋友接受您的访问，您通过朋友的描述，然后对朋友的描述做出一个判断，这就是访问者模式。</p>
<p><strong>优点：</strong> 1、符合单一职责原则。 2、优秀的扩展性。 3、灵活性。</p>
<p><strong>缺点：</strong> 1、具体元素对访问者公布细节，违反了迪米特原则。 2、具体元素变更比较困难。 3、违反了依赖倒置原则，依赖了具体类，没有依赖抽象。</p>
<p><strong>使用场景：</strong> 1、对象结构中对象对应的类很少改变，但经常需要在此对象结构上定义新的操作。 2、需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免让这些操作”污染”这些对象的类，也不希望在增加新操作时修改这些类。</p>
<p><strong>注意事项：</strong>访问者可以对功能进行统一，可以做报表、UI、拦截器与过滤器。</p>
<p><strong>实现</strong></p>
<p>我们将创建一个定义接受操作的 <em>ComputerPart</em> 接口。<em>Keyboard<em>、</em>Mouse<em>、</em>Monitor</em> 和 <em>Computer</em> 是实现了 <em>ComputerPart</em> 接口的实体类。我们将定义另一个接口 <em>ComputerPartVisitor<em>，它定义了访问者类的操作。</em>Computer</em> 使用实体访问者来执行相应的动作。</p>
<p><em>VisitorPatternDemo<em>，我们的演示类使用 *Computer</em>、*ComputerPartVisitor</em> 类来演示访问者模式的用法。</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/8qB6aYP2cKGeNVx.png" alt="img"></p>
<p> 1、定义一个表示元素的接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>  <span class="class"><span class="keyword">interface</span> <span class="title">ComputerPart</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(ComputerPartVisitor computerPartVisitor)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、创建扩展了上述接口的实体类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Keyboard</span> <span class="keyword">implements</span> <span class="title">ComputerPart</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(ComputerPartVisitor computerPartVisitor)</span> </span>&#123;</span><br><span class="line">        computerPartVisitor.visit(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Monitor</span> <span class="keyword">implements</span> <span class="title">ComputerPart</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(ComputerPartVisitor computerPartVisitor)</span> </span>&#123;</span><br><span class="line">        computerPartVisitor.visit(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mouse</span> <span class="keyword">implements</span> <span class="title">ComputerPart</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(ComputerPartVisitor computerPartVisitor)</span> </span>&#123;</span><br><span class="line">        computerPartVisitor.visit(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Computer</span> <span class="keyword">implements</span> <span class="title">ComputerPart</span> </span>&#123;</span><br><span class="line">    ComputerPart[] parts;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Computer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        parts = <span class="keyword">new</span> ComputerPart[]&#123;<span class="keyword">new</span> Mouse(),<span class="keyword">new</span> Keyboard(),<span class="keyword">new</span> Monitor()&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(ComputerPartVisitor computerPartVisitor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (ComputerPart part : parts) &#123;</span><br><span class="line">            part.accept(computerPartVisitor);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        computerPartVisitor.visit(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4、创建实现了上述类的实体访问者</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ComputerPartDisplayVisitor</span> <span class="keyword">implements</span> <span class="title">ComputerPartVisitor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(Computer computer)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Displaying Computer."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(Mouse mouse)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Displaying Mouse"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(Monitor monitor)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Displaying Monitor."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(Keyboard keyboard)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Displaying Keyboard."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5、使用 ComputerPartDisplayVisitor 来显示 Computer 的组成部分</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VisitorPatternDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ComputerPart computer = <span class="keyword">new</span> Computer();</span><br><span class="line"></span><br><span class="line">        computer.accept(<span class="keyword">new</span> ComputerPartDisplayVisitor());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/5RIuaQ4Otmn3MlZ.png" alt="img"></p>
<p>参考：<a href="https://www.runoob.com/design-pattern/visitor-pattern.html" target="_blank" rel="noopener">https://www.runoob.com/design-pattern/visitor-pattern.html</a></p>
<h3 id="模板模式"><a href="#模板模式" class="headerlink" title="模板模式"></a>模板模式</h3><p>在模板模式（Template Pattern）中，一个抽象类公开定义了它的方法/模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行。</p>
<p><strong>介绍</strong></p>
<p><strong>意图：</strong>定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</p>
<p><strong>主要解决：</strong>一些方法通用，却在每一个子类都重新写了这一方法。</p>
<p><strong>何时使用：</strong>有一些通用的方法。</p>
<p><strong>如何解决：</strong>将这些通用算法抽象出来。</p>
<p><strong>关键代码：</strong>在抽象类实现，其他步骤在子类实现。</p>
<p><strong>应用实例：</strong> 1、在造房子的时候，地基、走线、水管都一样，只有在建筑的后期才有加壁橱加栅栏等差异。 2、西游记里面菩萨定好的 81 难，这就是一个顶层的逻辑骨架。 3、spring 中对 Hibernate 的支持，将一些已经定好的方法封装起来，比如开启事务、获取 Session、关闭 Session 等，程序员不重复写那些已经规范好的代码，直接丢一个实体就可以保存。</p>
<p><strong>优点：</strong> 1、封装不变部分，扩展可变部分。 2、提取公共代码，便于维护。 3、行为由父类控制，子类实现。</p>
<p><strong>缺点：</strong>每一个不同的实现都需要一个子类来实现，导致类的个数增加，使得系统更加庞大。</p>
<p><strong>使用场景：</strong> 1、有多个子类共有的方法，且逻辑相同。 2、重要的、复杂的方法，可以考虑作为模板方法。</p>
<p><strong>注意事项：</strong>为防止恶意操作，一般模板方法都加上 final 关键词。</p>
<p><strong>实现</strong></p>
<p>我们将创建一个定义操作的 <em>Game</em> 抽象类，其中，模板方法设置为 final，这样它就不会被重写。<em>Cricket</em> 和 <em>Football</em> 是扩展了 <em>Game</em> 的实体类，它们重写了抽象类的方法。</p>
<p><em>TemplatePatternDemo*，我们的演示类使用 *Game</em> 来演示模板模式的用法。</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/3omVLcfxtAqeHK9.png" alt="img"></p>
<p> 1、创建一个抽象类，它的模板方法被设置为 final</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Game</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">startPlay</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">endPlay</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span></span>&#123;</span><br><span class="line">        initialize();</span><br><span class="line"></span><br><span class="line">        startPlay();</span><br><span class="line"></span><br><span class="line">        endPlay();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、创建扩展了上述类的实体类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cricket</span> <span class="keyword">extends</span> <span class="title">Game</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">initialize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Cricket Game Initialized! Start Playing."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">startPlay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Cricket Game Started! Enjoy the game."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">endPlay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Cricket Game Finished!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Football</span> <span class="keyword">extends</span> <span class="title">Game</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">initialize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Football Game Initialized! Start Playing."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">startPlay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Football Game Started! Enjoy the game."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">endPlay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Football Game Finished!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、使用 Game 的模板方法 play() 来演示游戏的定义方式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TemplatePatternDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Game game = <span class="keyword">new</span> Cricket();</span><br><span class="line">        game.play();</span><br><span class="line"></span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        game = <span class="keyword">new</span> Football();</span><br><span class="line">        game.play();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/YWuALi69BtNDUJ3.png" alt="img"></p>
<p> 参考：<a href="https://www.runoob.com/design-pattern/template-pattern.html" target="_blank" rel="noopener">https://www.runoob.com/design-pattern/template-pattern.html</a></p>
<h2 id="其他模式"><a href="#其他模式" class="headerlink" title="其他模式"></a>其他模式</h2><h3 id="空对象模式"><a href="#空对象模式" class="headerlink" title="空对象模式"></a>空对象模式</h3><p>在空对象模式（Null Object Pattern）中，一个空对象取代 NULL 对象实例的检查。Null 对象不是检查空值，而是反应一个不做任何动作的关系。这样的 Null 对象也可以在数据不可用的时候提供默认的行为。在空对象模式中，我们创建要给指定各种要执行的操作的抽象类和扩展该类的实体类，还创建一个未对该类做任何实现的空对象类，该空对象类将无缝地使用在需要检查空值的地方。</p>
<p>实现</p>
<p>我们将创建一个定义操作（在这里，是客户的名称）的 <em>AbstractCustomer</em> 抽象类，和扩展了 <em>AbstractCustomer</em> 类的实体类。工厂类 <em>CustomerFactory</em> 基于客户传递的名字来返回 <em>RealCustomer</em> 或 <em>NullCustomer</em> 对象。</p>
<p><em>NullPatternDemo*，我们的演示类使用 *CustomerFactory</em> 来演示空对象模式的用法。</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/sAg4bQJ5LzBwMXi.png" alt=""></p>
<p> 1、创建一个抽象类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractCustomer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">isNil</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、创建扩展了上述类的实体类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RealCustomer</span> <span class="keyword">extends</span> <span class="title">AbstractCustomer</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RealCustomer</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isNil</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NullCustomer</span> <span class="keyword">extends</span> <span class="title">AbstractCustomer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Not Available in Customer Database"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isNil</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、创建 CustomerFactory 类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomerFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] names = &#123;<span class="string">"Rob"</span>, <span class="string">"Joe"</span>, <span class="string">"Julie"</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AbstractCustomer <span class="title">getCustomer</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; names.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(names[i].equalsIgnoreCase(name))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> RealCustomer(name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> NullCustomer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4、使用 CustomerFactory，基于客户传递的名字，来获取 RealCustomer 或 NullCustomer 对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NullObjectPatternDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AbstractCustomer customer1 = CustomerFactory.getCustomer(<span class="string">"Rob"</span>);</span><br><span class="line">        AbstractCustomer customer2 = CustomerFactory.getCustomer(<span class="string">"Bob"</span>);</span><br><span class="line">        AbstractCustomer customer3 = CustomerFactory.getCustomer(<span class="string">"Julie"</span>);</span><br><span class="line">        AbstractCustomer customer4 = CustomerFactory.getCustomer(<span class="string">"Laura"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"Customers"</span>);</span><br><span class="line">        System.out.println(customer1.getName());</span><br><span class="line">        System.out.println(customer2.getName());</span><br><span class="line">        System.out.println(customer3.getName());</span><br><span class="line">        System.out.println(customer4.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/gk8WAMDECH7PczQ.png" alt="img"></p>
<p> 我们使用一个空对象代替了对象的判空处理。</p>
<p>参考：<a href="https://www.runoob.com/design-pattern/null-object-pattern.html" target="_blank" rel="noopener">https://www.runoob.com/design-pattern/null-object-pattern.html</a></p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
  </entry>
  <entry>
    <title>数据库系统概论</title>
    <url>/2020/08/04/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/</url>
    <content><![CDATA[<h2 id="数据库系统概论"><a href="#数据库系统概论" class="headerlink" title="数据库系统概论"></a>数据库系统概论</h2><h3 id="数据库系统的作用"><a href="#数据库系统的作用" class="headerlink" title="数据库系统的作用"></a>数据库系统的作用</h3><h4 id="数据与数据管理"><a href="#数据与数据管理" class="headerlink" title="数据与数据管理"></a>数据与数据管理</h4><p>　　1）数据。描述事物的符号记录称为数据。数据是数据库中存储的对象，也是数据库管理系统处理的对象。数据和关于数据的解释是不可分的。</p>
<p>　　2）数据管理。数据处理是指对各种数据进行采集、存储、检索、加工、传播和应用等一系列活动的总和。数据管理是对数据进行有效的分类、组织、编码、存储、检索、维护和应用，它是数据处理的中心问题。</p>
<h4 id="数据管理技术的产生与发展"><a href="#数据管理技术的产生与发展" class="headerlink" title="数据管理技术的产生与发展"></a>数据管理技术的产生与发展</h4><p>　　1）人工管理阶段。面向应用程序，一个数据集只能对应一个程序，没有相应的软件系统专门负责数据的管理工作。当多个应用程序涉及某些相同的数据时，必须由各自的应用程序分别定义和管理这些数据，无法共享利用，存在大量冗余。</p>
<p>　　2）文件系统阶段。利用文件系统管理数据就是由专门的软件对数据进行统一管理。对于一个特定的应用，数据被集中组织存放在多个数据文件组中，并针对该文件组来开发特定的应用程序。文件系统利用“按文件名访问，按记录进行存取”的管理技术，可以对文件进行修改、插入和删除。</p>
<p>　　文件系统的弊端：数据共享性差，数据冗余和不一致。数据独立性差。数据孤立。数据获取困难。完整性问题（也称为一致性约束）。原子性问题。并发访问异常。安全性问题。</p>
<p>　　3）数据库管理系统阶段。数据库管理系统是由一个相互关联的数据的集合和一组用以访问、管理和控制这些数据的程序组成。这个数据集合通常称为数据库。</p>
<p>　　数据库管理系统的优点：</p>
<p>　　a. 数据整体结构化。</p>
<p>　　b.数据的共享度高，冗余度低，易扩充。<strong>数据独立性</strong>高。</p>
<p>　　c.数据独立性是用来描述数据与应用程序之间的依赖程度，包括数据的物理独立性和数据的逻辑独立性。</p>
<p>　　<strong>物理独立性</strong>是指用户的应用程序与存储在磁盘上数据库中的数据是相互独立的。</p>
<p>　　<strong>逻辑独立性</strong>是指用户的应用程序与数据的逻辑结构是相互独立的。</p>
<p>　　d.数据由数据库管理系统统一管理和控制</p>
<p>　　DBMS 必须提供：<strong>数据的安全性保护。数据的完整性检查。并发控制。数据库恢复。</strong></p>
<h3 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h3><p>　　数据模型是一个描述数据语义、数据与数据之间联系、数据操作，以及一致性（完整性）约束的概念工具的集合。通过数据模型可以对现实世界的数据特征进行抽象。</p>
<h4 id="数据模型的分类"><a href="#数据模型的分类" class="headerlink" title="数据模型的分类"></a>数据模型的分类</h4><p>　　数据模型应满足三方面的要求：一是能比较真实地模拟现实世界；二是容易被人所理解；三是便于在计算机上实现。</p>
<p>　　1）<strong>概念模型</strong>。又称信息模型，它按用户的观点或认识对现实世界的数据和信息进行建模，主要用于数据库设计。常用的概念模型有 E-R 模型，OO 模型。</p>
<p>　　2）<strong>逻辑模型</strong>。逻辑层是数据抽象的中间层，用于描述数据库数据的整体逻辑结构。该层的数据抽象称为逻辑数据模型。它是用户通过数据库管理系统看到的现实世界，是按计算机系统的观点对数据建模，即数据的计算机实现形式，主要用于 DBMS 的实现。</p>
<p>　　3）<strong>物理模型</strong>。物理层是数据抽象的最低层，用来描述数据的物理存储结构和存取方法。它不但由 DBMS 的设计决定，而且与操作系统、计算机硬件密切相关。</p>
<h4 id="数据模型的组成要素"><a href="#数据模型的组成要素" class="headerlink" title="数据模型的组成要素"></a>数据模型的组成要素</h4><p>　　1）<strong>数据结构</strong>。数据结构描述数据库的组成对象（数据）以及对象之间的联系。</p>
<p>　　2）<strong>数据操作</strong>。数据操作指对数据库中各种对象的实例允许执行的操作集合，包括操作及有关的操作规则。</p>
<p>　　3）<strong>数据的完整性约束条件</strong>。完整性规则是给定数据模型中数据及其联系所具有的制约和依存规则，用以限定复合数据模型的数据库状态以及状态的变化，以保证数据的正确、有效和相容。</p>
<p>　　数据模型有：层次模型、网状模型、关系模型、面向对象模型、XML模型。</p>
<h4 id="数据抽象与数据库三级模式"><a href="#数据抽象与数据库三级模式" class="headerlink" title="数据抽象与数据库三级模式"></a>数据抽象与数据库三级模式</h4><h5 id="数据抽象"><a href="#数据抽象" class="headerlink" title="数据抽象"></a><strong>数据抽象</strong></h5><p>　　1）物理层抽象。最低层次的抽象，描述数据实际上是怎样存储的。</p>
<p>　　2）逻辑层抽象。描述数据库中存储什么数据以及这些数据之间存在什么关系。</p>
<p>　　3）视图层抽象。最高层次的抽象，只描述整个数据库的某个部分。</p>
<h5 id="数据库的三级模式"><a href="#数据库的三级模式" class="headerlink" title="数据库的三级模式"></a><strong>数据库的三级模式</strong></h5><p>　　模式是数据库中全体数据的逻辑结构和特征的描述，它仅仅设计型的描述，不涉及具体的值。模式的一个具体值称为模式的一个实例。</p>
<p>　　数据库的三级模式结构是指数据库管理系统提供的外模式、模式和内模式 3 个不同的抽象级别观察数据库中数据的角度。</p>
<p>　　1）模式。也称为逻辑层数据抽象。是数据库中全体数据的逻辑结构和特征的描述，是所有用户的公共数据视图。DBMS 提供 数据定义语言（DDL）来严格定义模式。模式对应于表。</p>
<p>　　2）外模式。对应于视图层数据抽象，它是数据库用户能够看见和使用的局部数据的逻辑结构和特征的描述。</p>
<p>　　3）内模式。也称存储模式，对应于物理层数据抽象，它是数据的物理结构和存储方式的描述，是数据在数据库内部的表示方式。</p>
<h5 id="数据库的两层映像功能与数据独立性"><a href="#数据库的两层映像功能与数据独立性" class="headerlink" title="数据库的两层映像功能与数据独立性"></a><strong>数据库的两层映像功能与数据独立性</strong></h5><p>　　1）<strong>外模式/模式映像</strong>。定义了外模式与模式之间的对应关系。当模式改变时，由数据库管理员对各个外模式/模式的映像作相应的改变，可以保持外模式不变。<strong>保证了数据与程序的逻辑独立性，简称为数据的逻辑独立性。</strong></p>
<p>　　2）<strong>模式/内模式映像</strong>。当数据库的存储结构改变了，由数据库管理员对模式。内模式映像作相应的改变，可以使模式保持不变。<strong>保证了数据与程序的物理独立性，简称为数据的物理独立性。</strong></p>
<h3 id="数据库系统"><a href="#数据库系统" class="headerlink" title="数据库系统"></a>数据库系统</h3><h4 id="数据库系统组成"><a href="#数据库系统组成" class="headerlink" title="数据库系统组成"></a>数据库系统组成</h4><p>　　从DBMS角度来看：数据库系统结构是外模式/模式/内模式的三级模式；从用户角度看：数据库系统分为单用户结构、主从式结构、分布式结构、客户/服务器、浏览器/应用服务器/数据库服务器等结构。</p>
<p>　　数据库中包含 4 类数据：用户数据、元数据、索引和应用元数据。用户数据就是通过结构化的关系（二维表）组织的所有业务数据的集合；元数据是对关系数据库结构的描述数据和数据库的有关统计数据，也成为数据字典；索引是为了改进数据库的性能和可访问性而建立的附件数据；应用元数据是用户窗体、报表、查询和其他形式的应用组件。</p>
<h4 id="数据库管理系统"><a href="#数据库管理系统" class="headerlink" title="数据库管理系统"></a>数据库管理系统</h4><h5 id="DBMS-的功能"><a href="#DBMS-的功能" class="headerlink" title="DBMS 的功能"></a><strong>DBMS 的功能</strong></h5><p>　　1）数据定义。DBMS 提供数据定义语言（Data Definition Language，DDL），用户通过它可以方便的对数据库中的数据对象进行定义。</p>
<p>　　2）数据组织、存储和管理。DBMS 分类组织、存储和管理各种数据，包括数据字典、用户数据、数据的存取路径等。</p>
<p>　　3）数据操纵。DBMS 还提供数据操纵语言（Data Manipulation Language，DML）用户通过它实现增删改查。</p>
<p>　　4）数据库的事务管理和运行。数据库在建立、运行和维护时由 DBMS 统一管理、统一控制，以保证数据的安全性、完整性、多用户对数据的并发操作以及发生故障后的系统恢复。</p>
<p>　　5）数据库的建立和维护。数据库初始数据的输入、转换功能，数据库的转储、恢复功能，数据库的重组织功能和性能监视、分析功能等。</p>
<h5 id="DBMS-的组成"><a href="#DBMS-的组成" class="headerlink" title="DBMS 的组成"></a><strong>DBMS 的组成</strong></h5><p>　　1）模式更新。对数据库中的逻辑结构进行修改。</p>
<p>　　2）查询。</p>
<p>　　3）更新。</p>
<p>　　4）查询处理器。对用户请求的 SQL 操作进行查询优化。</p>
<p>　　5）存储管理器。根据执行策略，从数据库中取数据或更新数据。</p>
<p>　　6）事务管理器。负责保证系统的完整性，保证多个同时运行的事务不发生冲突。</p>
<h2 id="关系模型与关系代数"><a href="#关系模型与关系代数" class="headerlink" title="关系模型与关系代数"></a>关系模型与关系代数</h2><h3 id="关系模型"><a href="#关系模型" class="headerlink" title="关系模型"></a>关系模型</h3><h4 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h4><p>　　1）关系模型的数据结构为二维表，亦称关系，每个表（关系）有唯一的名字。</p>
<p>　　2）关系数据库是表的集合，即关系的集合。 </p>
<h4 id="关系数据结构的形式化定义"><a href="#关系数据结构的形式化定义" class="headerlink" title="关系数据结构的形式化定义"></a>关系数据结构的形式化定义</h4><p>　　1）域。域是一组具有相同数据类型的值的集合。如{‘男’，‘女’}。</p>
<p>　　2）笛卡儿积。</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/c3YP65x9nMUm7EK.png" alt="img"></p>
<p> 　3）码。</p>
<p>　　　　超码：属性集 A 可以唯一标识关系 r 总中的一个元组，则称属性集 A 为关系 r 的一个超码。</p>
<p>　　　　候选码：对于关系 r 的一个或多个属性的集合 A ，如果属性集 A 的任何真子集都不能成为关系的超码，则称属性集 A 为候选码。</p>
<p>　　　　主码：若一个关系有多个候选码，可以选定其中一个候选码作为该关系的主码。</p>
<p>　　　　总结：主码 属于 候选码 属于 超码。</p>
<h4 id="关系模式"><a href="#关系模式" class="headerlink" title="关系模式"></a>关系模式</h4><p>　　关系完整性的约束条件：</p>
<p>　　1）实体完整性。主码不能为空。</p>
<p>　　2）参照完整性。外码要么为空要么能等于被参照关系的某个元组的主码。</p>
<p>　　3）用户自定义完整性。限制关系中某些属性的值符合业务语义要求。如限制性别为男或女。</p>
<p>　　</p>
<h3 id="关系操作"><a href="#关系操作" class="headerlink" title="关系操作"></a>关系操作</h3><p>　　关系操作有查询操作和更新操作两大类。查询操作又可分为选择、投影、连接、除、并、交、差、笛卡儿积等。其中<strong>选择、投影、集合并、集合差和笛卡儿积是 5 种基本关系操作</strong>。</p>
<p>​        关系代数</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/wNd74x2S3sOeajV.png" alt="img"></p>
<p> 　在连接中把不能连接的元组丢弃称为<strong>自然连接</strong>，把左关系中不能连接的元组保留到结果关系称为<strong>左外连接</strong>，把右关系中不能连接的元组保留到结果关系中称为<strong>右外连接</strong>，把左右关系中不能连接的元组都保留到结果关系中称为<strong>全外连接</strong>。</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/6kVrK947GniRo5f.png" alt="img"></p>
<p>　　关系代数例题</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/qnDoKAmvJxYUhdk.png" alt="img"></p>
<p>　　1）查找选修了 08-09 学年第一学期（08091）开出的全部课程的学生学号和姓名。</p>
<p>　　解析：先找出所有08-09 学年第一学期的课程号，然后用选课关系表除这些课程号得到选修了08-09 学年第一学期全部课程学生的学号，再和学生表连接然后投影出学号和姓名。</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/M8QDBnxT6GNHA4r.png" alt="img"></p>
<p>　　2）查找至少选修了一门其直接先修课编号为 CS012 的课程的学生学号和姓名。</p>
<p>　　解析：先找出先修课编号为 CS012 的课程然后依次连接选修关系和学生关系，最后投影出学生学号（没选过先修课编号为 CS012 的课程的同学会连接失败，如果选了多门先修课编号为 CS012 的课程的同学，投影会将学生学号和姓名去重）。</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/CJ1dBG6NVYhOEtn.png" alt="img"></p>
<p>　　3）查找至少选修了学号为0703010 的学生所选课程的学号和姓名。</p>
<p>　　解析：先找出学号为0703010的学生所选的课程号，然后用选修关系除这些课程号，得到至少选修了学号为0703010 的学生所选课程的学号，再和学生表连接，投影出学号和姓名。</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/mOjbEfyIU97XVFH.png" alt="img"></p>
<h2 id="SQL语言"><a href="#SQL语言" class="headerlink" title="SQL语言"></a>SQL语言</h2><h3 id="SQL-概述"><a href="#SQL-概述" class="headerlink" title="SQL 概述"></a>SQL 概述</h3><p>　　SQL 语言由 4 部分组成，包括数据定义语言 DDL、数据操纵语言 DML、数据控制语言和其他。</p>
<p>　　1）数据定义语言（Data Definition Language，DDL）：主要用于定义数据库的逻辑结构，包括数据库，基本表，视图和索引等，扩展 DDL 还支持存储过程、函数、对象、触发器等的定义。DDL 包括 3 类语言，即定义、修改和删除。</p>
<p>　　2）数据操纵语言（Data Manipulation Language，DML）：主要用于对数据库的数据进行检索和更新，其中更新操作包括插入、删除和修改数据。</p>
<p>　　3）数据控制语言（Data Control Language，DCL）：主要用于对数据库的对象进行授权、用户维护（包括创建、修改和删除）、完整性规则定义和事务定义等。</p>
<p>　　4）其他：主要是嵌入式 SQL 语言和动态 SQL 语言的定义。</p>
<p>　　</p>
<p>　　SQL特点：风格统一。高度非过程化。面向集合的操作方式。同一种语法结构提供两种使用方式（独立使用SQL对数据库进行操作，嵌入到高级语言中）。语言简洁，易学易用。</p>
<p>　　SQL主要动词：</p>
<p>　　1）数据查询：select；</p>
<p>　　2）数据定义：create、alter、drop；</p>
<p>　　3）数据操纵：insert、update、delete；</p>
<p>　　4）数据控制：grant、revoke；</p>
<h3 id="简单查询"><a href="#简单查询" class="headerlink" title="简单查询"></a>简单查询</h3><p>　　where 子句可以实现关系代数中的选择运算，用于查询满足选择条件的元组。where 子句中常用的查询条件如下所示：</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/5NmKQzuGXSE8p3H.png" alt="img"></p>
<p> 　% 表示任意长度的字符串，_表示任意一个字符， escape ‘ \ ‘ 表示 \ 后的符号不是通配符。</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/bJOVFf4XQM53hxK.png" alt="img"></p>
<h3 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h3><p>　　外连接：</p>
<p>　　1）左外连接</p>
<p>　　　　select xxx </p>
<p>　　　　from 表a <strong>left outer join</strong> 表b <strong>on</strong> a.xx=b.xx</p>
<p>　　2）右外连接</p>
<p>　　　　select xxx </p>
<p>　　　　from 表a <strong>right outer join</strong> 表b <strong>on</strong> a.xx=b.xx</p>
<p> 　3）全外连接</p>
<p>　　　　select xxx </p>
<p>　　　　from 表a <strong>full outer join</strong> 表b <strong>on</strong> a.xx=b.xx</p>
<h3 id="嵌套子查询"><a href="#嵌套子查询" class="headerlink" title="嵌套子查询"></a>嵌套子查询</h3><h4 id="使用-in-的子查询"><a href="#使用-in-的子查询" class="headerlink" title="使用 in 的子查询"></a>使用 in 的子查询</h4><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/Ut6bKM5lAWsTPiL.png" alt="img"></p>
<p> <img src="https://gitee.com/hoo334/picgo/raw/master//img/Hm7MZoWqi2VEt9F.png" alt="img"></p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/BhbMpFjTZxcPXUn.png" alt="img"></p>
<p> <img src="https://gitee.com/hoo334/picgo/raw/master//img/Sq2ceb7Lfpahj8E.png" alt="img"></p>
<h4 id="使用比较运算符的子查询"><a href="#使用比较运算符的子查询" class="headerlink" title="使用比较运算符的子查询"></a>使用比较运算符的子查询</h4><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/vt87Oam4YzwJxES.png" alt="img"></p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/OdEwbPAcBqGKonx.png" alt="img"></p>
<h4 id="使用存在量词-exists-的子查询"><a href="#使用存在量词-exists-的子查询" class="headerlink" title="使用存在量词 exists 的子查询"></a>使用存在量词 exists 的子查询</h4><p>　　SQL 查询提供量词运算。量词有两种：一是存在量词，二是全称量词。全程量词可以用存在量词替代，故 SQL 语句仅提供存在量词的运算，使用谓词 exists 表示，全称量词转化通过 not exists 谓词来实现。</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/hM1PlF8UboEXQqe.png" alt="img"></p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/KN9bScEkCjZJhMf.png" alt="img"></p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/XEBS7msaRO3tfek.png" alt="img"></p>
<h3 id="聚合查询"><a href="#聚合查询" class="headerlink" title="聚合查询"></a>聚合查询</h3><h4 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h4><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/bLqFIkXJCKAzrGa.png" alt="img"></p>
<p> 　如果指定 distinct 谓词，表示在计算时首先消除&lt;列名&gt;取重复值的元组，然后再进行统计。</p>
<h4 id="分组聚合"><a href="#分组聚合" class="headerlink" title="分组聚合"></a>分组聚合</h4><p>　　在 SQL 查询中，往往需要对数据进行分组运算，分组运算的目的是为了细化聚合函数的作用对象。如果不对查询结果进行分组，则聚合函数作用于整个查询结果；如果对查询结果进行分组，则聚合函数分别作用于每个组，查询结果是按组聚合输出。SQL 语句中通过 group by 和having 子句来实现分组运算，其中：</p>
<p>　　group by 子句对查询结果按某一列或某几列进行分组，值相等的分为一组；</p>
<p>　　having 子句对分组的结果进行选择，仅输出满足条件的组。该子句必须与group by 子句配合使用。</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/mWZfg9ps8JA73nF.png" alt="img"></p>
<p> 　聚合函数可以直接使用在 having 子句中，也可以用于子查询中，但<strong>在 where 子句中不可以直接使用聚合函数。</strong></p>
<h4 id="复杂查询"><a href="#复杂查询" class="headerlink" title="复杂查询"></a>复杂查询</h4><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/h7m4821v9RjIJGN.png" alt="img"></p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/heOE2QcbPfitLYI.png" alt="img"></p>
<p> 或者</p>
<p>　　select studentNo, avg(score) as avgScore</p>
<p>　　from score </p>
<p>　　group by studentNo</p>
<p>　　having count(*) &gt;5</p>
<p>　　order by avgScore</p>
<p>　　limit 0,1</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/NRbIMlTqom1LdJS.png" alt="img"></p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/kT2RU6ud3DBzLAf.png" alt="img"></p>
<h3 id="集合运算"><a href="#集合运算" class="headerlink" title="集合运算"></a>集合运算</h3><p>　　SQL 支持集合运算。select 语句查询的结果是集合，多个 select 语句的结果可以进行集合操作，传统的集合操作主要包括并 union、交 intersect、差 except 运算，<strong>在执行集合运算时要求参与运算的查询结果的列数一样，其对应列的数据类型必须一致。</strong></p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/QvEbtCTGPunSkRr.png" alt="img"></p>
<h3 id="SQL-查询一般格式"><a href="#SQL-查询一般格式" class="headerlink" title="SQL 查询一般格式"></a>SQL 查询一般格式</h3><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/d5JLQ4SFejksW8t.png" alt="img"></p>
<h3 id="SQL-数据定义语言"><a href="#SQL-数据定义语言" class="headerlink" title="SQL 数据定义语言"></a>SQL 数据定义语言</h3><p>　　数据库中的关系集合必须由数据定义语言 DDL 来定义，包括：数据库模式、关系模式、每个属性的值域、完整性约束、每个关系的索引集合和关系的物理存储结构等。</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/IADEaU95sFGYO8Q.png" alt="img"></p>
<h4 id="数据库的定义"><a href="#数据库的定义" class="headerlink" title="数据库的定义"></a>数据库的定义</h4><h5 id="数据库的创建"><a href="#数据库的创建" class="headerlink" title="数据库的创建"></a>数据库的创建</h5><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/oZAH7Sla91zNXuF.png" alt="img"></p>
<h5 id="数据库的删除"><a href="#数据库的删除" class="headerlink" title="数据库的删除"></a>数据库的删除</h5><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/QXKwkRidjT6Aq4L.png" alt="img"></p>
<h4 id="基本表的定义"><a href="#基本表的定义" class="headerlink" title="基本表的定义"></a>基本表的定义</h4><h5 id="创建基本表"><a href="#创建基本表" class="headerlink" title="创建基本表"></a>创建基本表</h5><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/6rCEphyxYKgv3bi.png" alt="img"></p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/BNoTkclZdWVqS3L.png" alt="img"></p>
<p> <img src="https://gitee.com/hoo334/picgo/raw/master//img/ntiAphIVuWEmoXP.png" alt="img"></p>
<h5 id="基本表的修改"><a href="#基本表的修改" class="headerlink" title="基本表的修改"></a>基本表的修改</h5><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/A9nHdB8csqLz6p5.png" alt="img"></p>
<p>　　 基本表在修改过程中，不可以删除列，一次仅执行一种操作。</p>
<h5 id="基本表的删除"><a href="#基本表的删除" class="headerlink" title="基本表的删除"></a>基本表的删除</h5><p>　　<img src="https://gitee.com/hoo334/picgo/raw/master//img/ZO6B1CmIU9dGKEe.png" alt="img"></p>
<p> 　若选择 restrict ，则该表的删除有限制条件，即该表不能有视图，触发器以及被他表所引用，该项为默认项。</p>
<p>　　若选择 cascade， 则该表的删除没有限制条件，在删除基本表的同时，也删除建立在该表上的所有索引，完整性规则，触发器和视图。</p>
<h4 id="索引的定义"><a href="#索引的定义" class="headerlink" title="索引的定义"></a>索引的定义</h4><p>　　如果数据有序，则检索速度是非常快的，对表中的记录进行排序有两种方案：一是对记录进行物理上的重新组织。二是不改变物理顺序，通过建立索引来实现数据记录的重新排列，称为逻辑排序。</p>
<p>　　一张表可以建立多个索引，可以从不同的角度加快查询速度，如果索引建立的比较多，会给数据维护带来较大的系统开销。</p>
<p>　　索引通常是由指针构成的记录，指针逻辑上按照索引关键字进行排序，但不改变表中记录的物理顺序。索引和基本表分别存储。</p>
<p>　　如果索引文件中的记录<strong>按照某个搜索码值指定的顺序物理存储</strong>，那么该搜索码对应的索引就称为<strong>主索引</strong>，也叫<strong>聚集索引</strong>。<strong>搜索码值顺序与索引文件中记录的物理顺序不同</strong>的那些索引称为<strong>辅助索引</strong>或<strong>非聚集索引</strong>。</p>
<h5 id="索引的建立"><a href="#索引的建立" class="headerlink" title="索引的建立"></a>索引的建立</h5><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/B3SlMcuEm9wDe4s.png" alt="img"></p>
<h5 id="索引的删除"><a href="#索引的删除" class="headerlink" title="索引的删除"></a>索引的删除</h5><p>　　索引一旦建立，用户就不需要管理它，由系统自动维护。如果某个关系经常要执行插入、删除和修改操作，系统会花费很多时间来维护索引，从而降低基本表的更新速度，因此可删除那些不经常使用的索引。删除索引的语法为：</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/OUpFAjhemWIoxsi.png" alt="img"></p>
<h3 id="SQL-数据更新语言"><a href="#SQL-数据更新语言" class="headerlink" title="SQL 数据更新语言"></a>SQL 数据更新语言</h3><p>　　SQL 数据更新语句包括 3 条：插入 insert、删除 delete、修改 update。</p>
<h4 id="插入数据"><a href="#插入数据" class="headerlink" title="　　插入数据"></a>　　插入数据</h4><h5 id="插入一条元组"><a href="#插入一条元组" class="headerlink" title="插入一条元组"></a>插入一条元组</h5><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/6vrnQYmcUW9O31k.png" alt="img"></p>
<h5 id="插入多条元组"><a href="#插入多条元组" class="headerlink" title="插入多条元组"></a>插入多条元组</h5><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/HfeLn6dDRWCwyAZ.png" alt="img"></p>
<h4 id="删除数据"><a href="#删除数据" class="headerlink" title="　删除数据"></a>　删除数据</h4><p>　　<img src="https://gitee.com/hoo334/picgo/raw/master//img/9yTpORSIfmKBXYj.png" alt="img"></p>
<h4 id="修改数据"><a href="#修改数据" class="headerlink" title="　　修改数据"></a>　　修改数据</h4><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/5mzi2Dy9jEgW3t4.png" alt="img"></p>
<h3 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h3><p>　　视图是虚表，是从一个或几个基本表（或视图）中导出的表，在系统的数据字典中仅存放了视图的定义，不存放视图对应的数据。</p>
<h4 id="定义视图"><a href="#定义视图" class="headerlink" title="定义视图"></a>定义视图</h4><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/R9MgBo7XGwK2Y8a.png" alt="img"></p>
<p> 　with check option ：当对视图进行插入、删除和更新操作时必须满足视图定义的谓词条件。</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/eETgZ48mJ17ASh3.png" alt="img"></p>
<h4 id="查询视图"><a href="#查询视图" class="headerlink" title="查询视图"></a>查询视图</h4><p>　　查询是对视图进行的最主要的操作。从用户的角度来看，查询视图与查询基本表的方式是完全一样的。</p>
<h4 id="更新视图"><a href="#更新视图" class="headerlink" title="更新视图"></a>更新视图</h4><p>　　更新视图指通过视图来插入、删除和修改基本表中的数据。由于视图是一个虚表，不实际存放数据，对视图的更新最终要转换为对基本表的更新，因此，如果视图的定义中包含了表达式，或聚合运算，或消除重复值运算，则不能对视图进行更新操作。</p>
<h4 id="删除视图"><a href="#删除视图" class="headerlink" title="删除视图"></a>删除视图</h4><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/FiN2qdoAf8LMkCu.png" alt="img"></p>
<h3 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h3><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/VeDnJizjmpqPsXB.png" alt="img"></p>
<p> 　1）查询在2005-2008 年之间没有归还图书的读者编号、读者姓名、读者工作单位、图书编号、图书名称和借书日期。</p>
<p>　　分析：将读者、借阅、书籍三个关系连接起来然后判断书籍是否应该在 2005~2008年之间归还且书籍归还日期为空。</p>
<p>　　select rd.readerNo, rd.readerName, rd.workUnit, bk.bookNo, bk.bookName, br.borrowDate</p>
<p>　　from Reader rd, Borrow br, Book bk</p>
<p>　　where rd.readerNo=br.readerNo and br.bookNo=bk.bookNo and year(shouldDate) between 2005 and 2008 and br.returnDate is null</p>
<p>　　2)查询没有借书的读者姓名（分别用 in 子查询和存在量词子查询表达）。</p>
<p>　　分析：首先在借阅表中找出所有借过书还没有归还的读者号，然后判断每一个读者的读者号是否在前面找出的读者号里面，不在则代表没有借书。</p>
<p>　　select readerName</p>
<p>　　from Reader</p>
<p>　　where readerNo not in(</p>
<p>　　select distinct readerNo</p>
<p>　　from Borrow</p>
<p>　　where returnDate is null ); </p>
<p>　　select readerName</p>
<p>　　from Reader</p>
<p>　　where not exists (</p>
<p>　　select *</p>
<p>　　from Borrow</p>
<p>　　where Reader.readerNo=Borrow.readerNo and returnDate is null );</p>
<p>　　3)查询既借阅了“离散数学”又借阅了“数据库系统概念”两本书的读者编号、读者姓名、借书日期和图书名称。</p>
<p>　　分析：先找出借阅了离散数学的读者编号，再去看该读者是否借阅了数据库系统概念。</p>
<p>　　select rd.readerNo, rd.readerName, br.borrowDate, bk.bookName</p>
<p>　　from Reader rd, Borrow br, Book bk</p>
<p>　　where rd.readerNo=br.readerNo and br.bookNo=bk.bookNo and bookName=’离散数学’</p>
<p>　　and exists (</p>
<p>　　select * </p>
<p>　　from Borrow, Book</p>
<p>　　where Borrow.bookNo=Book.bookNo and rd.readerNo=Borrow.readerNo and Book.bookName=’数据库系统概念’ );</p>
<p>　　4）查询没有借阅’“经济管理”类图书的读者编号、读者姓名和出生日期（分别用 in 子查询和存在量词子查询表达）。</p>
<p>　　分析：先找出借阅了经济管理类书籍的读者号，然后判断每一个读者编号是否在前面找到的读者号中。</p>
<p>　　select readerNo, readerName, substring(identitycard,7,8) as birthday</p>
<p>　　from Reader</p>
<p>　　where readerNo not in (</p>
<p>　　select readerNo</p>
<p>　　from Borrow</p>
<p>　　where bookNo in(</p>
<p>　　select bookNo</p>
<p>　　from Book</p>
<p>　　where classNo in(</p>
<p>　　select classNo</p>
<p>　　from BookClass</p>
<p>　　where className=’经济管理’ )));</p>
<p>　　</p>
<p>　　</p>
<p>　　select readerNo, readerName, reader, substring(identitycard,7,8) as birthday</p>
<p>　　from Reader</p>
<p>　　where not exists(</p>
<p>　　select *</p>
<p>　　from Borrow br, Book bk, BookClass bc</p>
<p>　　where br.bookNo=bk.bookNo and bk.classNo=bc.classNo and bc,className=’经济管理’ and br.readerNo = Reader.readerNo);</p>
<p>　　</p>
<p>　　5)查询至少借阅了“马永强”所借的所有图书的读者编号、读者姓名、和工作单位。</p>
<p>　　分析：马永强所借的书他都借过 即 没有马永强借的书是他没有借的</p>
<p>　　select readerNo, readerName, workUnit</p>
<p>　　from Reader r1        //遍历每一位读者</p>
<p>　　where r1.readerNo not in(</p>
<p>　　select readerNo</p>
<p>　　from Borrow b1    //读者借书</p>
<p>　　where not exists(</p>
<p>　　select *</p>
<p>　　from Reader r2</p>
<p>　　where r2.readerName=’马永强’ and not exists(</p>
<p>　　select *</p>
<p>　　from Borrow b2      //马永强借书</p>
<p>　　where r2.readerNo=b2.readerNo and b1.bookNo=b2.bookNo and b2.returnDate is null)));</p>
<h2 id="关系数据理论"><a href="#关系数据理论" class="headerlink" title="关系数据理论"></a>关系数据理论</h2><h3 id="数据冗余导致的问题"><a href="#数据冗余导致的问题" class="headerlink" title="数据冗余导致的问题"></a>数据冗余导致的问题</h3><p>　　1）冗余存储：信息被重复存储，导致浪费大量存储空间。</p>
<p>　　2）更新异常：当重复的信息的一个副本被修改，所有副本都必须进行同样的修改。因此当更新数据时，系统要付出很大的代价来维护数据库的完整性，否则会面临数据不一致的风险。</p>
<p>　　3）插入异常：只有当一些信息事先已经存放在数据库中时，另外一些信息才能存入数据库中。</p>
<p>　　4）删除异常：删除某些信息时可能丢失其他信息。</p>
<h3 id="函数依赖定义"><a href="#函数依赖定义" class="headerlink" title="函数依赖定义"></a>函数依赖定义</h3><h4 id="函数依赖"><a href="#函数依赖" class="headerlink" title="函数依赖"></a>函数依赖</h4><p>　　在关系R中，若属性或者属性集 A 中 两个元组的值相等，如果这两个元祖中对应的属性或者属性集B中的值也相同，则记作A—&gt;B。 A函数决定B； 或者 B函数依赖于A。</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/E4hlWZPTntAf6KX.png" alt=""></p>
<h4 id="平凡与非平凡函数依赖"><a href="#平凡与非平凡函数依赖" class="headerlink" title="平凡与非平凡函数依赖"></a>平凡与非平凡函数依赖</h4><p>　　对于任一关系模式，平凡函数依赖都是必然成立的，它不反映新的语义。若不特别声明，总是讨论非平凡函数依赖。</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/Yrj2GxN84q5mglZ.png" alt=""></p>
<h4 id="完全函数依赖和部分函数依赖"><a href="#完全函数依赖和部分函数依赖" class="headerlink" title="完全函数依赖和部分函数依赖"></a>完全函数依赖和部分函数依赖</h4><p>　　完全函数依赖：（学号,课号）——&gt;成绩;   单独一个学号，不能决定成绩，单独一个课程，也不能决定成绩；只有二者同时，才能决定；</p>
<p>　　部分函数依赖：（学号,课号）——&gt;姓名；学号和课号能决定姓名, 单独一个 学号 也能决定 姓名；</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/W4s5Xqyj9JPelo1.png" alt=""></p>
<h4 id="传递函数依赖"><a href="#传递函数依赖" class="headerlink" title="传递函数依赖"></a>传递函数依赖</h4><p>　　学号—&gt;系号，系号—&gt;系主任;       系主任   传递依赖于  学号</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/8MYz1S5RQP7LhxO.png" alt=""></p>
<h3 id="函数依赖理论"><a href="#函数依赖理论" class="headerlink" title="函数依赖理论"></a>函数依赖理论</h3><h4 id="码、超码、候选码和主码"><a href="#码、超码、候选码和主码" class="headerlink" title="码、超码、候选码和主码"></a>码、超码、候选码和主码</h4><p>　　码是一个或多个属性的集合。</p>
<p>　　超码是一个或多个属性的集合，超码中的这些属性可以让我们在一个实体集中唯一地标识一个实体。</p>
<p>　　候选码是极小的超码集，也就是它的任意真子集都不是超码，而他本身是超码。</p>
<p>　　主码是被选中用来在一个关系中区分不同元组的候选码。</p>
<p>　　<strong>候选码的确定：</strong></p>
<p>　　设关系模式R中U=ABC…….等N个属性，U中的属性在FD中有四种范围：</p>
<p>　　(1)左右出现;<br>　　(2)只在左部出现;<br>　　(3)只在右部出现;<br>　　(4)不在左右出现;</p>
<p>　　算法：按以下步骤求候选键：<br>　　1.只在FD右部出现的属性，不属于候选码;<br>　　2.只在FD左部出现的属性，一定存在于某候选码当中;<br>　　3.外部属性一定存在于任何候选码当中;  (左右都不出现)</p>
<p>　　4.其他属性逐个与2,3的属性组合，求属性闭包，直至X的闭包等于U,若等于U,则X为候选码。</p>
<p>　　例1：R&lt;U,F&gt;,U=(A,B,C,D,E,G),F={AB–&gt;C,CD–&gt;E,E–&gt;A.A–&gt;G},求候选码以及主属性。</p>
<p>　　因为：G只在右边出现，所以候选码肯定不包含G，BD只出现在左边，所以，候选码中肯定有BD，而BD的闭包还是BD，则对BD进行组合,除了G以外,BD可以跟A,C,E进行组合。</p>
<p>  　　<strong>先看ABD</strong><br>  　　ABD本身自包ABD,而AB–&gt;C,CD–&gt;E,A–&gt;G,所以ABD的闭包为ABDCEG=U<br> 　 　<strong>再看BDC</strong><br>　　  CD–&gt;E,E–&gt;A,A–&gt;G,BDC本身自包,所以BDC的闭包为BDCEAG=U<br> 　　 <strong>最后看BDE</strong><br>　　  E–&gt;A,A–&gt;G,AB–&gt;C,BDE本身自包,所以BDE的闭包为BDEAGC=U</p>
<p>  　　因为(ABD)、(BCD)、(BDE)的闭包都是ABCDEG所以本问题的候选码有3个分别是ABD、BCD和BDE</p>
<p> 　　候选码：ABD，BCD，BDE；</p>
<p>　　主属性（主要的属性，能决定其他属性的)：ABCDE;</p>
<p>　　非主属性：G；  
　　</p>
<h4 id="Armstrong-公理系统"><a href="#Armstrong-公理系统" class="headerlink" title="Armstrong 公理系统"></a>Armstrong 公理系统</h4><p>　　设关系模式R&lt;U,F&gt;，其中U为属性集，F是U上的一组函数依赖，那么有如下推理规则</p>
<p>　　① A1自反律：若Y⊆X⊆U，则X→Y为F所蕴含；                    即：ABC→AB；   AB——&gt;A (平凡依赖函数)；<br>　　② A2增广律：若X→Y为F所蕴含，且Z⊆U，则XZ→YZ为F所蕴含；<br>　　③ A3传递律：若X→Y，Y→Z为F所蕴含，则X→Z为F所蕴含。<br>　　根据上面三条推理规则，又可推出下面三条推理规则：<br>　　④ 合并规则：若X→Y，X→Z，则X→YZ为F所蕴含；<br>　　⑤ 伪传递规则：若X→Y，WY→Z，则XW→Z为F所蕴含；  即：A→B，AC→BC；BC→D ；得出AC→D；<br>　　⑥ 分解规则：若X→Y，Z⊆Y，则X→Z为F所蕴含。      即：A→BC;  能得出：  A→B，A→C；  </p>
<h4 id="属性集闭包"><a href="#属性集闭包" class="headerlink" title="属性集闭包"></a>属性集闭包</h4><p>　　闭包就是由一个属性直接或间接推导出的所有属性的集合。</p>
<p>　　例如：f={a-&gt;b，b-&gt;c，a-&gt;d，e-&gt;f}；由a可直接得到b和d，间接得到c，则a的闭包就是{a，b，c，d}；</p>
<p>　　已知关系R(A1，A2，A3，A4，A5，A6)，函数依赖集F为{ (A2，A3)——&gt;A4，A3——&gt;A6，(A2，A5)——&gt;A1 }， 问(A2，A3)关于F的属性闭包为：{A2，A3,A4,A6}；  因为：A2，A3能带到A4，A3能得到A6；</p>
<p>　　已知关系R(A，B，C，D，E，F，G)，函数依赖集F为{ A ——&gt;B，B——&gt;D，AD——&gt;EF，AG——&gt;C}， 问：A关于F的属性闭包为:{A,B,D,E,F}；     因为：A能得到B，B能得到D，AD能得到EF;  </p>
<h4 id="最小函数依赖集（正则覆盖）"><a href="#最小函数依赖集（正则覆盖）" class="headerlink" title="最小函数依赖集（正则覆盖）"></a><strong>最小函数依赖集（正则覆盖）</strong></h4><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><p>　　如果函数依赖集F满足以下条件，则称F为一个极小函数依赖集。也称为最小依赖集或最小覆盖。</p>
<p>　　(1)F中任一函数依赖的右部仅含有一个属性。</p>
<p>　　(2)F中不存在这样的函数依赖X→A，使得F与F-{X→A}等价。</p>
<p>　　(3)F中不存在这样的函数依赖X→A，X有真子集Z使得F-{X→A}U{Z→A}与F等价。</p>
<h5 id="最小依赖集通用算法"><a href="#最小依赖集通用算法" class="headerlink" title="最小依赖集通用算法"></a><strong>最小依赖集通用算法</strong></h5><p>　　① 用分解的法则，使F中的任何一个函数依赖的右部仅含有一个属性；</p>
<p>　　② 去掉多余的函数依赖：从第一个函数依赖X→Y开始将其从F中去掉，然后在剩下的函数依赖中求X的闭包X+，看X+是否包含Y，若是，则去掉X→Y；否则不能去掉，依次做下去。直到找不到冗余的函数依赖；</p>
<p>　　③ 去掉各依赖左部多余的属性。一个一个地检查函数依赖左部非单个属性的依赖。<strong>例如XY→A，若要判 X 为多余的，则以X→A代替XY→A，若 A 属于(Y)+，则 X 是多余属性（A 不通过 XY→A，通过 Y 就可以得到 A ，证明 X 是冗余的。），若 X 为多余的则用 Y→A 替代 XY→A。</strong></p>
<h5 id="最小依赖集案例"><a href="#最小依赖集案例" class="headerlink" title="最小依赖集案例"></a>最小依赖集案例</h5><p>　　例1：关系模式R(U，F)中，U=ABCDEG，F={B-&gt;D，DG-&gt;C,BD-&gt;E,AG-&gt;B,ADG-&gt;BC}；求F的最小函数依赖集</p>
<p>　　步骤：</p>
<p>　　（1）用分解的法则，使F中的任何一个函数依赖的右部仅含有一个属性；得到：F={B-&gt;D，DG-&gt;C,BD-&gt;E,AG-&gt;B,ADG-&gt;B，ADG-&gt;C}；</p>
<p>　　（2）去掉多余的函数依赖：从第一个函数依赖X→Y开始将其从F中去掉，然后在剩下的函数依赖中求X的闭包X+，依次做下去。直到找不到冗余的函数依赖；</p>
<p>　　　　① 去掉B-&gt;D，此时F={DG-&gt;C,BD-&gt;E,AG-&gt;B,ADG-&gt;B，ADG-&gt;C}，此条件下得出B的闭包 B+ = B；B+不包含D，所以B-&gt;D保留。</p>
<p>　　　　②去掉DG-&gt;C，此时F={B-&gt;D,BD-&gt;E,AG-&gt;B,ADG-&gt;B，ADG-&gt;C}，此时DG闭包DG+ = DG，不包含C,所以不能去掉DG-&gt;C.</p>
<p>　　　　③ 去掉BD-&gt;E，此时F={B-&gt;D，DG-&gt;C,AG-&gt;B,ADG-&gt;B，ADG-&gt;C}，此时闭包BD+ = BD,不包含E，所以不能去掉BD-&gt;E，继续保留。</p>
<p>　　　　④去掉AG-&gt;B，此时F={B-&gt;D，DG-&gt;C,BD-&gt;E,ADG-&gt;B，ADG-&gt;C}；此时AG+ = AG，不包含B，所以不能去掉AG-&gt;B，继续保留。</p>
<p>　　　　⑤去掉ADG-&gt;B，此时F={B-&gt;D，DG-&gt;C,BD-&gt;E,AG-&gt;B,ADG-&gt;C}，此时ADG+ = ADGCBE,包含了B，所以删除ADG-&gt;B，不保留。</p>
<p>　　　　⑥去掉ADG-&gt;C，此时F={B-&gt;D，DG-&gt;C,BD-&gt;E,AG-&gt;B}，此时ADG+ = ADGCBD,包含了C，所以删除ADG-&gt;C，不保留。</p>
<p>　　　　综上所得，此时得到F={B-&gt;D，DG-&gt;C,BD-&gt;E,AG-&gt;B}；</p>
<p>　　（3）去掉各依赖左部多余的属性。一个一个地检查函数依赖左部非单个属性的依赖。</p>
<p>　　此时函数依赖左边非单个属性有：DG-&gt;C,BD-&gt;E,AG-&gt;B；所以做如下操作：</p>
<p>　　　　①先来看DG-&gt;C，<strong>判断 D 是否多余，用 D-&gt;C 代替 DG-&gt;C 并求 DG - D = G 的闭包</strong>，此时G的闭包G+ = G，不包含C，保留D。判断 G 是否多余，求 DG - G = D 的闭包，此时D+ = D，不包含C，所以G也不能去掉；</p>
<p>　　　　②再来看BD-&gt;E，判断 B 是否多余，求 BD - B = D 的闭包，此时D的闭包D+ = D，不含E，保留B。判断 D 是否多余，求 BD - D = B 的闭包，此时B+ = BDE，包含了E，所以<strong>去掉D。</strong></p>
<p>　　　　③最后再来看 AG-&gt;B，判断 A 是否多余，求 AG - A = G 的闭包，G+ = G，不包含B，不能去掉A。判断 G 是否多余，求 AG - G = A 的闭包，A的闭包A+ =A，不含B，不能去掉G，还是AG-&gt;B ；</p>
<p>　　所以最后得出：F的最小函数依赖集是：F={B-&gt;D，DG-&gt;C,B-&gt;E,AG-&gt;B}；</p>
<h4 id="无损连接分解判定"><a href="#无损连接分解判定" class="headerlink" title="无损连接分解判定"></a>无损连接分解判定</h4><h5 id="判断表法"><a href="#判断表法" class="headerlink" title="判断表法"></a>判断表法</h5><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/lHaYsVfUW1kOC69.png" alt=""></p>
<p> <img src="https://gitee.com/hoo334/picgo/raw/master//img/JAR2xnFpjH6qCoD.png" alt=""></p>
<p> <img src="https://gitee.com/hoo334/picgo/raw/master//img/vg6JaYUop15BFlO.png" alt=""></p>
<h5 id="无损连接定理"><a href="#无损连接定理" class="headerlink" title="无损连接定理"></a>无损连接定理</h5><p>　　<img src="https://gitee.com/hoo334/picgo/raw/master//img/5qiw86uL2yGmSPZ.png" alt=""></p>
<p>　　案例（1）：关系模式R（SAIP），F={S—&gt;A,SI—&gt;P};  ρ={R1(SA),R2(SIP)}检测分解是否为无损连接？</p>
<p>　　因为：R1∩R2 = S ；R1—R2 = A； R2—R1 = IP；所以得出：S —&gt;A；或者S —&gt;IP； 而 S —&gt;A 在F={S—&gt;A,SI—&gt;P}中，所以此分解是无损连接。</p>
<p>　　举例（2）：已知R&lt;U,F&gt;，U={A,B,C}，F={A→B}，如下的两个分解：<br>　　① ρ1={AB,BC}；</p>
<p>　　② ρ2={AB,AC}；</p>
<p>　　因为：AB∩BC = B；AB—BC = A；BC—AB = C；得出；B→A，或者 B→A，两个都不包含在F={A→B}中，所以 ρ1 分解是有损的。</p>
<p>　　因为：AB∩AC = A；AB—AC = B；AC—AB = C；得出：A→B，或者A→C，而A→B包含在F={A→B}中，所以 ρ2 分解是无损的。</p>
<h4 id="保持依赖分解判定"><a href="#保持依赖分解判定" class="headerlink" title="保持依赖分解判定"></a>保持依赖分解判定</h4><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/rZvdit19IXUeu46.png" alt=""></p>
<p>　　</p>
<p>​        案例（1）：关系模式R&lt;U, F&gt;，U=｛A, B, C, D, E｝，F＝{B→A，D→A，A→E，AC→B｝则分解ρ={R1（ABCE），R2（CD）｝是否满足保持函数依赖。</p>
<p>　　因为：B→A，A→E，AC→B在R1上成立，D→A在R1和R2上都不成立，因此需做进一步判断。</p>
<p>　　由于B→A，A→E，AC→B都是被保持的（因为它们的元素都在R1中），因此我们要进一步判断的是D→A是不是也被保持。</p>
<p>　　①先看R1：因为：result = D；result ∩R1 = ф (空集)；所以：t=ф，result=D；</p>
<p>　　②再看R2：因为：result = D；result ∩R2 = D；D+ = DA; D+ ∩ R2 = D; 所以：t=D，result=D；</p>
<p>　　一个循环后result未发生变化，因此最后result=D，并未包含A，所以D→A未被保持，该分解不是保持依赖的。</p>
<p>　　案例（2）：关系R&lt;U,F&gt;，U={A,B,C,D,E}，F={A→C,B→C,C→D,DE→C,CE→A}，R的一个分解为R1(AD)，R2(AB)，R3(BE)，R4(CDE)，R5(AE)，判断这个分解是否具有函数依赖性。</p>
<p>　　因为：,C→D,DE→C均在R4(CDE)中被保持，而A→C,B→C，CE→A，在R1….R5上都不成立，需要进一步判断。</p>
<p>　　（1）A→C；</p>
<p>　　①先看R1：因为：result = A；result ∩R1 = A ； A+ = ACD ； A+ ∩ R1 = AD；所以：t=AD，result=AD； 此时，result改变，则，进入R2；</p>
<p>　　②再看R2：因为：result = AD；result ∩R2 = ф，最后还是result = AD；</p>
<p>　　③再看R3：因为：result = AD；result ∩R3 = ф，最后还是result = AD；</p>
<p>　　④再看R4：因为：result = AD；result ∩R4 = D，D+ = D; D+ ∩ R4= D；最后还是result = AD；</p>
<p>　　⑤再看R5：因为：result = AD；result ∩R5 = A，最后还是result = AD；</p>
<p>　　最后result = AD 并未包含C；所以，所以D→A未被保持，该分解不是保持依赖的；</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/9ndTFcB2j7MrzIP.png" alt="image-20200413172034818"></p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/svSjHaFopgIeTwL.png" alt="image-20200413172105632"></p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/XU2MsqG8edf6HIh.png" alt="image-20200413172128282"></p>
<h4 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h4><p>　　（1）：1NF：每个分量都是不可再分的数据项（值、原子）。即：属性中，不能存在复合属性 或者 多值属性。</p>
<p>　　（2）：2NF：每一个非主属性 完全函数依赖 于 候选键（码）。注意：这里是码（不是主属性）；即：不能存在 非主属性部分函数依赖于码。</p>
<p>　　（3）：3NF：每一个非主属性 都不传递依赖于 码。 即：不能存在非主属性对于码的传递函数依赖。</p>
<p>　　（4）：BCNF：不存在 主属性 对于 码 的 部分函数依赖 与 传递函数依赖。判断方法：箭头左边的必须是候选码（不能只是一个属性，部分码）。</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/f8IdKbFRrWoZPw3.png" alt=""></p>
<p>　　<strong>判断范式的方法：</strong></p>
<p>　　<img src="https://gitee.com/hoo334/picgo/raw/master//img/RcqhALHKwyl9GUX.png" alt=""></p>
<p> 　　例1：R（A，B，C），F={A-&gt;B, B-&gt;A, A-&gt;C}</p>
<p>　　　　L ：No，R：C，LR：A，B</p>
<p>　　　　计算A+ = ABC ，A 是候选码</p>
<p>　　　　计算B+ = ABC，B 是候选码</p>
<p>　　　　主属性： A，B ；非主属性： C</p>
<p>　　　　1）看非主属性是否部分依赖于主属性，发现没有部分依赖。</p>
<p>　　　　2）看非主属性是否传递依赖于主属性，发现 B -&gt; A -&gt; C ，C 传递依赖于 B，<strong>但这个传递依赖成立的条件是 A -&gt; B 不成立，否则A -&gt; C 推不出来。</strong>故没有部分传递依赖。</p>
<p>　　　　3）看所有依赖左边是否全部为候选码，所有依赖左边依次是 A，B，A 全部为 候选码 故为 BCNF 范式。</p>
<p>　　　　例2：R（A，B，C，D），F={B-&gt;D, D-&gt;B, AB-&gt;C}</p>
<p>　　　　L：A， R：C，LR：B，D</p>
<p>　　　　L 一定为主属性，将 L 和 LR 组合为 AB，AD</p>
<p>　　　　主属性： A，B，D ；非主属性： C</p>
<p>　　　　AB+ = ABCD；AD+ = ABCD；故 AB，AD为候选码。</p>
<p>　　　　1）查看部分依赖。 C 完全依赖于 AB，没有部分依赖。</p>
<p>　　　　2）查看传递依赖。C直接完全依赖于候选码 AB，没有传递依赖。</p>
<p>　　　　3）查看是否全为候选码。所有依赖左边依次是 B，D，AB ，B，D不为 候选码 故为 3NF 范式。</p>
<h4 id="模式分解"><a href="#模式分解" class="headerlink" title="模式分解"></a>模式分解</h4><h5 id="3NF-分解"><a href="#3NF-分解" class="headerlink" title="3NF 分解"></a><strong>3NF 分解</strong></h5><p>　　1）计算最小函数依赖</p>
<p>　　2）将最小函数依赖依次分解，得到 3NF 保持函数依赖分解。</p>
<p>　　3）将保持依赖分解添加一个候选码到结果中，得到 3NF 无损连接分解。</p>
<h5 id="BCNF-分解"><a href="#BCNF-分解" class="headerlink" title="BCNF 分解"></a><strong>BCNF 分解</strong></h5><p>　　R(A，B，C，D)，F={A-&gt;B，C-&gt;D}一直找不是候选码的函数依赖项 A-&gt;B，将依赖集分解为两部分：</p>
<p>　　1）AB</p>
<p>　　2）ACD (B 可由A 推出)</p>
<p>　　继续分解 ACD。</p>
<p>　　<img src="https://gitee.com/hoo334/picgo/raw/master//img/yL3SnojMe8WakFN.png" alt=""></p>
<p>　　例： R（A，B，C，D，E，F），F={AE-&gt;F，A-&gt;B, BC-&gt;D, CD-&gt;A, CE-&gt;F}</p>
<h5 id="3NF-分解例子"><a href="#3NF-分解例子" class="headerlink" title="3NF 分解例子"></a><strong>3NF 分解</strong>例子</h5><p>　　<strong>1）计算最小函数依赖集</strong>，这里省略，可以看到 F 的最小函数依赖集就是它本身。</p>
<p>　　<strong>2）计算候选码</strong></p>
<p>　　L：C，E</p>
<p>　　R：F</p>
<p>　　LR：A，B，D</p>
<p>　　L 一定为主属性，将 L 和 LR 组合为 ACE，BCE，CDE。</p>
<p>　　主属性： A，B，C，D ，E；非主属性： F</p>
<p>　　ACE+ = ABCDEF；BCE+ = ABCDEF；CDE+ = ABCDEF；故ACE，BCE，CDE为候选码。</p>
<p> 　　<strong>3）分解</strong></p>
<p>　　将上面的函数依赖依次分解得到：AEF，AB，BCD，CDA，CEF。</p>
<p>　　得到 3NF 保持函数依赖分解 : AEF，AB，BCD，CDA，CEF</p>
<p>　　任意添加一个候选码进去(这里选 ACE)。</p>
<p>　　得到 3NF 无损连接依赖分解 : AEF，AB，BCD，CDA，CEF，ACE</p>
<h5 id="BCNF-分解例子"><a href="#BCNF-分解例子" class="headerlink" title="BCNF 分解例子"></a><strong>BCNF 分解例子</strong></h5><p>　　<strong>依次分解左边不是候选码的依赖项</strong></p>
<p>　　AE-&gt;F，A-&gt;B, BC-&gt;D, CD-&gt;A, CE-&gt;F 左边全部都不是候选码，都需要分解。</p>
<p>　　第一次分解 AE-&gt;F：</p>
<p>　　AEF， 剩下 R=（ABCDE），F={A-&gt;B, BC-&gt;D, CD-&gt;A} （F可以被导出，若 F 在依赖的左边需要使用其他依赖代替）</p>
<p>　　第二次分解 A-&gt;B：</p>
<p>　　AB，剩下 R=（ACDE）， F={AC-&gt;D, CD-&gt;A} （B可以被导出，<strong>丢失BC-&gt; D</strong>）</p>
<p>　　第三次分解 CD-&gt;A：</p>
<p>　　CDA，剩下 R=（CDE）， F={} （A可以被导出）</p>
<p>　　CDE为候选码分解停止。</p>
<p>　　故 BCNF 分解为 AEF，AB，CDA，CDE</p>
<p>参考：</p>
<p>　　<a href="https://blog.csdn.net/prdslf001001/article/details/80336835" target="_blank" rel="noopener">https://blog.csdn.net/prdslf001001/article/details/80336835</a></p>
<p>　　<a href="https://www.bilibili.com/video/av73467859/" target="_blank" rel="noopener">https://www.bilibili.com/video/av73467859/</a></p>
<p>　　<a href="https://www.bilibili.com/video/BV1eE411a79r/" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1eE411a79r/</a></p>
<h2 id="E-R模型"><a href="#E-R模型" class="headerlink" title="E - R模型"></a>E - R模型</h2><h3 id="数据库设计过程"><a href="#数据库设计过程" class="headerlink" title="数据库设计过程"></a>数据库设计过程</h3><p>​    1）需求分析：了解和分析系统将要提供的功能及未来数据库的用户需求。</p>
<p>​    2）概念设计：根据需求分析中得到的信息，设计者此阶段须选择适当的数据模型将这些需求转化为数据库的概念模式。例如 <strong>E - R 模型</strong> 是概念设计。</p>
<p>​    3）逻辑设计：将概念设计转化为所选择的数据库管理系统支持的逻辑数据模型，即数据库模式。逻辑数据库设计的任务是将 E - R 模型转化为关系数据库模式。</p>
<p>​    4）模式求精：对已得到的关系数据库模式进行分析找出潜在的问题并加以改进和优化。</p>
<p>​    5）物理设计：为逻辑数据库选取一个最适合现实应用的物理结构。</p>
<p>​    6）应用与安全设计：数据库系统必须指出哪些用户可以访问数据库以及他们通过哪些存储过程访问数据库。</p>
<h3 id="E-R-模型基本概念及表示"><a href="#E-R-模型基本概念及表示" class="headerlink" title="E - R 模型基本概念及表示"></a>E - R 模型基本概念及表示</h3><h4 id="实体与实体集"><a href="#实体与实体集" class="headerlink" title="实体与实体集"></a>实体与实体集</h4><p>​    实体是客观世界中可区别于其他事物的“事物”或“对象”。</p>
<p>​    实体的两个特征：独立存在（一个实体的存在不依赖于其他实体）、可区别于其他实体。</p>
<p>​    实体集是指具有相同类型及相同性质（或属性）的实体集合。</p>
<h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><p>​    实体是通过一组属性来描述的，属性是实体集中每个实体都具有的描述性性质。在已实体集中，所有实体都具有相同的属性。</p>
<p>​    每个属性所允许的取值范围或集合称为该属性的<strong>域</strong>。</p>
<p>​    E - R 模型中的属性可按如下类型划分：</p>
<p>​    1）简单属性和复合属性。简单属性是指不能再分为更小部分的属性。复合属性指可以进一步划分为更小部分的属性。</p>
<p>​    2）单值属性和多值属性。如果某属性对一个特定实体任何时候都只能有单独的一个值，则称该属性为单值属性，否则为多值属性。例如一个studentNo 属性只对应一个学号，为单值属性。一个phoneNumber属性可能有不同数目的值，为多值属性。</p>
<p>​    3）空值（NULL）属性。当某个属性上没有值时可以使用 NULL 值。</p>
<p>​    4）派生属性，这类属性的值可以从其他属性的值派生出来。例如实体集 Student 的 age 属性表示学生的年龄，它可以由当前日期和生日属性的值计算得到。</p>
<p>​    在 E - R 图中，实体集用矩形表示，属性用椭圆表示，多值属性用双椭圆表示，派生属性用虚线椭圆表示，属性与实体之间用连线表示。</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/2lqtAhLbzMSsjE4.png" alt="image-20200405101025891"></p>
<h4 id="联系与联系集"><a href="#联系与联系集" class="headerlink" title="联系与联系集"></a>联系与联系集</h4><p>​    联系集是 n （n &gt;= 2）个实体集上的数学关系，这些实体集不必互异。</p>
<p>​    参与联系的实体集的数目称为联系集的度。</p>
<p>​    下图中，Student 与 Course 之间有 Enroll 联系集，选课联系集上有 Score 属性。课程里面的 PriorCourse 属性参照 Course 关系。 </p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/kKAVRhcFCMYjawT.png" alt="image-20200405101234923"></p>
<h3 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h3><h4 id="映射约束"><a href="#映射约束" class="headerlink" title="映射约束"></a>映射约束</h4><p>​    映射基数指一实体集中的一个实体通过一个联系集能同时与另一个实体集相联系的实体数目。在二元联系中，共有 4 种映射基数：1：1（一对一）、1：m（一对多）、m：1（多对一）、m：n（多对多）。</p>
<p>​    在 E - R 图中，“—&gt;”指向参与联系集中“一”方实体集，线段“—”表示参与联系集中的“多”方实体集。</p>
<h4 id="码约束"><a href="#码约束" class="headerlink" title="码约束"></a>码约束</h4><h5 id="实体集的码"><a href="#实体集的码" class="headerlink" title="实体集的码"></a>实体集的码</h5><p>​    码是一个或多个属性的集合。</p>
<p>​    超码是一个或多个属性的集合，超码中的这些属性可以让我们在一个实体集中唯一地标识一个实体。</p>
<p>​    候选码是极小的超码集，也就是它的任意真子集都不是超码，而他本身是超码。</p>
<p>​    主码是被选中用来在一个关系中区分不同元组的候选码。</p>
<h5 id="联系集的码"><a href="#联系集的码" class="headerlink" title="联系集的码"></a>联系集的码</h5><p>​    二元联系集的主码选择依赖于联系集的映射基数，具体如下。</p>
<p>​    1）一对一：主码可以使用参与联系集中的任何一方实体集的主码；</p>
<p>​    2）一对多和多对一：主码由“多的一方实体集的主码组成；</p>
<p>​    3）多对多：主码由参与联系集中所有实体集的主码组成。</p>
<h4 id="参与约束"><a href="#参与约束" class="headerlink" title="参与约束"></a>参与约束</h4><p>​    如果实体集 A 中的每个实体都参与到联系集 R 中至少一个联系中，则称实体集 A 全部参与联系集 R。</p>
<h4 id="存在依赖与弱实体集"><a href="#存在依赖与弱实体集" class="headerlink" title="存在依赖与弱实体集"></a>存在依赖与弱实体集</h4><p>​    存在一类实体集，其属性不足以形成主码，它们必须依赖于其他实体集的存在而存在，称这样的实体集为<strong>弱实体集</strong>。与此相对，其属性可以形成主码的实体集称为<strong>强实体集</strong>。弱实体集所依赖的强实体集称为<strong>标识实体集</strong>。弱实体集必须与一个标识实体集相关联才有意义，该实体集称为<strong>标识实体集</strong>。</p>
<p>​    对于弱实体集，必须满足下列限制：</p>
<p>​    1）标识实体集和弱实体集必须是一对多联系集。</p>
<p>​    2）弱实体集在标识联系集中是全部参与。</p>
<p>​    E - R 图使用双矩形表示弱实体集，双菱形表示标识联系，用虚下划线表示弱实体集的部分码。下图描述了 CourseClass 及其标识实体集 Course 之间的标识联系集 Arrange 。注意标识联系集没有描述性属性，因为任何所需的属性都可和弱实体相关联。</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/JW8oG15VvgYqley.png" alt="image-20200405103558371"></p>
<h3 id="E-R-模型转化为关系模型"><a href="#E-R-模型转化为关系模型" class="headerlink" title="E - R 模型转化为关系模型"></a>E - R 模型转化为关系模型</h3><h4 id="E-R-模型转化方法"><a href="#E-R-模型转化方法" class="headerlink" title="E - R 模型转化方法"></a>E - R 模型转化方法</h4><p>​    1）强实体集转化方法：将实体集的每个属性对应为关系模式的属性，实体集的码作为关系模式的码。</p>
<p>​    2）弱实体集转化方法：弱实体集对应的关系模式属性由弱实体集本身的描述属性加上所依赖的强实体集的主码属性组成。<strong>主码由所依赖的强实体集主码和弱实体集的部分码组成</strong>。</p>
<p>​    3）联系集转化方法    </p>
<p>​        联系集一般转化方法：一个联系集转化为一个关系模式。联系集的主码设置见“联系集的主码“。</p>
<p>​        一对多或多对一联系集的转化：在 ”多“ 方的实体集中添加 ”一“ 方的主码，使 ”一“ 方的主码成为 ”多“ 方 的外码。</p>
<p>​    4）复合属性及多值属性转化方法：对于复合属性，应为每个子属性创建一个单独的属性，而不是为复合属性自身创建的一个单独的属性。</p>
<h3 id="习题-1"><a href="#习题-1" class="headerlink" title="习题"></a>习题</h3><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/Kfh8vNiTAQraPkX.png" alt="image-20200414081715392"></p>
<p>​    <img src="https://gitee.com/hoo334/picgo/raw/master//img/cdBWLxwvRQb9FnV.png" alt="image-20200414081741823"></p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/Ex5MTBGdXacLkyV.png" alt="image-20200414081901050"></p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/jGQMRbT2FCctdne.png" alt="image-20200414081801666"></p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/GPsadUnVFbQJm9l.png" alt="image-20200414081819570"></p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/eAio7uRHx3bcEQX.png" alt="image-20200414081934207"></p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/roiPmwSHdhaqDV4.png" alt="image-20200414101333649"></p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/a1hWbyZrOe6kMSC-1594978995215.png" alt="image-20200414101352852"></p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/IqghOSjkUmcQD7M.png" alt="image-20200414101445958"></p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/jJVGegbAKdwCi1S.png" alt="image-20200414101457645"></p>
<h2 id="数据库完整性与安全性"><a href="#数据库完整性与安全性" class="headerlink" title="数据库完整性与安全性"></a>数据库完整性与安全性</h2><h3 id="数据库安全性"><a href="#数据库安全性" class="headerlink" title="数据库安全性"></a>数据库安全性</h3><h4 id="SQL-存取控制机制"><a href="#SQL-存取控制机制" class="headerlink" title="SQL 存取控制机制"></a>SQL 存取控制机制</h4><p>​    SQL 支持受控的存取保护，即在自主存取控制中，用户对于不同的数据对象有不同的存取权限，不同的用户对同一对象也有不同的权限，而且用户还可将其拥有的存取权限转授给其他用户。因此自主存取控制非常灵活。</p>
<p>​    自主存取控制通过 SQL 的 grant 和 revoke 语句实现。</p>
<p>​    用户权限是由两个要素组成的：数据对象和操作对象。</p>
<p>​    用户的存取权限：该用户可以在哪些数据对象上进行哪些类型的操作。定义存取权限称为授权。</p>
<p>​    自主存取控制能够通过授权机制有效地控制其他用户对敏感数据的存取。</p>
<h5 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h5><p>​    创建用户语句 create user 的语法如下：</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/PMcSmGxa3O7JzBb.png" alt="image-20200405154743908"></p>
<p>​    只有系统的超级用户才有权创建一个新的数据库用户。新创建的数据库用户有 3 种权限 connect、resource 和 dba。默认为 connect 权限，拥有 connect 权限的用户不能创建新用户、模式和基本表，只能登录数据库。然后由 dba 或其他用户给他转授权限。拥有 resource 权限的用户可以创建基本表和视图，并称为所创建对象的属主，但不能创建模式和新用户。数据库对象的属主可以使用 grant 语句把该对象上的存取权限授予其他用户。拥有 dba 权限的用户是系统中的超级用户，可以创建新用户、模式、基本表和视图等；dba 拥有所有数据库对象的存取权限，还可以将这些权限授予给一般用户。</p>
<h5 id="权限的授予与收回"><a href="#权限的授予与收回" class="headerlink" title="权限的授予与收回"></a>权限的授予与收回</h5><p>​    grant 和 revoke 有两种权限：目标权限和命令权限。</p>
<h6 id="命令权限的授予与收回"><a href="#命令权限的授予与收回" class="headerlink" title="命令权限的授予与收回"></a>命令权限的授予与收回</h6><p>​    命令级权限主要指 DDL 操作权限。命令权限的授予语句 grant 和 收回语句 revoke 的语法分别为：</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/jWhtYLXsdeT6iAE.png" alt="image-20200405155559635"></p>
<p>​    其中 &lt; command_list &gt; 可以是 create database、create default、create function、create procedure、create rule、create table、create view、create index、backup database 和 backup log 等。</p>
<p>​    一次可以授予多种权限，授予多种权限时，权限之间用逗号分隔。</p>
<p>​    all：表示上述所有权限。</p>
<p>​    public：表示所有用户。</p>
<p>​    &lt; username_list &gt;：指定的用户名列表。如果将某组权限同时授予多个用户，则用户名之间用逗号分隔。</p>
<h6 id="目标权限的授予与收回"><a href="#目标权限的授予与收回" class="headerlink" title="目标权限的授予与收回"></a>目标权限的授予与收回</h6><p>​    目标权限主要指对对象的 DML 操作权限。对象权限的授予语句 grant 和收回语句 revoke 的语法分别为：</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/iEl5Mm3Tw8tWVQ6.png" alt="image-20200405160348795"></p>
<p>​    其中 &lt; command_list &gt; 可以是 update、select、insert、delete、execute 和 all 。execute 针对存储过程授予执行权限，update、select、insert、delete 针对基本表和视图授权， all 指全部的权限。</p>
<p>​    cascade ：级联收回。</p>
<p>​    restrict：默认值，若转赋了权限，则不能收回。</p>
<p>​    with grant option：将指定对象上的目标权限授予其他安全账户的能力，但是不允许循环授权。即不允许将其得到的权限授予其祖先。</p>
<h3 id="数据库完整性"><a href="#数据库完整性" class="headerlink" title="数据库完整性"></a>数据库完整性</h3><h4 id="完整性约束条件"><a href="#完整性约束条件" class="headerlink" title="完整性约束条件"></a>完整性约束条件</h4><p>​    完整性约束条件作用的对象可以是关系、元组、列 3 种。列约束主要是列的类型、取值范围、精度、是否允许空值等的约束条件。元组约束是元组中属性间的联系的约束。关系约束是若干元组间、关系集合上以及关系之间的约束。</p>
<p>​    完整性约束条件涉及的这 3 类对象，其状态可以是静态的，也可以是动态的。</p>
<p>​    静态约束是指数据库每一确定状态时的数据对象所应满足的约束条件，它反映数据库状态合理性的约束，这是最重要的一类完整性约束。</p>
<p>​    静态约束主要表现在：</p>
<p>​    1）静态列级约束：对一个列的取值域的说明。对数据类型（类型，长度、单位、精度等）、数据格式、对取值范围或取值集合的约束、对空值的约束和其他约束。</p>
<p>​    2）静态元组约束：规定元组的各个列之间的约束关系。</p>
<p>​    3）静态关系约束：在一个关系的各个元组之间或若干关系之间存在各种联系或约束。常见的静态关系约束有：<strong>实体完整性约束、参照完整性约束和函数依赖约束</strong>。</p>
<p>​    </p>
<p>​    动态约束是指数据库从一种状态转变为另一种状态时的新、旧值之间所应满足的约束条件，它是反映数据库状态变迁的约束。</p>
<p>​    动态约束主要表现在：</p>
<p>​    1）动态列级约束。修改列定义或列值时应满足的约束条件。<strong>包括修改列定义时的约束</strong>（将允许空值的列修改为不允许空值，记录中有一列为空值，拒绝修改）<strong>修改列值时的约束</strong>（修改列值有时需要参照其旧值）。</p>
<p>​    2）动态元组约束：指需改元组的值时元组中各个字段间需要满足某种约束条件。</p>
<p>​    3）动态关系约束：动态关系约束是加在关系变化前后状态上的限制条件。例如，事物一致性、原子性等约束条件。</p>
<p>​    </p>
<p>​    完整性约束又可以分为立即执行的约束和延迟执行的约束。</p>
<p>​    立即执行约束：检查是否违背完整性约束的时机是在一条语句执行完后立即检查。</p>
<p>​    延迟执行约束：需要延迟到整个事务执行结束后再进行检查。</p>
<p>​    </p>
<h4 id="实体完整性"><a href="#实体完整性" class="headerlink" title="实体完整性"></a>实体完整性</h4><p>​    实体完整性要求基本表的主码值唯一且不允许为空值。primary key 指定</p>
<p>​    实体完整性的检查和违约处理：</p>
<p>​    1）检查主码是否唯一。如果不唯一则拒绝插入或修改。（索引或顺序查找）</p>
<p>​    2）检查主码的各个属性是否为空，只要有一个为空则拒绝插入或修改。</p>
<h4 id="参照完整性"><a href="#参照完整性" class="headerlink" title="参照完整性"></a>参照完整性</h4><p>​    参照完整性为若干个表中的相应元组建立联系。参照完整性定义是使用 create table 语句中的 foreign key 和 references 短语来实现，或通过 alter table 语句中的 add foreign key 来实现。</p>
<p>​    参照完整性的检查和违约处理：</p>
<p>​    1）拒绝执行。如果发生了违约，阻止操作。</p>
<p>​    2）级联操作。当删除或修改被参照关系的某个元组造成了与参照关系的不一致时，则删除或修改参照表中所有不一致的元组。级联操作必须在定义外码时给出定义（在外码定义最后追加 on delete/update cascade）。</p>
<p>​    3）设置为空值。如果外码可以为空，发生了违约则将外码置空。</p>
<p>​    4）置空值删除。删除被参照关系的元组，并将被参照关系中相应元组的外码置空值。</p>
<h4 id="用户自定义完整性"><a href="#用户自定义完整性" class="headerlink" title="用户自定义完整性"></a>用户自定义完整性</h4><h5 id="属性上的约束"><a href="#属性上的约束" class="headerlink" title="属性上的约束"></a>属性上的约束</h5><p>​    包括：列值非空、列值唯一、设置默认值和满足 check 定义。如果不满足则拒绝相应的操作。</p>
<p>​    以上约束分别通过 not null、unique、default+默认值、check 实现。</p>
<h5 id="元组上的约束"><a href="#元组上的约束" class="headerlink" title="元组上的约束"></a>元组上的约束</h5><p>​    元组上的约束可以设置不同属性之间的取值相互约束条件，也是用 check 实现。插入元组或修改属性的值时，RDBMS 检查元组上的约束条件是否满足，否则拒绝操作。</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/fNQagDl4ZItoTWi.png" alt="image-20200405164250636"></p>
<p>​    第一个 check 为属性上的约束，放在属性定义后，第二个 check 为元组上的约束。    </p>
<h4 id="完整性约束的修改"><a href="#完整性约束的修改" class="headerlink" title="完整性约束的修改"></a>完整性约束的修改</h4><p>​    要修改约束必须先删除约束，然后加入新的约束。</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/n9JVSWwL5aC14o8.png" alt="image-20200405164505007"></p>
<h3 id="游标"><a href="#游标" class="headerlink" title="游标"></a>游标</h3><p>​    若要对 select 语句返回的结果值进行逐行处理，必须使用游标。可对游标的当前位置进行更新、查询和删除，使用游标必须经历 5 个步骤：</p>
<p>​    1）定义游标：declare；</p>
<p>​    2）打开游标：open；</p>
<p>​    3）逐行提取游标集中的行：fetch；</p>
<p>​    4）关闭游标：close；</p>
<p>​    5）释放游标：deallocate；</p>
<h4 id="游标的使用"><a href="#游标的使用" class="headerlink" title="游标的使用"></a>游标的使用</h4><h5 id="定义游标"><a href="#定义游标" class="headerlink" title="定义游标"></a>定义游标</h5><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/vcoWwbID6UaBy2i.png" alt="image-20200405165033658"></p>
<p>​    read only 表示当前游标集中的元组仅可以查询，不可以修改。update表示可以对当前游标集中的元组进行更新操作，如果有 of &lt; columnName_list &gt;，表示仅可以对游标集中指定的属性列进行更新操作。</p>
<h5 id="打开游标"><a href="#打开游标" class="headerlink" title="打开游标"></a>打开游标</h5><p>​    系统按照游标的定义从数据库中将数据检索出来，放在内存的游标集中，并为游标集指定一个游标，该游标指向游标集中的第一个元组。</p>
<p>​    打开游标的语法：open &lt; cursorName &gt;</p>
<h5 id="获取当前游标值"><a href="#获取当前游标值" class="headerlink" title="获取当前游标值"></a>获取当前游标值</h5><p>​    要对当前游标所指向的元组进行操作，必须获取当前游标所指向的元组，其语法是</p>
<p>​    fetch &lt; cursorName &gt; into &lt; @variableName_list &gt;</p>
<p>​    <strong>获取当前游标的值，必须将当前游标所指向的元组的各个属性值分别用变量接收，其变量个数、数据类型必须与定义游标中的 select 子句所定义的属性（或表达式）个数数据类型相一致。</strong></p>
<p>​    SQL Server 中，变量名前面必须使用 @ 符号，使用一个 @ 符号位局部变量，使用两个 @ 为全局变量。</p>
<p>​    执行一次该语句，系统将当前游标所指向的元组属性放到变量中，然后游标自动下移一个元组。当游标移至尾部，则不可以再读取游标，必须关闭游标再重新打开游标。可以通过检查全局变量 @@FETCH_STATUS 来判断是否已经读完游标集中所有行。</p>
<p>​    @@FETCH_STATUS 的值有：</p>
<p>​    0 ：fetch 语句成功，表示已经从游标集中获取了元组值。</p>
<p>​    1：fetch 语句失败或此行不在结果集中。</p>
<p>​    2：被提取的行不存在。</p>
<h5 id="关闭游标"><a href="#关闭游标" class="headerlink" title="关闭游标"></a>关闭游标</h5><p>​    close  &lt; cursorName &gt;</p>
<h5 id="释放游标所占用的存储空间"><a href="#释放游标所占用的存储空间" class="headerlink" title="释放游标所占用的存储空间"></a>释放游标所占用的存储空间</h5><p>deallocate  &lt; cursorName &gt;</p>
<h5 id="变量赋值"><a href="#变量赋值" class="headerlink" title="变量赋值"></a>变量赋值</h5><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/NUanJEF7lpHYyhA.png" alt="image-20200405195554371"></p>
<h4 id="对当前游标集的修改"><a href="#对当前游标集的修改" class="headerlink" title="对当前游标集的修改"></a>对当前游标集的修改</h4><p>​    可以对当前游标集中的元组执行删除和更新操作。</p>
<h5 id="删除游标集中的当前行"><a href="#删除游标集中的当前行" class="headerlink" title="删除游标集中的当前行"></a>删除游标集中的当前行</h5><p>​    delete from &lt; tableName &gt; where current of &lt; cursorName  &gt;</p>
<h5 id="更新游标集中的当前行"><a href="#更新游标集中的当前行" class="headerlink" title="更新游标集中的当前行"></a>更新游标集中的当前行</h5><p>​    update &lt; tableName &gt;</p>
<p>​    set &lt; columnName &gt;=&lt; expr &gt;[,&lt; columnName &gt;=&lt; expr &gt;…]</p>
<p>​    where current of &lt; cursorName &gt;</p>
<h3 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h3><p>​    存储过程是为了完成特定功能汇集而成的一组命名了的 SQL 语句集合，该集合编译后存放在数据库中，可按实际情况重新编译。</p>
<p>​    使用存储过程的优点：将业务操作封装、便于事务管理、实现一定程度的安全性保护、特别适合统计和查询操作、减少网络通信量。</p>
<h4 id="创建存储过程"><a href="#创建存储过程" class="headerlink" title="创建存储过程"></a>创建存储过程</h4><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/vXtEcyQObCRpxT6.png" alt="image-20200405200322658"></p>
<p>​    output：输出参数，被调用者获取使用。</p>
<h4 id="执行存储过程"><a href="#执行存储过程" class="headerlink" title="执行存储过程"></a>执行存储过程</h4><p>​    存储过程创建后存放在数据库中，当要使用存储过程时，必须执行命令 execute。</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/GlUWZ8rtMVhSO5y.png" alt="image-20200405200618013"></p>
<h4 id="修改和删除存储过程"><a href="#修改和删除存储过程" class="headerlink" title="修改和删除存储过程"></a>修改和删除存储过程</h4><h5 id="修改存储过程"><a href="#修改存储过程" class="headerlink" title="修改存储过程"></a>修改存储过程</h5><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/z1no7G8baR5Yp9t.png" alt="image-20200405200745811"></p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/s79bqRDMnWKrEvm.png" alt="image-20200405200755212"></p>
<h5 id="删除存储过程"><a href="#删除存储过程" class="headerlink" title="删除存储过程"></a>删除存储过程</h5><p>​    drop procedure &lt; procedureName &gt;</p>
<h3 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h3><p>​    触发器是用户定义在关系表上的一类由事件驱动的存储过程，由服务器自动激活。触发器可以进行更为复杂的检查和操作，具有更精细和强大的数据控制能力。</p>
<p>​    有两个特殊的表用在触发器语句中，不同的数据库其名称不一样。以SQL Server 为例介绍触发器。</p>
<p>​    1）deleted 表。存储 delete 和 update 语句执行时所影响的行的拷贝，在 delete 和 update 语句执行前被作用的行转移到 deleted 表中，即将被删除的元组或修改前的元组值存入该表中。</p>
<p>​    2）inserted 表。存储 insert 和 update 语句执行时所映像的行的拷贝，在 insert 和 update 语句执行期间，新行被同时加到 inserted 表和触发器中，即将被插入的元组或修改后的元组存入该表中，同时也更新基本表。</p>
<h4 id="创建触发器"><a href="#创建触发器" class="headerlink" title="创建触发器"></a>创建触发器</h4><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/KzmCBDclWnp6hxR.png" alt="image-20200405201801494"></p>
<p>​    &lt;insert|update|delete&gt; ：触发器事件。</p>
<h4 id="修改和删除触发器"><a href="#修改和删除触发器" class="headerlink" title="修改和删除触发器"></a>修改和删除触发器</h4><p>​    修改触发器：</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/rSV8gNdlaT6vQwx.png" alt="image-20200405202018722"></p>
<p>​    删除触发器：</p>
<p>​    drop trigger &lt; triggerName &gt;</p>
<h4 id="触发器的作用"><a href="#触发器的作用" class="headerlink" title="触发器的作用"></a>触发器的作用</h4><p>​    触发器常用于保证完整性，并在一定程度上实现安全性，如用触发器来进行审计。</p>
<h2 id="事务管理与恢复"><a href="#事务管理与恢复" class="headerlink" title="事务管理与恢复"></a>事务管理与恢复</h2><h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><h4 id="事务概念"><a href="#事务概念" class="headerlink" title="事务概念"></a>事务概念</h4><p>​    对于用户而言，事务是具有完整逻辑意义的数据库操作序列的集合。对于数据库管理系统而言，事务则是一个读写操作序列。这些操作是一个不可分割的逻辑工作单元，要么都做，要么都不做。</p>
<p>​    通常有有两种类型的事务结束语句：</p>
<p>​    1）事务提交（commit）：将成功完成事务的执行结果（即更新）永久化，并释放事务占有的全部资源。</p>
<p>​    2）事务回滚（rollback）：中止当前事务、撤销其对数据库所做的更新，并释放事务占有的全部资源。</p>
<p>​    </p>
<p>SQL Server 数据库提供了 3 种类型的事务模式：显式事务、隐式事务及自定义事务。</p>
<p>​    显式事务是指用户使用了 Transact-SQL 事务语句所定义的事务，其事务语句包括：</p>
<p>​    事务开始：begin transaction</p>
<p>​    事务提交：commit transaction，commit work</p>
<p>​    事务回滚：rollback transaction，rollback work</p>
<p>​    隐式事务是指事务提交或回滚后，SQL Server 自动开始新的事务。该类事务不需要采用 begin transaction 语句标识事务的开始。</p>
<p>​    自动定义事务模式：当一个语句成功执行后，它被自动提交，而当执行过程中出错时，则被自动回滚。</p>
<h4 id="事务特性"><a href="#事务特性" class="headerlink" title="事务特性"></a>事务特性</h4><p>​    1）原子性（Atomicity）。事务的所有操作要么全部被执行，要么都不执行。</p>
<p>​    2）一致性（Consistency）。一个单独执行的事务应保证其执行结果的一致性，即总是将数据库从一个一致性状态转化到另一个一致性状态。</p>
<p>​    3）隔离性（Isolation）。当多个事务并发执行时，一个事务的执行不能影响另一个事务，即并发执行的各个事务不能相互干扰。</p>
<p>​    4）持久性（Durability）。一个事务提交成功后，它对数据库的改变必须是永久的，即使随后系统出现故障。</p>
<h4 id="事务并发执行与调度"><a href="#事务并发执行与调度" class="headerlink" title="事务并发执行与调度"></a>事务并发执行与调度</h4><p>​    数据库管理系统允许多个事务并发执行，其主要优点是增加系统吞吐量和减少平均响应时间。</p>
<p>​    </p>
<p>​    并发事务带来的问题：</p>
<p>​    1）<strong>脏读（Dirty Read）</strong>：一个事务正在访问数据并对数据进行修改，修改还没有提交到数据库，这是另外一个事务访问了这个数据，然后使用了这个数据。这个数据更改之前的数据，另一个事务读到的数据是“脏数据”，依靠“脏数据”所做的操作是不正确的。</p>
<p>　2）<strong>丢失修改（Lost to modify）</strong>：一个事务读取一个数据时，另外一个事务也访问了该数据，在第一个事务中修改数据后，第二个事务也修改了这个数据。第一个事务内的修改结果丢失，因此称作丢失修改。例如事务1读取某表中的数据 A=20 ，事务2也读取A=20，事务1修改A=A-1，事务2也修改A=A-1，最终结果A=19，事务1的修改丢失。</p>
<p>　3）<strong>不可重复读（Unrepeatable read）</strong>：在一个事务内多次读同一个数据在这个事务还没有结束时，另一个事务也访问该数据。在第一个事务的两次读之间，另一个事务可能已经修改了数据，导致两次读取的数据可能不太一样。</p>
<p>　4）<strong>幻读（Phanatom read）</strong>：幻读与不可重复读类似。发生在一个事务读了几行数据，接着另一个并发 事务插入了一些数据。在随后的查询中第一个事务就会发现多了一些原本不存在的记录，好像发生了幻觉。    </p>
<h4 id="事务调度及正确性准则"><a href="#事务调度及正确性准则" class="headerlink" title="事务调度及正确性准则"></a>事务调度及正确性准则</h4><p>​    事务并发执行顺序是随机的，将由多个事务操作组成的随机执行序列称为一个调度。对于一组事务操作组成的调度序列而言，应满足下列条件：</p>
<p>​    1）该调度包括该组事务的全部操作；</p>
<p>​    2）属于同一个事务的操作应保持在原事务中的执行顺序。</p>
<p>​    串行调度：在调度 S 中，如果属于同一事务的操作都是相邻的，则称 S 是串行调度。</p>
<p>​    冲突操作：在一个调度 S 中，如果 A 和 B 是不同事务在相同数据对象上的操作，并且其中至少有一个是写操作，则称 A 与 B 是冲突操作。</p>
<p>​    冲突等价：如果一调度 S 可以经过交换一系列非冲突操作执行的顺序而得到一个新的调度 S‘ ，则称 S 与 S’ 是冲突等价的。</p>
<p>​    冲突可串行化：如果一调度 S 与一串行调度是冲突等价 的，则称 S 是冲突可串行化的。</p>
<h5 id="判断调度是否可串行化的方法"><a href="#判断调度是否可串行化的方法" class="headerlink" title="判断调度是否可串行化的方法"></a>判断调度是否可串行化的方法</h5><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/KOWfz9e1juAwros.png" alt="image-20200406101649482"></p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/4C2VSsKYmMUngI8.png" alt="image-20200406101753978"></p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/W5y9jOtbTdmeuCz.png" alt="image-20200406101814976"></p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/1uJ9kfFZqtl7VEz.png" alt="image-20200406101908368"></p>
<p>​    图 10-2(a) 中，对于 A 的并发访问：R1(A), W1(A), R2(A), W2(A)，存在 W1(A)后执行R2(A)，W1(A)后执行W2(A)。故 T1 -&gt; T2。优先图中无环可以串行化。</p>
<p>​    图 10-2(b) 中，对于 A 的并发访问：R2(A), W2(A), R1(A), W1(A) ，存在 W2(A)后执行R1(A)，W2(A)后执行W1A)。故 T2 -&gt; T1。优先图中无环可以串行化。</p>
<p>​    图10-8 中，对于 A 的并发访问：R4(A), W4(A), R6(A), W6(A)，存在 W4(A)后执行R6(A)，W4(A)后执行W6(A)。故 T4-&gt; T6。对于 B 的并发访问：R6(B), W6(B), R4(B), W4(B)，存在 W6(B)后执行R4(B)，W6(B)后执行W4(B)。故 T6-&gt; T4。优先图中有环，不可串行化。</p>
<h3 id="并发控制"><a href="#并发控制" class="headerlink" title="并发控制"></a>并发控制</h3><h4 id="基于封锁的协议"><a href="#基于封锁的协议" class="headerlink" title="基于封锁的协议"></a>基于封锁的协议</h4><p>​    并发控制机制大体上可分为悲观的和乐观的两种。悲观的并发控制方法认为数据库 的一致性经常会收到破坏，因此在事务访问数据对象前采取一定措施加以控制，只有得到访问许可时，才能访问数据对象，如<strong>基于封锁的并发控制方法</strong>。而乐观的并发控制方法则认为数据库的一致性通常不会得到破坏，故事务执行时可直接访问数据对象，只在事务结束时才验证数据库的一致性是否会遭到破坏，如基于有效性验证方法。</p>
<p>​    基于封锁的并发控制方法的基本思想是：当事务 <em>T</em> 需访问数据对象 <em>Q</em> 时，先申请对 <em>Q</em> 的锁。如批准获得，则 <em>T</em> 继续执行，且此后不允许其他任何事物修改 <em>Q</em>，直到事务 <em>T</em> 释放 <em>Q</em> 上的锁为止。</p>
<p>​    基本锁类型：</p>
<p>​    1）共享锁（Shared Lock，记为 S ）：如果事务 <em>T</em> 获得的对象 <em>Q</em> 上的共享锁，则 <em>T</em> 可读 <em>Q</em> 但不能写 <em>Q</em> 。</p>
<p>​    2）排他锁（eXclusive lock，记为 X ）：如果事务 <em>T</em> 获得的对象 <em>Q</em> 上的排他锁，则 <em>T</em> 可读 <em>Q</em> 又能写 <em>Q</em> 。</p>
<p>​    <strong>一个数据对象 <em>Q</em> 上可能有多个（被不同事务拥有的）共享锁，但任何时候只能有一个排他锁。</strong></p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/sNHdY7A2PhBy3ET.png" alt="image-20200406104004431"></p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/JX7bQ8va4hoMHNK.png" alt="image-20200406104529309"></p>
<p>​    图10-13 中的调度存在以下问题：</p>
<p>​    1）脏读。T2 步骤 11 读了 T1 修改后的数据，而T1 在步骤 12 回滚了。</p>
<p>​    2）不可重复读。如 T3 两次读到 A 的值不同。</p>
<p>​    3）不可串行化。</p>
<p>​    出现上述问题的原因是<strong>事务过早地释放了锁</strong>，如果规定事务在结束后才释放其持有地锁则可以保证调度的可串行性。但这会导致系统性能下降。</p>
<h4 id="两阶段封锁协议"><a href="#两阶段封锁协议" class="headerlink" title="两阶段封锁协议"></a>两阶段封锁协议</h4><p>​    两阶段封锁协议要求每个事务分两个阶段提出申请锁和解锁申请。</p>
<p>​    1）增长阶段：事务可以获得锁，但不能释放锁。</p>
<p>​    2）缩减阶段：事务可以释放锁，但不能获得新锁。</p>
<p>​    一开始，事务处于增长阶段，事务根据需要获得锁。一旦该事务释放了锁，它就进入了缩减阶段，不能再发出加锁请求。</p>
<p>​    两阶段封锁协议能保证冲突可串行化。对于任何事务，调度中该事务获得其最后加锁的时刻（增长阶段结束点）称为事务的封锁点。多个事务可以根据它们的封锁点进行排序，而这个顺序就是并发事务的一个冲突可串行化顺序。</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/6OxDya25XE3bVAo.png" alt="image-20200406105546498"></p>
<p>​    图10-14 采用了两阶段封锁，允许 T4 在获得全部锁后（A 和 B 上的排他锁）提前释放部分锁（步骤 7 释放了 A 上的排他锁），T5得以提前执行，从而提高了 T4 和 T5 的并发度，该调度是可串行化 的。</p>
<p>​    两阶段封锁保证了并发执行事务的正确性，但仍存在两个主要问题：</p>
<p>​    1）可能导致死锁，即持有锁的事务出现相互等待都不能继续执行。解除死锁的一个简单方法是超时机制。如果一个事务为某个锁等待的时间过长，可以悲观得认为死锁已经发生，回滚该事务并重启。</p>
<p>​    2）不能避免读脏数据。</p>
<p>​    另一个两阶段封锁得变体是强两阶段封锁协议，它要求事务提交之前不得释放任何锁。事务可以按其提交得顺序串行化。</p>
<h4 id="封锁协议总结"><a href="#封锁协议总结" class="headerlink" title="封锁协议总结"></a>封锁协议总结</h4><p>在运用 X 锁和 S 锁这两种基本封锁对数据对象加锁时，还要约定一些规则。例如，何时申请 X 锁和 S 锁、封锁时间、何时释放等。这些规则称为封锁协议。</p>
<p>对并发操作的不正确调度可能会带来脏读、丢失修改、不可重复读等不一致性问题。三级封锁协议分别在不同程度上解决了这些问题，为并发操作的正确调度提供一定的保证。</p>
<ol>
<li>一级封锁协议，事务 T 在修改数据 R 之前必须先对其加 X 锁，直到事务结束才释放。事务结束包括正常结束（COMMIT）和非正常结束（ROLLBACK）。</li>
<li>二级封锁协议，在一级封锁协议基础上增加事务 T 在读取数据 R 之前必须先对其加 S 锁，读完后即可释放 S 锁。</li>
<li>三级封锁协议，在一级封锁协议基础上增加事务 T 在读取数据 R 之前必须先对其加 S 锁，直到事务结束才释放。</li>
</ol>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/RkMmTrJnKHz3OWl.png" alt="image-20200511093025700"></p>
<p>总结：三个等级的封锁协议都是事务结束后释放 X 锁，不同的是一级封锁对于读取数据不加 S 锁，二级封锁加 S 锁，但在读取操作结束后就释放，三级封锁加 S 锁，在事务结束后释放。一级封锁保证不会丢失修改，二级封锁保证不会丢失修改和脏读，三级封锁保证不会丢失修改、脏读和可重复读。</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/GvaPKLouCjOWF9s.png" alt="image-20200511095857695"></p>
<h4 id="活锁与死锁"><a href="#活锁与死锁" class="headerlink" title="活锁与死锁"></a>活锁与死锁</h4><p>活锁就是一个事务一直处于“饥饿”状态。死锁即为临界资源的循环占用。</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/F5Vo6EMKPB9akYb.png" alt="image-20200511100149015"></p>
<p>避免出现“饥饿”现象的最简方法为采用 FCFS 策略。</p>
<p>避免死锁的方法有<strong>预防死锁</strong>和<strong>诊断并解除死锁</strong>两种。</p>
<p>预防死锁：</p>
<ol>
<li>一次封锁法，每个事务必须一次将所有使用的数据全部加锁。</li>
<li>顺序封锁法，对数据对象规定一个封锁顺序，所有事务都按这个顺序实施封锁。</li>
</ol>
<p>诊断和解除死锁</p>
<ol>
<li>超时法，如果一个事务的等待时间超过了规定的时限，就认为发生了死锁。</li>
<li>等待图法，出现环则发现死锁。</li>
</ol>
<h4 id="封锁的粒度"><a href="#封锁的粒度" class="headerlink" title="封锁的粒度"></a>封锁的粒度</h4><p>封锁对象的大小称为封锁粒度。封锁对象可以是逻辑单元，也可以是物理单元。封锁粒度与系统的并发度和并发控制的开销密切相关，封锁的粒度越大，并发度越小，系统的开销也越小；封锁的粒度越小，并发度较高，系统开销也较大。</p>
<h5 id="多粒度封锁"><a href="#多粒度封锁" class="headerlink" title="多粒度封锁"></a>多粒度封锁</h5><p>多粒度树的根结点是整个数据库，表示最大的数据粒度。叶节点表示最小的数据粒度。</p>
<p>多粒度封锁协议允许多粒度树中的每个结点被独立地加锁，对一个结点加锁意味着这个结点所有子节点也被加以同样类型的锁。在多粒度封锁中，一个数据对象可能以两种方式封锁：显式封锁和隐式封锁。显示封锁是应事务的要求直接加到数据对象上的锁；隐式封锁是该数据对象没有被独立加锁，由于其上级结点加锁而使该数据对象加上了锁。</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/Mix5FDt8dfVoYwX.png" alt="image-20200511122559581"></p>
<h5 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h5><p>意向共享锁（Intent Share Lock，IS 锁）意向排他锁（Intent Exclusive Lock，IX 锁）；共享意向排他锁（Share Intent Exclusive Lock，SIX 锁）。</p>
<ol>
<li>IS 锁，如果对一个数据对象加 IS 锁，表示它的子结点拟加 S 锁。</li>
<li>IX 锁，如果对一个数据对象加 IX 锁，表示它的子结点拟加 X 锁。</li>
<li>SIX 锁，如果对一个数据对象加 SIX 锁，表示对它加 S 锁，再加 IX 锁。</li>
</ol>
<p>在具有意向锁的多粒度封锁方法中，任意事务 T 要对一个数据对象加锁，必须先对它的上层结点加意向锁。申请封锁时应该按自上而下的次序进行，释放封锁时则应该按自下而上的次序进行。</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/WrXlch5Ly9KAwoS.png" alt="image-20200511123052840"></p>
<p>图 b 中，所谓锁的强度是指它对其他锁的排斥程度。一个事务在申请封锁时以强锁代替弱锁是安全的，反之则不然。</p>
<h4 id="其他并发控制机制"><a href="#其他并发控制机制" class="headerlink" title="其他并发控制机制"></a>其他并发控制机制</h4><p>并发控制的方法除了封锁技术外还有时间戳方法、乐观控制法和多版本并发控制等。</p>
<p>时间戳方法给每一个事务盖上一个时标，即事务开始执行的时间。每个事务具有唯一的时间戳，并按照这个时间戳来解决事务的冲突操作。</p>
<p>乐观控制阀认为书屋执行时很少发生冲突，不对事务进行特殊的管制，而是让它自由执行，事务提交前再进行正确性检查。如果发生冲突则回滚事务。</p>
<p>多版本并发控制是指数据库中通过维护数据对象的多个版本信息来实现高效并发控制的一种策略。</p>
<h3 id="恢复与备份"><a href="#恢复与备份" class="headerlink" title="恢复与备份"></a>恢复与备份</h3><h4 id="故障分类及恢复策略"><a href="#故障分类及恢复策略" class="headerlink" title="故障分类及恢复策略"></a>故障分类及恢复策略</h4><p>​    1）事务故障。事务未运行至正常终止点就夭折了。</p>
<p>​    2）系统故障。突发事件导致系统停止运行。</p>
<p>​    3）介质故障。硬件损坏。</p>
<p>​    4）其他故障。有人攻击。</p>
<h4 id="事务访问数据方式"><a href="#事务访问数据方式" class="headerlink" title="事务访问数据方式"></a>事务访问数据方式</h4><p>​    对于一个事务而言，它是通过 3 个地址空间同数据库进行交互：</p>
<p>​    1）保存数据库元素的磁盘块空间——物理数据库。</p>
<p>​    2）缓冲区管理器所管理的内存地址空间——数据缓冲区。</p>
<p>​    3）事务的局部地址空间——事务工作区。</p>
<p>​    当事务要读取数据库元素时，首先必须将该元素从物理数据库读取到数据缓冲区中，除非它已经在缓冲区中，然后再将缓冲区中的内容读到事务工作区中。</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/GZAjXMbNu4z7apB.png" alt="image-20200406111338451"></p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/TcfswaB6NqoKzdp.png" alt="image-20200406111426865"></p>
<h4 id="基于日志的故障恢复策略"><a href="#基于日志的故障恢复策略" class="headerlink" title="基于日志的故障恢复策略"></a>基于日志的故障恢复策略</h4><p>​    日志是 DBMS 记录数据库全部更新操作的序列文件。通常一个数据库系统只有一个日志文件，为所有事务共享，其主要特点有：</p>
<p>​    1）日志文件记录了数据库的全部更新顺序。</p>
<p>​    2）每条日志都记录在日志的尾部，故日志文件是一个追加文件。</p>
<p>​    3）DBMS 允许事务的并发执行导致日志文件是“交错的”。</p>
<p>​    4）属于单个事务的日志顺序与该事务的更新操作顺序是一致的。</p>
<p>​    5）日志记录通常是先写到日志缓冲区中，然后写到稳定存储器中。</p>
<p>​    数据库中的日志记录有两种类型：</p>
<p>​    1）记录数据更新操作的日志记录，包括 update，insert 和 delete 操作。</p>
<p>​    2）记录事务操作的日志记录，包括start，commit 和 abort 操作。</p>
<p>​    它们的具体记录格式如下：</p>
<p>​    &lt; Ti, A, V1,V2 &gt; 表示 Ti 对数据元素 A 执行了更新操作，V1为 A 更新前的值，V2表示 A 更新后的值。</p>
<p>​    &lt; Ti, START &gt; 表示事务 Ti 已经开始。此时 DBMS 完成对事务的初始化工作，如分配事务工作区等。</p>
<p>​    &lt; Ti, COMMIT &gt; 表示事务 Ti 已经提交。</p>
<p>​    &lt; Ti, ABORT &gt; 表示事务已经终止，即事务执行失败。</p>
<p>​    为了保证数据库能运用日志进行恢复，要求日志文件必须放到稳定存储器上，并且要求每条日志记录必须在其所包含数据元素的更新值写到稳定存储器之前写到稳定存储器上，即<strong>先写日志</strong>规则。</p>
<h5 id="UNDO-操作"><a href="#UNDO-操作" class="headerlink" title="UNDO 操作"></a>UNDO 操作</h5><p>​    事务 T 执行过程中修改了数据库后，可能由于某种原因事务中止或系统崩溃，可使用 UNDO 恢复技术将 T 修改的全部数据对象值恢复到 T 开始前的状态。</p>
<p>​    对于要 UNDO 的事务 T ，日志中记录有 &lt;T, START&gt; 以及 T 对数据库的所有更新操作的日志记录。UNDO 过程为：从 T 的最后一条更新日志开始，从日志尾向日志头（反向）依次将 T 更新的数据元素恢复为旧值（V1）。</p>
<p>​    之所以需要 UNDO ，是因为故障发生时未提交事务的修改可能已写到磁盘上。</p>
<h5 id="REDO-操作"><a href="#REDO-操作" class="headerlink" title="REDO 操作"></a>REDO 操作</h5><p>​    REDO 操作时对已提交事务进行重做，将数据库状态恢复到事务结束后的状态。</p>
<p>​    对于要 REDO 的事务 T，日志中已经记录了 &lt;T, START&gt;  ，T 的所有更新操作日志以及 &lt;T, COMMIT&gt;。REDO 的过程为：从 T 的第一条更新日志记录来时，从日志头向日志尾（顺向）依次将 T 更新的数据元素值恢复为新值（V2）。</p>
<p>​    需要 REDO 的原因是，故障发生时可能有些已提交事务的更新数据还未写到磁盘上。</p>
<h5 id="并发执行事务的基本恢复过程"><a href="#并发执行事务的基本恢复过程" class="headerlink" title="并发执行事务的基本恢复过程"></a>并发执行事务的基本恢复过程</h5><p>​    1）分析阶段。从日志头开始顺向扫描日志，以确定重做事务集和撤销事务集。将既有  &lt;T, START&gt;又有 &lt;T, COMMIT&gt; 日志记录的事务 T 加入重做事务集。将只有  &lt;T, START&gt;没有 &lt;T, COMMIT&gt; 日志记录的事务 T 加入撤销事务集。</p>
<p>​    2）撤销阶段。从日志尾反向扫描日志，对每一条属于撤销事务集中的事务更新操作日志依次执行 UNDO 操作。</p>
<p>​    3）重做阶段。从日志头顺向扫描日志，对每一条属于重做事务集中的事务更新操作日志依次执行 REDO 操作。</p>
<h4 id="检查点"><a href="#检查点" class="headerlink" title="检查点"></a>检查点</h4><p>​    检查点是周期性地向日志中写一条检查点记录并记录所有当前活跃的事务，为恢复管理器提供信息，以决定从日志的何处开始恢复。在日志记录中使用 &lt; Checkpoint L &gt;来指定检查点 L 。</p>
<p>​    图10-19 是系统崩溃时的不同事务状态类型，其中 Tc 为完成最近检查点时刻，Tf 为故障发生时刻。 </p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/TgmJlz6Qevkprni.png" alt="image-20200406114406231"></p>
<h4 id="备份与介质故障恢复"><a href="#备份与介质故障恢复" class="headerlink" title="备份与介质故障恢复"></a>备份与介质故障恢复</h4><p>​    动态备份是指备份操作与用户事务的执行并发进行，备份期间允许对数据库进行存取或修改。静态备份则要等待用户事务结束然后备份。</p>
<p>​    具体进行数据备份时可以有两种方式，一种是全备份，一种是增量备份。</p>
<p>​    全备份是指每次备份全部数据库，而增量备份只备份上次备份后更新过的数据。</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
  </entry>
  <entry>
    <title>计算机网络(谢希仁)</title>
    <url>/2020/08/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C(%E8%B0%A2%E5%B8%8C%E4%BB%81)/</url>
    <content><![CDATA[<h2 id="计算机网络体系概述"><a href="#计算机网络体系概述" class="headerlink" title="计算机网络体系概述"></a>计算机网络体系概述</h2><h3 id="计算机网络概述"><a href="#计算机网络概述" class="headerlink" title="计算机网络概述"></a><strong>计算机网络概述</strong></h3><h4 id="计算机网络概念"><a href="#计算机网络概念" class="headerlink" title="计算机网络概念"></a>计算机网络概念</h4><p>　　1）广义观点：只要是能实现远程信息处理的系统或能进一步达到资源共享的系统，都是计算机网络。</p>
<p>　　2）资源共享观点：计算机网络是 “以能够共享资源的方式互联起来的自治计算机系统的集合” 。该定义包含三层含义： 1、目的：资源共享；2、组成单元：分布在不同地理位置的多台独立的 “ 自治计算机”；3、网络中的计算机额必须遵循统一的规则–网络协议。</p>
<p>　　3）用户透明性观点：存在一个能够为用户自动管理的网络操作系统，它能够调用用户所需要的资源。　　</p>
<h4 id="计算机网络的组成"><a href="#计算机网络的组成" class="headerlink" title="计算机网络的组成"></a>计算机网络的组成</h4><p>　　1）从组成部分上来看：完整的计算机网络主要由<strong>硬件、软件、协议</strong>三大部分组成。硬件主要由主机、通信链路（双绞线、光纤）、交换设备（路由器、交换机）和通信处理机（网卡）等组成。软件主要是各种实现资源共享的软件和方便用户使用的各种工具软件（OS、FTP程序等），多属于应用层。协议规定了网络传输数据时所遵循的规范。</p>
<p>　　2）从工作方式来看：计算机网络可分为<strong>边缘部分</strong>和<strong>核心部分。</strong>边缘部分由供用户直接使用的主机使用，核心部分由大量的网络和连接这些网络的路由器组成，它为边缘部分提供连通性和交换服务。</p>
<p>　　3）从功能组成上看，计算机网络由通信子网和资源子网组成，通信子网由各种传输介质、通信设备和相应的网络协议组成，它使网络有数据传输、交换、控制和存储的能力。资源子网向网络用户提供共享其他计算机的资源的服务。</p>
<h4 id="计算机网络的功能"><a href="#计算机网络的功能" class="headerlink" title="计算机网络的功能"></a>计算机网络的功能</h4><p>　　1）<strong>数据通信</strong>：实现联网计算机之间的各种信息的传输。</p>
<p>　　2）<strong>资源共享</strong>：软件、硬件、数据的共享。</p>
<p>　　3）分布式处理：当某个计算机系统负荷过重，将任务分配给其他计算机系统。</p>
<p>　　4）提高可靠性。</p>
<p>　　5）负载均衡： 将工作任务均衡地分配给计算机网络中的各台计算机。</p>
<h4 id="计算机网络的分类"><a href="#计算机网络的分类" class="headerlink" title="计算机网络的分类"></a>计算机网络的分类</h4><h5 id="按分布范围分类"><a href="#按分布范围分类" class="headerlink" title="按分布范围分类"></a>按分布范围分类</h5><p>　　1）广域网 WAN（Wide Area Network）：广域网提供长距离通信。</p>
<p>　　2）城域网 MAN（Metropolitan Area Network）：大多采用以太网技术 覆盖城市或街区。</p>
<p>　　3）局域网 LAN（Local Area Network）：覆盖范围较小，传统上，局域网使用广播技术，广域网使用交换技术。</p>
<p>　　4）个人区域网 PAN（Personal Area Network）：覆盖范围最小。</p>
<p>　　</p>
<h5 id="按传输技术分类"><a href="#按传输技术分类" class="headerlink" title="按传输技术分类"></a>按传输技术分类</h5><p>　　1）广播式网络：所有联网计算机共享一个公共通信信道。当一台计算机利用它发送报文分组时，其他的所有计算机都会接收到该分组，接收到的计算机会检查目的地址来判断是否为自己的分组，不是则丢弃。</p>
<p>　　2）点对点网络：每条物理线路连接一对计算机。如果没有直接相连的线路，它们之间的分组就要通过中间节点的存储转发到达目的节点。</p>
<p>　　是否采用分组存储转发与路由机制是点对点式网络与广播式网络的区别，广域网基本属于点对点网络。</p>
<h5 id="按拓扑结构分类"><a href="#按拓扑结构分类" class="headerlink" title="按拓扑结构分类"></a>按拓扑结构分类</h5><p>　　网络拓扑结构是指网络中结点（路由器、主机等）与通信线路（网线）之间的几何关系。</p>
<p>　　<img src="https://gitee.com/hoo334/picgo/raw/master//img/DTdmvoEqzWPRCy2.png" alt="img"></p>
<p>　　1）总线形： 建网方便，重负载时通信效率不高。</p>
<p>　　2）星形：便于集中控制管理，成本高，中心结点对故障敏感。</p>
<p>　　3）环形：所有计算机接口设备连成一个环。典型的令牌环局域网。环中信号单向传输。</p>
<p>　　4）网状形：每个结点至少有两条路径与其他结点相连，多用在局域网，可靠性高，成本高。</p>
<h5 id="按使用者分类"><a href="#按使用者分类" class="headerlink" title="按使用者分类"></a>按使用者分类</h5><p>　　1）公用网：电信公司出资建设的大型网络。</p>
<p>　　2）专用网：某个单位自建的网络。</p>
<p>　　</p>
<h5 id="按交换技术分类"><a href="#按交换技术分类" class="headerlink" title="按交换技术分类"></a>按交换技术分类</h5><p>　　交换技术时指各主机之间、各通信设备之间或主机与通信设备之间为交换信息之间所采用的数据格式和交换装置的方式。</p>
<p>　　1）电路交换网络：在源结点和目的结点之间建立一条专用的通路用来传输数据，包括建立连接、传输数据和断开连接三个阶段。最典型的电路交换网是传统电话网络。</p>
<p>　　2）报文交换网络：用户数据加上源地址、目的地址、校验码等辅助信息，<strong>封装成报文</strong>，利用中间结点存储转发到达目的结点。</p>
<p>　　3）分组交换网络：<strong>将数据分成较短的固定长度的数据块</strong>，在每个数据块中加上目的地址、源地址和辅助信息组成分组以存储-转发方式传输。</p>
<p>　　</p>
<h5 id="按传输介质分"><a href="#按传输介质分" class="headerlink" title="按传输介质分"></a>按传输介质分</h5><p>　　传输介质分为有线和无线两大类，因此网络可分为有线网络和无线网络。有线网络分为双绞线网络、同轴电缆网络等。无线网络又可分为蓝牙、微波、无线电等类型。</p>
<p>　　　</p>
<h4 id="计算机网络标准化组织"><a href="#计算机网络标准化组织" class="headerlink" title="计算机网络标准化组织"></a>计算机网络标准化组织</h4><p>　　1）国际标准化组织（ISO）：制定主要标准 OSI参考模型、HDLC。</p>
<p>　　2）国际电信联盟（ITU）。</p>
<p>　　3）国际电气电子工程师协会（IEEE）。</p>
<p> 　</p>
<h4 id="计算机网络性能指标"><a href="#计算机网络性能指标" class="headerlink" title="计算机网络性能指标"></a>计算机网络性能指标</h4><p>　　1）带宽：网络通信线路所能传输数据的能力，是数字信道所能传输的 “最高数据率” 的同义词，单位 b/s。</p>
<p>　　2）时延：数据（一个分组或报文）从网络（或链路）的一端传送到另一端所需要的总时间，它由4部分构成 发送时延、传播时延、处理时延、排队时延。</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/aDkJnfzV4wTejlB.png" alt="img"></p>
<p>​    3）时延带宽积：发送端发送的第一个比特即将到达终点时，发送端已经发出了多少个比特。</p>
<p>　　时延带宽积 = 传播时延*信道带宽</p>
<p>　　<img src="https://gitee.com/hoo334/picgo/raw/master//img/ogeU1hSdpj54sB3.png" alt="img"></p>
<p>​        4）往返时延（Round-Trip Time）：从发送端发送数据开始，到发送端收到来自接收端的确认总共经过的时延。</p>
<p>　　5）吞吐量：单位时间内通过某个网络的数据量</p>
<p>　　6）速率：连接到计算机网络上的主机在数字信道上传送数据的速率，也称数据率，单位为b/s。通常把最高数据率称为带宽。</p>
<p>　　7）信道利用率 某一信道有百分之多少的时间是有数据通过的 信道利用率 = 有数据通过时间/（有+无）数据通过时间。</p>
<h3 id="计算机网络体系结构与参考模型"><a href="#计算机网络体系结构与参考模型" class="headerlink" title="计算机网络体系结构与参考模型"></a>计算机网络体系结构与参考模型</h3><h4 id="计算机网络分层结构"><a href="#计算机网络分层结构" class="headerlink" title="计算机网络分层结构"></a>计算机网络分层结构</h4><p>　　<img src="https://gitee.com/hoo334/picgo/raw/master//img/sqlSCvRFknEHVrJ.png" alt="img"></p>
<p> 　服务是垂直的，协议是水平的。</p>
<h4 id="计算机网络协议、接口、服务的概念"><a href="#计算机网络协议、接口、服务的概念" class="headerlink" title="计算机网络协议、接口、服务的概念"></a>计算机网络协议、接口、服务的概念</h4><p>  　　1. 协议：为进行网络中的数据交换而建立的规则、标准或约定称为网络协议（Network Protocol）,它是控制两个或多个对等实体进行通信的规则集合。协议由语法、语义和同步组成。语法规定了传输数据的格式。语义规定了所要完成的功能，即发出何种控制信息、完成何种动作和做出何种应答；同步规定了执行各种操作的条件、时序关系等。一个完整的协议通常具有线路管理、差错控制、数据转换等功能。</p>
<pre><code>    　　2. 接口：接口是同一结点内相邻两层间交换信息的交换点。每层只能为紧邻的层次之间定义接口，不能跨层定义接口。在典型的接口上，同一结点相邻两层的实体通过服务访问点（Service Access Point）进行交互。服务是通过SAP提供给上层使用的。

        　　3. 服务：服务是指下层为紧邻的上层提供的功能调用，它是垂直的。上层与下层交换一些命令使用服务原语。OSI将源语分为四类：请求，指示，响应，证实。</code></pre><p>　　<img src="https://gitee.com/hoo334/picgo/raw/master//img/49LkNCq6W3ySmKF.png" alt="img"></p>
<p> 　计算机网络提供的服务可按以下三种方式分类</p>
<p>　　<strong>1）面向连接服务与无连接服务。</strong></p>
<p>　　面向连接服务分为连接建立、数据传输和连接释放三个阶段。例如TCP。</p>
<p>　　无连接服务不需要建立连接，直接发送，尽最大努力交付，不保证通信的可靠性。例如IP，UDP</p>
<p>　　<strong>2）可靠服务与不可靠服务</strong></p>
<p>　　可靠服务指网络具有纠错、检错、应答机制，确保数据正确可靠传送到目的地。</p>
<p>　　不可靠服务是指网络只是尽量正确、可靠地传输，不能保证数据正确、可靠地传送到目的地。</p>
<p>　    <strong>3）有应答服务和无应答服务</strong></p>
<p>　　有应答服务是指接收方在收到数据后向发送方给出相应的应答。例如文件传输服务。</p>
<p>　　无应答服务是指接收方收到数据后不自动给出应答。</p>
<p>　　</p>
<h4 id="ISO-OSI-参考模型和TCP-IP模型"><a href="#ISO-OSI-参考模型和TCP-IP模型" class="headerlink" title="ISO/OSI 参考模型和TCP/IP模型"></a>ISO/OSI 参考模型和TCP/IP模型</h4><p>　　<img src="https://gitee.com/hoo334/picgo/raw/master//img/obOvLcMiUGETIAN.png" alt="img"></p>
<p> <img src="https://gitee.com/hoo334/picgo/raw/master//img/DzZ8rgE3SOcYiR4.png" alt="img"></p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/eRNgk93nSQomYJV.png" alt="img"></p>
<p> <img src="https://gitee.com/hoo334/picgo/raw/master//img/jVCxW8psaHF7EwO.png" alt="img"></p>
<p> <img src="https://gitee.com/hoo334/picgo/raw/master//img/gTzGmJbDRMC5kwa.png" alt="img"></p>
<h3 id="本章小结及疑难点"><a href="#本章小结及疑难点" class="headerlink" title="本章小结及疑难点"></a>本章小结及疑难点</h3><h4 id="计算机网络与分布式计算机系统的主要区别是什么？"><a href="#计算机网络与分布式计算机系统的主要区别是什么？" class="headerlink" title="计算机网络与分布式计算机系统的主要区别是什么？"></a>计算机网络与分布式计算机系统的主要区别是什么？</h4><p>​        分布式系统最主要的特点是：整个系统中的各个计算机对用户都是透明的。用户通过输入命令就可以运行程序，用户并不知道是哪台计算机在为它运行程序。操作系统为用户选择一台最合适的计算机来运行其程序，并将运行的结果传送到合适的地方。</p>
<p>计算机网络则不同，用户必须先登录欲运行程序的计算机，然后按照计算机的地址，将程序通过计算机网络传送到该计算机上运行，最后根据用户的命令将结果传送到指定的计算机。两者的区别主要是软件的不同。</p>
<h4 id="为什么一个网络协议必须考虑到各种不利的情况？"><a href="#为什么一个网络协议必须考虑到各种不利的情况？" class="headerlink" title="为什么一个网络协议必须考虑到各种不利的情况？"></a>为什么一个网络协议必须考虑到各种不利的情况？</h4><p>​        因为网络协议如果不全面考虑不利的情况，那么当情况发生变化时，协议就会保持理想状况，一直等下去。</p>
<h4 id="因特网使用的-IP-协议是无连接的，因此其传输是不可靠的。这样容易使人们感到因特网很不可靠。那么当初为什么不把因特网传输设计为可靠的呢？"><a href="#因特网使用的-IP-协议是无连接的，因此其传输是不可靠的。这样容易使人们感到因特网很不可靠。那么当初为什么不把因特网传输设计为可靠的呢？" class="headerlink" title="因特网使用的 IP 协议是无连接的，因此其传输是不可靠的。这样容易使人们感到因特网很不可靠。那么当初为什么不把因特网传输设计为可靠的呢？"></a>因特网使用的 IP 协议是无连接的，因此其传输是不可靠的。这样容易使人们感到因特网很不可靠。那么当初为什么不把因特网传输设计为可靠的呢？</h4><p>​        传统电信网的主要用途使电话通信，并且普通电话机不是智能的，因此电信公司必须花费巨大的代价把电信网设计的非常好，以保证用户的通信质量。<br>计算机网络的先驱们认为，计算机网络和电信网的一个重大区别是终端设备的性能差别很大。于是，他们采用了 “端到端的可靠传输” 策略，即在传输层使用面向连接的 TCP 协议，这样既能使网络部分价格便宜且灵活可靠，又能保证端到端的可靠传输。</p>
<h4 id="端到端通信和点到点通信有什么区别？"><a href="#端到端通信和点到点通信有什么区别？" class="headerlink" title="端到端通信和点到点通信有什么区别？"></a>端到端通信和点到点通信有什么区别？</h4><p>​        由物理层、数据链路层和网络层组成的通信子网为网络环境中的主机提供点到点的服务，而传输层为网络中的主机提供端到端的通信。<br>直接相连的结点之间的通信称为<strong>点到点通信</strong>，它只提供一台机器到另一台机器之间的通信，不涉及程序或进程的概念。同时，点到点通信并不能保证数据传输的可靠性，也不能说明源主机和目的主机之间是哪两个进程在通信，这些工作都是由传输层来完成的。<br>端到端通信建立在点到点通信的基础上，它是由一段段的点到点通信信道构成的，是比点到点通信更高一级的通信方式，以完成应用程序（进程）之间的通信。“端” 是指用户程序的端口，端口号标识了应用层中不同的进程。</p>
<h4 id="如何理解传输速率、带宽和传播速率？"><a href="#如何理解传输速率、带宽和传播速率？" class="headerlink" title="如何理解传输速率、带宽和传播速率？"></a>如何理解传输速率、带宽和传播速率？</h4><p>​        传输速率指主机在<strong>数字信道上发送数据的速率</strong>，也称数据率或比特率，单位是 b/s 。<br>带宽在计算机网络中指数字信道所能传送的“最高数据传输速率”，常用来表示网络的通信线路传送数据的能力。<br>传播速率是指电磁波在信道中传播的速率，单位是 m/s。</p>
<h4 id="试从多个方面比较电路交换、报文交换和分组交换的优缺点。"><a href="#试从多个方面比较电路交换、报文交换和分组交换的优缺点。" class="headerlink" title="试从多个方面比较电路交换、报文交换和分组交换的优缺点。"></a>试从多个方面比较电路交换、报文交换和分组交换的优缺点。</h4><p>​        电路交换的主要特点：<br>1）通信一定由有三个阶段：建立连接、通信、释放连接。<br>2）在整个通信过程中，通信的双方自始至终占用着所使用的物理信道。<br>电路交换对通信线路的利用率比较低。静态分配传输带宽，当发生拥塞时通信质量不会下降。<br>目前常用的分组交换是使用无连接的 IP 协议。这种分组交换以分组作为传输的单位。采用存储转发技术，无连接建立和释放这两个阶段，传送数据较快。动态分配传输带宽，对通信链路是逐段占用的。分组在各路由器存储转发时需要排队，这就会造成一定的时延。<br>报文交换也采用存储转发技术，报文交换不再把 报文分割为更小的分组，而是把整个报文在网络的结点中存储下来，然后转发出去。传输数据的时延较大。</p>
<h4 id="协议与服务有何区别？有何关系？"><a href="#协议与服务有何区别？有何关系？" class="headerlink" title="协议与服务有何区别？有何关系？"></a>协议与服务有何区别？有何关系？</h4><p>​        协议是控制两个对等实体（或多个实体）进行通信的规则的集合。在协议的控制下，两个对等实体间的通信使得本层能够向上一层提供服务。要实现本层协议，还需要使用下面一层所提供的服务。<br>协议是“水平的”，即协议是控制对等实体之间通信的规则。但服务是“垂直的”，即服务是由下层向上层通过层间接口提供的。</p>
<h4 id="网络协议的三个要素是什么？各有什么含义？"><a href="#网络协议的三个要素是什么？各有什么含义？" class="headerlink" title="网络协议的三个要素是什么？各有什么含义？"></a>网络协议的三个要素是什么？各有什么含义？</h4><p>1）语法，即数据与控制信息的结构或格式。<br>2）语义，即需要发出何种控制信息、完成何种动作以及做出何种响应。<br>3）同步，即时间实现顺序的详细说明。</p>
<h4 id="试述具有五层协议的网络体系结构的要点，包括各层的主要功能。"><a href="#试述具有五层协议的网络体系结构的要点，包括各层的主要功能。" class="headerlink" title="试述具有五层协议的网络体系结构的要点，包括各层的主要功能。"></a>试述具有五层协议的网络体系结构的要点，包括各层的主要功能。</h4><p>1）物理层。在物理层上传送数据的单位是比特。物理层的任务就是透明地传送比特流。<br>2）数据链路层。将网络层交下来地 IP 数据报组装成帧，在两个相邻结点间地链路上“透明”地传送帧中的数据。<br>3）网络层。负责为分组交换网上的不同主机提供通信服务。在发送数据时，网络层把传输层产生的报文段或用户数据报封装成分组或包进行传送。<br>4）传输层。传输层的任务就是负责向两个主机中进程之间的通信提供服务。<br>5）应用层。直接为用户的应用进程提供服务。</p>
<h2 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h2><h3 id="通信基础"><a href="#通信基础" class="headerlink" title="通信基础"></a><strong>通信基础</strong></h3><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><h5 id="数据、信号与码元"><a href="#数据、信号与码元" class="headerlink" title="数据、信号与码元"></a>数据、信号与码元</h5><p>　　1）数据：传送信息的实体。</p>
<p>　　2）信号：数据的电气或电磁表现，是数据在传输过程中的存在形式。</p>
<p>　　3）码元：用一个固定时长的信号波形表示一位k进制数字。</p>
<p>　　</p>
<h5 id="信源、信道与信宿"><a href="#信源、信道与信宿" class="headerlink" title="信源、信道与信宿"></a>信源、信道与信宿</h5><p>　　1）信源：产生与发送数据的源头 。2）信道：信号的传输媒介。3）信宿：接收数据的终点。</p>
<p>　　</p>
<h5 id="速率、波特与带宽"><a href="#速率、波特与带宽" class="headerlink" title="速率、波特与带宽"></a>速率、波特与带宽</h5><p>　　速率：单位时间传输的数据量。可以用码元传输速率和信息传输速率表示。</p>
<p>　　1）码元传输速率：单位时间内传输的码元个数。单位为波特Baud。</p>
<p>　　2）信息传输率：单位时间内传输的比特数，单位 b/s。</p>
<p>　　</p>
<h4 id="奈奎斯特定理和香农定理"><a href="#奈奎斯特定理和香农定理" class="headerlink" title="奈奎斯特定理和香农定理"></a>奈奎斯特定理和香农定理</h4><p>　　1）奈奎斯特定理：<strong>在理想低通信道中极限码元传输率为2W波特，其中W是理想低通信道的带宽单位为Hz。</strong>若用V来表示每个码元离散电平的数目，比如有16种不同的码元，采用NRZ码传输，发送一位需要1个信号周期，一个码元含有4bit信息量，若采用Manchester码 ，发送一位需要2个信号周期，一个码元含有2bit信息量。如果只有两种码元，采用NRZ，每个码元含有1bit信息量；采用Manchester，每个码元含有0.5bit信息量。</p>
<p>　　<strong>极限数据传输率 = 2W*log2(V)</strong></p>
<p>　　2）香农定理：给出了带宽受限且有高斯白噪声干扰的信道的极限数据传输率</p>
<p>　　<strong>信道的极限数据传输率 = W*log2(1+S/N)</strong></p>
<p> 　</p>
<h4 id="编码与调制"><a href="#编码与调制" class="headerlink" title="编码与调制"></a>编码与调制</h4><p>　　<img src="https://gitee.com/hoo334/picgo/raw/master//img/TgmOEQv4BAeCZXt.png" alt="img"></p>
<p> 　   归零编码（RZ）：高电平为1，低电平为0，在每个时钟周期中间均跳变到低电平。</p>
<p>　　非归零编码（NRZ）：高电平为1，低电平为0，无法传递时钟信号难以同步。</p>
<p>　　反转非归零码（NRZI）：用信号的翻转代表0，信号保持不变代表1。</p>
<p>　　曼彻斯特码（Manchester）：10 表示高电平，01表示低电平。以太网使用。</p>
<p>　　差分曼彻斯特码：若下一个电平为低，在码元边界反转，若为高电平则保持不变。</p>
<h4 id="电路交换、报文交换与分组交换"><a href="#电路交换、报文交换与分组交换" class="headerlink" title="电路交换、报文交换与分组交换"></a>电路交换、报文交换与分组交换</h4><p>　　1）电路交换：在进行数据传输前，两个结点之间必须<strong>建立一条双方独占的物理通信路径</strong>。时延小，有序传输，无冲突，实时性强。建立连接时间长，线路独占，灵活性差，难以规格化。</p>
<p>　　2) 报文交换：<strong>数据交换的单位是报文</strong>，报文携带有目标地址、源地址等信息。报文交换在交换结点采用存储转发的传输方式。无须建立连接，动态分配线路，提高线路可靠性提高线路利用率，提供多目标服务。转发时延大，需要较大缓存空间。</p>
<p>　　3）分组交换：<strong>限制每次传送数据块大小上限，</strong>采用存储–转发方式。无建立时延，线路利用率高、简化存储管理，加速传输，减少出错概率和重发数据量。存在传输时延，需要传输额外的信息量，当分组交换使用数据报服务时会出现失序、丢失或者重复分组，需要重新排序分组。采用虚电路服务，无失序问题但有呼叫建立、数据传输和虚电路释放三个过程。</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/2LT6fPzRjcS7sOm.png" alt="img"></p>
<h4 id="数据报和虚电路"><a href="#数据报和虚电路" class="headerlink" title="数据报和虚电路"></a>数据报和虚电路</h4><p>　　<strong>分组交换可分为面向连接的虚电路方式和无连接的数据报方式</strong>。这两种服务方式都由网络层提供。（IP分组）数据报方式和虚电路方式是分组交换的两种方式。</p>
<p>　　1）数据报：高层协议先将报文拆成若干个带序号的数据单元，在网络层加上控制信息形成数据报分组。<strong>不同的分组可以走不同的路径，也可以按不同的顺序到达目的结点。</strong></p>
<p>　　2）虚电路：在发送发和接收方建立一条逻辑上相连的虚电路，连接一旦确立就固定了虚电路所对应的物理路径。与电路交换类似，分为虚电路建立、数据传输和虚电路释放。端系统每次建立虚电路时，选择一个未使用过的虚电路号分配给该虚电路。<strong>每个数据分组不仅要有分组号、校验和控制信息还要有它要通过的虚电路号。</strong></p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/b4jrLfc7wiYvuMe.png" alt="img"></p>
<h3 id="传输介质"><a href="#传输介质" class="headerlink" title="传输介质"></a><strong>传输介质</strong></h3><h4 id="双绞线、同轴电缆、光纤与无线传输介质"><a href="#双绞线、同轴电缆、光纤与无线传输介质" class="headerlink" title="双绞线、同轴电缆、光纤与无线传输介质"></a>双绞线、同轴电缆、光纤与无线传输介质</h4><p>　　传输介质是发送设备和接收设备之间的物理线路。</p>
<p>　　1）双绞线：由两根采用一定规则并排绞合的互相绝缘的铜导线组合而成，绞合可以减少对相邻导线的电磁干扰。模拟传输和数字传输都可使用。</p>
<p>　　2）同轴电缆：由内导体、绝缘层、网状编织层和塑料外层构成。</p>
<p>　　3）光纤：主要由纤心和包层构成，利用光的全反射。</p>
<p>　　4）无线传输介质：无线电波 微光、红外光和激光。</p>
<p>　　</p>
<h4 id="物理层接口的特性"><a href="#物理层接口的特性" class="headerlink" title="物理层接口的特性"></a>物理层接口的特性</h4><p>　　1）机械特性：规定物理连接时所采用的规格、引线的数目、引脚的数量和排列情况。</p>
<p>　　2）电气特性：规定传输二进制位时，线路上信号的电压高低、阻抗匹配、传输速率和距离限制等。</p>
<p>　　3）功能特性：指明某条线上出现的某一电平的电压表示何种意义，接口部件的信号线用途。</p>
<p>　　4）规程特性：定义各条物理线路的工作规程和时序关系。</p>
<h3 id="物理层设备"><a href="#物理层设备" class="headerlink" title="物理层设备"></a><strong>物理层设备</strong></h3><h4 id="中继器"><a href="#中继器" class="headerlink" title="中继器"></a>中继器</h4><p>　　中继器又称转发器，主要功能是将信号整形并放大再转发出去，消除衰减，<strong>其原理是信号再生</strong>。有两个端口输入和输出端口。使用中继器连接的几个网段仍是一个局域网，它不能连接两个具有不同速率的局域网，它没有存储转发功能。中继器两端的网络部分是网段，而不是子网。</p>
<h4 id="集线器"><a href="#集线器" class="headerlink" title="集线器"></a>集线器</h4><p>　　集线器实质上是一个多端口的中继器工作在物理层。当Hub工作时，一个端口收到数据信号后，将其整形放大，使之再生然后转发到其他所有端口，Hub在网络中只起信号放大和转发作用，目的是扩大网络的传输范围，不具备信号的定向传输能力。Hub组成的网络是共享式网络，逻辑上仍是一个总线网，Hub只能在半双工状态下工作。集线器不能分割冲突域，例如一个带宽为10Mbps 的集线器上连接了8台计算机，8台计算机同时工作时，每台计算机真正拥有的带宽时1.25Mbps。</p>
<h3 id="本章小结及疑难点-1"><a href="#本章小结及疑难点-1" class="headerlink" title="本章小结及疑难点"></a>本章小结及疑难点</h3><h4 id="奈式准则和香农公式的主要区别是什么？这两个公式对数据通信的意义是什么？"><a href="#奈式准则和香农公式的主要区别是什么？这两个公式对数据通信的意义是什么？" class="headerlink" title="奈式准则和香农公式的主要区别是什么？这两个公式对数据通信的意义是什么？"></a>奈式准则和香农公式的主要区别是什么？这两个公式对数据通信的意义是什么？</h4><p>​        奈式准则指出了，码元传输的速率是受限的，不能任意提高，否则在接收端就无法正确判断码元是 1 还是 0（因为有码元之间的相互干扰）。</p>
<p>​        奈式准则是在理想条件下推导出的。在实际条件下，最高码元传输速率要比理想条件下得出的数值还要小些。奈式准则并没有对信息传输速率给出限制，要提高信息传输率就要提高每个码元所含的信息量。</p>
<p>​        香农公式给出了信息传输率的极限，即对于一定的传输带宽（Hz）和一定的信噪比，信息传输率的上限就确定了。要想提高信息的传输速率，必须设法提高传输线路的带宽或提高所传信号的信噪比。</p>
<h4 id="同步通信和异步通信的区别是什么？"><a href="#同步通信和异步通信的区别是什么？" class="headerlink" title="同步通信和异步通信的区别是什么？"></a>同步通信和异步通信的区别是什么？</h4><p>​        “异步通信”是一种很常用的通信方式。接收端必须时刻做好接收准备。发送端可以在任意时刻发送字符。异步通信可以用字符和帧作为发送单位，但必须注意字符或帧的开始和结束标识。</p>
<p>​        “同步通信”的通信双方必须先建立同步，即双方的时钟要调整到同一个频率。收发双方不停地接收连续的同步比特流。</p>
<h4 id="位同步和帧同步的区别是什么？"><a href="#位同步和帧同步的区别是什么？" class="headerlink" title="位同步和帧同步的区别是什么？"></a>位同步和帧同步的区别是什么？</h4><p>​        位同步是指接收端时钟已经调整到和发送端时钟完全一样，因此接收端收到比特流后，就能在每一位的中间位置进行判决。位同步的目的是为了将发送端发送的每一个比特都正确的接收下来。仅仅有位同步还不够，因为数据以帧为单位进行发送。一个帧必须有明确的界限，也就是有帧定界符。接收端在收到比特流后，必须能够正确地找出帧定界符，以便知道哪些比特构成一个帧。接收端确定了帧的准确位置就是完成了帧同步。</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/MYGosKipFAkC62X.png" alt="image-20200427161642085"></p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/U3H9wYFLjGCya6D.png" alt="image-20200427161701168"></p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/CD5szARNdXO238P.png" alt="image-20200410102252708"></p>
<h2 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h2><h3 id="数据链路层的功能"><a href="#数据链路层的功能" class="headerlink" title="数据链路层的功能"></a>数据链路层的功能</h3><h4 id="为网络层提供服务"><a href="#为网络层提供服务" class="headerlink" title="为网络层提供服务"></a>为网络层提供服务</h4><p>　　对网络层而言，数据链路层的基本任务是将源机器中来自网络层的数据传输到目标机器的网络层。</p>
<p>　　1）无确认的无连接服务。源机器发送数据帧时<strong>不需要先建立链路连接</strong>，目的机器收到数据帧时<strong>无需发回确认</strong>，对于<strong>丢失的帧交给上层处理</strong>。<strong>适用于实时通信或误码率较低的通信信道，如以太网</strong>。</p>
<p>　　2）有确认的无连接服务。源机器发送数据帧时<strong>不需要先建立链路连接</strong>，目的机器收到数据帧时<strong>必须发回确认。</strong>源机器在规定的时间内未收到确认信号时就<strong>重传丢失的帧</strong>。适用于误码率较高的通信信道，如无线通信。</p>
<p>​        3）有确认的面向连接服务。帧传输过程分为三个阶段：建立数据链路、传输帧、释放数据链路。目的机器对收到的每一帧都要给出确认，源机器收到确认后才能发送下一帧。适用于通信要求（可靠性、实时性）较高的场合。</p>
<p>　　</p>
<h4 id="链路管理"><a href="#链路管理" class="headerlink" title="链路管理"></a>链路管理</h4><p>　　数据链路层连接的建立、维持和释放过程称为链路管理，它主要用于面向连接的服务。链路两端的结点要通信必须首先确认对方已处于就绪状态，并交换一些必要的信息以对帧序号初始化，然后才能建立连接，在传输过程中能要维持连接，传输完成后要释放该连接。</p>
<p>　　</p>
<h4 id="帧定界、帧同步与透明传输"><a href="#帧定界、帧同步与透明传输" class="headerlink" title="帧定界、帧同步与透明传输"></a>帧定界、帧同步与透明传输</h4><p>　　两个工作站之间传输信息时，必须将网络层的分组封装成帧，以帧的格式进行传送。将一段数据的前后分别<strong>添加首部和尾部</strong>就构成了帧。首部和尾部含有很多控制信息，它们的一个重要作用是确定帧的边界，即<strong>帧定界</strong>。帧同步指的是接收方应能从收到的二进制比特流中区分帧的起始和终止。如在  <strong>HDLC 通信规程中用标识位F（01111110）来标识帧的开始和结束。</strong>检测到帧标识位 F 即认为是帧的开始，然后一旦检测到帧标识位 F 即表示帧的结束。</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/sNDjvCmKV7gE1xI.png" alt="img"></p>
<p> 　如果在数据中刚好出现 01111110 的序列会误认为是帧的结束而抛弃后面的数据，要采取有效的措施解决这个问题，即透明传输。<strong>透明传输就是不管所传送数据是什么样的比特组合，都应当能在链路上传送。</strong></p>
<p> 　</p>
<h4 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h4><p>　　由于收发双发各自的工作速率和缓存空间的差异可能发送方的发送能力大于接受方的接收能力的现象，流量控制实际上就是限制发送方的数据流量，使其发送速率不超过接收方的接收能力。</p>
<p>　　流量控制并不是数据链路层特有的功能，许多高层协议也提供此功能，只不过控制的对象不同而已。对于数据链路层来说，控制的是相邻两节点之间数据链路上的流量，对于传输层来说，控制的则是源端口到目的端口之间的流量。</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/TcEumn3joNMX9Us.png" alt="img"></p>
<h4 id="差错控制"><a href="#差错控制" class="headerlink" title="差错控制"></a>差错控制</h4><p>　　由于信道噪声等原因，帧在传输过程中可能会出现错误。用以使发送方确定接收方是否正确收到由其发送的数据的方法称为差错控制。通常，这些错误可分为位错和帧错。</p>
<p>　　位错指帧中某些位出现了差错。通常采用<strong>循环冗余校验（CRC）方式发现位错</strong>，通过自动重传请求（Automatic Repeat reQuest<strong>，ARQ）方式来重传出错的帧</strong>。发送方将数据帧加CRC校验码一起发送，接收方根据检错码对数据帧进行错误检测，若发现错误则丢弃，发送方超时重传该数据帧。ARQ法只需返回很少的控制信息就可有效确认所发数据帧是否被正确接收。</p>
<p>　　帧错指帧的丢失、重复或失序等错误在数据链路层引入<strong>定时器和编号机制</strong>，能保证每一帧最终都能有且仅有一次正确地交付给目的结点。</p>
<h3 id="组帧"><a href="#组帧" class="headerlink" title="组帧"></a>组帧</h3><p>　　数据链路层之所以要把比特组合成帧为单位传输，是为了在出错时只重发出错地帧，而不必重发全部数据，从而提高数据。为了接收方能正确地接收并检查所传输地帧，发送方必须依据一定地规则把网络层递交地分组封装成帧（称为组帧）。组帧主要解决帧定界、帧同步、透明传输等问题。</p>
<p>　　组帧既要加首部又要加尾部。 接收方依靠帧中地定界符来区分帧地开始和结尾。分组（IP数据报）仅是包含在帧中的数据部分。</p>
<h4 id="字符计数法"><a href="#字符计数法" class="headerlink" title="字符计数法"></a>字符计数法</h4><p>　　字符计数法是指<strong>在帧的头部使用一个计数字段来标明帧内字符数</strong>。如果计数字段出错后面的全部出错。</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/zWNs7ADgBUthZQF.png" alt="img"></p>
<p> 　</p>
<h4 id="字符填充法的首尾定界符法"><a href="#字符填充法的首尾定界符法" class="headerlink" title="字符填充法的首尾定界符法"></a>字符填充法的首尾定界符法</h4><p>　　字符填充法使用一些特定的字符来定界一帧的开始（DLE STX）与结束（DLE ETX）。为了使信息位中出现的特殊字符不误认为帧的首尾定界符，可以在<strong>特殊字符前面填充一个转义字符（DLE）来加以区分</strong>（转义字符使ASCII 码中的控制字符，是一个字符 DLE只是一个代号），以实现数据的透明传输。</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/tBpYfKaSMN3vyCk.png" alt="img"></p>
<p> 上图中信息部分含有一个转义字符DLE，因此在传输过程中添加一个转义字符，接收方将其去掉。</p>
<p>　　</p>
<h4 id="零比特填充的首尾标志法"><a href="#零比特填充的首尾标志法" class="headerlink" title="零比特填充的首尾标志法"></a>零比特填充的首尾标志法</h4><p>　　使用 01111110 来标志一帧的开始和结束。在信息位中遇到连续的5个1则自动在后面添加一个0。性能优于字符填充法。</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/QXAdYuFaspT4J9S.png" alt="img"></p>
<h4 id="违规编码法"><a href="#违规编码法" class="headerlink" title="违规编码法"></a>违规编码法</h4><p>　　在物理层进行比特编码时，通常采用违规编码。例如曼彻斯特码。可以借用违规编码序列来定界帧的起始和终止。</p>
<p>　　<strong>目前较常用的组帧方法是比特填充法和违规编码法。</strong></p>
<h3 id="差错控制-1"><a href="#差错控制-1" class="headerlink" title="差错控制"></a>差错控制</h3><p> 　比特传输是传输差错的一种，这里仅讨论比特差错。通常利用编码技术来进行差错控制，主要有两类：<strong>自动重传请求ARQ</strong>和<strong>前向纠错FEC</strong>。<strong>在ARQ方式中，接收端检测出差错时通知发送端重发</strong>，直到收到正确的码字。<strong>在FEC 方式中，接收端不但能发现差错还能确定出错位置纠错</strong>。差错控制可分为检错编码和纠错编码。</p>
<h4 id="检错编码"><a href="#检错编码" class="headerlink" title="检错编码"></a>检错编码</h4><p>　　1）奇偶校验码。在信息位后添加一位校验，以传输11100101 为例，如果是奇校验码 信息位中有5个1 为奇数则信息位为0，11100101 0 。如果是偶校验码 校验位为1 11100101 1。“奇”（“偶”）代表加上信息位之后的 “1” 的个数为 奇（偶）。它分为垂直奇偶校验、水平奇偶校验和水平垂直奇偶校验。</p>
<p>　　2）循环冗余码。又称多项式码，任意一个由二进制数位串组成的代码都可以与一个只含有0和1两个系数的多项式建立一一对应关系。</p>
<p>　　给定一个 m bit 的帧或报文，发送器生成 r bit 的序列称为帧检验序列（FCS）。形成的帧将由m+r bit 组成。发送方和接收方事先商定一个多项式 G(x) （最高位和最低位必须为1），使这个带校验码的帧刚好能被预先确定的多项式 G(x) 整除。接收方用同样的多项式去除收到的帧，如果无余数，认为无差错。</p>
<p>　　假设一个帧有 m 位，对应的多项式为 M(x)，计算冗余码的步骤如下;</p>
<p>　　a. 加0。假设G(x)的阶为 r ，在帧的低位端加上 r 个0。</p>
<p>　　b. 模2除（不涉及借位，0-1=1） 用帧的数据串除G(x)的数据串得到的余数为冗余码（共 r 位，前面的 0 不可以省略）。</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/tgyXjxhYJPOEvR2.jpg" alt="img"></p>
<h4 id="纠错编码"><a href="#纠错编码" class="headerlink" title="纠错编码"></a>纠错编码</h4><p>　　以下海明码编码原理与过程。</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/poDZz6wILR4KMNE.jpg" alt="img"></p>
<p> 　</p>
<h3 id="流量控制与可靠传输机制"><a href="#流量控制与可靠传输机制" class="headerlink" title="流量控制与可靠传输机制"></a>流量控制与可靠传输机制</h3><h4 id="流量控制、可靠传输与滑动窗口机制"><a href="#流量控制、可靠传输与滑动窗口机制" class="headerlink" title="流量控制、可靠传输与滑动窗口机制"></a>流量控制、可靠传输与滑动窗口机制</h4><p>　　流量控制涉及对链路上的帧的发送速率的控制，以使接收方有足够的缓冲空间来接收每个帧。</p>
<p>　　流量控制的基本方法是由接收方控制发送方的速率，常见的方式有两种：<strong>停止-等待协议</strong>和<strong>滑动窗口协议</strong>。</p>
<h5 id="停止-等待流量控制基本原理"><a href="#停止-等待流量控制基本原理" class="headerlink" title="停止-等待流量控制基本原理"></a>停止-等待流量控制基本原理</h5><p>　　发送方每发送一帧，都要等待接收方的应答信号才能发送下一帧，效率很低。</p>
<h5 id="滑动窗口流量控制基本原理"><a href="#滑动窗口流量控制基本原理" class="headerlink" title="滑动窗口流量控制基本原理"></a>滑动窗口流量控制基本原理</h5><p>　　在任意时刻，发送发都维持一组连续的允许发送的帧的序号，称为发送窗口。同时接收方也维持一组连续的允许接收帧的序号，称为接收窗口。<strong>发送方每接收到一个确认帧，发送窗口就向前滑动一个帧的位置。</strong></p>
<p>　　<strong>滑动窗口特性：</strong></p>
<p>　　a.只有接收窗口向前滑动（同时接收方发送了确认帧时），发送窗口才有可能向前移动（发送发接收到了确认帧）。</p>
<p>　　b.从滑动窗口概念上看，停止-等待协议、后退 N 帧协议和选择重传协议只在发送窗口大小与接收窗口大小上有所差别：</p>
<p>　　停止-等待协议：发送窗口大小 = 1，接收窗口大小 = 1</p>
<p>　　后退 N 帧协议：发送窗口 &gt; 1，接收窗口大小 = 1</p>
<p>　　选择重传协议：发送窗口 &gt; 1，接收窗口大小 &gt; 1</p>
<p>　　c.接收窗口大小为 1 时，可保证帧的有序接收。</p>
<p>　　d.<strong>数据链路层的滑动窗口协议中，窗口的大小在传输过程中是固定的，传输层的滑动窗口会改变。</strong></p>
<h5 id="可靠传输机制"><a href="#可靠传输机制" class="headerlink" title="可靠传输机制"></a>可靠传输机制</h5><p>　　数据链路层的可靠传输通常使用确认和超时重传两种机制来完成。确认是一种无数据的控制帧，这种控制帧使得接收方知道哪些内容被正确接收。有时候为了提高传输效率，将确认捎带在一个回复帧中，称为捎带确认。超时重传是发送方在发送数据帧后一段时间内没有收到确认帧，重新发送该数据帧。</p>
<p>　　自动重传请求（ARQ）通过接收方请求发送方重传出错的数据帧来恢复出错的帧。传统的自动重传请求分三种，停止-等待 ARQ，后退N帧 ARQ ，选择性重传 ARQ。</p>
<p>　　停止等待 ARQ：发送一帧，确认一帧。超时重传。</p>
<p>　　后退 N 帧 ARQ：可以连续发送窗口内的帧，接收方接收窗口为 1 可以保证按序接收数据帧。如果采用 n 比特对帧编号， 则其发送窗口W的大小应满足 <strong>1 &lt;= W &lt;= 2^n-1</strong> 。如果发送方窗口大于上限就会造成无法分辨新帧和旧帧。</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/opi2d3rDtv9aZu6.png" alt="img"></p>
<p> 　2 号帧出错，丢弃窗口内所有帧。</p>
<p>　    选择重传 ARQ：设法只重传出现差错的数据帧或计时器超时的帧，必须加大接收窗口，接收发送序号不连续但仍处在接收窗口中的那些数据帧。等到所缺失的帧后一起交给主机。若采用 n 比特对帧编号则满足发送窗口<strong>W1 + W2 &lt;= 2^n</strong> 。接收窗口不应超过发送窗口 。一般情况下 <strong>W1=W2 = 2^(n-1)</strong>。</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/B9UL7qNWwoVFgKk.png" alt="img"></p>
<p> <strong>GBN 和选择重传 都使用累计确认 收到 3 号帧的确认说明 接收方已经收到 0 - 3 号帧。</strong>　</p>
<p>　　信道效率：发送方在一个发送周期的时间内，有效地发送数据所需要地时间占整个发送周期的比率。</p>
<p>　　例如，发送方从开始发送数据开始到收到第一个确认帧为止，称为一个发送周期，设为T，发送方在这个周期内共发送L比特的数据，发送方的数据传输率为C，则发送方用于发送有效数据的时间为L/C，在这种情况下 信道利用率为 (L/C)/T。</p>
<p>　　信道吞吐率 = 信道利用率 * 发送方的发送速率。</p>
<h3 id="介质访问控制"><a href="#介质访问控制" class="headerlink" title="介质访问控制"></a>介质访问控制</h3><p>　　介质访问控制所要完成的任务是，为使用介质的每个结点隔离来自同一信道上其他结点所传送的信号，以协调活动结点的传输。用来决定广播信道中信道分配的协议属于数据链路层的一个子层，称为介质访问控制（Medium Access Control， MAC）子层。</p>
<h4 id="信道划分介质访问控制"><a href="#信道划分介质访问控制" class="headerlink" title="信道划分介质访问控制"></a>信道划分介质访问控制</h4><p>　　信道划分介质访问控制将使用介质的每个设备与来自同一通信信道上的其他设备的通信隔开，把时域和频域资源合理地分配给网络上地设备。在一条介质上同时携带多个传输信号的方法来提高系统的利用率，这就是多路复用。</p>
<p>　　1）频分多路复用（FDM）：将多路基带信号调制到不同频率载波上，再叠加形成一个复合信号的多路服用技术。</p>
<p>　　2）时分多路复用（TDM）：将一条物理信道按时间分成若干时间片，轮流地分配给多个信号使用。每个时间片由复用的一个信号占用。</p>
<p>　　3）波分多路复用（WDM）：在一根光纤中传输多种不同波长的光信号。</p>
<p>　　4）码分多路复用（CDM）：采用不同的编码来区分各路原始信号。</p>
<p>　　码分多址（Code Division Multiple Access ，CDMA）是码分复用的一种方式。每比特时间分成 m 个更短的时间槽，称为码片。当两个或多个站点同时发送时，各路数据在信道中线性相加。为从信道中分离出各路信号，要求<strong>各个站点的码片序列相互正交</strong>。</p>
<p>　　可以把多个站点发送的数据看作多个向量，这些向量都是两两正交的。发送方和接收方都有相同的、独一无二的码片序列。在信道中多个向量线性相加，在接收端用码片序列和信道中多个向量的和做规格化内积（点乘后取平均值）我们知道正交的向量点乘的结果为0，其他的向量可以忽略掉。只有发送方的向量做规格化内积。结果为 1 则代表 发送1 ，结果为 -1 代表发送0.。</p>
<p>　　</p>
<h4 id="随机访问介质访问控制"><a href="#随机访问介质访问控制" class="headerlink" title="随机访问介质访问控制"></a>随机访问介质访问控制</h4><p>　　当有两个或多个用户同时发送信息时，就会产生帧的冲突。为了解决帧的碰撞，每个用户须按照一定的规则重传它的帧，知道该帧无碰撞地通过。常用的协议有 ALOHA 协议、CSMA 协议、CSMA/CD协议、CSMA/CA协议等，他们的核心思想是：胜利者争用获得信道，从而获得信息的发送权。<strong>随机介质访问控制机制实质上是将一种广播信道转化为点到点信道的行为。</strong></p>
<h5 id="ALOHA-协议"><a href="#ALOHA-协议" class="headerlink" title="ALOHA 协议"></a>ALOHA 协议</h5><p>　　a. 纯 ALOHA 协议 ：不检测信道状态 直接发送 ，一段时间没收到确认 <strong>等待一段随机的时间</strong>后再发送，直到成功。假设网络负载（T 时间内所有站点发送的所有帧数）为G,纯ALOHA吞吐量（T时间内发送成功的平均帧数）为 S = G<em>e^(-2</em>G) 。当G=0.5时。 S = 0.184</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/SmI1ruGDC2xyXAQ.png" alt="img"></p>
<p>　　b.时隙 ALOHA 协议 ：把所有各站在时间上同步起来，并将时间划分为一段段等长的时隙，规定只能在每个时隙开始才能发送一个帧。在一个时隙内又两个或以上的帧到达时在下一个时隙产生碰撞碰撞后重传策略与纯 ALOHA 协议相似。网络吞吐量S与网络负载关系是 S = G*e^(-G) 。当G=0.5时。 S = 0.368</p>
<h5 id="CSMA-协议（Carrier-Sense-Multiple-Access，载波监听多路访问）"><a href="#CSMA-协议（Carrier-Sense-Multiple-Access，载波监听多路访问）" class="headerlink" title="CSMA 协议（Carrier Sense Multiple Access，载波监听多路访问）"></a>CSMA 协议（Carrier Sense Multiple Access，载波监听多路访问）</h5><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/GN7rqSDIsl9ecpw.png" alt="img"></p>
<h5 id="CSMA-CD-协议-（Carrier-Sense-Multiple-Access-with-Collision-Detection，-载波监听多路访问-碰撞检测）有线局域网–以太网"><a href="#CSMA-CD-协议-（Carrier-Sense-Multiple-Access-with-Collision-Detection，-载波监听多路访问-碰撞检测）有线局域网–以太网" class="headerlink" title="CSMA/CD 协议 （Carrier Sense Multiple Access with Collision Detection， 载波监听多路访问/碰撞检测）有线局域网–以太网"></a>CSMA/CD 协议 （Carrier Sense Multiple Access with Collision Detection， 载波监听多路访问/碰撞检测）<strong>有线局域网–以太网</strong></h5><p>　　CSMA/CD 是 CDMA 的改进，CSMA/CD 适用于总线型网络或半双工网络。“载波监听”指发送前前检测总线上是否有其他站点在发送数据，若有则暂时不发送数据，等待信道变为空闲再发送。”碰撞检测“ 就是边发送边监听，即适配器边发送边监听信道上信号电压的变化情况，判断是否有其他站点是否也在发送数据。</p>
<p>　　<strong>CSMA/CD 的工作流程可概括为 “先听后发，边听边发，冲突停发，随机重发”。</strong></p>
<p>　　采用CSMA/CD 协议的以太网不可能进行全双工通信，只能进行半双工通信。</p>
<p> <img src="https://gitee.com/hoo334/picgo/raw/master//img/CvOhY84VSxdtLwj.png" alt="img"></p>
<p> 　为了确保发送站在发送数据的同时能检测到可能存在的冲突，需要在发送完帧之前就能收到自己发送出去的数据，<strong>帧的传输时延至少要两倍于信号在总线中的传播时延</strong>，所以CSMA/CD 总线网中所有数据帧必须要大于一个最小帧长。<strong>最小帧长 = 总线传播时延*数据传输率*2。以太网最小帧长64B 最大帧长1500B。</strong></p>
<p>　　</p>
<p>　　二进制退避算法：确定基本退避时间，一般取两倍的总线端到端传播时延 2r 。定义参数 k ，它等于重传次数 <strong>k=min(重传次数，10)</strong>。从离散的整数集合 0 ~ 2^k -1 中随机取出一个数n，重传所需要退避的时间就是n倍的基本退避时间 2nr。当重传16次仍不成功抛弃此帧，向上层报告。</p>
<h5 id="CSMA-CA-协议-（Carrier-Sense-Multiple-Access-with-Collision-Avoidence）无线局域网"><a href="#CSMA-CA-协议-（Carrier-Sense-Multiple-Access-with-Collision-Avoidence）无线局域网" class="headerlink" title="CSMA/CA 协议 （Carrier Sense Multiple Access with Collision Avoidence）无线局域网"></a>CSMA/CA 协议 （Carrier Sense Multiple Access with Collision Avoidence）无线局域网</h5><p>　　无线局域网环境下，不能简单地搬用CSMA/CD 协议，特别是碰撞检测部分。主要有两个原因 a.接收信号的强度会远小于发送信号地强度，无线介质上信号强度的动态变化范围很大，若要实现碰撞检测，硬件上的花费就会过大。b.在无线通信中，并非所有站点都能听见对方，即存在“隐蔽站”问题。　　</p>
<p>　　CSMA/CA 采用二进制指数退避算法。任何一个站要发送数据帧时，不仅要等待一个时间间隔，还要进入争用窗口，并计算随机退避时间以便再次试图接入信道。</p>
<p>　　CSMA/CA 还使用预约信道、ACK帧、RTS/CTS 帧等三种机制来实现碰撞避免：</p>
<p>　　预约信道：发送方在发送数据的同时向其他站点通知自己传输数据需要的时间长度，以便让其他站点在这段时间内不会发送数据，从而避免碰撞。</p>
<p>　　ACK帧：所有站点在正确接收到发给自己的帧（除广播帧和组播帧）后，都需要向发送方发回一个ACK帧。</p>
<p>　　RTS/CTS 帧：可选的碰撞避免机制，主要解决无线网中的 “屏蔽站”问题。</p>
<p>　　CSMA/CD 与 CSMA/CA 区别：</p>
<p>　　CSMA/CD 可以检测冲突但无法避免；CSMA/CA 发送包的同时不能检测信道上有无冲突，只能尽量避免。</p>
<p>　　CSMA/CD 用于总线形以太网， CSMA/CA用于无线局域网 802.11 a/b/g/n等。</p>
<p>　　CSMA/CD 通过电缆中的电压变化来检测；CSMA/CA 采用能能量检测、载波检测、和能量载波混合检测三种检测信道空闲的方式。</p>
<p>　　总结：CSMA/CA 在发送数据前广播告知其他结点，让其他结点不要发送数据。CSMA/CD 发送前侦听，边发送边侦听，一旦出现碰撞停止发送。</p>
<p>　　</p>
<h4 id="轮询访问介质访问控制：令牌传递协议"><a href="#轮询访问介质访问控制：令牌传递协议" class="headerlink" title="轮询访问介质访问控制：令牌传递协议"></a>轮询访问介质访问控制：令牌传递协议</h4><p>　　在轮询访问中，用户不能随机地发送消息，而是要通过一个集中控制的监控站，以循环方式轮询每个结点，再决定信道的分配。典型的轮询访问介质访问控制协议是令牌传递协议，主要用在令牌环局域网中。当环上一个站希望传送帧时，必须等待令牌。一旦收到令牌，站点便可启动发送帧。帧在环上传送时，不管该帧是否是发给本站点的，所有站点都进行转发，直到该帧回到它的始发站，并<strong>由始发站撤销该帧</strong>。帧的目的站除转发帧外，应针对该帧维持一个副本。当计算机都不需要发送数据时，<strong>令牌在环形网上游荡</strong>。数据链路层研究的是<strong>点到点</strong>之间的通信。</p>
<h3 id="局域网"><a href="#局域网" class="headerlink" title="局域网"></a>局域网</h3><h4 id="局域网的基本概念和体系结构"><a href="#局域网的基本概念和体系结构" class="headerlink" title="局域网的基本概念和体系结构"></a>局域网的基本概念和体系结构</h4><p>　　局域网（LAN）是指在一个较小的物理范围内，将各种设备通过双绞线等连接介质互相连接起来组成资源和信息共享的计算机互联网络。</p>
<p>　　局域网的特性主要由三个要素决定：拓扑结构、传输介质、介质访问控制方式，最重要的是介质访问控制方式，决定局域网的技术特性。</p>
<p>　　常见的局域网拓扑结构：星形、环形、总线形和星形总线形复合型结构。</p>
<p>　　局域网的介质访问控制方式有 CSMA/CD、令牌总线和令牌环，其中前两种方法主要用于总线形局域网，令牌环主要用于环形局域网。</p>
<p>　　三种特殊的局域网拓扑实现如下：</p>
<p>　　以太网：逻辑拓扑是总线形结构，物理拓扑是星形或拓展星形结构。</p>
<p>　　令牌环：逻辑拓扑是环形结构，物理拓扑是星形结构。</p>
<p>　　FDDI（光纤分布数字接口）：逻辑拓扑是环形结构，物理拓扑是双环结构。</p>
<p>　　<strong>IEEE 802标准定义的局域网参考模型只对应于OSI参考模型的数据链路层和物理层，将数据链路层拆分成两个子层：逻辑链路控制（LLC）子层和媒体接入控制（MAC）子层。与接入传输媒体有关的内容都放在MAC子层，主要功能包括：组帧和拆帧、比特传输差错检测、透明传输。LLC子层与传输媒体无关，它向网络层提供无确认无连接、面向连接、带确认无连接、告诉传送4种不同的连接服务类型。</strong></p>
<h4 id="以太网与IEEE-802-3"><a href="#以太网与IEEE-802-3" class="headerlink" title="以太网与IEEE 802.3"></a>以太网与IEEE 802.3</h4><h5 id="以太网的传输介质与网卡"><a href="#以太网的传输介质与网卡" class="headerlink" title="以太网的传输介质与网卡"></a>以太网的传输介质与网卡</h5><p>　　IEEE 802.3 标准是一种基带总线形的局域网标准。</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/L8FeJPwOCcDUB4x.png" alt="img"></p>
<p> 　网卡工作在数据链路层和物理层。出厂时自带MAC地址。</p>
<h5 id="以太网的MAC帧"><a href="#以太网的MAC帧" class="headerlink" title="以太网的MAC帧"></a>以太网的MAC帧</h5><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/FWhknbH3deVaCMv.png" alt="img"></p>
<p> 　由于总线上使用的是广播通信，因此网卡从网络上每收到一个MAC帧，首先用硬件检查MAC帧中的MAC地址，如果是发往本站的帧就留下否则丢弃。</p>
<p>　　以太网帧结构：</p>
<p>　　前导码：使接收端与发送端时钟同步。第一个字段7B，是前同步码，用来快速实现MAC帧的比特同步。第二个字段是帧开始定界符，1B。</p>
<p>　　注意：MAC帧并不需要帧结束符，在以太网传输帧时，各帧之间必须有一定的间隙。但不要误以为以太网帧不需要尾部，<strong>在数据链路层上帧既要加首部又要加尾部。</strong></p>
<p>　　地址：通常使用MAC地址，6B。</p>
<p>　　类型：2B，指出数据域中携带的数据应交给哪个协议实体处理。</p>
<p>　　数据：46~1500B，包含高层的协议信息。由于CSMA/CD 限制，以太网帧必须满足最小长度64B</p>
<p>　　校验码（FCS）：4B，采用32位循环冗余校验码（CRC），<strong>不但需要校验MAC帧的数据部分还要校验目的地址、源地址和类型字段，但不校验前导码</strong>。</p>
<h5 id="高速以太网"><a href="#高速以太网" class="headerlink" title="高速以太网"></a>高速以太网</h5><p>　　a. 100BASE-T 以太网：100Mb/s 星形拓扑结构以太网，半双工使用 CSMA/CD，全双工不使用CSMA/CD。</p>
<p>　　b. 吉比特以太网：1Gb/s 半双工使用 CSMA/CD，全双工不使用CSMA/CD。</p>
<p>　　c.10吉比特网：10Gb/s 只使用光纤作为传输媒体，只工作在全双工方式，没有争用问题，不使用CSMA/CD。</p>
<p>　　</p>
<h4 id="IEEE-802-11"><a href="#IEEE-802-11" class="headerlink" title="IEEE 802.11"></a>IEEE 802.11</h4><p>　　IEEE 802.11 是无线局域网的一系列协议标准，包括 802.11a 和802.11b等。它们制定了MAC 层协议，运行在多个物理层标准上。</p>
<p>　　802.11 的MAC 层采用CSMA/CA 协议进行介质访问控制。</p>
<p>　　无线局域网可分为两大类：固定基础设施无线局域网和无固定基础设施无线局域网自组织网络。</p>
<p>　　a. 有固定基础设施无线局域网：802.11标准规定无线局域网的最小构件是基本服务集（BSS）。一个基本服务集包括一个基站和若干移动站。BSS内可直接通信，与BSS外的站点通信时要通过本BSS的基站。基本服务集中的基站也称接入点，其作用和网桥相似。</p>
<p>　　b. 无固定基础设施无线局域网自组织网络</p>
<p>　　自组织网络没有上述基本服务集的接入点，而是由一些平等状态移动站相互通信组成的临时网络。各站点之间地位平等，中间结点都为转发结点，这些结点都具有路由器功能。</p>
<h4 id="令牌环网的基本原理"><a href="#令牌环网的基本原理" class="headerlink" title="令牌环网的基本原理"></a>令牌环网的基本原理</h4><p>　　令牌环网的每一站通过电缆与环接口干线耦合器（TCU）相连。TCU 的主要作用是，传递所有经过的帧，为接入站发送和接收数据提供接口。TCU 的状态有收听和发送状态。在令牌环网中有一个令牌沿着环形总线在入网结点计算机间依次传递，令牌实际上是一个特殊格式的MAC控制帧，它本身不包含信息，仅控制信道的使用，确保在同一时刻只有一个结点能够独占信道。</p>
<p>　　令牌环网物理上采用星形拓扑结构，逻辑上仍是环形拓扑结构。</p>
<h3 id="广域网"><a href="#广域网" class="headerlink" title="广域网"></a>广域网</h3><h4 id="广域网基本概念"><a href="#广域网基本概念" class="headerlink" title="广域网基本概念"></a>广域网基本概念</h4><p>　　广域网通常指覆盖范围很广的长距离网络。广域网是因特网的核心部分，其任务是长距离运送主机所发送的数据。</p>
<p>　　广域网由一些结点交换机几连接这些交换机的链路组成。结点交换机的功能是将分组存储并转发。局域网使用的协议主要在数据链路层，而广域网使用的协议主要在网络层。</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/lshEwS5eZCVgQk7.png" alt="img"></p>
<p> 　广域网一个重要问题是路由选择和分组转发。路由选择协议负责搜索分组从某个结点到目的结点的最佳传输路由，以便构造路由表，然后从路由表再构造出转发分组的转发表。分组通过转发表转发。PPP 协议和HDLC 协议是目前最常用的两种广域网数据链路层控制协议。</p>
<h4 id="PPP-协议"><a href="#PPP-协议" class="headerlink" title="PPP 协议"></a>PPP 协议</h4><p>　　PPP（Point-to-Point Protocol）是使用串行线路<strong>面向字节</strong>的协议，该协议应用再直接连接两个结点的链路上。设计的目的只要是用来通过拨号或专线方式建立点对点发送数据，使其成为各种主机、网桥和路由器之间简单连接的一种共同解决方案。</p>
<p>　　PPP协议有三个组成部分</p>
<p>　　1）链路控制协议（LCP）。一种扩展链路控制协议，用于建立、配置、测试和管理数据链路。</p>
<p>　　2）网络控制协议（NCP）。PPP协议采用多种网络层协议，每个不同的网络层协议要用一个相应的NCP来配置，为网络层协议建立和配置逻辑连接。</p>
<p>　　3）一个将IP数据报封装到串行链路的方法。IP数据报在PPP帧中就是其信息部分，这个信息部分的长度受最大传输单元（MTU）的限制。</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/1b9RQXWtLTOj3Hn.png" alt="img"></p>
<p> 　标志字段F 仍为01111110 前后各占1B若它出现在信息字段中，必须做字节填充，使用的控制转义字符为 7D 。在PPP中，地址字段A占1B，规定为0xFF，控制字段C占1B，规定为0x03，两者的内容始终不变。<strong>PPP是面向字符的</strong>，因而所有PPP帧的长度都是整数个字节。协议字段占2B，说明信息段中运载的是什么种类的分组，以比特0开始的是诸如IP、IPX这样的网络层协议；以比特1开始的用来协商其他协议。信息段长度是可变的，大于等于0且小于等于1500B。FCS 检验地址字段、控制字段、协议字段和信息字段。</p>
<p>　　<strong>PPP提供差错检测但不提供纠错功能，只保证无差错接收。是不可靠的传输协议，也不使用序号和确认机制。仅支持点对点的链路通信。PPP只支持全双工链路。PPP的两端可以运行不同的网络协议。</strong></p>
<h4 id="HDLC-协议"><a href="#HDLC-协议" class="headerlink" title="HDLC 协议"></a>HDLC 协议</h4><p>　　高级数据链路控制（High-level Data Link Control）协议是ISO 制定的<strong>面向比特</strong>的数据链路层协议。</p>
<p>　　1）站。HDLC 有3种站类型：主站、从站和复合站。主站负责控制链路的操作，主站发出的帧成为<strong>命令帧</strong>。从站受控于主站，按主站的命令进行操作，发出的帧称为<strong>响应帧</strong>。有些站既有主站的功能又有从站的功能，称为复合站，可以发出两种帧。</p>
<p>　　2）数据操作方式</p>
<p>　　a. 正常相应方式。非平衡结构操作方式。主站向从站传输数据，从站响应传输，从站只有收到主站的许可后，才可进行响应。</p>
<p>　　b. 异步平衡方式。平衡结构操作方式。每个复合站都可以进行对另一站的数据传输。</p>
<p>　　c. 异步响应方式。非平衡结构操作方式。从站即使未收到主站的允许也可以传输。</p>
<p>　　3）HDLC 帧</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/4gb1UdZuOLzao5e.png" alt="img"></p>
<p> 　标志段F：8 bit，01111110。采用比特填充的首尾标志法实现透明传输。地址字段A：8 bit 使用非平衡方式传送数据时，站地址写入从站的地址，使用平衡方式传送数据时，站地址写入应答站的地址。控制字段C：根据其第一位或第一第二位的取值可以将HDLC 帧分为三类：</p>
<p>　　1）信息帧，第一位为0，用来传输数据信息，或使用捎带技术对数据进行确认。</p>
<p>　　2）监督帧，第一二位为10，用于流量控制和差错控制，执行对信息帧的确认、请求重发和请求暂停发送等功能。　</p>
<p>　　3）无编号帧，低一二位为11，用于提供对链路的建立、拆除等多种控制功能。</p>
<p>　　 <strong>PPP与HDLC区别：</strong></p>
<p>　　1）PPP面向字节，HDLC 面向比特</p>
<p>　　2）PPP帧比HDLC帧多一个2B的协议字段，当协议字段为0x0021时，表示信息字段是IP数据报。</p>
<p>　　3）PPP不使用序号和确认机制，只保证无差错接收，端到端差错检测由高层负责。HDLC信息帧使用了编号和确认机制，能够提供可靠传输。</p>
<h3 id="数据链路层设备"><a href="#数据链路层设备" class="headerlink" title="数据链路层设备"></a>数据链路层设备</h3><h4 id="网桥的概念及其基本原理"><a href="#网桥的概念及其基本原理" class="headerlink" title="网桥的概念及其基本原理"></a>网桥的概念及其基本原理</h4><p>　　两个或多个以太网通过网桥连接后，就成为一个覆盖范围更大的以太网，原来的以太网称为一个网段。网桥工作在链路层的MAC子层，可以使以以太网各网段成为隔离开的碰撞域。网桥处理数据是帧它工作在数据链路层，中继器放大器处理的对象是信号，它工作在物理层。</p>
<p>　　网桥的基本特点：</p>
<p>　　1）具备寻址和路径选择的能力，以确定帧的传输方向</p>
<p>　　2）从源网络接收帧，以目的网络的介质访问控制协议向目的网络转发该帧</p>
<p>　　3）网桥在不同或相同类型的LAN之间存储并转发帧，必要时还进行链路层上的协议转换。</p>
<p>　　4）网桥对接收到的帧不做任何修改，或只对帧的封装格式做很少的修改。</p>
<p>　　5）网桥可以通过帧翻译互联不同类型的局域网，即把原协议的信息段内容作为另一种协议的信息部分封装在帧中。</p>
<p>　　6）网桥应有足够大的缓冲空间。</p>
<p>　　网桥的优点：</p>
<p>　　1）能过滤通信量；2）扩大了物理范围；3）可使用不同的物理层；4）可互联不同类型的局域网；5）提高了可靠性；6）性能得到改善</p>
<p>　　网桥的缺点：</p>
<p>　　1）增大了时延；2）MAC子层没有流量控制功能（流量控制在LLC子层）；3）不同MAC子层的网桥接在一起时，需要进行帧格式的转换；4）网桥只适合用户数不多和通信量不大的局域网，否则广播信息太多引起广播风暴。</p>
<p>　　网桥必须具有路径选择的功能，接收到帧后要决定正确的路径，将该帧转送到响应的目的局域网站点。根据路径算法的不同，可将网桥分为透明网桥和源路由网桥。</p>
<p>　　1.透明网桥（选择的不是最佳路由）</p>
<p>　　接收与之连接的所有LAN传送的每一帧，到达帧的路由选择取决于源LAN 和目的LAN 。1）如果源LAN和目的LAN相同则丢弃；2）如果源LAN和目的LAN不同则转发此帧；3）如果目的LAN未知，那么扩散此帧。（网桥自学习算法）</p>
<p>　　2.源路由网桥（选择的是最佳路由）</p>
<p>　　路由选择由发送数据帧的源站负责，网桥只根据真正的路由信息对帧进行接收和转发。为了找到最佳的路由，源站以广播方式向目的站发送一个发现帧作为探测用。目的站也将一一发送应答帧；每个应答帧将通过原路径返回，途径的网桥把自己的标志记录在应答帧中；源站选出最佳路由。</p>
<p>　　3.两种网桥的比较</p>
<p>　　使用源路由网桥可以利用最佳路由，若两个以太网之间使用并联的路由器还可以是通信量较平均的分配给每个网桥。采用透明网桥时，只能使用生成树，而生成树并不能保证所有路由是最佳的，也不能在不同的链路中进行负载均衡。</p>
<p>　　透明网桥和源路由网桥中提到的最佳路由并不是经过路由器最少的路由，而是可以发送帧往返时间最短的路由。</p>
<h4 id="局域网交换机及其工作原理"><a href="#局域网交换机及其工作原理" class="headerlink" title="局域网交换机及其工作原理"></a>局域网交换机及其工作原理</h4><h5 id="局域网交换机"><a href="#局域网交换机" class="headerlink" title="局域网交换机"></a>局域网交换机</h5><p>　　以太网交换机是一个多端口的网桥，它工作在数据链路层。交换机能将网络分成更小的冲突域，为每个工作站提供更高的带宽。利用交换机还可以实现虚拟局域网（VLAN）不仅可以隔离冲突域还能隔离广播域。</p>
<h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><p>　　以太网交换机的原理是，检测以太端口来的数据帧的源和目的地的MAC地址，然后与系统内部的动态查找表进行比较，若数据帧的MAC地址不在查找表中，则将该地址加入查找表，并将数据帧发送给响应的目的端口。</p>
<h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><p>　　a.交换机的每个端口都直接与单台主机相连，工作在全双工方式。</p>
<p>　　b.以太网交换机能同时连通许多对端口，使每对相互通信的主机都能像独占通信媒体那样无碰撞地传输数据。</p>
<p>　　c.即插即用。</p>
<p>　　d.交换速率高。</p>
<p>　　e.独占传输媒体地带宽</p>
<h5 id="两种交换方式"><a href="#两种交换方式" class="headerlink" title="两种交换方式"></a>两种交换方式</h5><p>　　a.直通式交换机只检查帧地目的地址，帧在接收后几乎马上就能被传出去。</p>
<p>　　b.存储转法式交换机先将接收到地帧缓存到高速缓冲器中，检查并转发。</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/I3H5PKNcn1RFGxh.png" alt="img"></p>
<h3 id="本章小结及疑难点-2"><a href="#本章小结及疑难点-2" class="headerlink" title="本章小结及疑难点"></a>本章小结及疑难点</h3><h4 id="“链路”-和-“数据链路”-有何区别？"><a href="#“链路”-和-“数据链路”-有何区别？" class="headerlink" title="“链路” 和 “数据链路” 有何区别？"></a>“链路” 和 “数据链路” 有何区别？</h4><p>​        链路指从一个结点到相邻结点的一段物理线路，其中间没有任何其他任何的交换结点。在进行数据通信时，两台计算机之间的通信路径往往要通过许多段这样的链路。</p>
<p>​        数据链路则是另一个概念，要在一条线路上传送数据，除了必须要有一条物理线路外，还必须有一些通信协议来控制这些数据的传输。若把实现这些协议的硬件和软件加到链路上，就构成了数据链路。</p>
<h4 id="为什么-PPP-协议不使用帧的编号和确认机制来实现可靠传输？"><a href="#为什么-PPP-协议不使用帧的编号和确认机制来实现可靠传输？" class="headerlink" title="为什么 PPP 协议不使用帧的编号和确认机制来实现可靠传输？"></a>为什么 PPP 协议不使用帧的编号和确认机制来实现可靠传输？</h4><p>​        PPP 不使用序号和确认机制出于以下考虑：</p>
<p>​        若使用能够实现可靠传输的数据链路层协议（如 HDLC ），开销就会增大。当数据链路层出现差错的概率不大时，使用简单的 PPP 较为合理。</p>
<p>​        在因特网环境下， PPP 的信息字段放入的数据是 IP 数据报。假定数据链路层实现了非常可靠的传输协议，但在上升到网络层后仍可能由于网络拥塞而被丢弃。数据链路层的可靠传输并不能保证网络层的传输也是可靠的。</p>
<p>​        PPP 在帧格式中有帧校验序列 FCS 字段。对于每个接收到的帧， PPP 都要使用硬件进行 CRC 校验若发现有差错，则丢弃该帧（只要是上交到上一层的帧都是无差错的）。端到端的差错控制由高层协议负责。</p>
<h4 id="交换机和网桥的不同之处。"><a href="#交换机和网桥的不同之处。" class="headerlink" title="交换机和网桥的不同之处。"></a>交换机和网桥的不同之处。</h4><p>​        1）网桥的端口一般连接局域网，而交换机的端口一般直接与局域网的主机相连。</p>
<p>​        2）交换机允许多对计算机同时通信，而网桥仅允许每个网段上的计算机同时通信。</p>
<p>​        3）网桥采用存储转发方式进行转发，而以太网交换机还可以采用直通方式进行转发，且以太网交换机采用了专用的交换结构芯片，转发速度比网桥快。</p>
<h4 id="局域网的主要特点是什么？为什么局域网采用广播通信方式而广域网不采用呢？"><a href="#局域网的主要特点是什么？为什么局域网采用广播通信方式而广域网不采用呢？" class="headerlink" title="局域网的主要特点是什么？为什么局域网采用广播通信方式而广域网不采用呢？"></a>局域网的主要特点是什么？为什么局域网采用广播通信方式而广域网不采用呢？</h4><p>​        局域网最主要的特点是：网络为一个单位所拥有，且地理范围和站点数量有限。局域网的地理范围较小，且为一个单位所拥有，采用广播通信方式十分方便。但广域网的地理范围很大，如果采用广播通信方式势必造成通信资源的极大浪费。</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/LtEuor7PDM3xKzb.png" alt="image-20200410134049382"></p>
<h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><h3 id="网络层的功能"><a href="#网络层的功能" class="headerlink" title="网络层的功能"></a><strong>网络层的功能</strong></h3><h4 id="异构网络互联"><a href="#异构网络互联" class="headerlink" title="异构网络互联"></a>异构网络互联</h4><p>　　网络互联：将两个以上的计算机网络，通过一定的方法，用一种或多种通信处理设备（中间设备）连接起来。</p>
<p>　　中继设备分以下四种：</p>
<p>　　1）物理层中继设备：中继器，集线器。</p>
<p>　　2）数据链路层中继设备：网桥或交换机。</p>
<p>　　3）网络层中继设备：路由器。</p>
<p>　　4）网络层以上的中继设备：网关。</p>
<p>　　使用物理层的中继设备时，只是把一个网络扩大了，从网络层的角度看仍是同一个网络。网络互联通常指用路由器进行网络互联和路由选择。</p>
<p>　　TCP/IP 体系在网络互联上采用的做法是在网络层采用标准化协议，相互连接的网络可以是异构的。</p>
<p>　　</p>
<h4 id="路由与转发"><a href="#路由与转发" class="headerlink" title="路由与转发"></a>路由与转发</h4><p>　　路由器主要完成两个功能：一是路由选择（确定哪一条路径），二是分组转发（当一个分组到达时采取的动作）。前者是根据特定的路由选择协议构造出路由表，同时经常或定期地和相邻路由器交换路由信息而不断更新和维护路由表。后者处理通过路由器的数据流，关键操作是转发表查询、转发及相关地队列管理和任务调度等。</p>
<p>　　1）路由选择：按照复杂的分布式算法，根据相邻路由器所得到地关于整个网络拓扑的变化情况，动态地选择路由。</p>
<p>　　2）分组转发：指路由器按照转发表将用户的 IP 数据报从合适的端口转发出去。</p>
<p>　　</p>
<h4 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h4><p>　　因出现过量的分组而引起网络性能下降的现象称为拥塞。拥塞控制的作用是确保子网能够承载所达到的流量。</p>
<p>　　流量控制：抑制发送端的发送数据速率。</p>
<p>　　拥塞控制方法：</p>
<p>​        1）开环控制。在设计网络时事先将有关发生拥塞的因素考虑到。</p>
<p>​        2）闭环控制。采用检测系统监视。</p>
<h3 id="路由算法"><a href="#路由算法" class="headerlink" title="路由算法"></a><strong>路由算法</strong></h3><h4 id="静态路由与动态路由"><a href="#静态路由与动态路由" class="headerlink" title="静态路由与动态路由"></a>静态路由与动态路由</h4><p>​        静态路由算法（非自适应路由算法）。指由网络管理员手工配置的路由信息。</p>
<p>​        动态路由算法（自适应路由算法）。路由器上的路由表项是通过相互连接的路由器之间彼此交换信息，然后按照一定的算法优化出来的。</p>
<p>　　</p>
<h4 id="距离-向量路由算法"><a href="#距离-向量路由算法" class="headerlink" title="距离-向量路由算法"></a>距离-向量路由算法</h4><p>　　在距离-向量路由算法中所有结点定期地将它们的整个路由选择表传送给所有与之相连的结点。这种路由表包含：1）每条路径的目的地（另一结点）；2）路径的代价（也称距离）。RIP中将距离定义为跳数–从源端口到目的端口的路由器个数。<strong>“好消息传的快，坏消息传的慢”</strong></p>
<p>　　</p>
<h4 id="链路状态路由算法"><a href="#链路状态路由算法" class="headerlink" title="链路状态路由算法"></a>链路状态路由算法</h4><p>　　链路状态路由算法要求每个参与该算法的结点都具有完全的网络拓扑信息。它们执行下述两项任务：1）主动测试所有邻接结点的状态。2）定期地将链路状态传播给所有其他结点。典型的链路状态算法是OSPF算法。</p>
<p>　　链路状态路由算法有3个特征：</p>
<p>　　1）向本自治系统中所有路由器发送信息，治理使用的方法是洪泛法，路由器通过所有端口向所有相邻的路由器发送信息。每个相邻的路由器又将信息发往所有其他的路由器。</p>
<p>　　2)发送的信息是与路由器相邻的所有路由器的链路状态，但这只是路由器所知道的部分信息。</p>
<p>　　3）只有当链路状态发生变化时，路由器才向所有路由器发送此消息。</p>
<h4 id="层次路由"><a href="#层次路由" class="headerlink" title="层次路由"></a>层次路由</h4><p>　　因特网把路由选择协议分为两大类：</p>
<p>　　1）一个自治系统内部所使用的路由选择协议称为内部网关协议（IGP），也称域内路由选择，具体的协议有RIP 和OSPF 等。</p>
<p>　　2）自治系统之间所使用的路由选择协议称为外部网关协议（EGP），也称域间路由选择，用在不同自治系统的路由器之间交换路由信息。具体的协议有BGP。</p>
<h3 id="IPv4"><a href="#IPv4" class="headerlink" title="IPv4"></a><strong>IPv4</strong></h3><h4 id="IPv4分组"><a href="#IPv4分组" class="headerlink" title="IPv4分组"></a>IPv4分组</h4><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/2S4LzoC5UadXEVb.png" alt="img"></p>
<p> 　一个IP分组由首部和数据两部分组成。首部前一部分长度固定，共20B。</p>
<p>　　1）版本。占4位。IP版本，目前使用4。</p>
<p>　　2）首部长度。占4位。<strong>以4B为单位</strong>，最大值为60B（4位最多表示15），最常用20B。</p>
<p>　　3）总长度。占16位。指首部和数据部分的总长度，<strong>单位为字节</strong>，所以最长65535B。</p>
<p>　　4）标识。占16位。它是一个计数器，每产生一个数据报就加1，并赋值给标识字段。</p>
<p>　　5）标志。占3位。X DF MF 共三位。<strong>DF=0表示可以分片。MF=1表示后面还有分片</strong>。</p>
<p>　　6）片偏移。占13位。它指出较长的分组在分片后，某片在原分组中的相对位置。<strong>以8B为单位</strong>。每个分片的长度一定是8B的整数倍。</p>
<p>　　7）首部校验和。占16位。只校验分组的首部，不校验数据部分。</p>
<p>　　8）生存时间（TTL）。占8位。数据段在网络中可通过的路由器的最大值。</p>
<p>　　9）协议。占8位指出分组携带的数据使用何种协议，6 代表 TCP，17 代表UDP。</p>
<p>　　10）源地址字段。占4B，标识发送方的IP地址。</p>
<p>　　11）目的地址字段。占4B，标识接收方的IP地址。</p>
<p>　　</p>
<p>　　分片例子：</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/ms5cGHWLrvOjZJX.png" alt="img"></p>
<p> 　网络层转发分组的流程：</p>
<p>　　1）从首部中取出目的主机的IP地址 D，得出目的网络地址N。</p>
<p>　　2）若网络N与此路由器直接相连，把数据报直接交付给目的主机D。否则间接交付执行3。</p>
<p>　　3）若路由表中有目的地址为D的特定主机路由，把数据报传到下一跳路由器。否则执行4。</p>
<p>　　4）若路由表中有到达网络N的路由器，传给下一跳路由器，否则执行5。</p>
<p>　　5）若路由表中有一个默认路由，把数据报传给默认路由，否则执行6。</p>
<p>　　6）报告转发分组出错。</p>
<p>　　总结：检查接收主机是否与发送主机在同一局域网内–》 检查是否可以通过下一跳路由器直达接收主机 –》 检查是否可以通过下一跳路由器到达另一个路由器（可到达目的主机）–》报错。</p>
<p>　　注意：得到下一跳路由器IP地址后不是直接将下一跳路由器的IP之间填入IP数据报首部。而是将其封装在帧中，改变帧的接收MAC地址。通过这个MAC地址找到下一跳路由器。<strong>在不同网络中传送时，MAC帧中的源地址和目的地址要发生变化，网桥在转发帧时，不改变帧的源地址。</strong></p>
<p>　　</p>
<h4 id="IPv4地址与NAT"><a href="#IPv4地址与NAT" class="headerlink" title="IPv4地址与NAT"></a>IPv4地址与NAT</h4><h5 id="IPv4-地址"><a href="#IPv4-地址" class="headerlink" title="IPv4 地址"></a>IPv4 地址</h5><p>　　连接到因特网上的每台主机或路由器都分配一个32比特的全球唯一标识符，即IP地址。传统的IP地址是分类的地址，分为A，B，C，D，E五类。</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/YOFb4qsouhinm6T.png" alt="img"></p>
<p>　　<strong>IP地址=网络号+主机号</strong></p>
<p>　　 特殊用途的IP地址：</p>
<p>　　a.主机号全0表示网络本身。</p>
<p>　　b.主机号全1表示网络的广播地址。</p>
<p>　　c. 127.0.0.0 保留为环路自检地址，此地址表示任意主机本身。</p>
<p>　　d.32位全为0，0.0.0.0表示本网络上的本主机</p>
<p>　　e.32位全为1 255.255.255.255 表示整个TCP/IP网络的广播地址，又称受限广播地址。</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/FZVzXlYEQIjDyxP.png" alt="img"></p>
<h5 id="网络地址转换"><a href="#网络地址转换" class="headerlink" title="网络地址转换"></a>网络地址转换</h5><p>　　网络地址转换（NAT）是指将专用网络地址（如Internet）转换为公用地址（ 如Internet）。它使整个专用网只需一个全球IP地址就可以与因特网连通。工作在传输层。</p>
<p>　　一个典型NAT 转换表 WAN 138.76.29.7：5001 ；LAN 192.168.0.2：2233。NAT 工作在传输层。</p>
<p>　　私有IP地址只用于LAN，不用于WAN连接。私有IP网段如下：</p>
<p>　　A类：1个A类网段，<strong>10</strong>.0.0.0 ~ <strong>10</strong>.255.255.255.255</p>
<p>　　B类：16个B类网段，<strong>172.16</strong>.0.0 ~ <strong>172.31</strong>.255.255</p>
<p>　　C类：256个C类网段，<strong>192.168.0</strong>.0~<strong>192.168.255</strong>.255</p>
<h4 id="子网划分与子网掩码、CIDR"><a href="#子网划分与子网掩码、CIDR" class="headerlink" title="子网划分与子网掩码、CIDR"></a>子网划分与子网掩码、CIDR</h4><h5 id="子网划分"><a href="#子网划分" class="headerlink" title="子网划分"></a>子网划分</h5><p>　　子网划分纯属一个单位内部的事情，对外仍然表现为没有划分子网的网络。仅仅是把主机号这部分再进行划分。</p>
<h5 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h5><p>　　子网验码是一个与IP地址相对应的、长32bit的二进制串，由一串1和一串0组成。1对应网络号和子网号，0对应主机号。</p>
<p>　　</p>
<p>　　使用子网验码的分组转发如下：</p>
<p>　　a.从首部中取出目的主机的IP地址 D。</p>
<p>　　b.对<strong>路由器直接相连的网络</strong>逐个检查，用各网络的子网验码和D逐位做与操作，如果结果等于该网络的网络号，直接交付，否则间接交付执行c。</p>
<p>　　c.若路由表中有目的地址为D的特定主机路由，把数据报传到下一跳路由器。否则执行d。</p>
<p>　　d.检查路由表中每一行，如果子网掩码与D的与操作结果与目的网络地址网络号相同则传给下一跳路由器，否则执行e。</p>
<p>　　e.若路由表中有一个默认路由，把数据报传给默认路由，否则执行f。</p>
<p>　　f.报告转发分组出错。</p>
<p>　　总结：检查接收主机是否与发送主机在同一局域网内–》 检查是否可以通过下一跳路由器直达接收主机 –》 检查是否有默认路由–》报错。</p>
<h5 id="无分类域间路由选择（CIDR）"><a href="#无分类域间路由选择（CIDR）" class="headerlink" title="无分类域间路由选择（CIDR）"></a>无分类域间路由选择（CIDR）</h5><p>　　CIDR使用“网络前缀”的概念代替子网的概念。</p>
<p>　　<strong>CIDR使用斜线计法 IP地址/网络前缀占用比特数。</strong></p>
<h4 id="ARP、DHCP与ICMP"><a href="#ARP、DHCP与ICMP" class="headerlink" title="ARP、DHCP与ICMP"></a>ARP、DHCP与ICMP</h4><p>　　1）IP地址与硬件地址</p>
<p>　　IP地址由于路由器的隔离不能进行广播，这时候就只能通过数据链路层的MAC地址以广播方式寻址。</p>
<p>　　2）地址解析协议（ARP）</p>
<p>　　IP到MAC地址的映射，这就是地址解析协议（Address Resolution Protocol，ARP）。</p>
<p>　　<strong>ARP工作在网络层，先查看ARP缓存，如果没有目的IP对应的MAC地址则使用目的MAC地址为ff-ff-ff-ff-ff-ff的帧来封装并广播ARP请求分组。</strong>目的主机收到该 ARP 请求后向源主机发出 ARP 响应分组。</p>
<p>　　3）动态主机配置协议（DHCP）</p>
<p>　　动态主机配置协议（Dynamic Host Configuration Protocol，DHCP）常用于给主机动态地分配IP地址，提供了即插即用地机制，允许一台计算机加入新的网络和获取IP地址。DHCP是<strong>应用层</strong>协议，它是基于UDP的。</p>
<p>　　4）网际控制报文协议（ICMP）</p>
<p>　　为了提高IP数据报交付成功的机会，在网络层使用了网际控制报文协议（Internet Control Message Protocol，ICMP）来让主机或路由器报告差错和异常情况。ICMP报文作为IP数据报的数据，加上数据报的首部，组成IP数据报发送出去。</p>
<p>　　ICMP报文有两种 ICMP差错报文和ICMP询问报文。</p>
<p>　　ICMP差错报文5种类型：</p>
<p>　　1）终点不可达。路由器或主机不能交付数据报。</p>
<p>　　2）源点抑制。路由器或主机由于拥塞丢弃数据报。</p>
<p>　　3）时间超过。路由器收到TTL=0的数据报。</p>
<p>　　4）参数问题。路由器或主机收到数据报中首部字段值不正确。</p>
<p>　　5）改变路由（重定向）。路由器把改变路由报文发送给主机。</p>
<p>　　不发送ICMP 差错报文的情况：</p>
<p>　　1）对ICMP 差错报文不发送。</p>
<p>　　2）对第一个分片的数据报片后续所有数据报片都不发送。</p>
<p>　　3）对组播地址的数据报不发送。</p>
<p>　　4)对具有特殊地址的数据报不发送。</p>
<p>　　</p>
<p>　　ICMP询问报文有4种类型：回送请求和回答报文、时间戳请求和回答报文、掩码地址请求和回答报文、路由器询问和通告报文。</p>
<p>　　<strong>ICMP的常见应用是分组间探测PING，PING使用了ICMP会送请求和回答报文。PING工作在应用层，直接使用网络层的ICMP回送请求和回答报文。</strong></p>
<h3 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h3><h4 id="IPv6-特点"><a href="#IPv6-特点" class="headerlink" title="IPv6 特点"></a>IPv6 特点</h4><p>　　1）IPv6共128位，2）简化了IP分组头3）更好地支持选项</p>
<p>　　</p>
<h4 id="IPv6-地址"><a href="#IPv6-地址" class="headerlink" title="IPv6 地址"></a>IPv6 地址</h4><p>　　IPv6 数据报的目的地址可以是 单播、多播和组播。</p>
<p>　　IPv4 向IPv6 过渡可以采用双协议栈和隧道技术两种策略。双协议栈是指在一台设备上同时装有IPv4 和IPv6 协议栈。隧道技术是将整个IPv6数据报封装到IPv4的数据部分。</p>
<h3 id="路由协议"><a href="#路由协议" class="headerlink" title="路由协议"></a>路由协议</h3><h4 id="自治系统"><a href="#自治系统" class="headerlink" title="自治系统"></a>自治系统</h4><p>　　自治系统（Automatic System，AS）单一技术管理下的一组路由器。</p>
<p>　　</p>
<h4 id="域内路由和域间路由"><a href="#域内路由和域间路由" class="headerlink" title="域内路由和域间路由"></a>域内路由和域间路由</h4><p>　　1）内部网关协议（Internal Gateway Protocol，IGP）：在一个自治系统内部使用的路由选择协议。如 RIP、OSPF。</p>
<p>　　2） 外部网关协议（External Gateway Protocol，EGP）：自治系统之间的路由选择协议。如BGP-4。</p>
<p>　　</p>
<h4 id="路由信息协议（RIP）"><a href="#路由信息协议（RIP）" class="headerlink" title="路由信息协议（RIP）"></a>路由信息协议（RIP）</h4><p>　　网络中的每个路由器维护从它自身到每个目的网络的距离记录。RIP距离最大为15，超过15代表不可达。RIP默认在任意两个使用RIP的路由器之间每30秒广播一次RIP路由更新信息，以便自动建立并维护路由表。RIP中每个网络的子网掩码必须相同。</p>
<p>　　RIP 的特点：</p>
<p>　　1）仅和相邻路由器交换信息。</p>
<p>　　2）路由器交换的信息是当前路由器所知道的全部信息，即自己的额路由表。</p>
<p>　　3）按固定的时间间隔交换路由器信息，如每隔30秒。</p>
<p>　　</p>
<p>　　距离向量算法：</p>
<p>　　每个路由表都有三个关键数据：&lt;目的网络N，距离d，下一跳路由器X&gt;</p>
<p>　　1）对每个相邻路由器中发过来的RIP报文，先修改所有的项目，把“下一跳”字段中的地址都改为 X，并把所有“距离”字段加1。</p>
<p>　　2）对修改后的RIP报文中的每个项目，执行如下步骤。</p>
<p>　　a.当原来的路由表中没有目的网络N时，把该项目添加到路由表中。</p>
<p>　　b.当原来的路由表中有目的网络N，且下一跳路由器地址是X时，用收到的项目替换原路由表中的项目。</p>
<p>　　c.当原来的路由表中有目的网络N，且下一跳地址不是X时，选择距离较小的更新。</p>
<p>　　3）如果180 秒（RIP 默认超时时间为 180秒）还没有收到相邻路由器的更新路由器，那么把此相邻路由器记为不可达路由器。</p>
<p>　　</p>
<p>　　RIP最大优点是实现简单、开销小、收敛过程较快。</p>
<p>　　RIP缺点如下：</p>
<p>　　a.限制了网络的规模</p>
<p>　　b.路由器之间交换的是路由器中的完整路由表因此网络规模越大，开销也越大。</p>
<p>　　c.网络出现故障时，会出现慢收敛现象（需要较长时间才能将此信息传到所有路由器）俗称坏消息传的慢。</p>
<p>　　</p>
<h4 id="开放最短路径优先（OSPF）协议"><a href="#开放最短路径优先（OSPF）协议" class="headerlink" title="开放最短路径优先（OSPF）协议"></a>开放最短路径优先（OSPF）协议</h4><h5 id="OSPF-和-RIP-的区别。"><a href="#OSPF-和-RIP-的区别。" class="headerlink" title="OSPF 和 RIP 的区别。"></a>OSPF 和 RIP 的区别。</h5><p>　　a.OSPF 向本自治系统中的所有路由器发送信息，使用的是洪泛法。RIP仅向临近的路由器发送信息。</p>
<p>　　b.发送的信息是与本路由器相邻的所有路由器的链路状态，但这只是部分信息。RIP发送整个路由表。</p>
<p>　　c.只有当链路状态发生变化时，路由器才用洪泛法向所有路由器发送此信息。</p>
<p>　　d.OSPF是网络层协议，它不使用UDP或TCP，而直接使用IP数据报传送（其IP数据报首部协议字段为89）.RIP是应用层协议，它在传输层使用UDP。</p>
<h5 id="OSPF-基本工作原理"><a href="#OSPF-基本工作原理" class="headerlink" title="OSPF 基本工作原理"></a>OSPF 基本工作原理</h5><p>　　各个路由器之间频繁地交换链路状态信息，所有路由器最终都能建立一个链路状态数据库。这个数据库就是全网的拓扑结构，它在全网范围内是一致的。每个路由器根据这个全网拓扑结构图，使用Dijkstra 最短路径算法计算从自己到各目的网络的最优路径，以此构造自己的路由表。当链路状态更新时需要重新计算。</p>
<p>　　注意：虽然使用Dijkstra算法能计算出完整的最优路径，但路由表中不会存储完整的路径，而只存储“下一跳”（只有到了下一跳路由器才能再知道下一跳怎样走）。</p>
<p>　　</p>
<p>　　OSPF 的五种分组类型：</p>
<p>　　a.问候分组，用来维持临站的可达性。</p>
<p>　　b.数据库描述分组，向临站给出自己的链路状态数据库中所有链路状态的摘要信息。</p>
<p>　　c.链路状态请求分组，向对方请求发送某些链路状态项目的详细信息。</p>
<p>　　d.链路状态更新分组，用洪泛法对全网更新链路状态。</p>
<p>　　e.链路状态确认分组，对链路更新分组的确认。</p>
<p>　　通常每隔10秒，每两个相邻路由器都要交换一次问候分组，以便知道哪些站可达。OSPF 还归档每隔一段时间就刷新数据库中的链路状态。</p>
<p>　　</p>
<h4 id="边界网关协议（BGP）"><a href="#边界网关协议（BGP）" class="headerlink" title="边界网关协议（BGP）"></a>边界网关协议（BGP）</h4><p>　　边界网关协议（Border Gateway Protocol，BGP）是不同自治系统的路由器之间交换路由信息的协议，是一种外部网关协议。只能尽力寻找一条能够到达目的网络且比较好的路由，而非寻找一条最佳路由。<strong>BGP 是应用层协议，它是基于TCP的。</strong></p>
<p>　　BGP的工作原理如下：每个自治系统的管理员要选择至少一个路由器作为该自治系统的“BGP”发言人。一个BGP发言人要与其他自治系统中的BGP发言人交换路由信息，就要先建立TCP连接。在此连接上交换BGP报文以建立BGP会话，在利用BGP会话交换路由信息。</p>
<p>　　BGP特点：1）BGP 交换路由信息的结点数量级是自治系统的数量级。2）每个自治系统中的BGP发言人数目是很少的。</p>
<p>　　BGP共使用4种报文：</p>
<p>　　1）打开报文。用来与相邻的另一个BGP发言人建立关系。</p>
<p>　　2）更新报文。用来发送某一路由的信息，以及要撤销的多条路由。</p>
<p>　　3）保活报文。用来确认打开报文并周期性地证实临站关系。</p>
<p>　　4）通知报文。用来发送检测到地差错。</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/orCBvgIw8smXcWj.png" alt="img"></p>
<h3 id="IP-组播"><a href="#IP-组播" class="headerlink" title="IP 组播"></a><strong>IP 组播</strong></h3><h4 id="组播的概念"><a href="#组播的概念" class="headerlink" title="组播的概念"></a>组播的概念</h4><p>　　人们所需要的组播机制是让源计算机一次发送的单个分组可以抵达用一个组标识的若干目标主机，并被它们正确接收。</p>
<p>　　组播一定仅应用于UDP。主机使用一个称为IGMP（因特网组管理协议）的协议加入组播组。主机在组播时仅发送一份数据，只有数据在传送路径出现分岔时才将分组复制后继续转发。组播需要路由器的支持。</p>
<h4 id="IP-组播地址"><a href="#IP-组播地址" class="headerlink" title="IP 组播地址"></a>IP 组播地址</h4><p>　　IP 组播使用 D类地址格式。D类地址前四位是1110，因此D类地址范围是 224.0.0.0 ~ 239.255.255.255.每个D类地址标志一个组播组。</p>
<p>　　组播数据报与一般IP数据报的区别是，前者使用D类IP 地址作为目的地址，并且首部中的协议字段值是2，表明使用IGMP。需要注意的是：</p>
<p>　　1）组播数据报也是“尽最大努力交付”，不提供可靠交付。</p>
<p>　　2）组播地址只能用于目的地址，而不能用于源地址。</p>
<p>　　3）对组播数据报不产生ICMP差错报文。</p>
<p>　　4）并非所有D类地址都可以作为组播地址。</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/ev5FiWZCnjNrbsV.png" alt="img"></p>
<h4 id="IGMP-与组播路由算法"><a href="#IGMP-与组播路由算法" class="headerlink" title="IGMP 与组播路由算法"></a>IGMP 与组播路由算法</h4><p>　　IGMP 应视为 TCP/IP 的一部分，其工作可分为两个阶段：</p>
<p>　　1）当某台主机加入新的组播组时，该主机应向组播组地址发送一个IGMP 报文，声明自己要称为该组的成员。</p>
<p>　　2）本地组播路由器要周期性地探询本地局域网上的主机，以便知道这些主机是否仍继续时组的成员。</p>
<p>　　</p>
<h3 id="移动IP"><a href="#移动IP" class="headerlink" title="移动IP"></a><strong>移动IP</strong></h3><h4 id="移动-IP-的概念"><a href="#移动-IP-的概念" class="headerlink" title="移动 IP 的概念"></a>移动 IP 的概念</h4><p>　　支持移动性的因特网体系结构与协议共称移动IP。它是为了满足移动结点在移动中保持其连接性而设计的。</p>
<p>　　基于IPv4 的移动IP定义三种功能实体：移动结点、本地代理和外部代理。本地代理和外部代理又称为移动代理。</p>
<p>　　1）移动结点。具有永久IP地址的移动结点。</p>
<p>　　2）本地代理。在一个网络环境中，一个移动结点的永久“居所”被称为归属网络，在归属网络中代表移动结点执行移动管理功能的实体称为本地代理。</p>
<p>　　3）外部代理。在外部网络中帮助移动结点完成移动管理功能的实体称为外部代理。</p>
<h4 id="移动IP通信过程"><a href="#移动IP通信过程" class="headerlink" title="移动IP通信过程"></a>移动IP通信过程</h4><p>　　移动IP为移动主机设置了两个IP地址，即主地址和辅地址。移动主机在本地网时，使用的是主地址。当移动到另一个网络时，需要获得一个临时的辅地址，但此时主地址仍不变，从外网移回本地网时，辅地址改变或撤销，主地址仍然保持不变。</p>
<h3 id="网络层设备"><a href="#网络层设备" class="headerlink" title="网络层设备"></a>网络层设备</h3><h4 id="路由器的组成和功能"><a href="#路由器的组成和功能" class="headerlink" title="路由器的组成和功能"></a>路由器的组成和功能</h4><p>　　路由器是一种具有多个输入/输出端口的专用计算机，其任务是连接异构网络并完成路由转发，在多个逻辑网络互联时必须使用路由器。如果源主机和目的主机在同一个网络上，那么直接交付而无需通过路由器。如果源主机和目的网络不在同一各网络上，路由器按照转发表指出的路由将数据报转发给下一个路由器，称为间接交付。</p>
<p>　　路由器由路由选择和分组转发两部分构成。路由器是网络层设备，它实现了网络模型的下三层。如果一个存储转发设备实现了某个层次的功能，那么它就可以互联两个在该层次上使用不同协议的网段。例如网桥实现了物理层和数据链路，网桥就可以互联两个物理层和数据链路层不同的网段。</p>
<p>　　路由选择部分也称控制部分，其核心构件是路由选择处理机。</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/EBMz9khK71uWvjy.png" alt="img"></p>
<h4 id="路由表与路由转发"><a href="#路由表与路由转发" class="headerlink" title="路由表与路由转发"></a>路由表与路由转发</h4><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/SQFZdbVO8KBNiDj.png" alt="img"></p>
<h3 id="本章小结及疑难点-3"><a href="#本章小结及疑难点-3" class="headerlink" title="本章小结及疑难点"></a>本章小结及疑难点</h3><h4 id="“尽最大努力交付”有哪些含义？"><a href="#“尽最大努力交付”有哪些含义？" class="headerlink" title="“尽最大努力交付”有哪些含义？"></a>“尽最大努力交付”有哪些含义？</h4><p>​    1）不保证源主机发送的 IP 数据报一定无差错地交付到目的主机。</p>
<p>​    2）不保证源主机发送的 IP 数据报都在某一规定 的时间内交付到目的主机。</p>
<p>​    3）不保证源主机发送的 IP 数据报一定按发送时的顺序交付到目的主机。</p>
<p>​    4）不保证源主机发送的 IP 数据报不会重复交付给目的主机。</p>
<p>​    5）不故意丢弃 IP 数据报。丢弃 IP 数据报的情况是：<strong>路由器检测出首部校验和有错误；或由于网络中通信量过大，路由器或目的主机中的缓存已无存储空间。</strong></p>
<p><strong>交付目的主机的 IP 数据报都是 IP 数据报的首部没有出现差错或没有检测出来有差错的。</strong></p>
<p>​    总结：尽最大努力交付不保证 IP 数据报：无差错、准时到达、按序到达、不会重复交付。丢弃数据报的情况：缓存满。</p>
<h4 id="在互联网中，能否使用一个很大的交换机来代替全部的路由器？"><a href="#在互联网中，能否使用一个很大的交换机来代替全部的路由器？" class="headerlink" title="在互联网中，能否使用一个很大的交换机来代替全部的路由器？"></a>在互联网中，能否使用一个很大的交换机来代替全部的路由器？</h4><p>​        不行。交换机和路由器的功能是很不一样的。交换机和在一个单个的网络中和若干个计算机相连，并且可以将一个计算机发送过来的帧转发给另一个计算机。从这点上看，交换机具有集线器的转发帧的功能。但交换机比集线器的功能强很多。集线器在同一时间只允许一个计算机和其他计算机进行通信，但交换机允许多个计算机同时进行通信。</p>
<p>​        路由器连接两个或几个网络，路由器可在网络之间转发分组（即 IP 数据报）。这些互联的网络是异构的。如果存在异构网络互联，使用交换机是不行的。</p>
<h4 id="当运行-PING-127-0-0-1-时，这个-IP-数据报将发给谁？"><a href="#当运行-PING-127-0-0-1-时，这个-IP-数据报将发给谁？" class="headerlink" title="当运行 PING 127.0.0.1 时，这个 IP 数据报将发给谁？"></a>当运行 PING 127.0.0.1 时，这个 IP 数据报将发给谁？</h4><p>​        127.0.0.1 是环回地址。主机将测试用的 IP 数据报发给本主机的 ICMP（而不是发送到互联网上）以便进行环回测试。</p>
<h4 id="全-1-的-IP-地址是否是向整个互联网进行广播的一种地址？"><a href="#全-1-的-IP-地址是否是向整个互联网进行广播的一种地址？" class="headerlink" title="全 1 的 IP 地址是否是向整个互联网进行广播的一种地址？"></a>全 1 的 IP 地址是否是向整个互联网进行广播的一种地址？</h4><p>​        不是。在 IP 地址中的全 1 地址表示仅在本网络上（发送这个 IP 数据报的主机所连局域网）进行广播。这种广播叫做受限的广播。如果网络号是具体的网络号，主机号全 1 叫做定向广播，这是对某一个具体的网络（网络号指明的网络）上的所有主机进行广播的一种地址。</p>
<h4 id="IP-协议有分片的功能，但广域网中的分组则不必分片。这是为什么？"><a href="#IP-协议有分片的功能，但广域网中的分组则不必分片。这是为什么？" class="headerlink" title="IP 协议有分片的功能，但广域网中的分组则不必分片。这是为什么？"></a>IP 协议有分片的功能，但广域网中的分组则不必分片。这是为什么？</h4><p>​        IP 数据报可能要经过许多个网络，而源主机事先并不知道后面要经过的这些网络中分组的最大长度是多少，当超过某个网络的最大长度限制时就需要分片。</p>
<p>​        广域网能够通过的分组的最大长度是该广域网中所有主机都事先知道的，源主机不可能发送网络不支持的过长分组。</p>
<h4 id="链路层广播和-IP-广播有何区别？"><a href="#链路层广播和-IP-广播有何区别？" class="headerlink" title="链路层广播和 IP 广播有何区别？"></a>链路层广播和 IP 广播有何区别？</h4><p>​        链路层广播使用数据链路层协议，在一个以太网史昂实现对该局域网上所有主机的 MAC 帧进行广播。</p>
<p>​        IP 广播则是用 IP 协议，通过互联网实现的对一个网络上的所有主机的 IP 数据报广播。</p>
<h4 id="当路由器利用-IP-数据报首部中的-“首部校验和”-字段检测出在传输过程中出现了差错时，就简单地将其丢弃。为什么不发送一个-ICMP-报文给源主机呢？"><a href="#当路由器利用-IP-数据报首部中的-“首部校验和”-字段检测出在传输过程中出现了差错时，就简单地将其丢弃。为什么不发送一个-ICMP-报文给源主机呢？" class="headerlink" title="当路由器利用 IP 数据报首部中的 “首部校验和” 字段检测出在传输过程中出现了差错时，就简单地将其丢弃。为什么不发送一个 ICMP 报文给源主机呢？"></a>当路由器利用 IP 数据报首部中的 “首部校验和” 字段检测出在传输过程中出现了差错时，就简单地将其丢弃。为什么不发送一个 ICMP 报文给源主机呢？</h4><p>​        IP 协议并不要求源主机重传有差错的数据报。保证无差错传输是由 TCP 协议完成的。另一方面，首部校验和只能校验出 IP 数据报的首部是否出现差错，但不知道首部中的源地址字段有没有出错，如果出错，将数据报传到错误的地址也是无意义的。</p>
<h4 id="有人认为，不使用-CIDR-也行。例如，使用-CIDR-时，给某单位分配了一个地址块-20，相当于-16-个-C-类地址块。如果不使用-CIDR-，而直接给该单位分配-16-个-C-类地址块，那么在效果上不是一样吗？"><a href="#有人认为，不使用-CIDR-也行。例如，使用-CIDR-时，给某单位分配了一个地址块-20，相当于-16-个-C-类地址块。如果不使用-CIDR-，而直接给该单位分配-16-个-C-类地址块，那么在效果上不是一样吗？" class="headerlink" title="有人认为，不使用 CIDR 也行。例如，使用 CIDR 时，给某单位分配了一个地址块 /20，相当于 16 个 C 类地址块。如果不使用 CIDR ，而直接给该单位分配 16 个 C 类地址块，那么在效果上不是一样吗？"></a>有人认为，不使用 CIDR 也行。例如，使用 CIDR 时，给某单位分配了一个地址块 /20，相当于 16 个 C 类地址块。如果不使用 CIDR ，而直接给该单位分配 16 个 C 类地址块，那么在效果上不是一样吗？</h4><p>​        如果不采用 CIDR ，而直接分配 16 个 C 类地址块，相当于给该单位分配了 16 个 C 类网络。这个单位对外界来说，是 16 个 C 类网络。每一个 C 类网络都要在本单位外面的路由表中占有一个表项，使得路由表更大了。当本单位内的许多主机相互通信时，由于跨越了不同的网络，都必须使用路由器来转发 IP 数据报，开销增大。</p>
<h4 id="IP-数据报中的首部校验和并不检验数据报中的数据，这样做的优缺点是什么？计算首部校验和为什么不使用-CRC-校验码？"><a href="#IP-数据报中的首部校验和并不检验数据报中的数据，这样做的优缺点是什么？计算首部校验和为什么不使用-CRC-校验码？" class="headerlink" title="IP 数据报中的首部校验和并不检验数据报中的数据，这样做的优缺点是什么？计算首部校验和为什么不使用 CRC 校验码？"></a>IP 数据报中的首部校验和并不检验数据报中的数据，这样做的优缺点是什么？计算首部校验和为什么不使用 CRC 校验码？</h4><p>​        优点是不校验数据部分可以加快分组转发的速度，缺点是数据部分出现差错不能及早发现，由上层检查数据是否出错。不使用 CRC 可减少路由器进行校验的时间。</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/rPoZzSghkIDjyR6.png" alt="image-20200411110119434"></p>
<h2 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h2><h3 id="传输层提供的服务"><a href="#传输层提供的服务" class="headerlink" title="传输层提供的服务"></a>传输层提供的服务</h3><h4 id="传输层的功能"><a href="#传输层的功能" class="headerlink" title="传输层的功能"></a>传输层的功能</h4><p>　　传输层向它上面的应用层提供通信服务，属于面向通信部分的最高层，同时也是用户功能中的最底层。</p>
<p>　　<strong>传输层</strong>位于网络层上，它为运行在不同主机上的<strong>进程</strong>之间提供了逻辑通信，<strong>网络层</strong>提供<strong>主机</strong>之间的逻辑通信。即使网络层协议不可靠（网络层协议使分组丢失、混乱或重复），传输层同样能为应用程序提供可靠的服务。</p>
<p>　　传输层的功能如下：</p>
<p>　　1）提供应用进程之间的通信（端到端的通信）。与网络层的区别是，网络层提供的是主机之间的逻辑通信。</p>
<p>　　2）复用和分用。复用是指发送方不同的应用进程都可以使用同一个传输层协议传输数据；分用指接收方的传输层在剥去报文的首部后能够把这些数据正确交付到目的进程。</p>
<p>　　注意：传输层的复用和分用与网络层复用分用功能不同。网络层的复用是指发送方不同协议的数据都可以封装成IP数据报发送出去，分用是指接收方的网络层在剥去首部后把数据交付给相应的协议。</p>
<p>　　3）传输层还要对收到的报文进行差错检测（首部和数据部分）。而网络层只检测 IP 数据报的首部，不检验数据部分是否出错。</p>
<p>　　4）提供两种不同的传输协议，即面向连接的 TCP 和面向无连接的 UDP。网络层无法同时实现两种协议（在网络层要么只提供面向连接的服务，如虚电路；要么只提供无连接服务，如数据报，不可能在网络层同时存在这两种方式）。</p>
<p>　　当传输层采用 TCP 时尽管下面的网络是不可靠的，但这种逻辑通信通道就相当于一条全双工的可靠信道。当传输层采用 UDP 时，这种逻辑信道仍是一条不可靠信道。</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/3FQL42bwSgD95yh.png" alt="img"></p>
<h4 id="传输层的寻址与端口"><a href="#传输层的寻址与端口" class="headerlink" title="传输层的寻址与端口"></a>传输层的寻址与端口</h4><h5 id="端口的作用"><a href="#端口的作用" class="headerlink" title="端口的作用"></a>端口的作用</h5><p>　　端口能够让应用层的各种应用进程将其数据通过端口向下交付给传输层，以及让传输层知道将其报文段中的数据向上交付给应用层相应的进程。端口是传输层服务访问点（TSAP），它在传输层的作用类似于 IP 地址在网络层的作用，或MAC地址在数据链路层的作用，只不过IP地址和MAC地址标识的是主机，而端口标识的是主机中的应用进程。</p>
<p>　　数据链路层的SAP 是MAC地址，网络层的SAP是IP地址，传输层的SAP 是端口。</p>
<h5 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a>端口号</h5><p>　　应用进程通过端口号进行标识，端口号长16个比特，能够表示65536 个不同的端口号。</p>
<p>　　端口号只具有本地意义，即端口号只标识本计算机应用层中的各进程，在因特网中不同计算机的相同端口号是没有联系的。根据端口号范围可将端口分为两类：</p>
<p>　　1）服务端使用的端口号。这里分为两类，最重要的一类是<strong>熟知端口号</strong>，数值为<strong>0~1023</strong>，IANA（互联网地址指派机构）把这些端口号指派给了TCP/IP最重要的一些应用程序，让所有用户都知道。另一类为登记端口号，数值为 1024~49151。它是供没有熟知端口的应用程序使用的，使用这类端口必须在IANA登记。</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/wcfgOCdMm4XUkRv.png" alt="img"></p>
<p> 　2）客户端使用的端口号，数值为 49152~65535 ，这类端口号仅在客户进程运行时才动态地选择，因此又称短暂端口号（也称临时端口）。</p>
<h5 id="套接字"><a href="#套接字" class="headerlink" title="套接字"></a>套接字</h5><p>　　在网络中通过IP地址来区别不同地主机，通过端口号来标识和区分一台主机中不同应用进程。在网络中采用发送方和接收方地套接字（Socket）组合来识别端点。</p>
<p>　　套接字 = （主机IP地址，端口号）</p>
<p>　　它唯一地标识网络中的一台主机和其上的一个应用。</p>
<p>　　</p>
<h4 id="无连接服务与面向连接服务"><a href="#无连接服务与面向连接服务" class="headerlink" title="无连接服务与面向连接服务"></a>无连接服务与面向连接服务</h4><p>　　面向连接服务就是在通信双方进行通信之前，必须先建立连接，在通信过程中，整个连接的情况一直被实时地监控和管理。通信结束后，应该释放这个连接。</p>
<p>　　无连接服务是指两个实体之间地通信不需要先建立好连接，需要通信时，直接将信息发送到“网络”中，让该信息地传递在网上尽力而为地往目的地传送。</p>
<p>　　TCP/IP 协议族 在 IP 上使用了两个传输协议：一个是面向连接的传输控制协议（Transmission Control Protocol，TCP），采用TCP时，传输层向上提供的是一条全双工的可靠逻辑信道；另一个是无连接的用户数据报协议（User Datagram Protocol，UDP），采用UDP时，传输层向上提供的是一条不可靠的逻辑信道。</p>
<p>　　TCP 在传送数据之前必须先建立连接，数据传送后要释放连接。TCP 不提供广播或组播服务。由于TCP提供面向连接的可靠传输服务，不可避免地增加了许多开销，如确认、流量控制、计时器及连接管理等。TCP 更适合可靠性更重要地场合，如 FTP，HTTP，TELNET等。</p>
<p>　　UDP 是一个无连接地非可靠传输层协议。它在IP之上仅提供两个附加服务：多路复用和对数据地错误检查。UDP 比较简单，执行速度快、实时性好。使用 UDP 的应用主要包括小文件传送协议（TFTP）、DNS、SMTP和实时传输协议（RTP）。</p>
<h3 id="UDP-协议"><a href="#UDP-协议" class="headerlink" title="UDP 协议"></a>UDP 协议</h3><h4 id="UDP-数据报"><a href="#UDP-数据报" class="headerlink" title="UDP 数据报"></a>UDP 数据报</h4><h5 id="UDP-概述"><a href="#UDP-概述" class="headerlink" title="UDP 概述"></a>UDP 概述</h5><p>　　UDP 具有如下优点：1) UDP 无须建立连接。2）无连接状态。3）分组首部开销小，TCP 有20B的首部开销，UDP 仅有8B的开销。4）应用层能更好地控制要发送的数据和发送时间。</p>
<p>　　UDP 常用于一次性传输较少数据的网络应用如 DNS等。UDP 提供尽最大努力交付，不保证可靠交付。UDP 是面向报文的。报文不可分割，是UDP数据报处理的最小单位。</p>
<p>　　</p>
<h5 id="UDP的首部格式"><a href="#UDP的首部格式" class="headerlink" title="UDP的首部格式"></a>UDP的首部格式</h5><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/f6CQvHwS4l57PYu.png" alt="img"></p>
<p>　　1）源端口。源端口号。在需要对方回信时选用，不用可为全0.</p>
<p>　　2）目的端口。目的端口号。交付报文时必须使用到。</p>
<p>　　3）长度。UDP 数据报的长度（包括首部和数据），其最小值是 8B。</p>
<p>　　4）校验和。检测UDP数据报在传输中是否有错。有错就丢弃。</p>
<p>　　当传输 层从IP 层收到 UDP 数据报时，就根据首部中的目的端口，把UDP数据报通过相应的端口上交给应用进程。如果接收方UDP发现收到的报文中目的端口号不正确，丢弃报文，并由ICMP发送“端口不可达”差错报文给发送方。</p>
<p>　　</p>
<h4 id="UDP-校验"><a href="#UDP-校验" class="headerlink" title="UDP 校验"></a>UDP 校验</h4><p>　　在计算校验和时要在UDP数据报之前增加12B的伪首部，仅仅是为了计算校验和。</p>
<p>　　<strong>IP 数据报的校验和只检验IP数据报的首部，UDP的校验和则检查首部和数据部分。</strong></p>
<h3 id="TCP-协议"><a href="#TCP-协议" class="headerlink" title="TCP 协议"></a>TCP 协议</h3><h4 id="TCP-协议的特点"><a href="#TCP-协议的特点" class="headerlink" title="TCP 协议的特点"></a>TCP 协议的特点</h4><p>　　TCP 是在不可靠的 IP 层上实现的可靠数据传输协议，它主要解决传输的可靠、有序、无丢失和不重复问题。</p>
<p>　　TCP 协议的特点：</p>
<p>　　1）TCP 是面向连接的传输层协议。</p>
<p>　　2）每条TCP 连接只能有两个端点，每条TCP 连接只能是点对点的。</p>
<p>　　3）TCP 提供可靠的交付服务，保证传输的数据无差错、不丢失、不重复且有序。</p>
<p>　　4）TCP 提供全双工通信，允许双方的应用进程在任何时候都能发送数据，为此 TCP 连接的两端都设有发送缓存和接收缓存。</p>
<p>　　5）TCP 是面向字节流的。</p>
<p>　　</p>
<h4 id="TCP-报文段"><a href="#TCP-报文段" class="headerlink" title="TCP 报文段"></a>TCP 报文段</h4><p>　　TCP 传送的数据单元称为报文段。一个TCP 报文段分为 TCP 首部和TCP 数据两部分。整个TCP 报文作为 IP 数据报的数据部分封装在 IP 数据报中。其首部的前20B是固定的。TCP 报文段首部最短为20B，后面有4N字节是根据需要而增加的选项，通常长度是4B的整数倍。</p>
<p>　　TCP 报文段既可以用来运载数据，又可以用来建立连接、释放连接和应答。</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/ZrPKCWlDYTie6Mj.png" alt="img"></p>
<p> 　1）源端口和目的端口 各占2B。端口是传输层和应用层的服务接口，运输层的复用和分用功能都通过端口实现。</p>
<p>　　2）序号字段 占4B。TCP 是面向字节流的（TCP 传送时是逐个字节传送的），所以<strong>TCP连接传送得数据流中得每个字节都编上一个序号。序号字段得值指的是本报文段所发送的数据的第一个字节的序号</strong>。</p>
<p>　　3）确认号字段，占4B。<strong>是期望收到对方下一个报文段的数据的第一个字节的序号。若确认号为 N，则表明到序号 N-1 为止的所有数据都已正确收到。</strong></p>
<p>　　4）数据偏移（首部长度）占4位。表示首部的长度 以4B为单位。</p>
<p>　　5）保留字段。占6位。</p>
<p>　　6）紧急位URG。URG=1时，表明紧急指针字段有效。告诉系统报文段中有紧急数据。URG 要配合紧急指针使用，即数据从第一个字节到紧急指针所指字节就是紧急数据。</p>
<p>　　7）确认位ACK。只有当ACK=1时确认号字段才有效。当ACK=0时确认号无效。<strong>TCP 规定，在连接建立后所有传送的报文段必须把ACK置1。</strong></p>
<p>　　8）推送位PSH。接收TCP 收到PSH=1的报文段，就尽快地交付给应用进程。</p>
<p>　　9）复位位RST。当RST=1时表明TCP连接中出现严重错误，必须释放连接再重新建立运输连接。</p>
<p>　　10）同步位SYN。同步SYN=1表示这是一个连接请求或连接接收报文。当SYN=1，ACK=0时表示这是一个连接请求报文，若对方同意建立连接，则在相应报文中使用SYN=1，ACK=1。</p>
<p>　　11）终止位FIN。用来释放一个连接。FIN表明此报文段的额发送方的数据已发送完毕。</p>
<p>　　12）窗口字段。占2B它指出现在允许对方发送的数据量。</p>
<p>　　13）校验和。占2B。校验和字段检验的范围包括首部和数据两部分。计算校验和也要在TCP报文段前面加上12B的伪首部。</p>
<p>　　14）紧急指针字段。占16位，指出本报文段中紧急数据有多少字节。</p>
<p>　　15）选项字段。长度可变。TCP 只规定了一种窜巷，即最大报文长度MSS。MSS是TCP报文段中数据字段的最大长度。</p>
<p>　　16）填充字段。使整个首部长度是4B的整数倍。</p>
<h4 id="TCP-连接管理"><a href="#TCP-连接管理" class="headerlink" title="TCP 连接管理"></a>TCP 连接管理</h4><p>　　TCP 是面向连接的协议，因此每个TCP 连接都有三个阶段：<strong>连接建立、数据传送和连接释放</strong>。</p>
<p>　　TCP 连接建立过程中，要解决以下三个问题：</p>
<p>　　1）要使每一方都能够确知对方的存在。</p>
<p>　　2）要允许双方协商一些参数</p>
<p>　　3）能够运输实体资源。</p>
<p>　　TCP 把连接作为最基本的抽象，每条TCP连接有两个端点，TCP连接的端点不是主机，不是主机的IP地址，不是应用进程，也不是传输层的协议端口。TCP连接的端口称为套接字。端口拼接到IP地址即构成套接字。</p>
<p>　　1、TCP 连接的建立：三次握手。</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/blFim8spoScZdGB.png" alt="img"></p>
<p> 　服务端的资源是在第二次握手时分配的，客户端的资源是在第三次握手时分配的，使得服务器易收到SYN洪泛攻击。</p>
<h5 id="为什么不采用“两次握手”建立连接？"><a href="#为什么不采用“两次握手”建立连接？" class="headerlink" title="为什么不采用“两次握手”建立连接？"></a><strong>为什么不采用“两次握手”建立连接？</strong></h5><p>　　防止两次握手情况下将已经失效的连接请求报文突然又传到服务器而产生错误。以客户 A 向服务器 B 建立连接为例。A 向 B 先发送连接请求 ，但是网络拥堵没有及时到达，还没有到达 B ，A的就超时重传了，再次发送了一个连接请求。等第一个请求报文到达服务器时服务器给出确认报文。收到第二个报文服务器认为又要请求连接，又给出确认报文。在网络拥堵时就会浪费服务器资源。</p>
<p>　　如果是三次握手，第二次的请求报文不是服务器想要的报文，连接建立失败。</p>
<p>　　2、TCP 连接的释放：四次挥手。</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/5wOiGbaTICBSJ4j.png" alt="img"></p>
<h5 id="为什么不采用“三次挥手”释放连接，且发送最后一次挥手报文要等待2MSL时间呢？"><a href="#为什么不采用“三次挥手”释放连接，且发送最后一次挥手报文要等待2MSL时间呢？" class="headerlink" title="为什么不采用“三次挥手”释放连接，且发送最后一次挥手报文要等待2MSL时间呢？"></a><strong>为什么不采用“三次挥手”释放连接，且发送最后一次挥手报文要等待2MSL时间呢？</strong></h5><p>　　1）确保A发送的 最后一个确认报文能够到达B，如果 A 不等待 2MSL， 若A返回的最后一个确认报文段丢失，B不能正常关闭，而此时A已经关闭，不可能再重传。</p>
<p>　　2)防止出现“已失效的连接请求报文段”。A 在发送最后一个确认报文段之后，再经过2MSL可保证本连接持续的时间内产生的所有报文段从网络中消失。</p>
<p>　　</p>
<h4 id="TCP-可靠传输"><a href="#TCP-可靠传输" class="headerlink" title="TCP 可靠传输"></a>TCP 可靠传输</h4><p>　　TCP 使用了校验、序号、确认和重传等机制来达到这一目的。</p>
<h5 id="序号"><a href="#序号" class="headerlink" title="序号"></a>序号</h5><p>　　TCP 首部的序号字段用来保证数据能有序提交给应用层，TCP 把数据视为一个无结构但有序的字节流，序号建立在传送的字节流上，而不建立在报文段上。</p>
<p>　　TCP 连接传送的数据流中的每个字节都编上一个序号。</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/frq8gsQlw239Y1h.png" alt="img"></p>
<p>　　上图中第一个报文段序号为0，第二个为3。</p>
<h5 id="确认"><a href="#确认" class="headerlink" title="确认"></a>确认</h5><p>　　<strong>TCP 首部的确认号是期望收到对方的下一个报文段的第一个字节的序号。</strong></p>
<p>　　<strong>TCP 默认使用累计确认，即TCP 只确认数据流中至第一个丢失字节为止的字节。</strong></p>
<h5 id="重传"><a href="#重传" class="headerlink" title="重传"></a>重传</h5><p>　　有两种事件会导致TCP 对报文段进行重传，超时和冗余 ACK。</p>
<p>　　1）超时</p>
<p>　　TCP 每发送一个报文段，就对这个报文段设置一次计时器。重传时间到期未收到确认则重传。</p>
<p>　　2）冗余ACK（冗余确认）</p>
<p>　　TCP 规定每当比期望序号大的失序报文到达时，就发送一个冗余ACK，指明下一个期望字节的序号。</p>
<h4 id="TCP-流量控制"><a href="#TCP-流量控制" class="headerlink" title="TCP 流量控制"></a>TCP 流量控制</h4><p>　　TCP 提供流量控制服务来消除发送方使接收方缓冲区溢出的可能性，流量控制是一个速度匹配服务。</p>
<p>　　TCP 提供一种基于滑动窗口协议的流量控制机制，这里介绍TCP如何使用窗口机制来实现流量控制。</p>
<p>　　在通信过程中，接收方根据自己的接收缓存的大小，动态地调整发送方地发送窗口大小，这称为<strong>接收窗口 rwnd</strong>，即调整TCP首部中“窗口”字段值，来限制发送方向向网络注入报文地速率。同时发送方根据其对当前网络拥塞程序的估计而确定的窗口值，这称为<strong>拥塞窗口 cwnd</strong>。</p>
<p>　　例如，在通信中，有效数据只从A发往B，而B仅向A发送确认报文，这时B可通过设置确认报文段首部的窗口字段来将rwnd通知给A。<strong>rwnd即接收方允许连续接收的最大能力，单位是字节。</strong></p>
<p> 　传输层和数据链路层的流量控制的区别是：传输层定义端到端用户之间的流量控制、数据链路层定义两个中间结点的流量控制。另外，数据链路层的滑动窗口协议的大小不能动态变化，传输层的可以动态变化。</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/Dodg3HIf7sBjJbW.png" alt="img"></p>
<h4 id="TCP-拥塞控制"><a href="#TCP-拥塞控制" class="headerlink" title="TCP 拥塞控制"></a><strong>TCP 拥塞控制</strong></h4><p>　　所谓拥塞控制，是为了防止过多的数据注入网络，保证网络中的路由器或链路不致过载。</p>
<p>　　拥塞控制与流量控制的区别：拥塞控制是网络能够承受现有的网络复合，是一个全局性的过程，涉及所有主机、所有的路由器，以及与降低网络传输性能有关的所有因素。流量控制往往是指点对点 的通信量的控制，即接收端控制发送端，它所要做的是抑制发送端发送数据的速率。</p>
<p>　　发送方在确定发送报文段的速率时，既要根据接收方的接收能力，又要从全局考虑不要使网络发生拥塞。因此，TCP 协议要求发送方维护以下两个窗口：　　</p>
<p>　　1）接收窗口cwnd，接收方根据目前接收缓存大小所许诺的最新窗口值，反映接收方的容量。由接收方根据其放在TCP报文首部的窗口值通知发送方。</p>
<p>　　2）拥塞窗口cwnd，发送方根据自己估算的网络拥塞程度而设置的窗口值，反映网络的当前容量。</p>
<p>　　<strong>发送窗口的上限值应取接收窗口 rwnd 和拥塞窗口 cwnd 中较小的一个。</strong></p>
<p>　　<strong><img src="https://gitee.com/hoo334/picgo/raw/master//img/2wIRxO9r1jsymtp.png" alt="img"></strong></p>
<p> 　接收窗口的大小可根据TCP报文的窗口字段通知发送方，发送方如何维护拥塞窗口呢？下面讲慢开始和拥塞避免算法。</p>
<h5 id="慢开始和拥塞避免"><a href="#慢开始和拥塞避免" class="headerlink" title="慢开始和拥塞避免"></a>慢开始和拥塞避免</h5><h6 id="慢开始算法"><a href="#慢开始算法" class="headerlink" title="慢开始算法"></a>慢开始算法</h6><p>　　在TCP 刚连接好并开始发送TCP 报文时，先令拥塞窗口 cwnd=1，即一个最大报文段长度MSS，每收到一个对新报文的确认后将 cwnd加1，即增大一个MSS。逐步加大发送方的拥塞窗口。</p>
<p>　　例如，A 向 B 发送数据，发送时 A 的拥塞窗口为 2，那么 A 一次可以发送两个 TCP 报文段，经过一个 RTT 后，A 收到 B 对刚才两个报文的确认，于是把拥塞窗口调整为 4，下一次发送时就可以一次发送4个报文段。</p>
<p>　　<strong>使用慢开始算法后，每经过一个传输轮次（一个RTT），拥塞窗口 cwnd 就会加倍，即cwnd 的大小指数式增长。这样慢开始一直把拥塞窗口 cwnd 增大到一个规定的慢开始门限 ssthresh（阈值），然后改用拥塞避免算法。</strong></p>
<h6 id="拥塞避免算法"><a href="#拥塞避免算法" class="headerlink" title="拥塞避免算法"></a>拥塞避免算法</h6><p>　　<strong>发送端的拥塞窗口 cwnd 每经过一个 RTT 就增加一个MSS的大小，而不是加倍，时cwnd按线性规律缓慢增长，当出现一次超时（网络拥塞）时，令慢开始门限 ssthresh 等于当前cwnd 的一半。</strong></p>
<h6 id="网络拥塞的处理"><a href="#网络拥塞的处理" class="headerlink" title="网络拥塞的处理"></a>网络拥塞的处理</h6><p>　　网络出现拥塞时，无论是在慢开始阶段还是在拥塞避免阶段，只要对方检测到超时事件的发生，就要把慢开始门限 ssthresh 设置为出现拥塞时的发送方 cwnd 值得一般 （但不能小于2）.然后把拥塞窗口cwnd 重新设置为1，执行慢开始算法。这样做得目的是迅速减少主机发送到网络中得分组数，使得发生拥塞的路由器有足够时间把队列中积压的分组处理完。</p>
<p>　　拥塞避免并不能完全避免拥塞。</p>
<p>　<img src="https://gitee.com/hoo334/picgo/raw/master//img/vD9GEh5pFyoHwIq.png" alt="img"></p>
<h5 id="快重传和快恢复"><a href="#快重传和快恢复" class="headerlink" title="快重传和快恢复"></a>快重传和快恢复</h5><p>　　 快重传和快恢复算法是对慢开始和拥塞避免算法的改进。</p>
<h6 id="快重传"><a href="#快重传" class="headerlink" title="快重传"></a>快重传</h6><p>　　快重传技术采用了冗余ACK来检测丢包的发生。同样，冗余 ACK 也用于网络拥塞的检测（丢了包意味着网络出现了拥塞）。快重传并非取消重传计时器，而是在某些情况下更早地重传丢失地报文段。</p>
<p>　　<strong>当发送方连续收到三个重复的ACK报文时，直接重传对方尚未收到的报文段，而不必等待那个报文段设置的重传计时器超时。</strong></p>
<h6 id="快恢复"><a href="#快恢复" class="headerlink" title="快恢复"></a>快恢复</h6><p>　　发送端收到连续的三个冗余 ACK（即重复确认）时，执行“乘法减小”算法，把慢开始门限 ssthresh 设置为出现拥塞时发送方cwnd的一半。与满开始（慢开始算法将拥塞窗口cwnd设置为 1）的不同之处是，它把cwnd 的值设置为慢开始门限ssthresh 改变之后的值，然后开始执行拥塞避免算法（“加法增大”），使拥塞窗口缓慢地线性增大。</p>
<p>　　由于跳过了 cwnd 从1起始的慢开始过程，所以称为快恢复。快恢复算法实现的过程如下图。虚线为慢开始的处理过程。</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/RQCNmEf41ZLnPO8.png" alt="img"></p>
<p> 　在流量控制中，发送方发送数据的量由接收方决定，在拥塞控制中，则由发送方自己通过检测 网络状况来决定。实际上，慢开始、拥塞避免、快重传和快恢复几种算法应是同时应用在拥塞控制机制中，<strong>当发送方检测到超时的时候，就开始慢开始和拥塞避免，当发送方接收发到冗余 ACK 时就采用快重传和快恢复。</strong></p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/kHdKev7JVR15yna.png" alt="img"></p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/UvJc6VCxe7fIGim.png" alt="image-20200507213947478"></p>
<h3 id="知识结构图"><a href="#知识结构图" class="headerlink" title="知识结构图"></a>知识结构图</h3><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/p1mQsEuLAqKbizO.png" alt="image-20200411154708823"></p>
<h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><h3 id="网络应用模型"><a href="#网络应用模型" class="headerlink" title="网络应用模型"></a>网络应用模型</h3><h4 id="客户-服务器模型"><a href="#客户-服务器模型" class="headerlink" title="客户/服务器模型"></a>客户/服务器模型</h4><p>　　在客户/服务器模型（Client/Server，C/S）模型中，有一个总是打开的主机称为服务器，它服务于许多来自其他称为客户机的主机请求。</p>
<p>　　其工作流程如下：</p>
<p>　　1）服务器处于接收请求的状态。</p>
<p>　　2）客户机发出服务请求，并等待接收结果。</p>
<p>　　3）服务器收到请求后，分析请求，进行必要的处理，得到结果并发送给客户机。</p>
<p>　　客户程序必须知道服务器程序的地址。常见的使用客户/服务器模型的应用包括 Web、文件传输协议（FTP）、远程登录和电子邮件等。</p>
<p>　　客户/服务器模型的主要特点还有：</p>
<p>　　1）网络中各计算机的地位不平等，服务器可以通过对用户权限的控制来达到管理客户机的目的。整个网络的管理工作由少数服务器担当。</p>
<p>　　2）客户机之间不直接通信。</p>
<p>　　3）可扩展性不佳，受服务器硬件和带宽的限制，服务器支持的客户机有限。</p>
<p>　　</p>
<h4 id="P2P模型"><a href="#P2P模型" class="headerlink" title="P2P模型"></a>P2P模型</h4><p>　　在C/S 模型中，服务器性能的好坏决定了整个系统的性能。当大量的用户请求服务时，服务器必然成为系统的瓶颈。P2P 模型的思想是整个网络中的传输内容不再被保留在中心服务器上，每个结点都同时具有下载、上传的功能，其权利和义务都是大体对等的。</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/YfH16xOIqM4p5SB.png" alt="img"></p>
<p> 　与C/S 模型相比，P2P 模型的优点主要体现在：</p>
<p>　　1）减轻服务器的计算压力，消除了对某个服务器的完全依赖。</p>
<p>　　2）多个客户机之间可以直接共享文档。</p>
<p>　　3）可扩展性好。</p>
<p>　　4）网络健壮性强。</p>
<h3 id="域名系统"><a href="#域名系统" class="headerlink" title="域名系统"></a>域名系统</h3><h4 id="层次域名空间"><a href="#层次域名空间" class="headerlink" title="层次域名空间"></a>层次域名空间</h4><p>　　因特网采用层次树状结构的命名方法。采用这种命名方法，任何一个连接到因特网的主机或路由器，都有一个唯一的层次结构名称，即域名（Domain Name）。域（Domain）是名字空间中一个可被管理的划分。域可以划分为子域，子域也能划分。这样就形成了顶级域、二级域、三级域等。每个域名都由标号序列组成，各标号之间用（“.”）隔开。</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/jiIY6to5ZTGnhbB.png" alt="img"></p>
<p> 　域名中标号要注意：</p>
<p>　　1）标号中的英文不区分大小写。</p>
<p>　　2）标号中除连字符（-）外不允许使用其他的标点符号。</p>
<p>　　3）每个标号不超过 63 个字符，多标号组成的完整域名最长不超过 255 个字符。</p>
<p>　　4）级别最低的域名写在最左边，级别最高的域名写在最右边。</p>
<p>　　</p>
<p>　　顶级域名（Top Level Domain）分为如下三大类：</p>
<p>　　1）国家顶级域名。国家和某些地区的域名，“.cn”表示中国。</p>
<p>　　2）通用顶级域名。常见的“.com”（公司）、“.net”（网络服务机构）、“.org”（非盈利性组织）</p>
<p>　　3）基础结构域名。 arpa 用于反向域名解析。</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/MYlKHhTdcOXG1yo.png" alt="img"></p>
<h4 id="域名服务器"><a href="#域名服务器" class="headerlink" title="域名服务器"></a>域名服务器</h4><p>　　域名到 IP 地址的解析是由运行在域名服务器上的程序完成的，一个服务器所管辖的范围称为区。每个域名服务器不但能够进行一些域名到 IP 地址的解析，而且还必须具有连向其他域名服务器的信息。当自己不能进行域名到 IP 地址的转换时，能够知道到什么地方去找其他域名服务器。</p>
<p>　　DNS 使用了大量的域名服务器，它们以层次方式组织。采用分布式设计的 DNS，是一个在因特网上实现分布式数据库的精彩范例。</p>
<p>　　主要有 4 种类型的域名服务器：</p>
<p>　　1）根域名服务器。根域名服务器是最高层次的服务器，所有根域名服务器都知道所有顶级域名服务器的 IP 地址。根域名服务器也是最重要的域名服务器。<strong>根域名服务器用来管理顶级域（如.com），通常它并不直接把待查询的域名直接转换为 IP 地址，而是告诉本地域名服务器下一步应当找哪一个顶级域名服务器进行查询。</strong></p>
<p>　　2）顶级域名服务器。负责管理在该顶级域名服务器注册的所有二级域名。收到 DNS 查询请求时，就给出相应的回答（可能是最后的结果，也可能是下一步应当查找的域名服务器的 IP 地址）。</p>
<p>　　3）授权域名服务器（权限域名服务器）。授权域名服务器总能将其管辖的主机名转换为该主机的IP 地址。</p>
<p>　　4）本地域名服务器。当一台主机发出 DNS 查询请求时，这个查询请求报文就发送给该主机的本地域名服务器。我们在 Windows 系统中配置“本地连接” 时，就需要填写 DNS 地址，这个地址就是本地 DNS 的地址。</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/TWcnYbumtrf46jG.png" alt="img"></p>
<h4 id="域名解析过程"><a href="#域名解析过程" class="headerlink" title="域名解析过程"></a>域名解析过程</h4><p>　　域名解析是指把<strong>域名映射成为 IP 地址</strong>或把 IP 地址映射成域名的过程。前者称为<strong>正向解析</strong>，后者称为反向解析。当客户端需要域名解析时，通过本机的额DNS 客户端构造一个 DNS 的请求报文， 以 <strong>UDP 数据报</strong>方式发往本地域名服务器。域名解析有两种方式：递归查询和递归与迭代相结合的查询。<strong>递归查询给根服务器造成的负载过大，在实际中几乎不使用。</strong></p>
<p>　　常用递归与迭代相结合的查询方式如下图所示。 </p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/mL9shJUbPAdkfYS.png" alt="img"></p>
<p> 　假定客户机想获知域名为 y.abc.com主机地 IP 地址，域名解析地过程（用使用 8 个UDP 报文）如下：</p>
<p>　　1）客户机向本地域名服务器发出 DNS 请求报文。</p>
<p>　　2）本地域名服务器收到后查询本地缓存，若有记录直接返回。若没有记录，以 DNS 客户的身份向根域名服务器发起解析请求。</p>
<p>　　3)根域名服务器收到请求后，判断该域名属于 .com 域，将对应的顶级域名服务器 dns.com 的 IP 地址返回给本地域名服务器。</p>
<p>　　4）本地域名服务器向 顶级域名服务器 dns.com 发出解析请求报文。</p>
<p>　　5）顶级域名服务器 dns.com 接收到请求后，判断该域名属于 abc.com域，因此将对应的授权域名服务器 dns.abc.com 的 IP 地址返回给本地域名服务器。</p>
<p>　　6）本地域名服务器向 dns.abc.com 发起解析请求报文。</p>
<p>　　7）授权域名服务器 dns.abc.com 收到请求后将 查询结果返回给本地域名服务器。</p>
<p>　　8）本地域名服务器将查询结果保存到本地缓存，同时返回给客户机。</p>
<p>　　为了提高 DNS 的查询效率，并减少互联网上的 DNS 查询报文数量，在域名服务器中广泛地使用了高速缓存。当一个 DNS 服务器接收到 DNS 查询结果时，它能将该 DNS 信息缓存在高速缓存中。</p>
<p>　　</p>
<h3 id="文件传输协议（FTP）"><a href="#文件传输协议（FTP）" class="headerlink" title="文件传输协议（FTP）"></a>文件传输协议（FTP）</h3><h4 id="FTP-的工作原理"><a href="#FTP-的工作原理" class="headerlink" title="FTP 的工作原理"></a>FTP 的工作原理</h4><p>　　文件传输协议（File Transfer Protocol，FTP）是因特网上使用的最广泛的文件传输协议。FTP 提供交互式的访问，允许客户指明文件的类型与格式，并允许文件具有存取权限。它屏蔽了各计算机系统的细节，适合于在异构网络中的任意计算机之间传送文件。</p>
<p>　　FTP 提供以下功能：</p>
<p>　　1）提供不同种类主机系统之间的文件传输能力。</p>
<p>　　2）以用户权限管理的方式提供用户对远程 FTP 服务器上的文件管理能力。</p>
<p>　　3）以匿名 FTP 的方式提供公用文件共享的能力。</p>
<p>　　FTP 采用 客户/服务器的工作方式，它使用 TCP 可靠的传输服务。一个 FTP 服务器可同时为多个客户机进程提供服务。FTP 的服务器进程由两大部分组成：一个主进程，负责接收新的请求；另外由若干从属进程，负责处理单个请求。</p>
<p>　　其工作步骤如下：</p>
<p>　　1）打开熟知端口21（控制端口），使客户进程能够连接上。</p>
<p>　　2）等待客户进程发连接请求。</p>
<p>　　3）启动从属进程来处理客户进程发来的请求。主进程与从属进程并发执行，从属进程处理完客户的请求后终止。</p>
<p>　　4）回到等待状态。</p>
<p>　　</p>
<h4 id="控制连接与数据连接"><a href="#控制连接与数据连接" class="headerlink" title="控制连接与数据连接"></a>控制连接与数据连接</h4><p>　　FTP 在工作时使用两个并行的 TCP 连接：<strong>一个控制连接（端口号21），一个是数据连接（端口号20）</strong>。</p>
<p>　　1）控制连接。服务器监听21端口，等待客户连接，控制连接用来传递控制信息 以7位 ASCII 格式传送。</p>
<p>　　2）数据连接。服务器端接收到客户端发来的文件传输请求后，创建数据传送进程和数据连接。数据连接用来连接客户端和服务器端的数据传送进程，数据传送进程实际完成文件的传送，在传送完毕后关闭“数据传送连接”并结束运行。</p>
<h3 id="电子邮件"><a href="#电子邮件" class="headerlink" title="电子邮件"></a>电子邮件</h3><h4 id="电子邮件系统的组成结构"><a href="#电子邮件系统的组成结构" class="headerlink" title="电子邮件系统的组成结构"></a>电子邮件系统的组成结构</h4><p>　　一个电子邮件系统应具有三个最主要的组成构件，用户代理（User Agent）、邮件服务器和电子邮件使用的协议，如 SMTP、POP3（或 IMAP）等。</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/GkUHhObCvaygi7Z.png" alt="img"></p>
<p>​        用户代理（UA）：用户与电子邮件系统的接口。通常情况下，就是一个运行在PC上的程序。</p>
<p>　　邮件服务器：组成电子邮件系统的核心。邮件服务器的功能是发送和接收邮件，同时还要向发信人报告邮件的传送情况。邮件服务器采用C/S方式工作，但是它能够同时充当客户和服务器。</p>
<p>　　邮件发送协议和读取协议：邮件发送协议用于在用户代理向邮件服务器发送邮件或在邮件服务器之间发送邮件，通常使用 SMTP；邮件读取协议用于用户代理从邮件服务器读取邮件，如 POP3；SMTP 主动将邮件推到服务器，POP3 向邮件服务器发出请求拉取用户邮箱的邮件。</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/3iuyE4KN7TogBsz.png" alt="img"></p>
<h4 id="电子邮件格式与MIME"><a href="#电子邮件格式与MIME" class="headerlink" title="电子邮件格式与MIME"></a>电子邮件格式与MIME</h4><p>　　1、电子邮件格式</p>
<p>​        一个电子邮件分为信封和内容两大部分，邮件内容又分为首部和主体两部分。To：为收件人，Subject：为主题。</p>
<p>　　2、多用途网络邮件扩充 MIME</p>
<p>　　SMTP 只能传送一定长度的 ASCII 码且无法传送可执行文件及其他二进制对象，因此提出了多用途网络邮件扩充（Multipurpose Internet Mail Extensions）。MIME 增加了邮件主体的结构，并定义了传送非ASCII 码的编码规则。并未改动SMTP 或取代它。</p>
<p>　　MIME 主要包括以下三部分内容：</p>
<p>　　1）5 个新的邮件首部字段，包括 MIME 版本、内容描述、内容标识、内容传送编码和内容类型。</p>
<p>　　2）定义了许多邮件内容的格式，对多媒体电子邮件的表示方法进行了标准化。</p>
<p>　　3）定义了传送编码，可对任何内容格式进行格式转换。</p>
<p>　　</p>
<h4 id="SMTP-和-POP3"><a href="#SMTP-和-POP3" class="headerlink" title="SMTP 和 POP3"></a>SMTP 和 POP3</h4><h5 id="SMTP"><a href="#SMTP" class="headerlink" title="SMTP"></a>SMTP</h5><p>　　简单邮件传输协议（Simple Mail Transfer Protocol）是一种提供可靠且有效的电子邮件传输的协议，它控制两个相互通信的 SMTP 进程交换信息。<strong>SMTP 使用 C/S 方式。使用 TCP 连接，端口号为25</strong>。SMTP 通信有以下三个阶段：</p>
<p>　　1）连接建立</p>
<p>​        发件人的邮件到达邮件服务器缓存之后，邮件服务器每隔一段时间对邮件缓存扫描一次。如果有邮件使用 SMTP 熟知端口（25）与接收方服务器 SMTP 服务器建立 TCP 连接。连接成功后接收方发出 220 Service ready 。发送方服务器向接收方发出 HELLO 命令，附上发送方的主机名。SMTP 不使用中间邮件服务器，TCP 总是在发送方和接收方这两个邮件服务器之间建立。</p>
<p>　　2）邮件传送</p>
<p>　　连接建立后，邮件的传送从 MAIL 命令开始，MAIL命令后面有发件人的地址。若接收方SMTP已经准备好接收 则回复 250 OK。接着发送一个或多个 RCPT命令给接收方服务器，每发送一个RCPT 命令都有相应的信息返回 250 OK 或 550 No such user here。RCPT的作用是检测接收方是否做好了接收邮件的准备。获取 OK 的答复之后客户端使用 DATA 命令，表示开始传输邮件的内容。</p>
<p>　　3）连接释放</p>
<p>　　邮件发送完后，SMTP 客户发送 QUIT 命令SMTP 服务器返回211（服务关闭）。</p>
<p>　　</p>
<h5 id="POP3"><a href="#POP3" class="headerlink" title="POP3"></a>POP3</h5><p>　　邮局协议（Post Office Protocol，POP）是一个非常简单但功能有限的邮件读取协议。POP 也使用C/S 工作方式，在传输层使用 TCP，端口号为 110。POP 有两种工作方式：下载并保留，下载并删除。这里的保留和删除指是否保留服务器上的邮件。</p>
<p>　　另一个邮件接收协议是因特网报文存取协议（IMAP），它比POP复杂得多，IMAP 为用户提供了创建文件夹等命令。</p>
<p>　　</p>
<h3 id="万维网（WWW）"><a href="#万维网（WWW）" class="headerlink" title="万维网（WWW）"></a>万维网（WWW）</h3><h4 id="WWW-的概念与组成结构"><a href="#WWW-的概念与组成结构" class="headerlink" title="WWW 的概念与组成结构"></a>WWW 的概念与组成结构</h4><p>　　万维网（Word Wide Web，WWW）是一个资料空间，在这个空间中：一样有用的事务称为一样资源，并由一个“全域统一资源定位符（URL）”标识。这些资源通过超文本传输协议（HTTP）传送给使用者。</p>
<p>　　万维网的内核部分是由三个标准构成的：</p>
<p>　　1）统一资源定位符（URL）。负责标识万维网上的各种文档。</p>
<p>　　2）超文本传输协议（HTTP）。应用层协议，使用TCP连接进行可靠的传输。</p>
<p>　　3）超文本标记语言（HTML）。一种文档结构的标记语言。</p>
<p>　　URL 的一般形式是：&lt;协议&gt;://&lt;主机&gt;:&lt;端口&gt;/&lt;路径&gt;</p>
<p>　　常见的协议有 http、ftp 等。</p>
<p>　　万维网以C/S方式工作，浏览器是用户计算机上的万维网客户程序。</p>
<p>　　</p>
<h4 id="超文本传输协议（HTTP）"><a href="#超文本传输协议（HTTP）" class="headerlink" title="超文本传输协议（HTTP）"></a>超文本传输协议（HTTP）</h4><p>　　HTTP 是面向事务的应用层协议，它规定了在浏览器和服务器之间的请求和响应的格式与规则，是万维网上能够可靠地交换文件的重要基础。</p>
<h5 id="HTTP-的操作过程"><a href="#HTTP-的操作过程" class="headerlink" title="HTTP 的操作过程"></a>HTTP 的操作过程</h5><p>　　浏览器要访问 WWW 服务器时，首先要完成对 WWW 服务器的域名解析。一旦获得了服务器的 IP 地址，浏览器就通过TCP向服务器发送连接建立请求。</p>
<p>　　每个万维网站点都有一个服务器进程，它不断地监听 TCP 的端口80（默认），当监听到连接请求后就向浏览器建立连接。TCP 连接建立后，浏览器就向服务器发送请求获取某个页面的 HTTP 请求。服务器收到 HTTP 请求后，将构件所请求 Web 页的必需信息，通过 HTTP 的响应返回给浏览器。浏览器再将信息进行解释，然后将Web 页显示给用户，最后TCP 连接释放。</p>
<p>　　访问一个网站发生的事件，以访问清华网站为例。</p>
<p>　　1）浏览器分析链接指向页面的 URL （<a href="http://www.tsinghua.edu.cn/chn/index.htm）。" target="_blank" rel="noopener">http://www.tsinghua.edu.cn/chn/index.htm）。</a></p>
<p>　　2）浏览器向 DNS 请求解析 <a href="http://www.tsinghua.edu.cn" target="_blank" rel="noopener">www.tsinghua.edu.cn</a> 的 IP 地址。</p>
<p>　　3）域名系统 DNS 解析出清华大学服务器的 IP 地址。</p>
<p>　　4）浏览器与该服务器建立 TCP 连接（默认端口号为 80）</p>
<p>　　5）浏览器发出 HTTP 请求：GET/chn/index.htm。</p>
<p>　　6）服务器通过 HTTP 响应把文件 index.htm 发送给浏览器。</p>
<p>　　7）TCP 连接释放。</p>
<p>　　8）浏览器解释文件 index.htm，并将Web 页显示给用户。</p>
<p>　　总结：DNS 解析 IP 地址，建立 TCP 连接，客户端发送 HTTP 请求，服务端响应 HTTP，TCP 连接释放，浏览器渲染页面。</p>
<h5 id="HTTP-的特点"><a href="#HTTP-的特点" class="headerlink" title="HTTP 的特点"></a>HTTP 的特点</h5><p>　　HTTP 是无状态的，同一个客户第二次访问同一个服务器上的页面时，服务器的响应与第一次被访问的相同。因为服务器并不记得曾经访问过的这个用户，也不记得为该客户曾经服务过多少次。</p>
<p>　　HTTP 的无状态设计使服务器更容易支持大量并发的 HTTP 请求。在实际应用中，通常使用 Cookie 加数据库的方式来跟踪用户的活动。Cookie 是一个存储在用户主机中的文本文件，里面有一串识别码，用于Web 服务识别用户。</p>
<p>　　HTTP 既可以使用非持久连接，也可以使用持久连接（HTTP/1.1支持）。</p>
<p>　　对于非持久连接，每个网页元素的传输都需要单独建立一个TCP连接（5 张图片 5 个 TCP 连接），请求一个万维网文档所需要的事件是该文档的传输时间加上两倍往返时间 RTT。（一个 RTT 用于 TCP 连接，另一个RTT 用于请求和接收文档。三次握手的第三次可以发送HTTP请求）。</p>
<p>　　所谓持久连接，指万维网服务器在发送响应后仍然保持这条连接，使同一个客户和服务器可以继续在这条连接上传送后续的 HTTP 请求与响应报文。</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/ChsAGEzXFHxfRVk.png" alt="img"></p>
<p> 　持久连接又分为非流水线和流水线两种方式。对于非流水线方式，客户收到前一个响应后才能发出下一个请求。HTTP/1.1 默认方式是使用流水线的持久连接。</p>
<h5 id="HTTP-报文结构"><a href="#HTTP-报文结构" class="headerlink" title="HTTP 报文结构"></a>HTTP 报文结构</h5><p>　　HTTP 是面向文本的，因此报文中的每个字段都是一些 ASCII 码串，并且每个字段的长度都是不确定的。</p>
<p>　　有两类 HTTP 报文：请求报文和响应报文。</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/nib94M5QDNgkAy3.png" alt="img"></p>
<p> <img src="https://gitee.com/hoo334/picgo/raw/master//img/HqsRhgfN4BPynmj.png" alt="img"></p>
<h3 id="知识结构图-1"><a href="#知识结构图-1" class="headerlink" title="知识结构图"></a>知识结构图</h3><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/mN2ThOy3YQ47BdH.png" alt="image-20200507171655791"></p>
<h2 id="协议总结"><a href="#协议总结" class="headerlink" title="协议总结"></a>协议总结</h2><h3 id="应用层协议：（应用程序）"><a href="#应用层协议：（应用程序）" class="headerlink" title="应用层协议：（应用程序）"></a><strong>应用层协议：（应用程序）</strong></h3><h4 id="使用TCP"><a href="#使用TCP" class="headerlink" title="使用TCP"></a>使用TCP</h4><p>　　HTTP（Hypertext Transfer Protocol ）超文本传输协议 &lt;端口号 80&gt;， 面向事务的应用层协议。</p>
<p>　　FTP（File Transfer Protocol ）文件传输协议&lt;端口号21&gt;减少或消除不同操作系统下处理文件的不兼容性。 </p>
<p>　　TELNET 远程登录协议 &lt;端口号23&gt; 。</p>
<p>　　SMTP （Simple Mail Transfer Protocol ）简单邮件传输协议 &lt;端口号25&gt; 用于发送邮件。 </p>
<p>　　POP3 (Post Office Protocol 3) 即邮局协议的第3 个版本，用于接受邮件。 </p>
<p>　　IMAP4 (Internet Message Access Protocol 4) Internet 信息访问协议的第 4 版本 。</p>
<h4 id="使用UDP"><a href="#使用UDP" class="headerlink" title="使用UDP"></a>使用UDP</h4><p>　　DHCP(Dynamic Host Configuration Protocol)动态主机分配协议，使用 UDP 协议工作，主要有两个用途：给内部网络或网络服务供应商自动分配 IP 地址，给用户或者内部网络管理员作为对所有计算机作中央管理的手段。实 现即插即用连网。 </p>
<p>　　DNS(Domin Name System<em>)</em> 域名系统协议，同时占用TCP和UDP的 53 端口。区域传送使用TCP，<strong>域名解析使用UDP</strong>。书上没有写区域传送的内容，只讲了域名解析，我将DNS归于UDP中，其实是不对的。</p>
<h3 id="传输层协议：（进程-端口）-数据单元：数据段"><a href="#传输层协议：（进程-端口）-数据单元：数据段" class="headerlink" title="传输层协议：（进程/端口） 数据单元：数据段"></a><strong>传输层协议：（进程/端口） 数据单元：数据段</strong></h3><p>　　TCP  （Transmission Control Protocol ）传输控制协议提供可靠的面向连接的服务，传输数据前须先建立连接，结束后释放。可靠的全双工信道。可靠、有序、无丢失、不重复。</p>
<p>　　UDP (User Datagram Protocol ）用户数据报协议发送数据前无需建立连接，不使用拥塞控制，不保证可靠交付，最大努力交付。 </p>
<p>　　RTP(Real-time Transport Protocol ）实时传送协议 。</p>
<h3 id="网络层协议：（路由器）数据单元：数据报"><a href="#网络层协议：（路由器）数据单元：数据报" class="headerlink" title="网络层协议：（路由器）数据单元：数据报"></a><strong>网络层协议：（路由器）数据单元：数据报</strong></h3><p>　　IP (IPv4 · IPv6) (Internet Protocol) 网络之间互连的协议。</p>
<p>　　ARP (Address Resolution Protocol) 即地址解析协议，实现通过IP 地址得 知其物理地址。 </p>
<p>　　RARP (Reverse Address Resolution Protocol)反向地址转换协议允许局域 网的物理机器从网关服务器的 ARP 表或者缓存上请求其 IP地址。 </p>
<p>　　 ICMP (Internet Control Message Protocol ）Internet 控制报文协议。它是TCP/IP 协议族的一个子协议，用于在IP 主机、路由器之间传递控制消息。</p>
<p>　　 RIP (Router information protocol) 路由信息协议是一种在网关与主机之间交换路由选择信息的标准。 </p>
<p>　　OSPF (Open Shortest Path First)开放式最短路径优先,分布式链路状态协议。 </p>
<h3 id="数据链路层：（网卡、网桥、交换机）数据单元：帧"><a href="#数据链路层：（网卡、网桥、交换机）数据单元：帧" class="headerlink" title="数据链路层：（网卡、网桥、交换机）数据单元：帧"></a><strong>数据链路层：（网卡、网桥、交换机）数据单元：帧</strong></h3><p>　　ARQ（Automatic Repeat-reQuest ）自动重传请求协议，错误纠正协议之一，包括停止等待ARQ 协议和连续ARQ 协议，错误侦测、正面确认、逾时重传与负面确认继以重传等机制。</p>
<p>　　纯 ALOHA 协议 ：不检测信道状态 直接发送 ，一段时间没收到确认 <strong>等待一段随机的时间</strong>后再发送，直到成功。</p>
<p>　　时隙 ALOHA 协议 ：把所有各站在时间上同步起来，并将时间划分为一段段等长的时隙，规定只能在每个时隙开始才能发送一个帧。</p>
<p>　　 CSMA/CD(Carrrier Sense Multiple Access with Collision Detection)载波监听多点接入/碰撞检测协议。<strong>以太网</strong>，总线型网络，协议的实质是载波监听和碰撞检测。载波监听即发数据前先检测总线上是否有其他计算机在发送数据，如暂时不发数据，避免碰撞。碰撞检测为计算机边发送数据边检测信道上的信号电压大小。 </p>
<p>　　CSMA/CA(Carrier Sense Multiple Access with Collision Avoidence) <strong>无线局域网，</strong>CSMA/CA 采用二进制指数退避算法。任何一个站要发送数据帧时，不仅要等待一个时间间隔，还要进入争用窗口，并计算随机退避时间以便再次试图接入信道。</p>
<p>　　PPP(Point-to-Ponit Protocol)点对点协议，<strong>广域网，面向字节</strong>，由三部分组成：一个将IP 数据报封装到串行链路的方法；一个用于建立、配置和测试数据链路连接的链路控制协议。</p>
<p>　　HDLC  （High-Level Data Link Control ）高级数据链路控制，<strong>广域网，面向比特</strong>，同步网上传输数据的数据链路层协议。 </p>
<p>　　 ATM  （Asynchronous Transfer Mode ）异步传递方式，建立在电路交换和分组交换的基础上的一种面向连接的快速分组交换技术。 “异步”是指将ATM 信元“异步插入”到同步的 SDH 比特流中。如同步插入则用户在每帧中所占的时隙相对位置固定不变。“同步”是指网络中各链路上的比特流都是受同一非常精确的主时钟的控制。Wi-Fi 、WiMAX 、DTM 、令牌环、以太网、FDDI 、帧中继、 GPRS 、 EVDO 、HSPA 、L2TP 、ISDN 。</p>
<p>　　</p>
<h3 id="物理层：（中继器、集线器）数据单元：比特"><a href="#物理层：（中继器、集线器）数据单元：比特" class="headerlink" title="物理层：（中继器、集线器）数据单元：比特"></a><strong>物理层：（中继器、集线器）数据单元：比特</strong></h3><p><img src="https://gitee.com/hoo334/picgo/raw/master//img/YITdvmGgt7KWQy1.png" alt="img"></p>
<p> 参考：<a href="https://www.cnblogs.com/newsouls/p/5436266.html" target="_blank" rel="noopener">https://www.cnblogs.com/newsouls/p/5436266.html</a></p>
<p>　　</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
  </entry>
  <entry>
    <title>买卖股票</title>
    <url>/2021/10/22/%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8/</url>
    <content><![CDATA[<h4 id="121-买卖股票的最佳时机"><a href="#121-买卖股票的最佳时机" class="headerlink" title="121. 买卖股票的最佳时机"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/" target="_blank" rel="noopener">121. 买卖股票的最佳时机</a></h4><p>难度：简单</p>
<p>给定一个数组 <code>prices</code> ，它的第 <code>i</code> 个元素 <code>prices[i]</code> 表示一支给定股票第 <code>i</code> 天的价格。</p>
<p>你只能选择 <strong>某一天</strong> 买入这只股票，并选择在 <strong>未来的某一个不同的日子</strong> 卖出该股票。设计一个算法来计算你所能获取的最大利润。</p>
<p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 <code>0</code> 。</p>
<a id="more"></a>

<p> <strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[7,1,5,3,6,4]</span><br><span class="line">输出：5</span><br><span class="line">解释：在第 2 天（股票价格 &#x3D; 1）的时候买入，在第 5 天（股票价格 &#x3D; 6）的时候卖出，最大利润 &#x3D; 6-1 &#x3D; 5 。</span><br><span class="line">     注意利润不能是 7-1 &#x3D; 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：prices &#x3D; [7,6,4,3,1]</span><br><span class="line">输出：0</span><br><span class="line">解释：在这种情况下, 没有交易完成, 所以最大利润为 0。</span><br></pre></td></tr></table></figure>

<p> <strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= prices.length &lt;= 105</code></li>
<li><code>0 &lt;= prices[i] &lt;= 104</code></li>
</ul>
<p><strong>题解：</strong></p>
<p>对于只能买卖一次的股票交易，对于 prices 数组中的数对 （<code>prices[i]</code>，<code>prices[j]</code> 且<code>i &lt; j</code>，求 <code>prices[j] - prices[i]</code> 的最大值 。</p>
<p><strong>方法一：暴力枚举（代码略）</strong></p>
<p>直接枚举右边界 j，然后向左枚举左边界 i, 维护最大值。</p>
<ul>
<li><p>时间：$O(n^2)$</p>
</li>
<li><p>空间：$O(1)$ </p>
</li>
</ul>
<p><strong>方法二：一次遍历</strong></p>
<p>在遍历过程中维护最小值 minStock，省略内层循环。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.length &lt; <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">// minStock 为 prices[0 ... i] 中最小值</span></span><br><span class="line">        <span class="keyword">int</span> minStock = prices[<span class="number">0</span>], profit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(prices[i] &gt; minStock)&#123;</span><br><span class="line">                profit = Math.max(profit, prices[i] - minStock);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                minStock = prices[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> profit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>时间：$O(n)$</p>
</li>
<li><p>空间：$O(1)$ </p>
</li>
</ul>
<h4 id="122-买卖股票的最佳时机-II"><a href="#122-买卖股票的最佳时机-II" class="headerlink" title="122. 买卖股票的最佳时机 II"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/" target="_blank" rel="noopener">122. 买卖股票的最佳时机 II</a></h4><p>难度：中等</p>
<p>给定一个数组 <code>prices</code> ，其中 <code>prices[i]</code> 是一支给定股票第 <code>i</code> 天的价格。</p>
<p>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p>
<p><strong>注意：</strong>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<p> <strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: prices &#x3D; [7,1,5,3,6,4]</span><br><span class="line">输出: 7</span><br><span class="line">解释: 在第 2 天（股票价格 &#x3D; 1）的时候买入，在第 3 天（股票价格 &#x3D; 5）的时候卖出, 这笔交易所能获得利润 &#x3D; 5-1 &#x3D; 4 。</span><br><span class="line">     随后，在第 4 天（股票价格 &#x3D; 3）的时候买入，在第 5 天（股票价格 &#x3D; 6）的时候卖出, 这笔交易所能获得利润 &#x3D; 6-3 &#x3D; 3 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: prices &#x3D; [1,2,3,4,5]</span><br><span class="line">输出: 4</span><br><span class="line">解释: 在第 1 天（股票价格 &#x3D; 1）的时候买入，在第 5 天 （股票价格 &#x3D; 5）的时候卖出, 这笔交易所能获得利润 &#x3D; 5-1 &#x3D; 4 。</span><br><span class="line">     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: prices &#x3D; [7,6,4,3,1]</span><br><span class="line">输出: 0</span><br><span class="line">解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</span><br></pre></td></tr></table></figure>

<p> <strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= prices.length &lt;= 3 * 104</code></li>
<li><code>0 &lt;= prices[i] &lt;= 104</code></li>
</ul>
<p><strong>题解：</strong></p>
<p><strong>方法一：动态规划</strong></p>
<p>这次我们可以买卖多次股票，选择第 i - 1天和 第 i 天分析：</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20211022165325957.png" alt="image-20211022165325957"></p>
<p>第 i 天<strong>有股票</strong>的情况分两种：前一天就有股票；前一天没股票，第 i 天买了股票。</p>
<p>有股票时的最大利润为两者中的最大值</p>
<p>类似的，第 i 天<strong>没股票</strong>的情况分两种：前一天没有有股票；前一天有股票，第 i 天买了股票。</p>
<p>有股票时的最大利润为两者中的最大值</p>
<p>令 $ f[i][0]$ 为第 i 天<strong>有股票</strong>时的最大利润，令 $ f[i][1]$ 为第 i 天<strong>没股票</strong>时的最大利润，可以得到如下转移方程：<br>$$<br>f[i][0] = max(f[i - 1][0], f[i - 1][1] - prices[i])<br>$$</p>
<p>$$<br>f[i][1] = max(f[i - 1][1], f[i - 1][0] + prices[i])<br>$$</p>
<p>初始条件：$ f[i][0] = -prices[0]$，$ f[i][1] = 0$</p>
<p>第 0 天就持有股票的最大利润为负（利润为 0 时就买了第 0 天的股票），没有持有股票的最大利润为 0 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = prices.length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][<span class="number">2</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">            dp[i][<span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>时间：$O(n)$</p>
</li>
<li><p>空间：$O(n)$ </p>
</li>
</ul>
<p>可以看到 第 i 天的状态只与第 i - 1天有关，可以进行空间优化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = prices.length;</span><br><span class="line">        <span class="keyword">int</span> dp0 = <span class="number">0</span>, dp1 = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> newdp0 = Math.max(dp0, dp1 + prices[i]);</span><br><span class="line">            <span class="keyword">int</span> newdp1 = Math.max(dp1, dp0 - prices[i]);</span><br><span class="line">            dp0 = newdp0;</span><br><span class="line">            dp1 = newdp1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>时间：$O(n)$</p>
</li>
<li><p>空间：$O(1)$ </p>
</li>
</ul>
<p><strong>方法二：贪心</strong></p>
<p>由于不限制交易次数，只要今天股价比昨天高，就交易。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> profit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(prices[i] &gt; prices[i - <span class="number">1</span>])&#123;</span><br><span class="line">                profit += prices[i] - prices[i - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> profit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>时间：$O(n)$</p>
</li>
<li><p>空间：$O(1)$ </p>
</li>
</ul>
<h4 id="123-买卖股票的最佳时机-III"><a href="#123-买卖股票的最佳时机-III" class="headerlink" title="123. 买卖股票的最佳时机 III"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/" target="_blank" rel="noopener">123. 买卖股票的最佳时机 III</a></h4><p>难度：困难</p>
<p>给定一个数组，它的第 <code>i</code> 个元素是一支给定的股票在第 <code>i</code> 天的价格。</p>
<p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 <strong>两笔</strong> 交易。</p>
<p><strong>注意：</strong>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<p> <strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：prices &#x3D; [3,3,5,0,0,3,1,4]</span><br><span class="line">输出：6</span><br><span class="line">解释：在第 4 天（股票价格 &#x3D; 0）的时候买入，在第 6 天（股票价格 &#x3D; 3）的时候卖出，这笔交易所能获得利润 &#x3D; 3-0 &#x3D; 3 。</span><br><span class="line">     随后，在第 7 天（股票价格 &#x3D; 1）的时候买入，在第 8 天 （股票价格 &#x3D; 4）的时候卖出，这笔交易所能获得利润 &#x3D; 4-1 &#x3D; 3 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：prices &#x3D; [1,2,3,4,5]</span><br><span class="line">输出：4</span><br><span class="line">解释：在第 1 天（股票价格 &#x3D; 1）的时候买入，在第 5 天 （股票价格 &#x3D; 5）的时候卖出, 这笔交易所能获得利润 &#x3D; 5-1 &#x3D; 4 。   </span><br><span class="line">     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。   </span><br><span class="line">     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：prices &#x3D; [7,6,4,3,1] </span><br><span class="line">输出：0 </span><br><span class="line">解释：在这个情况下, 没有交易完成, 所以最大利润为 0。</span><br></pre></td></tr></table></figure>

<p><strong>示例 4：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：prices &#x3D; [1]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure>

<p> <strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= prices.length &lt;= 105</code></li>
<li><code>0 &lt;= prices[i] &lt;= 105</code></li>
</ul>
<p>此题与 122 不同的是，限制了交易次数，只能交易两次。</p>
<p>类似的，我们分析一下第 <code>i</code>天有几个状态，第<code>i - 1</code> 天到第<code>i</code> 天的转移关系是什么样的。</p>
<p>我们可以将每天分为 5 个状态：没有任何买卖操作，第一次持有股票，第一次卖完股票，第二次持有股票，第二次卖完股票。由于没有任何买卖操作，利润总是 0 ，我们需要计算的只有 4 个状态。</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20211022172452534.png" alt="image-20211022172452534"></p>
<p>令 $ f[i][0]$ 为第 i 天<strong>第一次持有股票</strong>时的最大利润，令 $ f[i][1]$ 为第 i 天<strong>第一次没有股票</strong>时的最大利润，令 $ f[i][2]$ 为第 i 天<strong>第二次持有股票</strong>时的最大利润，令 $ f[i][3]$ 为第 i 天<strong>第二次没有股票</strong>时的最大利润，可以得到如下转移方程：<br>$$<br>f[i][0] = max(f[i - 1][0],  - prices[i])<br>$$</p>
<p>$$<br>f[i][1] = max(f[i - 1][1], f[i - 1][0] + prices[i])<br>$$</p>
<p>$$<br>f[i][2] = max(f[i - 1][2], f[i - 1][1] - prices[i])<br>$$</p>
<p>$$<br>f[i][3] = max(f[i - 1][3], f[i - 1][2] + prices[i])<br>$$</p>
<p>初始条件：$ f[i][0] = f[i][2] = -prices[0]$，$ f[i][1] = f[i][3] = 0$</p>
<p>$f[i][2] = -prices[0]$ 可以理解为买了 prices[0]，然后立马卖了 prices[0]，再次买入 prices[0]，这样就是第二次有股票。</p>
<p>在考虑边界条件时我们注意到以下事实：</p>
<blockquote>
<p>==<strong>无论题目中是否允许同一天买入卖出，这一操作都不会对最终结果造成影响，因为这一操作收益为零</strong>==</p>
</blockquote>
<p>我们可以进一步优化上述转移方程：<br>$$<br>f[0] = max(f[0],  - prices[i])<br>$$</p>
<p>$$<br>f[1] = max(f[1], f[0] + prices[i])<br>$$</p>
<p>$$<br>f[2] = max(f[2], f[1] - prices[i])<br>$$</p>
<p>$$<br>f[3] = max(f[3], f[2] + prices[i])<br>$$</p>
<p>对于$f[0] = max(f[0],  - prices[i])$来说，这是滚动数组常用技巧，左边的 $f[0]$代表<strong>今天</strong>第一次持有股票的最大利润，右边的 $f[0]$代表昨天第一次持有股票的最大利润；</p>
<p>对于$f[1] = max(f[1], f[0] + prices[i])$来说，左边的 $f[1]$代表<strong>今天</strong>第一次没有股票的最大利润，右边的 $f[1]$代表昨天第一次没有股票的最大利润，此时 $f[0]$应该是代表<strong>昨天</strong>第一次持有股票的最大利润，但由于我们刚才已经把值更新为<strong>今天</strong>第一次持有股票的最大利润。为什么这样转移方程依然正确？</p>
<blockquote>
<p>将今天的 <code>f[0]</code>带入 <code>f[1]</code> 计算公式中，得到$f[1] = max(f[1], max(f[0], -prices[i])+ prices[i] \ )$，此时 $f[0]$是代表<strong>昨天</strong>第一次持有股票的最大利润。<strong>我们多考虑了第 i 天买入股票的情况，但同时计算 $f[1]$时，又将股票卖出，这样的利润为 0</strong> ,这一操作收益为零，对结果没有影响。所以我们将新的 $f[0]$值用于计算不会导致错误结果。</p>
</blockquote>
<p>后面的依此类推。</p>
<p>最后，我们手中肯定没有股票，结果在  0, $f[1]$，$f[3]$中选择最大的，由于在状态转移中我们维护的是最大值，且$f[1]$，$f[3]$初始值为 0，0不可能为结果。如果最优解为交易一次，即$f[1]$，那么它也会因为我们在转移时允许在同一天买入并且卖出这一宽松的条件，从$f[1]$转移到$f[3]$，因此最后答案为 $f[3]$。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = prices.length;</span><br><span class="line">        <span class="keyword">int</span>[] f = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>];</span><br><span class="line">        <span class="comment">// 分为 5 个阶段：没买也没卖，买了一次，卖了一次，买了两次且卖了一次，卖了两次</span></span><br><span class="line">        f[<span class="number">0</span>] = f[<span class="number">2</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        f[<span class="number">1</span>] = f[<span class="number">3</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">            f[<span class="number">0</span>] = Math.max(f[<span class="number">0</span>], -prices[i]);</span><br><span class="line">            f[<span class="number">1</span>] = Math.max(f[<span class="number">1</span>], f[<span class="number">0</span>] + prices[i]);</span><br><span class="line">            f[<span class="number">2</span>] = Math.max(f[<span class="number">2</span>], f[<span class="number">1</span>] - prices[i]);</span><br><span class="line">            f[<span class="number">3</span>] = Math.max(f[<span class="number">3</span>], f[<span class="number">2</span>] + prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[<span class="number">3</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>时间：$O(n)$</p>
</li>
<li><p>空间：$O(1)$ </p>
</li>
</ul>
<h4 id="188-买卖股票的最佳时机-IV"><a href="#188-买卖股票的最佳时机-IV" class="headerlink" title="188. 买卖股票的最佳时机 IV"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/" target="_blank" rel="noopener">188. 买卖股票的最佳时机 IV</a></h4><p>难度：困难</p>
<p>给定一个整数数组 <code>prices</code> ，它的第 <code>i</code> 个元素 <code>prices[i]</code> 是一支给定的股票在第 <code>i</code> 天的价格。</p>
<p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 <strong>k</strong> 笔交易。</p>
<p><strong>注意：</strong>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<p> <strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：k &#x3D; 2, prices &#x3D; [2,4,1]</span><br><span class="line">输出：2</span><br><span class="line">解释：在第 1 天 (股票价格 &#x3D; 2) 的时候买入，在第 2 天 (股票价格 &#x3D; 4) 的时候卖出，这笔交易所能获得利润 &#x3D; 4-2 &#x3D; 2 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：k &#x3D; 2, prices &#x3D; [3,2,6,5,0,3]</span><br><span class="line">输出：7</span><br><span class="line">解释：在第 2 天 (股票价格 &#x3D; 2) 的时候买入，在第 3 天 (股票价格 &#x3D; 6) 的时候卖出, 这笔交易所能获得利润 &#x3D; 6-2 &#x3D; 4 。</span><br><span class="line">     随后，在第 5 天 (股票价格 &#x3D; 0) 的时候买入，在第 6 天 (股票价格 &#x3D; 3) 的时候卖出, 这笔交易所能获得利润 &#x3D; 3-0 &#x3D; 3 。</span><br></pre></td></tr></table></figure>

<p> <strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= k &lt;= 100</code></li>
<li><code>0 &lt;= prices.length &lt;= 1000</code></li>
<li><code>0 &lt;= prices[i] &lt;= 1000</code></li>
</ul>
<p>此题与 123 类似，但可交易 k 次，由之前的经验可以推导，每天应该有 <code>2 * k + 1</code>个状态。</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20211022200055327.png" alt="image-20211022200055327"></p>
<p>初始化数组 $f$ ，长度为 $2k + 1$，$f[0] = 0$ 表示没有参与任何交易的利润。$f[2<em>j - 1]$表示第 <code>j</code>次*</em>持有股票<strong>的最大利润，$f[2 * j ]$表示第<code>j</code>次</strong>没有股票**的最大利润，其中$1 &lt;= j &lt;= k$。</p>
<p>令 $j$ 为 数组 $f$  下标，我们可以写出转移方程：<br>$$<br>f[j] = max(f[j], f[j - 1] - prices[i]), j 为奇数<br>$$</p>
<p>$$<br>f[j] = max(f[j], f[j - 1] + prices[i]), j 为偶数<br>$$</p>
<p>同样的，最后的结果为第 k 次没有股票的最大利润$f[2 * k]$。</p>
<p>初始条件：所有奇数下标位置为 $ -prices[0]$, 所有偶数下标位置为 0，分析过程同 123 题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> n = prices.length;</span><br><span class="line">        <span class="keyword">int</span>[] f = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span> * k + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">2</span> * k; j += <span class="number">2</span>)&#123;</span><br><span class="line">            f[j] = -prices[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">2</span> * k; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>((j &amp; <span class="number">1</span>) == <span class="number">1</span>)&#123; <span class="comment">// 买</span></span><br><span class="line">                    f[j] = Math.max(f[j], f[j - <span class="number">1</span>] - prices[i]);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123; <span class="comment">//卖</span></span><br><span class="line">                    f[j] = Math.max(f[j], f[j - <span class="number">1</span>] + prices[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> f[<span class="number">2</span> * k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>时间：$O(nk)$</p>
</li>
<li><p>空间：$O(k)$ </p>
</li>
</ul>
<h4 id="309-最佳买卖股票时机含冷冻期"><a href="#309-最佳买卖股票时机含冷冻期" class="headerlink" title="309. 最佳买卖股票时机含冷冻期"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/" target="_blank" rel="noopener">309. 最佳买卖股票时机含冷冻期</a></h4><p>难度：中等</p>
<p>给定一个整数数组，其中第 <em>i</em> 个元素代表了第 <em>i</em> 天的股票价格 。</p>
<p>设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:</p>
<ul>
<li>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</li>
<li>卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。</li>
</ul>
<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,2,3,0,2]</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]</span><br></pre></td></tr></table></figure>

<p>显然，每天的状态有：持有股票，没有股票，冷冻期。我们画出今天和昨天的关系图：</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20211022213057682.png" alt="image-20211022213057682"></p>
<p>定义 $f[i][0]$ 第 <code>i</code> 天有股票， $f[i][1]$ 第 <code>i</code> 天无股票冷冻期， $f[i][2]$ 第 <code>i</code> 天无股票非冷冻期。可得到如下转移方程：<br>$$<br>f[i][0] = max(f[i - 1][0], f[i - 1][2] - prices[i])<br>$$</p>
<p>$$<br>f[i][1] = f[i - 1][0] + prices[i]<br>$$</p>
<p>$$<br>f[i][2] = max(f[i - 1][1], f[i - 1][2])<br>$$</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.length &lt; <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> n = prices.length;</span><br><span class="line">        <span class="keyword">int</span>[][] f = <span class="keyword">new</span> <span class="keyword">int</span>[n][<span class="number">3</span>];</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">            f[i][<span class="number">0</span>] = Math.max(f[i - <span class="number">1</span>][<span class="number">0</span>], f[i - <span class="number">1</span>][<span class="number">2</span>] - prices[i]);</span><br><span class="line">            f[i][<span class="number">1</span>] = f[i - <span class="number">1</span>][<span class="number">0</span>] + prices[i];</span><br><span class="line">            f[i][<span class="number">2</span>] = Math.max(f[i - <span class="number">1</span>][<span class="number">2</span>], f[i - <span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(f[n - <span class="number">1</span>][<span class="number">1</span>], f[n - <span class="number">1</span>][<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>时间：$O(n)$</p>
</li>
<li><p>空间：$O(n)$ </p>
</li>
</ul>
<p>我们可以只保存最近两天的数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.length &lt; <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> n = prices.length;</span><br><span class="line">        <span class="comment">// f[0] 表示第 i 天持有股票时的最大利润，f[1] 表示无股票冷冻期，f[2] 表示无股票非冷冻期</span></span><br><span class="line">        <span class="keyword">int</span>[] f = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line">        f[<span class="number">0</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span>[] newF = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line">            newF[<span class="number">0</span>] = Math.max(f[<span class="number">0</span>], f[<span class="number">2</span>] - prices[i]);</span><br><span class="line">            newF[<span class="number">1</span>] = f[<span class="number">0</span>] + prices[i];</span><br><span class="line">            newF[<span class="number">2</span>] = Math.max(f[<span class="number">2</span>], f[<span class="number">1</span>]);</span><br><span class="line">            f = newF;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(f[<span class="number">1</span>], f[<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间：$O(n)$</li>
<li>空间：$O(1)$ </li>
</ul>
<h4 id="714-买卖股票的最佳时机含手续费"><a href="#714-买卖股票的最佳时机含手续费" class="headerlink" title="714. 买卖股票的最佳时机含手续费"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/" target="_blank" rel="noopener">714. 买卖股票的最佳时机含手续费</a></h4><p>难度：中等</p>
<p>给定一个整数数组 <code>prices</code>，其中第 <code>i</code> 个元素代表了第 <code>i</code> 天的股票价格 ；整数 <code>fee</code> 代表了交易股票的手续费用。</p>
<p>你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。</p>
<p>返回获得利润的最大值。</p>
<p><strong>注意：</strong>这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：prices &#x3D; [1, 3, 2, 8, 4, 9], fee &#x3D; 2</span><br><span class="line">输出：8</span><br><span class="line">解释：能够达到的最大利润:  </span><br><span class="line">在此处买入 prices[0] &#x3D; 1</span><br><span class="line">在此处卖出 prices[3] &#x3D; 8</span><br><span class="line">在此处买入 prices[4] &#x3D; 4</span><br><span class="line">在此处卖出 prices[5] &#x3D; 9</span><br><span class="line">总利润: ((8 - 1) - 2) + ((9 - 4) - 2) &#x3D; 8</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：prices &#x3D; [1,3,7,5,10,3], fee &#x3D; 3</span><br><span class="line">输出：6</span><br></pre></td></tr></table></figure>

<p> <strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= prices.length &lt;= 5 * 104</code></li>
<li><code>1 &lt;= prices[i] &lt; 5 * 104</code></li>
<li><code>0 &lt;= fee &lt; 5 * 104</code></li>
</ul>
<p>此题就是 121 加上卖出手续费。关系图如下：</p>
<p><img src="https://gitee.com/hoo334/picgo/raw/master//img/image-20211022214139191.png" alt="image-20211022214139191"></p>
<p>令 $ f[i][0]$ 为第 i 天<strong>有股票</strong>时的最大利润，令 $ f[i][1]$ 为第 i 天<strong>没股票</strong>时的最大利润，可以得到如下转移方程：<br>$$<br>f[i][0] = max(f[i - 1][0], f[i - 1][1] - prices[i])<br>$$</p>
<p>$$<br>f[i][1] = max(f[i - 1][1], f[i - 1][0] + prices[i] -fee)<br>$$</p>
<p>初始条件：$ f[i][0] = -prices[0]$，$ f[i][1] = 0$</p>
<p>只保存最近两天的数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices, <span class="keyword">int</span> fee)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.length &lt; <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> n = prices.length;</span><br><span class="line">        <span class="keyword">int</span>[] f = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        f[<span class="number">0</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// f[0] 代表持有股票，f[1]代表没有股票</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span>[] newF = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">            newF[<span class="number">0</span>] = Math.max(f[<span class="number">0</span>], f[<span class="number">1</span>] - prices[i]);</span><br><span class="line">            <span class="comment">// 卖出收手续费</span></span><br><span class="line">            newF[<span class="number">1</span>] = Math.max(f[<span class="number">1</span>], f[<span class="number">0</span>] + prices[i] - fee);</span><br><span class="line">            f = newF;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>时间：$O(n)$</p>
</li>
<li><p>空间：$O(1)$ </p>
</li>
</ul>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>常用集合</title>
    <url>/2021/11/06/%E5%B8%B8%E7%94%A8%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<p>Java 集合 API</p>
<a id="more"></a>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CollectionTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testStack</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Deque&lt;Integer&gt; stack = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// push</span></span><br><span class="line">        stack.push(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// top</span></span><br><span class="line">        Integer a = stack.peek();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// pop</span></span><br><span class="line">        stack.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Queue&lt;Integer&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="comment">// 队尾添加元素</span></span><br><span class="line">        q.offer(<span class="number">1</span>);</span><br><span class="line">		</span><br><span class="line">        <span class="comment">// 取出队头元素</span></span><br><span class="line">        Integer a = q.poll();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 检索队头元素</span></span><br><span class="line">        Integer b = q.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testDeque</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Deque&lt;Integer&gt; deque = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="comment">// 队尾添加元素</span></span><br><span class="line">        deque.addLast(<span class="number">3</span>);</span><br><span class="line">        <span class="comment">// 队头添加元素</span></span><br><span class="line">        deque.addFirst(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取队头元素</span></span><br><span class="line">        Integer a = deque.getFirst();</span><br><span class="line">        <span class="comment">// 获取队尾元素</span></span><br><span class="line">        Integer b = deque.getLast();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 队尾删除元素</span></span><br><span class="line">        deque.removeLast();</span><br><span class="line">        <span class="comment">// 队头删除元素</span></span><br><span class="line">        deque.removeFirst();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testPriorityQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 大根堆</span></span><br><span class="line">        PriorityQueue&lt;Integer&gt; q = <span class="keyword">new</span> PriorityQueue&lt;&gt;((o1, o2) -&gt; o2 - o1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        小根堆</span></span><br><span class="line"><span class="comment">//        PriorityQueue&lt;Integer&gt; queue = new PriorityQueue&lt;&gt;();</span></span><br><span class="line">        <span class="comment">// 添加元素</span></span><br><span class="line">        q.add(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查看堆顶元素和取出堆顶元素</span></span><br><span class="line">        Integer a = q.peek();</span><br><span class="line">        Integer b = q.poll();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 删除堆中指定元素， 删除堆顶元素</span></span><br><span class="line">        q.remove(<span class="number">3</span>);</span><br><span class="line">        q.remove();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
</search>
